(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* File: application.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

module.exports = require('./ue/UE.js');
},{"./ue/UE.js":23}],2:[function(require,module,exports){
/* File: CommandManager.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

var Commands = require('./commands/EditorCommands');

function CommandManager(options) {
  this.options = options || null;
  this.commands = Commands || null;
}

var proto = CommandManager.prototype;

/**
 * Exscutes commands from the default command object
 * or commands added on the fly
 *
 * @param  {String} command - object property representing a command
 * @param  {Any} args
 */
proto.execute = function (command, args) {
  var me = this,
      cmds = me.commands;

  // Exit, nothing to execute or command not available
  if (!command || !cmds[command] || (!cmds[command].hasOwnProperty('handle') && !(typeof cmds[command].handle === 'function'))) {
    return;
  }

  if (typeof command === 'string') {
    return cmds[command].handle.call(me, args || null);
  }
};



/**
 * Dynamically adds commands to the commands object
 *
 * @param {Object} commandsList
 */
proto.addCommands = function (commandsList) {
  var me = this,
      commands = me.commands,
      command;

  for (command in commandsList) {
    if (commandsList.hasOwnProperty(command)) {
      commands[command] = commandsList[command];
    }
  }
};

/**
 * Delete commands from the commands object
 */
proto.deleteCommands = function () {
  var me = this,
      commands = me.commands,
      commandsList = Array.prototype.slice.call(arguments, 0);

  commandsList.forEach(function (command) {
    delete commands[command];
  });
};

module.exports = CommandManager;
},{"./commands/EditorCommands":24}],3:[function(require,module,exports){
/* File: DataProvider.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

/**
 * Data provider module
 *
 * Provides data for the application's modules. Creates an interface to communicate with
 * the Storage. Responsible for creating update fragments by extracting the segments for a node.
 */
var config = require('./config');
var Helpers = require('./Helpers');

var Storage = require('./Storage');
var MarkupDataFactory = require('./MarkupDataFactory');
var TranslationOrigin = require('./TranslationOrigin');
var Mediator = require('./Mediator');

var DataProvider = (function () {
  var storage = Storage[config.storage].getInstance(),
      createMarkupData = MarkupDataFactory.create,
      transOrigin = TranslationOrigin,
      _rand = Helpers._rand;


  function UpdateFragment (paragraphId, segmentId, children, isTarget, data) {
    this.type = 'UPDATE';
    this.paragraphUnitUUID = paragraphId;
    this.segment = {};
    this.segment.id = segmentId;
    this.segment.children = children || [];
    this.segment.type = 'segment';
    this.segment.translationOrigin = (data) ? data.translationOrigin : {};
    this.segment.segmentNumber = (data) ? data.segmentNumber : 0;
    this.segment.confirmationLevel = (data) ? data.confirmationLevel : '';
    this.segment.isLocked = (data) ? data.isLocked : false;
    this.isTarget = isTarget || true;
  }


  UpdateFragment.prototype.addChildren = function (children) {
    if (children.instanceOf('Array')) {
      this.segment.children.concat(children);

      return;
    }

    this.segment.children.push(children);
  };


  /**
   * Prepare children to be added to the
   * @param  {HTMLElement} segment children
   */
  function prepareNode (element) {
    var nodes = element.children,
        children = [],
        i = 0,
        l = nodes.length;

    for (; i < l; i++) {

      if (nodes[i].dataset.type === 'text') {
        children.push(createMarkupData({
          type: 'text',
          id: nodes[i].dataset.id,
          text: nodes[i].textContent,
          metadata: nodes[i].dataset.metadata
        }));
      }

      if (nodes[i].nodeType === 1 && nodes[i].nodeName.toLowerCase() === "br") {
        children.push(createMarkupData({
          type: 'text',
          text: '\r\n'
        }));
      }

      if (nodes[i].dataset.type === 'tagpair') {
        children.push(createMarkupData({
          type: 'tagPair',
          id: nodes[i].dataset.id,
          children: prepareNode(nodes[i]),
          metadata: nodes[i].dataset.metadata,
          tagPairDefinitionId: nodes[i].dataset.definitionid
        }));
      }

      if (nodes[i].dataset.type === 'locked') {
        children.push(createMarkupData({
          type: 'locked',
          children: prepareNode(nodes[i])
        }));
      }

      if (nodes[i].dataset.type === 'placeholder') {
        children.push(createMarkupData({
          type: 'placeholderTag',
          id: nodes[i].dataset.id,
          metadata: nodes[i].dataset.metadata,
          placeholderTagDefinitionId: nodes[i].dataset.definitionid
        }));
      }
    }

    return children;
  }


  /**
   * Prepare segment data to be sent back to the server
   * @param  {segmentEl} current segment element
   * @return {Object}    updated fragment object
   */
  function prepareSegment (segmentEl) {
    var segmentInnerElement = segmentEl.children[0],
        nodes = segmentInnerElement.children,
        children = [],
        i = 0,
        l = nodes.length,
        otherSegmentData = {};


    for (; i < l; i++) {

      if (nodes[i].dataset.type === 'text') {
        children.push(createMarkupData({
          text: nodes[i].textContent,
          type: 'text',
          metadata: nodes[i].dataset.metadata
        }));
      }

      if (nodes[i].nodeType === 1 && nodes[i].nodeName.toLowerCase() === "br") {
        children.push(createMarkupData({
          type: 'text',
          text: '\r\n'
        }));
      }

      if (nodes[i].dataset.type === 'tagpair') {
        //Get tag-content from tag-pair node
        var tagContent = nodes[i];

        //create a new tag-pair markupdata
        children.push(createMarkupData({
          type: 'tagPair',
          id: nodes[i].dataset.id,
          children: prepareNode(tagContent),
          metadata: nodes[i].dataset.metadata,
          tagPairDefinitionId: nodes[i].dataset.definitionid
        }));
      }

      if (nodes[i].dataset.type === 'locked') {
        children.push(createMarkupData({
          type: 'locked',
          children: prepareNode(nodes[i])
        }));
      }

      if (nodes[i].dataset.type === 'placeholder') {
        children.push(createMarkupData({
          type: 'placeholderTag',
          id: nodes[i].dataset.id,
          metadata: nodes[i].dataset.metadata,
          placeholderTagDefinitionId: nodes[i].dataset.definitionid
        }));
      }
    }

    var segmentData = segmentEl.dataset;
    var segmentNumber = segmentData.segmentNumber;
    var segment = DataProvider.segmentsMap[segmentNumber];

    // other segment data
    otherSegmentData = {
      translationOrigin: transOrigin.originalFormat(segment.translationorigin),
      confirmationLevel: formatConfirmationLevel(segment.confirmationlevel),
      segmentNumber: segmentNumber,
      isLocked: segmentData.isLocked ? segmentData.isLocked : false
    };

    return new UpdateFragment(segmentEl.dataset.puid, segmentEl.dataset.segmentNumber, children, true, otherSegmentData);
  }


  function formatConfirmationLevel (value) {
    switch (value) {
      case 'not-translated':
        return 'NotTranslated';
      case 'approved-sign-off':
        return 'ApprovedSignOff';
      case 'approved-translation':
        return 'ApprovedTranslation';
      case 'draft':
        return 'Draft';
      case 'rejected-sign-off':
        return 'RejectedSignOff';
      case 'rejected-translation':
        return 'RejectedTranslation';
      case 'translated':
        return 'Translated';
      default:
        return 'NotTranslated';
    }
  }


  function createDefinitionMap (data) {
    var map = {};

    for (var i = 0, l = data.length; i < l; i++) {
      map[data[i].id] = data[i];
    }

    return map;
  }

  return {
    segmentsMap: {},
    segmentsMapLength: 0,
    saveQueue: {},
    metadataMap: {},

    cacheMetadata: function (metadata) {
      var key = _rand() + '-' + _rand() + '-' + _rand();
      this.metadataMap[key] = metadata;

      return key;
    },


    /**
     * Add to save queue the user action
     *
     * @param {String} segmentId - id of segment
     * @param {String} paragraphId - id of paragraph unit
     * @param {Object|DOMnode} html - html content of the DOM node
     */
    addSaveQueue: function (segmentId, paragraphId, html) {
      this.saveQueue[paragraphId] = {
        segmentId: segmentId,
        html: html
      };
    },


    saveAllChanges: function () {
      var q = this.saveQueue,
          segments = [],
          promise = storage.saveOperation(segments);

      for (var i in q) {
        segments.push(prepareSegment(q[i].html));
      }

      promise.done(function () {
        console.info('Saved successfully');
      }).fail(function () {
        console.error('Error saving');
      });
    },


    saveSegmentChange: function (data) {
      var segments = [prepareSegment(data.el, data.otherSegmentData)],
          promise = storage.saveOperation(segments);

      promise.done(function () {
        console.info('Saved successfully');
      }).fail(function () {
        console.error('Error saving');
      });
    },


    /**
     * Returns the current document
     *
     * @param:  {Function} callback
     * @return: {Object} document
     */
    getCurrentDocument: function (callback) {
      if (callback) {
        callback(null, storage.currentDocument);
      }

      return storage.currentDocument;
    },


    /**
     * Set the current document
     *
     * @param: {String} id - document id
     * @param: {Function} callback
     */
    // TODO: To be refactored when it proves even more painful
    setCurrentDocument: function (id, callback) {
      var me = this, index, map;

      // Inject current document
      storage.getDocument(id, function (err, data) {

        me.initData(id, data);

        map = function (err, skeleton) {

          me.mapSkeletonData(skeleton);

          if ((+index + 1) === me.files.length) {
            if (callback) {
              callback(null, storage.currentDocument);
            }
          }
        };

        for (var index in me.files) {
          storage.getSkeleton(me.files[index].id, map);
        }

      });
    },

    initData: function (id, data) {
      this.files = data.files;
      storage.currentDocument.id = id;
    },

    mapSkeletonData: function (skeleton) {
      var me = this;

      me.tagPairMap = createDefinitionMap(skeleton.tagPairDefinitions);
      me.formatingGroupMap = createDefinitionMap(skeleton.formattingGroups);
      me.placeholderMap = createDefinitionMap(skeleton.placeholderTagDefinitions);
    },

    /**
     * Get Paragraph from storage
     *
     * @param: {String} id
     * @param: {Function} callback
     */
    getParagraph: function (id, callback) {
      if (!id && callback) {
        callback(true);
      }

      if (callback) {
        storage.getParagraph(id, callback);
      }
    },


    /**
     * Get the next set of paragraphs of the current document
     *
     * @param: {Function} callback
     */
    getNextParagraphs: function (callback) {
      storage.getNextParagraphs(callback);
    },


    /**
     * Get all paragraphs from storage
     *
     * @param: {Function} callback
     */
    getParagraphs: function (documentId, callback, limit, offset) {
      if (typeof callback === 'function') {
        storage.getParagraphs(documentId, callback, limit, offset);
      }
    },


    /**
     * Get all documents
     *
     * @param: {Function} callback
     */
    getDocuments: function (callback) {
      if (typeof callback === 'function') {
        storage.getDocuments(callback);
      }
    },


    /**
     * Returns one document from the list of documents
     * @param  {String} id
     * @return {String}
     */
    getDocumentInfo: function (id) {
      return storage.documents.filter(function (doc) {
        return doc.id === id;
      })[0];
    },


    getSegmentBySegmentNumber: function (segmentNumber) {
      return this.segmentsMap[segmentNumber];
    },


    /**
     * Binds handlers for saving the changes
     */
    bindHandlers: function () {
      var me = this,
          changes = {};

      Mediator.subscribe(
        'segment:start-edit', // Fired by markCurrentSegment() in KeyboardBindings
        function (data) {
          changes[data.segmentNumber] = {
            status: data.otherSegmentData.confirmationlevel,
            html: data.el.innerHTML
          };
        });

      Mediator.subscribe(
        'segment:end-edit', // Fired by markCurrentSegment() in KeyboardBindings
        function (data) {
          var html = data.el.innerHTML,
              status = data.otherSegmentData.confirmationlevel,
              original = changes[data.segmentNumber];

          if (html !== original.html || status !== original.status) {
            me.saveSegmentChange(data);
          }
        });
    },

    init: function () {
      this.bindHandlers();
    }
  };
})();

module.exports = DataProvider;

},{"./Helpers":5,"./MarkupDataFactory":9,"./Mediator":10,"./Storage":20,"./TranslationOrigin":22,"./config":25}],4:[function(require,module,exports){
/* File: Documents.js */
/* jshint undef: true, unused: true */
/* globals require, module */
'use strict';

/**
 * Documents module
 *
 * Displays all documents from the storage, attaches event handlers to the
 * documents for opening them
 *
 */

var config = require('./config');
var Helpers = require('./Helpers');
var DataProvider = require('./DataProvider');
var Paragraphs = require('./Paragraphs');



var Documents = (function () {

  var dataProvider = DataProvider;

  // Not used?
  // function createNode(tag, content, className, style) {
  //   var elm = document.createElement(tag);
  //   if (className) {
  //     elm.className = className;
  //   }

  //   if (style) {
  //     elm.style.cssText = style;
  //   }

  //   if (typeof (content) === 'string') {
  //     addText(elm, content);
  //   }

  //   if (content && content.nodeName) {
  //     elm.appendChild(content);
  //   }

  //   return elm;
  // }

  // function addText(elm, text) {
  //   elm.innerHTML = text;
  // }

  return {

    /*
      The list of documents
    */
    documents: [],

    /**
     * Open a document in the view
     *
     */
    openDocument: function (id) {
      var me = this;

      dataProvider.setCurrentDocument(id, function (err, doc) {
        Paragraphs.renderFirstParagraphs();
        me.showDocumentInfo(doc.data);
      });

    },

    showDocumentInfo: function (doc) {
      var elements = ['.ue-translation-information'];
      for (var i = 0; i < elements.length; i++) {
        var el = $(elements[i]);
        el.html(Helpers.template(el.data('tmpl'), doc));
      }
    },


    /**
     * Renders all the documents
     *
     */
    renderDocuments: function () {
      var $documentsList = this.$documentsList, me = this;
      DataProvider.getDocuments(function (err, documents) {
        var reverseDocs = documents.reverse();
        me.documents = reverseDocs;
        $documentsList.html(
          Helpers.template('tmpl-documents-list', { documents: reverseDocs })
        );
      });
    },

    showDocumentList: function () {
      this.$documentsList.slideDown();
      $('.documents-control').addClass('slideup');
      this.$editor.addClass('faded');
    },

    hideDocumentList: function () {
      this.$documentsList.slideUp();
      $('.documents-control').removeClass('slideup');
      this.$editor.removeClass('hidden faded');
    },

    bindHandlers: function () {
      var me = this;

      this.$body.on('click.openDoc', '[data-action="open-document"]',
        config.fullMode ?
          function () { // arg was 'event' - not used
            var $this = $(this);

            $('.documents-control').addClass('active');
            me.openDocument($this.data('id'));
            me.hideDocumentList();

            return false;
          } :
          function () { // arg was 'event' - not used
            window.location = config.baseUrl + '/show/' + this.dataset.id;
            return false;
          }
      );

      this.$body.on('click.showDocs', '[data-action="show-documents-list"]', function () { // arg was 'event' - not used
        me.showDocumentList();
        return false;
      });

      this.$body.on('click.hideDocs', '[data-action="hide-documents-list"]', function () { // arg was 'event' - not used
        me.hideDocumentList();
        return false;
      });
    },

    init: function () {
      this.$body = $('body');
      this.$documentsList = this.$body.find('#documents-list');
      this.$editor = $('.editor-wrapper');

      var root = config.baseUrl + '/';
      if (window.location.href === root || window.location.hash === null) {
        this.renderDocuments();
      }

      this.bindHandlers();

      if (!config.fullMode && !config.onlyDocs) {
        this.$documentsList.css({display: 'none'});
        this.openDocument(Helpers.paramsFromUrl('/document/:id', window.location.href)[0]);
        $('.documents-control').addClass('active');
      } else {
        this.$editor.addClass('hidden');
      }
    }
  };
})();

module.exports = Documents;
},{"./DataProvider":3,"./Helpers":5,"./Paragraphs":13,"./config":25}],5:[function(require,module,exports){
/* File: Documents.js */
/* jshint undef: true, unused: true */
/* globals require, module, Handlebars */
'use strict';

var config = require('./config');

var Helpers = (function () {
  var root          = config.baseUrl,
      optionalParam = /\((.*?)\)/g,
      namedParam    = /(\(\?)?:\w+/g,
      splatParam    = /\*\w+/g,
      escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  var TEMPLATES = {};

  Handlebars.registerHelper('ifCond', function (v1, v2, options) {
    if (v1 === v2) {
      return options.fn(this);
    }
    return options.inverse(this);
  });

  Handlebars.registerHelper('whichever', function () {
    for (var i = 0; i < arguments.length - 1; i++) {
      if (arguments[i]) {
        return arguments[i];
      }
    }

    return '';
  });

  Handlebars.registerHelper('toLanguageCodeLowerCase', function (str) {
    var minimumLanguageCodeLength = 2,
        standarsIsoLength = 5;

    if (str.length < minimumLanguageCodeLength) {
      return '';
    }

    if (str.length === minimumLanguageCodeLength) {
      return str.toLowerCase();
    }

    if (str.length === standarsIsoLength) {
      str = str.substring(3).toLowerCase();
    }

    return str;
  });

  function _routeToRegExp(route) {
    route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?')
                 .replace(namedParam, function (match, optional) {
                    return optional ? match : '([^\/]+)';
                  }).replace(splatParam, '(.*?)');

    return new RegExp('^' + route + '$');
  }

  function _extractParameters(route, fragment) {
    var result = route.exec(fragment);
    return result.slice(1);
  }

  function precompileTemplate(templateName, isPartial) {
    var el = document.getElementById(templateName);
    var str = el.innerHTML,
        partials = (el.dataset.partials || '').split(/\s+/);

    for (var i = 0; i < partials.length; i++) {
      if (partials[i]) {
        precompileTemplate(partials[i], true);
      }
    }

    if (isPartial) {
      Handlebars.partials[templateName] = Handlebars.compile(str);
    } else {
      TEMPLATES[templateName] = Handlebars.compile(str);
    }
  }


  function keyCodeToString(keyCode) {
    return String.fromCharCode(keyCode).toLowerCase();
  }

  /**
   * Converts document fragment to html string
   * @param  {DocumentFragment}
   * @return {String}
   */
  function fragmentToString(fragment) {
    var elem = document.createElement('div'),
        string = '';

    if (fragment && fragment.hasChildNodes()) {
      elem.appendChild(fragment.cloneNode(true));
      string = elem.innerHTML;
    }

    return string;
  }


  /**
   * Creates a documentFragment from a HTML Sring
   * @param  {String} elem HTML string '<dic class="some"></div>'
   * @return {DocumentFragment}
   */
  function stringToHTMLElement(elem) {
    var doc = document,
        div = doc.createElement('div'),
        fragment = doc.createDocumentFragment();

    div.innerHTML = elem;

    return fragment.appendChild(div.firstChild);
  }



  /**
   * Returns true if element has parent with given class name
   * @param  {HTMLNode} elem
   * @param  {String}   parentClass
   * @return {Boolean}
   */
  function hasParent(elem, parentClass) {
    while (elem && elem.nodeType !== 9 && (elem.nodeType !== 1 || !hasClass(elem, parentClass))) {
      elem = elem.parentNode;

      if (elem && elem.nodeType === 1 && hasClass(elem, parentClass)) {
        return true;
      }
    }

    return false;
  }


  /**
   * Returns true if an element has a given class
   * @param  {HTMLElement}  elem
   * @param  {String}       className
   * @return {Boolean}
   */
  function hasClass(elem, className) {
    return elem.className.replace(/[\t\r\n\f]/g, ' ').indexOf(className) >= 0;
  }


  /**
   * Escapes a HTML string
   * @param  {String} html - HTML string
   * @return {String} returns escaped HTML string
   */
  function escapeHTML(html) {
    var map = {
      '&'  : '&amp;',
      '<'  : '&lt;',
      '>'  : '&gt;',
      '"'  : '&quot;',
      '\'' : '&#x27;',
      '/'  : '&#x2F;',
    };

    return String(html).replace(/[&<>"'\/]/g, function (str) {
      return map[str];
    });
  }

  return {
    paramsFromUrl: function (policy, url) {
      policy = _routeToRegExp(policy);
      url = url.substr(root.length);

      return _extractParameters(policy, url);
    },

    _rand: function () {
      return parseInt(Math.random() * 0xFFFFFF, 10);
    },

    _extend: function (destination, source) {
      for (var property in source) {
        if (destination[property] && (typeof(destination[property]) === 'object') &&
           (destination[property].toString() === '[object Object]') && source[property]) {
          this._extend(destination[property], source[property]);
        } else {
          destination[property] = source[property];
        }
      }

      return destination;
    },

    constructor: function (prototype) {
      function mixin(obj, attr) {
        for (var i in attr) {
          obj[i] = attr[i];
        }
      }
      var c = function () {
        if (this.init) {
          this.init.apply(this, Array.prototype.slice.apply(arguments));
        }
      };
      mixin(c.prototype, prototype);
      return c;
    },

    template: function (templateName, data) {
      if (!TEMPLATES[templateName]) {
        precompileTemplate(templateName);
      }

      return TEMPLATES[templateName](data);
    },

    keyCodeToString: keyCodeToString,
    fragmentToString: fragmentToString,
    hasParent: hasParent,
    hasClass: hasClass,
    stringToHTMLElement: stringToHTMLElement,
    escapeHTML: escapeHTML
  };
})();

module.exports = Helpers;
},{"./config":25}],6:[function(require,module,exports){
/* File: Keyboard.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

var shiftEnterHandler = require('./keyboard/ShiftEnterHandler');
var segmentUnderCurrentSelection = require('./keyboard/SegmentUnderCurrentSelection');

module.exports = {
  ShiftEnterHandler: shiftEnterHandler,
  SegmentUnderCurrentSelection: segmentUnderCurrentSelection
};
},{"./keyboard/SegmentUnderCurrentSelection":27,"./keyboard/ShiftEnterHandler":28}],7:[function(require,module,exports){
/* File: KeyboardBingings.js */
/* jshint undef: true, unused: true */
/* globals $, _, require, module */
'use strict';

var dataProvider = require('./DataProvider');
var segmentWatcher = require('./SegmentsWatcher');
var Mediator = require('./Mediator');
var tmpl = require('./Tmpl');
var helpers = require('./Helpers');

var Segment = require('./Segment');
var Selection = require('./Selection');
var Keyboard = require('./Keyboard');
var Mouse = require('./Mouse');
var CommandManager = require('./CommandManager');

var KeyboardBindings = function (target) {
  var me = this;
  me.target = target;
};

var proto = KeyboardBindings.prototype = {
  // Keyboard keys
  keyTab: 9,
  keyBackspace: 8,
  keyEnter: 13,
  keySpace: 32,

  keyPageUp: 33,
  keyPageDown: 34,
  keyEnd: 35,
  keyHome: 36,
  keyInsert: 45,
  keyDelete: 46,

  keyLeftArrow: 37,
  keyUpArrow: 38,
  keyRightArrow: 39,
  keyDownArrow: 40,

  keyShift: 16,
  keyCtrl: 17,
  keyAlt: 18,
  keyEsc: 27,

  keyCapsLock: 20,
  keyNumLock: 144,
  keyScrollLock: 145,

  keyF1: 112,
  keyF2: 113,
  keyF3: 114,
  keyF4: 115,
  keyF5: 116,
  keyF6: 117,
  keyF7: 118,
  keyF8: 119,
  keyF9: 120,
  keyF10: 121,
  keyF11: 122,
  keyF12: 123
};

proto.ignoredKeys = [
  proto.keyLeftArrow,
  proto.keyUpArrow,
  proto.keyRightArrow,
  proto.keyDownArrow,
  proto.keyCapsLock,
  proto.keyScrollLock,
  proto.keyNumLock,
  proto.keyAlt,
  proto.keyCtrl,
  proto.keyShift,
  proto.keyPageUp,
  proto.keyPageDown,
  proto.keyHome,
  proto.keyEnd,
  proto.keyEnter,
  proto.keyEsc,
  proto.keyInsert,
  proto.keyF1,
  proto.keyF2,
  proto.keyF3,
  proto.keyF4,
  proto.keyF5,
  proto.keyF6,
  proto.keyF7,
  proto.keyF8,
  proto.keyF9,
  proto.keyF10,
  proto.keyF11,
  proto.keyF12
];

proto.allowedKeysInLockedContent = {
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'Left',
  38: 'Up',
  39: 'Right',
  40: 'Down',

  112: 'F1',
  113: 'F2',
  114: 'F3',
  115: 'F4',
  116: 'F5',
  117: 'F6',
  118: 'F7',
  119: 'F8',
  120: 'F9',
  121: 'F10',
  122: 'F11',
  123: 'F12'
};

proto.textNodeType = 3;
proto.elementNodeType = 1;
proto.currentSelection = null;
proto.currentElementIsLocked = false;

proto.bind = function () {
  var me = this;

  me.target.on('keydown', function (ev) { return me.disableEnterKey(ev); });
  me.target.on('keydown', function (ev) { return me.disableBackspaceAtStartOfSegment(ev); });
  me.target.on('keydown', function (ev) { return me.disableDeleteAtEndOfSegment(ev); });
  me.target.on('keydown', function (ev) { return me.handleBackspaceAction(ev); });
  me.target.on('keydown', function (ev) { return me.handleDeleteAction(ev); });
  me.target.on('keydown', function (ev) { return me.handleRemoveOnSelection(ev); });
  me.target.on('keydown', function (ev) { return me.preventTagsRemoval(ev); });
  me.target.on('keydown', function (ev) { return me.toggleSegmentLockState(ev); });
  me.target.on('keydown', function (ev) { return me.handleClearTagsShortcutPreventsDefault(ev); });
  me.target.on('keydown', function (ev) { return me.handleTabKey(ev); });

  // Trigger mouseup & keydown events in locked content to make sure we stop editing
  me.target.on('mouseup', function (ev) { return me.handleCrossSegmentSelection(ev); });
  me.target.on('keydown mouseup', function (ev) { return me.disableEditing(ev); });
  me.target.on('mouseup', function (ev) { return me.markCurrentSegment(ev); });

  me.target.on('keyup', function (ev) { return me.handleCaretPosition(ev); });
  me.target.on('keyup', function (ev) { return me.markCurrentSegment(ev); });
  me.target.on('keyup', function (ev) { return me.changeStatusToDraft(ev); });
  me.target.on('keyup', function (ev) { return me.changeStatusToConfirmed(ev); });
  me.target.on('keyup', function (ev) { return me.handleMissingTextContainer(ev); });
  me.target.on('keyup', function (ev) { return me.handleClearTags(ev); });
  me.target.on('keyup', function (ev) { return new Keyboard.ShiftEnterHandler(ev); });

  me.target.on('keyup paste', function (ev) { return me.resizeContainer(ev); });
  me.target.on('paste', function (ev) { return (new CommandManager()).execute('paste', ev); });

  // Handel CTRL+CLICK on tags
  me.target.on('mousedown', '[data-tag-copy="true"]',
    function (ev) { return new Mouse.CtrlClickHandler().handle(ev); });

  me.target.on('mouseover', '[data-tag-copy="true"]',
    function (ev) { return new Mouse.CtrlHoverHandler().mouseOver(ev); });

  me.target.on('mouseleave', '[data-tag-copy="true"]',
    function (ev) { return new Mouse.CtrlHoverHandler().mouseLeave(ev); });
};

// TODO once KeyboardBindings is refactored this can be removed
// SegmentUnderCurrentSelection has been moved to it's own module
proto._segmentUnderCurrentSelection = Keyboard.SegmentUnderCurrentSelection;


proto.disableEnterKey = function (ev) {
  var me = this;

  if (ev.shiftKey) {
    return;
  }

  if (ev.keyCode === me.keyEnter) {
    ev.preventDefault();
  }
};

proto.disableBackspaceAtStartOfSegment = function (ev) {
  var me = this;
  var selection = document.getSelection();
  var focusNode = selection.focusNode;
  var segmentEl;

  if (ev.keyCode !== me.keyBackspace) {
    return;
  }

  if (!me._isInvisibleChar(focusNode)) {
    return;
  }

  segmentEl = $(focusNode.parentNode);

  if (focusNode.previousSibling === null &&
      segmentEl.hasClass('ue-segment')) {
    ev.preventDefault();
  }
};

proto.disableDeleteAtEndOfSegment = function (ev) {
  var me = this,
      selection = document.getSelection(),
      focusNode,
      focusOffset;

  if (!selection.isCollapsed) {
    return;
  }

  if (ev.keyCode !== me.keyDelete) {
    return;
  }

  focusNode = selection.focusNode;
  focusOffset = selection.focusOffset;

  if (focusNode === null) {
    return;
  }

  if (focusNode.nextSibling === null &&
      focusNode.length === focusOffset &&
      me.isLastInSegment(focusNode)) {
    ev.preventDefault();
  }
};

proto.isLastInSegment = function (node) {
  var parentEl,
      nodeEl,
      atIndex,
      numberOfChildren;

  nodeEl = $(node);
  parentEl = nodeEl.parent();

  while (!parentEl.hasClass('ue-inline-content')) {
    nodeEl = parentEl;
    parentEl = nodeEl.parent();
  }

  atIndex = nodeEl.index() + 1;
  numberOfChildren = parentEl.children().length;

  return atIndex === numberOfChildren;
};

proto.handleBackspaceAction = function (ev) {
  var me = this,
      selection = document.getSelection(),
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset,
      previousSibling,
      inlineElement,
      tag,
      isStartTag;

  if (!selection.isCollapsed) {
    return;
  }

  if (focusNode === null) {
    return;
  }

  if ($(focusNode).hasClass('ue-tagpair-content') && focusOffset === 0) {
    selection.modify('move', 'backward', 'character');
    focusNode = selection.focusNode;
    focusOffset = selection.focusOffset;
  }

  if (!me._isInvisibleChar(focusNode)) {
    return;
  }

  inlineElement = focusNode.parentNode;
  tag = focusNode.previousSibling;

  if (ev.keyCode !== me.keyBackspace) {
    return;
  }

  if (inlineElement === null) {
    return;
  }

  if ($(inlineElement).hasClass('ue-segment')) {
    return;
  }

  if (focusOffset === 0) {
    selection.modify('move', 'forward', 'character');
  }

  isStartTag = $(tag).hasClass('ue-tag-start');

  if (isStartTag) {
    var ueTagWrapper = inlineElement;
    previousSibling = ueTagWrapper.previousSibling;

    var parentIsAnotherTag = $(ueTagWrapper.parentNode).hasClass('ue-tagpair-content');
    if (parentIsAnotherTag) {
      var ueTagPairContent = ueTagWrapper.parentNode;
      previousSibling = ueTagPairContent.previousSibling;
    }

  } else {
    previousSibling = inlineElement.previousSibling.lastChild;
  }

  me._removeInline(inlineElement, ev);

  if (previousSibling === null) {
    return;
  }

  var range = document.createRange();

  range.setStartAfter(previousSibling);

  selection.removeAllRanges();
  selection.addRange(range);

  ev.stopPropagation();
};


proto.handleDeleteAction = function (ev) {
  var me = this,
      selection = document.getSelection(),
      focusNode,
      focusNodeParent,
      focusOffset,
      nextSibling,
      ueTextParentEl,
      isNextSiblingTag,
      isNextSiblingTagHidden,
      isFocusOnText,
      isAtEndOfTextNode,
      isFocusInsideStartTag,
      isFocusOnInvisibleChar,
      isFocusInsidePreviousTag,
      isFocusAtStartOfSegment,
      selectionRangePosition,
      range;

  if (!selection.isCollapsed) {
    return;
  }

  if (ev.keyCode !== me.keyDelete) {
    return;
  }

  focusNode = selection.focusNode;
  focusNodeParent = focusNode.parentNode;
  focusOffset = selection.focusOffset;

  isFocusOnText = focusNode.nodeType === me.textNodeType;
  isAtEndOfTextNode = focusOffset === focusNode.length;
  isFocusOnInvisibleChar = me._isInvisibleChar(focusNode);
  isFocusInsideStartTag = isFocusOnInvisibleChar && $(focusNode.previousSibling).hasClass('ue-tag-start');
  isFocusInsidePreviousTag = isFocusOnInvisibleChar && $(focusNode.previousSibling).hasClass('ue-tag');
  isFocusAtStartOfSegment = isFocusOnInvisibleChar && $(focusNode).index() === 0;

  nextSibling = focusNode.nextSibling;

  if (isFocusOnInvisibleChar && focusOffset === 0) {
    selection.modify('move', 'forward', 'character');
  }

  if (isFocusOnText && !isFocusOnInvisibleChar) {
    if (!isAtEndOfTextNode) {
      return;
    }

    ueTextParentEl = $(focusNodeParent);

    if (ueTextParentEl.hasClass('ue-text')) { // we are in text before start tag
      nextSibling = focusNode.parentNode.nextSibling; // ue-tag-wrapper for start tag
    } else {
      throw 'unexpected case where selection is text, but is not contained in a text node';
    }

    // we are in text inside a tag pair
    if (nextSibling === null && $(focusNodeParent.parentNode).hasClass('ue-tagpair-content')) {
      nextSibling = focusNodeParent.parentNode.nextSibling; // ue-tag-wrapper for end tag
      selectionRangePosition = nextSibling.nextSibling; // what comes after the end-tag
    }
  }

  if (isFocusInsideStartTag) {
    var contentExists = focusNodeParent.nextSibling.firstChild;

    if (contentExists) {

      if ($(contentExists).hasClass('ue-text')) {
        // position cursor and let the default behavior
        range = document.createRange();
        range.setStartBefore(contentExists);

        selection.removeAllRanges();
        selection.addRange(range);

        return;
      }

      if ($(contentExists).hasClass('ue-tag-wrapper')) {
        nextSibling = contentExists;
      }

    } else { // we delete the current tag
      nextSibling = focusNodeParent;
    }

  } else if (isFocusInsidePreviousTag) {
    nextSibling = focusNodeParent.nextSibling;
  } else if (isFocusAtStartOfSegment) {
    nextSibling = focusNode.nextSibling.firstChild;
  }

  isNextSiblingTag = $(nextSibling).hasClass('ue-tag-wrapper');
  isNextSiblingTagHidden = isNextSiblingTag && $(nextSibling).hasClass('hide');

  if (isNextSiblingTagHidden) {
    return;
  }

  if (isNextSiblingTag) {
    me._removeInline(nextSibling, ev);
  }

  if (selectionRangePosition) {
    range = document.createRange();
    range.setStartBefore(selectionRangePosition);

    selection.removeAllRanges();
    selection.addRange(range);
  }
};

proto._removeInline = function (inlineElement, ev) {
  var tagPairId,
      tagPairContent,
      tagPairContentEl,
      isEndTagPair,
      isStartTagPair,
      isTagPair,
      isPlaceholder;

  isPlaceholder = inlineElement.dataset.type === 'placeholder';
  isEndTagPair = inlineElement.dataset.type === 'end-tag';
  isStartTagPair = inlineElement.dataset.type === 'start-tag';
  isTagPair = isStartTagPair || isEndTagPair;

  if (isPlaceholder) {
    inlineElement.remove();
    ev.preventDefault();

    return;
  }

  if (!isTagPair) {
    return;
  }

  if (isEndTagPair) {
    tagPairContent = inlineElement.previousSibling;
    tagPairId = tagPairContent.dataset.id;
  }

  if (isStartTagPair) {
    tagPairContent =  inlineElement.nextSibling;
    tagPairId = tagPairContent.dataset.id;
  }

  if (isTagPair) {
    segmentWatcher.removeTagPair(tagPairId);
    tagPairContentEl = $(tagPairContent);
    tagPairContentEl.replaceWith(tagPairContentEl.children());

    ev.preventDefault();
  }
};

proto.handleRemoveOnSelection = function (ev) {
  var me = this,
      selection = document.getSelection(),
      range,
      currentRange,
      rangeContent,
      commonAncestorContainer,
      startContainer;

  if (selection.getRangeAt(0).collapsed) {
    return;
  }

  if (ev.keyCode !== me.keyDelete && ev.keyCode !== me.keyBackspace) {
    return;
  }

  if (me.isCrossSegmentSelection()) {
    ev.preventDefault();
    return;
  }

  range = selection.getRangeAt(0);
  rangeContent = range.cloneContents();

  if (rangeContent.firstChild === rangeContent.lastChild &&
      rangeContent.firstChild.nodeType === me.textNodeType) {

    return;// allow default delete action
  }

  me.cleanupStrategy(rangeContent);


  currentRange = selection.getRangeAt(0);
  commonAncestorContainer = currentRange.commonAncestorContainer;
  startContainer = currentRange.startContainer;

  range.deleteContents();

  range = document.createRange();
  range.selectNode(startContainer);
  range.collapse();

  selection.removeAllRanges();
  selection.addRange(range);

  me.insertRangeContent(rangeContent, commonAncestorContainer);

  ev.preventDefault();
};

proto.isCrossSegmentSelection = function () {
  var selection = new Selection.SelectionContext(),
      result;

  result = selection.hasCommonAncestorClass('ue-editable');

  return result;
};

proto.cleanupStrategy = function (container) {
  var me = this;

  me.removeElementQueue = [];
  me._cleanup(container);
  me.removeElementQueue.forEach(function (item) {
    item.remove();
  });

  me.removeElementQueue = null;
};

proto._cleanup = function (container) {
  var me = this,
      i = 0,
      el;

  for (; i < container.childNodes.length; i++) {
    el = container.childNodes[i];

    me.removeText(el);
    me.removePairedTags(el, container);
    me.cleanTagPairContainer(el);
  }
};

proto.removeText = function (el) {
  var me = this,
      $el = $(el);

  if ($el.hasClass('ue-text')) {
    me.removeElementQueue.push($el);
  }
};

proto.removePairedTags = function (el, container) {
  var me = this,
      $el = $(el);

  if (el.dataset.type !== 'start-tag') {
    return;
  }

  var id = el.dataset.id;
  var matchedEndTag = _(container.childNodes).find(function (item) {
    var isTagWrapper = $(item).hasClass('ue-tag-wrapper'),

    isHidden = isTagWrapper && $(item).hasClass('hide'),
    dataset = item.dataset || {},
    isEndTag,
    hasMatchingId,
    isOk;

    isEndTag = dataset.type === 'end-tag';
    hasMatchingId = dataset.id === id;

    isOk = isTagWrapper && !isHidden && isEndTag && hasMatchingId;

    if (isOk) {
      return item;
    }

    return null;
  });

  var matchedTagPair = _(container.childNodes).find(function (item) {
    var isTagPairContainer = $(item).hasClass('ue-tagpair-content'),
    dataset = item.dataset || {},
    isTagPair,
    hasMatchingId,
    isOk;

    isTagPair = dataset.type === 'tagpair';
    hasMatchingId = dataset.id === id;

    isOk =  isTagPairContainer && isTagPair && hasMatchingId;

    if (isOk) {
      return item;
    }

    return;
  });

  if (matchedEndTag !== undefined) {
    me.removeElementQueue.push($el);
    me.removeElementQueue.push($(matchedEndTag));
    me.removeElementQueue.push($(matchedTagPair));
  }
};

proto.cleanTagPairContainer = function (el) {
  var me = this,
      isTagPair = $(el).hasClass('ue-tagpair-content');

  if (!isTagPair) {
    return;
  }

  me._cleanup(el);
};

proto.insertRangeContent = function (rangeContent, commonAncestorContainer) {
  var me = this,
      selection = document.getSelection(),
      focusNode,
      childNode,
      nextSibling,
      aheadSibling;

  focusNode = selection.focusNode;

  if (rangeContent.childNodes.length === 0) {
    return;
  }

  if (focusNode === null) {
    return;
  }

  // add content back
  while (focusNode.parentNode !== commonAncestorContainer) {
    focusNode = focusNode.parentNode;
  }

  childNode = rangeContent.childNodes[0];

  var firstChildEl = $(childNode);
  if (firstChildEl.hasClass('ue-tag-wrapper')) {
    // simple case, just add the content back
    $(focusNode).after(firstChildEl[0]);
    nextSibling = focusNode.nextSibling;
  } else if (me._needToMergeContainers(childNode, focusNode)) {
    me.mergeContentAtEndOf(childNode, focusNode);
    nextSibling = focusNode;
  }

  while (rangeContent.childNodes.length > 0) {
    childNode = rangeContent.childNodes[0];
    aheadSibling = nextSibling.nextSibling;

    if (me._needToMergeContainers(childNode, aheadSibling)) {
      me.mergeContentAheadOf(childNode, aheadSibling);
    } else {
      $(nextSibling).after(childNode);
      nextSibling = childNode;
    }
  }

};

proto._needToMergeContainers = function (childNode, aheadSibling) {
  var isChildNodeTagContainer,
      isAheadSibilingTagContainer,
      childNodeTagId,
      aheadSiblingTagId,
      isMergeNeeded;

  isChildNodeTagContainer = $(childNode).hasClass('ue-tagpair-content');
  isAheadSibilingTagContainer = $(aheadSibling).hasClass('ue-tagpair-content');

  if (!isChildNodeTagContainer) {
    return false;
  }

  if (!isAheadSibilingTagContainer) {
    return false;
  }

  childNodeTagId = childNode.dataset.id;
  aheadSiblingTagId = aheadSibling.dataset.id;

  isMergeNeeded = childNodeTagId === aheadSiblingTagId;

  return isMergeNeeded;
};

proto.mergeContentAheadOf = function (childNode, aheadSibling) {
  var me = this,
      positionEl;

  positionEl = $(childNode.childNodes[0]);
  positionEl.prependTo(aheadSibling);

  me.moveContents(childNode, positionEl);

  $(childNode).remove();
};

proto.mergeContentAtEndOf = function (childNode, previousSibling) {
  var me = this,
      positionEl;

  positionEl = $(childNode.childNodes[0]);
  positionEl.appendTo(previousSibling);

  me.moveContents(childNode, positionEl);

  $(childNode).remove();
};

proto.moveContents = function (fromNode, afterPositionEl) {
  var positionEl = afterPositionEl,
      childNode = fromNode,
      currentNode;

  while (childNode.childNodes.length > 0) {
    currentNode = childNode.childNodes[0];
    positionEl.after(currentNode);
    positionEl = $(currentNode);
  }
};

proto.preventTagsRemoval = function (ev) {
  var me = this,
      selection = document.getSelection(),
      textNode = selection.focusNode,
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset,
      focusNodeLength,
      isKeyBackspace = ev.keyCode === me.keyBackspace,
      isKeyDelete = ev.keyCode === me.keyDelete,
      singleCharacter = 1;

  if (!selection.isCollapsed) {
    return;
  }

  if (focusNode === null) {
    return;
  }

  if (!isKeyDelete && !isKeyBackspace) {
    return;
  }

  if (focusNode.nodeType === me.textNodeType) {
    // Firefox position fix
    if (focusOffset === 0 && isKeyBackspace) {
      me.fixFirefoxPositionZero();
      focusNode = selection.focusNode;
      focusOffset = selection.focusOffset;
    }

    focusNodeLength = focusNode.length;
    focusNode = focusNode.parentNode;
  }

  var isAtEnd = focusOffset === focusNodeLength;
  var isAtStart = focusOffset === singleCharacter;
  var isAtLastCharacter = (!isAtEnd && (focusOffset + singleCharacter)) === focusNodeLength;

  var isFocusOnText,
      isNextSiblingTag,
      isPreviousSibilingTag,
      isCurrentContainerTagPairContent,
      isParentTagContainer,
      ueTagWrapper,
      range;

  isFocusOnText = $(focusNode).hasClass('ue-text');
  // isParentTagContainer should be true in firefox
  isParentTagContainer = $(focusNode.parentNode).hasClass('ue-tagpair-content');

  var nextSibling = focusNode.nextSibling;
  var previousSibling = focusNode.previousSibling;
  var focusNodeParent = focusNode.parentNode;

  isNextSiblingTag = $(nextSibling).hasClass('ue-tag-wrapper');
  isPreviousSibilingTag = $(previousSibling).hasClass('ue-tag-wrapper');
  isCurrentContainerTagPairContent = $(focusNodeParent).hasClass('ue-tagpair-content');

  if (!isAtStart && !isAtEnd && !isAtLastCharacter || !isFocusOnText) {
    return;
  }

  if (isPreviousSibilingTag || isNextSiblingTag || isCurrentContainerTagPairContent) {
    if (isKeyBackspace) {
      ev.preventDefault();

      selection.removeAllRanges();
      range = document.createRange();
      range.setStart(textNode, (focusOffset - singleCharacter));
      range.setEnd(textNode, focusOffset);

      selection.addRange(range);
      range.deleteContents();

      // position
      if (isAtStart) {
        var moveDirection = isKeyBackspace ? 'backward' : 'forward';
        selection.modify('move', moveDirection, 'character');
      }
    }

    if (isKeyDelete && isNextSiblingTag) {
      var tagPairContent = nextSibling.nextSibling;
      var isTagPairContainer = $(tagPairContent).hasClass('ue-tagpair-content');

      if (isAtLastCharacter) {
        ev.preventDefault();

        // remove from the next text node
        selection.removeAllRanges();
        range = document.createRange();
        range.setStart(textNode, focusOffset);
        range.setEnd(textNode, focusOffset + singleCharacter);
        selection.addRange(range);
        range.deleteContents();

        // set selection position to start of text node
        selection.removeAllRanges();
        range = document.createRange();
        range.setStart(textNode, focusOffset);
        range.setEnd(textNode, focusOffset);
        selection.addRange(range);
      }

      if (isAtEnd) {
        if (isTagPairContainer) {
          var ueText = tagPairContent.firstChild;
          textNode = ueText.firstChild;

          if (textNode.length === 0) {
            // move to next sibling
            ueTagWrapper = tagPairContent.nextSibling;
            ueText = ueTagWrapper.nextSibling;

            if (ueText === null) {
              return;
            }

            textNode = ueText.firstChild;
          }

          ev.preventDefault();

          // remove from the next text node
          selection.removeAllRanges();
          range = document.createRange();
          range.setStart(textNode, 0);
          range.setEnd(textNode, 1);
          selection.addRange(range);
          range.deleteContents();

          // set selection position to start of text node
          range = document.createRange();
          range.setStart(textNode, 0);
          range.setEnd(textNode, 0);
          selection.addRange(range);
        }
      }
    }
  }

  if (isKeyDelete && isParentTagContainer) {
    // this is firefox, he puts the selection within the text node
    // unlike the current chrome implementation

    // remove textNode content
    var isRemovingFromCurrentTagContainer = focusOffset + singleCharacter === focusNodeLength;
    if (isRemovingFromCurrentTagContainer) {
      ev.preventDefault();

      range = document.createRange();
      range.setStart(textNode, focusOffset);
      range.setEnd(textNode, (focusOffset + singleCharacter));
      selection.removeAllRanges();
      selection.addRange(range);
      range.deleteContents();
    }
    // move selection to next sibling
    nextSibling = focusNodeParent;
    do {
      nextSibling = nextSibling.nextSibling;
    } while (nextSibling !== null && $(nextSibling).hasClass('ue-tag-wrapper'));

    textNode = nextSibling;
    do {
      textNode = textNode.firstChild;
    } while (textNode !== null && textNode.nodeType !== me.textNodeType);

    if (!isRemovingFromCurrentTagContainer) {
      ev.preventDefault();
      range = document.createRange();
      range.setStart(textNode, 0);
      range.setEnd(textNode, singleCharacter);
      selection.removeAllRanges();
      selection.addRange(range);
      range.deleteContents();
    }

    range = document.createRange();
    range.setStart(textNode, 0);
    range.setEnd(textNode, 0);
    selection.removeAllRanges();
    selection.addRange(range);
  }
};

proto.fixFirefoxPositionZero = function () {
  var selection = document.getSelection(),
      focusNode = selection.focusNode,
      ueText, ueTag, ueTagContainer,
      range;

  ueText = focusNode.parentNode;
  ueTag = ueText.previousSibling;

  if ($(ueTag).hasClass('ue-tag-wrapper')) {
    ueTagContainer = ueTag.previousSibling;

    range = document.createRange();
    range.selectNode(ueTagContainer.lastChild);
    range.collapse();

    selection.removeAllRanges();
    selection.addRange(range);
  }
};

proto.handleClearTagsShortcutPreventsDefault = function (ev) {
  var me = this,
    selection = new Selection.SelectionContext(),
    isCtrlPressed = ev.ctrlKey,
    isSpaceKeyPressed = ev.keyCode === me.keySpace,
    isClearTagsCommandPressed = isCtrlPressed && isSpaceKeyPressed;

  if (me.isCrossSegmentSelection()) {
    return;
  }

  if (selection.isCollapsed()) {
    return;
  }

  if (!isClearTagsCommandPressed) {
    return;
  }

  ev.preventDefault();
};

proto.handleClearTags = function (ev) {
  var me = this,
      selection = new Selection.SelectionContext(),
      isCtrlPressed = ev.ctrlKey,
      isSpaceKeyPressed = ev.keyCode === me.keySpace,
      isClearTagsCommandPressed = isCtrlPressed && isSpaceKeyPressed;

  if (me.isCrossSegmentSelection()) {
    return;
  }

  if (selection.isCollapsed()) {
    return;
  }

  if (!isClearTagsCommandPressed) {
    return;
  }

  me.tags = {};
  me.storedEvent = ev;

  var commonAncestorContainer = selection.commonAncestorContainer,
      startContainer = selection.startContainer,
      endContainer = selection.endContainer;
  if (commonAncestorContainer === startContainer && commonAncestorContainer === endContainer) {
    return;
  }
  // TODO see about edge cases where the startContainer and endContainer are left with no content
  // if selection at start is 0 maybe the tagpair start should automatically be included with the selection
  // if selection at end is full container length maybe the tagpair end should automatically be included with the selection

  var nodeWalker = new Selection.NodeWalker(startContainer);
  var end = new Selection.NodeWalker(endContainer);

  if (end.isTextNode()) {
    end = end.parent();
  }

  while (!nodeWalker.isNull() && !nodeWalker.isWrapperFor(commonAncestorContainer)) {
    me.identifyTagsInContainer(nodeWalker, end);
    nodeWalker = nodeWalker.parent();
  }

  var documentFragmentContainer = new Selection.NodeWalker(selection.cloneContents());

  me.moveTagsToFront = [];
  me.moveTagsToEnd = [];

  me.transformTags(documentFragmentContainer);

  me.moveTagsToFront.forEach(function (tag) {
    tag.remove();
  });
  me.moveTagsToEnd.forEach(function (tag) {
    tag.remove();
  });

  var needsToMoveTags =  me.moveTagsToFront.length > 0 || me.moveTagsToEnd.length > 0;
  if (!needsToMoveTags) {
    return;
  }

  selection.deleteContents();

  var patch = new Selection.NodeWalker(startContainer);
  if (patch.isTextNode()) {
    patch = patch.parent();
  }

  var lastEndTag = patch;
  while (patch.parent().isTagPairContainer()) {
    patch = patch.parent();
    if (me.moveTagsToFront.length > 0) {
      lastEndTag = me.moveTagsToFront.shift();
      patch.insertAfter(lastEndTag);
    }
  }
  lastEndTag.insertAfter(documentFragmentContainer);

  patch = new Selection.NodeWalker(endContainer);
  if (patch.isTextNode()) {
    patch = patch.parent();
  }

  while (!patch.isNull() && patch.parent().isTagPairContainer()) {
    patch = patch.parent();

    if (me.moveTagsToEnd.length > 0) {
      patch.insertBefore(me.moveTagsToEnd.pop());
    }
  }

  me.moveTagsToFront = null;
  me.moveTagsToEnd = null;
  me.tags = null;
  me.storedEvent = null;
};

proto.identifyTagsInContainer = function (nodeWalker, end) {
  var me = this,
      tagId;

  me.endContainerReached = false;

  do {
    if (nodeWalker.equals(end)) {
      me.endContainerReached = true;
    }

    if (nodeWalker.isTagPairContainer()) {
      nodeWalker = nodeWalker.firstChild();
      me.identifyTagsInContainer(nodeWalker, end);
      nodeWalker = nodeWalker.parent();
    }

    if (nodeWalker.isStartTag() && nodeWalker.canHide()) {
      tagId = nodeWalker.tagId();
      me.tags[tagId] = {startTag: nodeWalker,
        endTag: null
      };
    }

    if (nodeWalker.isEndTag() && nodeWalker.canHide()) {
      tagId = nodeWalker.tagId();
      me.tags[tagId] = me.tags[tagId] || {startTag: null, endTag: null };
      me.tags[tagId].endTag = nodeWalker;

      if (me.tags[tagId].startTag !== null) {
        me._removeInline(nodeWalker.el, me.storedEvent);

        delete me.tags[tagId];
      }
    }

    nodeWalker = nodeWalker.next();

  } while (!nodeWalker.isNull() && !me.endContainerReached);

  nodeWalker.returnToPrevious();
};

proto.transformTags = function (container) {
  var me = this,
      isInTags,
      nodeWalker;

  if (!container.hasChildren()) {
    return;
  }

  nodeWalker = container.firstChild();
  do {
    isInTags = nodeWalker.tagId() in me.tags;
    if (nodeWalker.isTagPairContainer() && isInTags) {
      var tagpair = nodeWalker;

      me.transformTags(tagpair);
      nodeWalker = nodeWalker.next();
      tagpair.replaceWithInnerContent();

      continue;
    }

    if (nodeWalker.isStartTag() && isInTags) {
      me.moveTagsToEnd.push(nodeWalker);
    }

    if (nodeWalker.isEndTag() && isInTags) {
      me.moveTagsToFront.push(nodeWalker);
    }

    nodeWalker = nodeWalker.next();
  } while (!nodeWalker.isNull());
};


proto.handleMissingTextContainer = function (ev) {
  var me = this,
      selection,
      focusNode,
      textContent,
      zeroWidthCharIndex,
      textBefore,
      textAfter,
      textEl,
      isInSegment,
      containerEl,
      currentText,
      ueTagWrapper,
      range;

  if (me.ignoredKeys.indexOf(ev.keyCode) !== -1) {
    return;
  }

  if (ev.keyCode === me.keyDelete || ev.keyCode === me.keyBackspace) {
    return;
  }

  selection = document.getSelection() || {};
  focusNode = selection.focusNode;

  if (focusNode === undefined || focusNode === null) {
    return;
  }

  textContent = focusNode.textContent;
  zeroWidthCharIndex = textContent.indexOf(String.fromCharCode(tmpl.zeroWidthNonJoinerCharCode));

  if (zeroWidthCharIndex > -1) {
    textBefore = textContent.substring(0, zeroWidthCharIndex);
    textAfter = textContent.substring(zeroWidthCharIndex + 1);

    textEl = $(tmpl.text).append(textBefore).append(textAfter);
    textEl[0].dataset.type = 'text';

    isInSegment = $(focusNode.parentNode).hasClass('ue-segment');

    if (isInSegment) {
      $(focusNode.nextSibling).prepend(textEl);
    } else {
      containerEl = $(focusNode.parentNode);

      if (containerEl.hasClass('ue-text')) {
        currentText = containerEl.text();
        containerEl.html(textEl.text() + currentText);
      } else if (containerEl.hasClass('ue-inline-content')) {
        containerEl.append(textEl);
      } else {
        ueTagWrapper = $(focusNode).parent();
        ueTagWrapper.after(textEl);
      }
    }

    $(focusNode).replaceWith(tmpl.zwnj);

    range = document.createRange();
    range.selectNode(textEl[0]);
    range.collapse();

    selection.removeAllRanges();
    selection.addRange(range);
  }
};

proto._hasInlineContentParent = function (node) {
  var hasInlineContentParent = $(node.parentNode).hasClass('ue-inline-content');

  return hasInlineContentParent;
};

proto._positionInParent = function (node) {
  var parent = node.parentNode,
      position = parent.children.indexOf(node);

  return position;
};

proto.resizeContainer = function (ev) {
  var me = this;
  var enterIsPressed = (ev.keyCode === me.keyEnter);

  if (!(ev.shiftKey && enterIsPressed)) {
    return;
  }

  segmentWatcher.resize(me.currentSegmentNumber);
};

proto.markCurrentSegment = function () {
  var me = this;

  var previousSegmentNumber = me.currentSegmentNumber;
  var previousSegmentEl = me.currentSegmentEl;

  var currentSegmentSelection = me._segmentUnderCurrentSelection();

  me.currentSegmentNumber = currentSegmentSelection.segmentNumber;
  me.currentSegmentEl = currentSegmentSelection.segmentEl;

  segmentWatcher.markContainerAsInactive(previousSegmentNumber);
  segmentWatcher.markContainerAsActive(me.currentSegmentNumber);

  if (me.currentSegmentNumber !== undefined &&
    me.currentSegmentEl !== undefined &&
    me.currentSegmentNumber !== previousSegmentNumber) {

    var currentDataset = me.currentSegmentEl.dataset;

    Mediator.publish('segment:start-edit', {
      el: me.currentSegmentEl,
      segmentNumber: currentDataset.segmentNumber,
      otherSegmentData: dataProvider.getSegmentBySegmentNumber(me.currentSegmentNumber)
    });

  }

  if (previousSegmentNumber !== me.currentSegmentNumber &&
      previousSegmentEl !== undefined) {
    var previousDataset = previousSegmentEl.dataset;

    Mediator.publish('segment:end-edit', {
      el: previousSegmentEl,
      segmentNumber: previousDataset.segmentNumber,
      otherSegmentData: dataProvider.getSegmentBySegmentNumber(previousSegmentNumber)
    });
  }
};

proto.changeStatusToDraft = function (ev) {
  var me = this,
      isShiftEnterPressed,
      segment,
      segmentData;

  isShiftEnterPressed = (ev.shiftKey && ev.keyCode === me.keyEnter);

  if (!isShiftEnterPressed && me.ignoredKeys.indexOf(ev.keyCode) !== -1) {
    return;
  }

  segmentData = dataProvider.getSegmentBySegmentNumber(me.currentSegmentNumber);
  segment = new Segment(segmentData);

  if ((!ev.ctrlKey || !ev.metaKey) && helpers.keyCodeToString(ev.which) !== 'l') {
    segment.changeToDraft();
  }


  Mediator.publish('segment:confirmationLevelChanged', segmentData);
};


proto.changeStatusToConfirmed = function (ev) {
  var me = this;
  var isCtrlEnterPressed = ev.ctrlKey && (ev.keyCode === me.keyEnter);

  if (!isCtrlEnterPressed) {
    return;
  }

  var segment = dataProvider.getSegmentBySegmentNumber(me.currentSegmentNumber);

  if (segment.confirmationlevel !== 'translated') {
    segment.confirmationlevel = 'translated';
    Mediator.publish('segment:confirmationLevelChanged', segment);
    Mediator.publish('segment:jumpToNextUnConfirmed', segment);
  }
};

proto.handleCaretPosition = function (ev) {
  var me = this,
      arrowKeyPressed = me.isArrowKey(ev.keyCode),
      selection = document.getSelection(),
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset,
      movementKeys = [me.keyLeftArrow, me.keyRightArrow],
      indexOfMovementKeys = movementKeys.indexOf(ev.keyCode);

  if (selection === null || focusNode === null) {
    return;
  }

  if (indexOfMovementKeys === -1) {
    return;
  }

  var isTextNode = focusNode.nodeType === me.textNodeType;

  var isMovingForward = ev.keyCode === me.keyRightArrow;
  var moveDirection = isMovingForward ? 'forward' : 'backward';

  if (isTextNode && (me._isInvisibleChar(focusNode))) {
    if (ev.keyCode === me.keyLeftArrow) {
      selection.modify('move', 'backward', 'character');
    }

    if (ev.keyCode === me.keyRightArrow) {
      selection.modify('move', 'forward', 'character');
    }
  }

  if (focusNode.nodeType === me.elementNodeType) {
    selection.modify('move', 'forward', 'character');
  }

  while (me._isInsideTag(selection.focusNode)) {
    selection.modify('move', moveDirection, 'character');
  }
};

proto._isInvisibleChar = function (node) {
  var textContent = node.textContent,
      isInvisibleChar = textContent.length === 1 &&
                        textContent.charCodeAt(0) === tmpl.zeroWidthNonJoinerCharCode;

  return isInvisibleChar;
};

proto._isInsideTag = function (node) {
  var isTag;

  if (node.parentNode === null) {
    return false;
  }

  isTag = $(node.parentNode).hasClass('ue-tag');

  return isTag;
};

proto.isArrowKey = function (keyCode) {
  var me = this;

  return keyCode === me.keyUpArrow ||
         keyCode === me.keyDownArrow ||
         keyCode === me.keyLeftArrow ||
         keyCode === me.keyRightArrow;
};



/**
 * Lock current segment on CTRL+l
 * @param  {EventObject} ev
 */
proto.toggleSegmentLockState = function (ev) {
  var me = this,
      charKey = helpers.keyCodeToString(ev.which),
      segment = me._segmentUnderCurrentSelection(),
      segmentData = dataProvider.getSegmentBySegmentNumber(me.currentSegmentNumber),
      segmentEl = segment.segmentEl,
      isLockedSegment,
      sourceRel;

  if ((ev.ctrlKey || ev.metaKey) && charKey === 'l') {
    ev.preventDefault();

    isLockedSegment = segmentData.isLocked || false; //helpers.hasClass(segmentEl, 'ue-segment-locked');
    sourceRel = $('[data-source-segment-number="' + segment.segmentNumber + '"]')[0];

    if (isLockedSegment) {
      // Un-lock segment and publish unlock event
      [segmentEl, sourceRel].forEach(function (elem) {
        elem.classList.remove('ue-segment-locked');
        elem.dataset.isLocked = false;
        segmentData.isLocked = false;
      });

      Mediator.publish('segment:unlock', segmentData);

      return;
    }

    // Mark segment as locked and publish lock event
    [segmentEl, sourceRel].forEach(function (elem) {
      elem.classList.add('ue-segment-locked');
      elem.dataset.isLocked = true;
      segmentData.isLocked = true;
    });

    Mediator.publish('segment:lock', segmentData);
  }
};


/**
 * Insert tab on TAB keypress
 * @param  {Event} ev
 */
proto.insertTab = function (selection) {
  var tab = tmpl.keyTab.unicode,
      textNode = document.createTextNode(tab),
      range;

  if (!selection.anchorNode) {
    return;
  }

  range = selection.getRangeAt(0);


  if (selection.isCollapsed) {
    range.insertNode(textNode);
  }

  if (!selection.isCollapsed) {
    range.deleteContents();
    range.insertNode(textNode);
  }


  // Move cursor after inserted tab
  range.setStartAfter(textNode);
  range.setEndAfter(textNode);

  selection.removeAllRanges();
  selection.addRange(range);
};


/**
 * Handel TAB keys press
 * @param  {Object} ev [description]
 */
proto.handleTabKey = function (ev) {
  var me = this,
      selection = document.getSelection();

  if (ev.keyCode === me.keyTab) {
    ev.preventDefault();

    // If locked segment or locked content
    // stop inserting tabs
    if (me.currentElementIsLocked) {
      return;
    }

    me.insertTab(selection);
  }
};


/**
 * Disables editting in a locked segment or a locked content
 * @param  {Object} ev
 */
proto.disableEditing = function (ev) {
  var me = this,
      currentSegment = me._segmentUnderCurrentSelection(),
      selectionContext = new Selection.SelectionContext(),
      selection = selectionContext.selection,
      nodeWalker = new Selection.NodeWalker(ev.target),
      isInvisibleChar = nodeWalker.isInvisibleChar(),
      isSegment = nodeWalker.isSegment(),
      segmentData, elem, range;

  // Make sure this is false by default
  me.currentElementIsLocked = false;

  // Is locked content
  if (selection.anchorNode) {
    elem = selectionContext.commonAncestorContainer;
  }

  if (isSegment && selectionContext.isCollapsed()) {
    range = document.createRange();
    range.selectNode(nodeWalker.firstChild().el.nextSibling);

    selection.removeAllRanges();
    selection.addRange(range);
    range.collapse(true);
  }

  // Is cursor in a locked segment or content?
  if (currentSegment.segmentEl.dataset.isLocked || helpers.hasParent(elem.parentNode, 'ue-locked-content')) {
    me.currentElementIsLocked = true;
  }

  if (me.currentElementIsLocked) {
    // Prevent user to edit locked segment or content
    if (!(ev.keyCode in me.allowedKeysInLockedContent)) {
      ev.preventDefault();

      segmentData = dataProvider.getSegmentBySegmentNumber(currentSegment.segmentNumber);

      // Prevent segment status change
      segmentData.stopEditing = me.currentElementIsLocked;
      Mediator.publish('segment:stopEditingInLockedContent', segmentData);

      return false;
    }
  }
};


/**
 * Handles cross segments selection
 * TODO: extend it for mouse drag selection or keyboard selection?
 */
proto.handleCrossSegmentSelection = function (ev) {
  var textContent = ev.target.textContent,
      selectionContext = new Selection.SelectionContext(),
      selection = selectionContext.selection,
      isInvisibleChar = (new Selection.NodeWalker(ev.target)).isInvisibleChar(),
      range;

  // If dblclick or tripleclick and segment is empty
  // (relies on Zero Width Non-Joiner, to be changed if it will be removed)
  if (ev.originalEvent.detail >= 2 && isInvisibleChar) {
    range = document.createRange();
    range.selectNode(ev.target.children[0]);

    selection.removeAllRanges();
    selection.addRange(range);
    range.collapse(true);
  }
};

module.exports = KeyboardBindings;
},{"./CommandManager":2,"./DataProvider":3,"./Helpers":5,"./Keyboard":6,"./Mediator":10,"./Mouse":11,"./Segment":14,"./SegmentsWatcher":17,"./Selection":18,"./Tmpl":21}],8:[function(require,module,exports){
/* File: Layout.js */
/* jshint undef: true, unused: true */
/* globals _, require, module */

'use strict';

var Helpers = require('./Helpers');
var Tmpl = require('./Tmpl');
var Mediator = require('./Mediator');
var RibbonMenuCommands = require('./layout/RibbonMenuCommands');

var displaySavingInformation = function (type) {
  var elem = document.getElementsByClassName('ue-status-information').item(0),
      children = elem ? elem.childNodes : null,
      tmpl = Tmpl.fileStatus,
      stringToHTMLElement = Helpers.stringToHTMLElement,
      i = 0, len, prepareMessage;

  // Exit if element is no present
  if (elem === undefined || elem === null) {
    return;
  }

  // Remove existing messages
  if (children.length) {
    len = children.length;

    for (; i < len; i++) {
      elem.removeChild(children[i]);
    }
  }

  // Display messages utility function
  prepareMessage = function (message) {
    return elem.appendChild(stringToHTMLElement(_.template(tmpl, {status: message})));
  }

  switch (type) {
    case 'before':
      prepareMessage('Saving changes...');
      break;

    case 'after':
      prepareMessage('All changes saved');
      break;

    case 'failed':
      prepareMessage('Saving failed');
      break;
  }
};

var beforeSave = function () {
  return displaySavingInformation('before');
};

var afterSave = function () {
  return displaySavingInformation('after');
};

var failedSave = function () {
  return displaySavingInformation('failed');
};


module.exports = {
  init: function () {
    $(function () {
      // TO DO: Re-factor this part which deals with
      //        editor columns resize
      $(window).on('load resize', function () {
        var wrapper = $('.wrapper'),
            west = $('.wrapper-west'),
            east = $('.wrapper-east'),
            lineNumbers = $('.ue-gutter'),
            status = $('.ue-status'),
            topHeight = $('.navbar').outerHeight(),
            ribbonHeight = $('.nav-ribbon').outerHeight(),
            windowHeight = $(window).height(),
            statusBarHeight = $('.status-bar').outerHeight(),
            colHeight;

        if (west.length || east.length) {
          colHeight = windowHeight - (topHeight + ribbonHeight + statusBarHeight);

          wrapper.height(colHeight);
          west.css('min-height', colHeight + 'px');
          east.css('min-height', colHeight + 'px');
          lineNumbers.css('min-height', colHeight + 'px');
          status.css('min-height', colHeight + 'px');
        }
      });

      // Sidebar show/hide
      $('.btn-menu').on('click', function () {
        var sidebarEl = $('.sidebar');

        $(this).toggleClass('active');
        if (sidebarEl.length) {
          sidebarEl.toggleClass('open');
        }
      });

    });

    Mediator.subscribe('save:before', beforeSave);
    Mediator.subscribe('save:done', afterSave);
    Mediator.subscribe('save:fail', failedSave);

    // Initialize the ribbon menu commands
    RibbonMenuCommands.init();
  }
};
},{"./Helpers":5,"./Mediator":10,"./Tmpl":21,"./layout/RibbonMenuCommands":29}],9:[function(require,module,exports){
/* File: MarkupDataFactory.js */
/* jshint undef: true, unused: true */
/* globals require, module */
'use strict';

var MarkupDataFactory = function () {
  var me = this;
  var dataProvider = null;

  var MarkupDataSchema = {
    id: { type: String },
    type: { type: String },
    metadata: { type: Object }
  };

  var MkContainerSchema = {
    children: { type: Array, required: true, defaults: [] }
  };

  var MkSegmentSchema = {
    segmentNumber: { type: String },
    isLocked: { type: Boolean },
    confirmationLevel: { type: String },
    translationOrigin: { type: Object }
  };

  var MkTagpairSchema = {
    tagPairDefinitionId: { type: String },
    canHide: { type: Boolean }
  };

  var MkPlaceholderSchema = {
    placeholderTagDefinitionId: { type: String }
  };

  var MkLockedContentSchema = {
    children: { type: Array }
  };

  var MkTextSchema = {
    text: { type: String }
  };

  function MarkupData(options) {
    dataProvider = dataProvider || require('./DataProvider');
    for (var property in MarkupDataSchema) {
      if (options.hasOwnProperty(property)) {
        this[property] = options[property];
      }

      if (!options.hasOwnProperty(property) && MarkupDataSchema[property]['required']) {
        this[property] = MarkupDataSchema[property]['defaults'];
      }

      if (options.metadata && typeof options.metadata === 'string') {
        options.metadata = dataProvider.metadataMap[options.metadata];
      }
    }
  }

  function MkContainer(options) {
    // Invoke the superclass constructor on the new object
    MarkupData.call(this, options);

    for (var property in MkContainerSchema) {
      if (options.hasOwnProperty(property)) {
        this[property] = options[property];
      }

      if (!options.hasOwnProperty(property) && MkContainerSchema[property]['required']) {
        this[property] = MkContainerSchema[property]['defaults'];
      }
    }
  }

  function MkSegment(options) {
    // Invoke the superclass constructor on the new object
    MkContainer.call(this, options);

    for (var property in MkSegmentSchema) {
      if (options.hasOwnProperty(property)) {
        this[property] = options[property];
      }

      if (!options.hasOwnProperty(property) && MkSegmentSchema[property]['required']) {
        this[property] = MkSegmentSchema[property]['defaults'];
      }
    }
  }

  function MkTagpair(options) {
    // Invoke the superclass constructor on the new object
    MkContainer.call(this, options);

    for (var property in MkTagpairSchema) {
      if (options.hasOwnProperty(property)) {
        this[property] = options[property];
      }

      if (!options.hasOwnProperty(property) && MkTagpairSchema[property]['required']) {
        this[property] = MkTagpairSchema[property]['defaults'];
      }
    }
  }

  function MkPlaceholder(options) {
    // Invoke the superclass constructor on the new object
    MarkupData.call(this, options);

    for (var property in MkPlaceholderSchema) {
      if (options.hasOwnProperty(property)) {
        this[property] = options[property];
      }

      if (!options.hasOwnProperty(property) && MkPlaceholderSchema[property]['required']) {
        this[property] = MkPlaceholderSchema[property]['defaults'];
      }
    }
  }

  function MkLockedContent(options) {
    // Invoke the superclass constructor on the new object
    MkContainer.call(this, options);


    for (var property in MkLockedContentSchema) {
      if (options.hasOwnProperty(property)) {
        this[property] = options[property];
      }

      if (!options.hasOwnProperty(property) && MkLockedContentSchema[property]['required']) {
        this[property] = MkLockedContentSchema[property]['defaults'];
      }
    }
  }

  function MkText(options) {
    // Invoke the superclass constructor on the new object
    MarkupData.call(this, options);

    for (var property in MkTextSchema) {
      if (options.hasOwnProperty(property)) {
        this[property] = options[property];
      }

      if (!options.hasOwnProperty(property) && MkTextSchema[property]['required']) {
        this[property] = MkTextSchema[property]['defaults'];
      }
    }
  }

  return {
    create: function (data) {
      //delete property that does not exist
      for (var property in data) {
        if (data.hasOwnProperty(property)) {
          if (data[property] === null || data[property] === '' || data[property] === 'undefined' || (typeof data[property] === 'undefined')) {
            delete data[property];
          }
        }
      }

      //determine class type
      if (data.type === 'segment') {
        me.markupdataClass = MkSegment;
      } else if (data.type === 'tagPair') {
        me.markupdataClass = MkTagpair;
      } else if (data.type === 'placeholderTag') {
        me.markupdataClass = MkPlaceholder;
      } else if (data.type === 'text') {
        me.markupdataClass = MkText;
      } else if (data.type === 'locked') {
        me.markupdataClass = MkLockedContent;
      }

      //create new markupdata
      return new me.markupdataClass(data);
    }
  };
};

module.exports = new MarkupDataFactory();
},{"./DataProvider":3}],10:[function(require,module,exports){
/* File: Mediator.js */
/* jshint undef: true, unused: true */
/* globals module, pubsub */
'use strict';

// var Mediator = {},
//     mediator = new pubsub();

// // Method aliases
// Mediator.publish = mediator.pub;
// Mediator.subscribe = mediator.sub;
// Mediator.unsubscribe = mediator.unsub;
// Mediator.subscribe_once = mediator.once;
// Mediator.subscribe_recoup = mediator.recoup;



var EventEmitter = require('events').EventEmitter,
    Mediator = new EventEmitter();

// Method aliases
Mediator.publish = Mediator.emit;
Mediator.subscribe = Mediator.on;
Mediator.unsubscribe = Mediator.removeListener;
Mediator.subscribe_once = Mediator.once;
// Mediator.subscribe_recoup = events.recoup;

module.exports = Mediator;
},{"events":41}],11:[function(require,module,exports){
/* File: Mouse.js */
'use strict';
var CtrlHoverHandler = require('./mouse/CtrlHoverHandler');
var CtrlClickHandler = require('./mouse/CtrlClickHandler');

module.exports = {
  CtrlHoverHandler: CtrlHoverHandler,
  CtrlClickHandler: CtrlClickHandler
};
},{"./mouse/CtrlClickHandler":30,"./mouse/CtrlHoverHandler":31}],12:[function(require,module,exports){
/* File: NodeWrapper.js */
/* jshint undef: true, unused: true */
/* globals require, module */
'use strict';

var Helpers = require('./Helpers');
var DataProvider = require('./DataProvider');
var TranslationOrigin = require('./TranslationOrigin');

var def;

var statusIconClass = {
    'NotTranslated': 'not-translated',
    'ApprovedSignOff': 'approved-sign-off',
    'ApprovedTranslation': 'approved-translation',
    'Draft': 'draft',
    'RejectedSignOff': 'rejected-sign-off',
    'RejectedTranslation': 'rejected-translation',
    'Translated': 'translated'
  };

var translationOriginClass = {
    'it': 'transparent',
    'at': 'blue',
    'pm': 'gray',
    'ap': 'yellow',
    'cm': 'green'
  };


var NodeWrapper = Helpers.constructor({
  _extend: Helpers._extend,

  init: function (attrs, parent) {
    this._attrs = attrs;
    this._parent = parent;
    this._extend(this, attrs);

    if (!this.type) {
      this.type = 'paragraph-unit';
    }

    if (this.metadata) {
      this.metadata = DataProvider.cacheMetadata(this.metadata);
    }

    switch (this.type) {

      case 'tagPair':
        def = this._extend({}, DataProvider.tagPairMap[this.tagPairDefinitionId]);
        def.pmetadata = def.metadata;
        delete def.metadata; // make sure we dont' overwrite our metadata
        delete def.id; // make sure we don't overwrite our id
        this._extend(this, def);

        break;

      case 'placeholderTag':
        def = this._extend({}, DataProvider.placeholderMap[this.placeholderTagDefinitionId]);
        def.pmetadata = def.metadata;
        delete def.metadata; // make sure we dont' overwrite our metadata
        delete def.id; // make sure we don't overwrite our id
        this._extend(this, def);

        break;

      case 'segment':
        if (!this.translationOrigin) {
          this.translationOrigin = TranslationOrigin.create();
        }

        DataProvider.segmentsMap[this.segmentNumber] = {
          'ordernumber' : this.segmentNumber,
          'isLocked' : this.isLocked || false,
          'confirmationlevel': statusIconClass[this.confirmationLevel] || 'not-translated',
          'translationorigin': this.translationOrigin
        };
        DataProvider.segmentsMapLength++;

        break;

      case 'text':
        break;

      case 'locked':
        break;
    }

    if (this.source) {
      this.source = new NodeWrapper(this.source, this);
    }

    if (this.target) {
      this.target = new NodeWrapper(this.target, this);
    }

    this._parent = parent || null;


    if (this.children) {
      this.children = this.children.map(function (child) {
        return new NodeWrapper(child, this);
      }, this);
    }


    // Prepare formatting
    if (this.formattingGroupId) {
      this.formattingGroup = this._extend(this.formattingGroup || {}, DataProvider.formatingGroupMap[this.formattingGroupId]);
    }
  },

  containsSegment: function () {
    return this.isSegment() || (this.children && this.children.filter(function (child) {
      return child.containsSegment();
    }).length);
  },

  isSegment: function () {
    return this.type === 'segment' || (this._parent && this._parent.isSegment());
  },

  metadataText: function () {
    return this.metadata ? JSON.stringify(this.metadata) : '';
  },

  subcontentText: function () {
    return this.localizableSubContentList ? JSON.stringify(this.localizableSubContentList) : '';
  },

  translationOriginText: function () {
    return this.translationOrigin ? JSON.stringify(this.translationOrigin) : '';
  },

  statusIcon: function () {
    return DataProvider.segmentsMap[this.segmentNumber].confirmationlevel || 'not-translated';
  },

  displayOriginIcon: function () {
    var translationOrigin = DataProvider.segmentsMap[this.segmentNumber].translationorigin;

    if (!translationOrigin || !translationOrigin.originType) {
      return false;
    }

    var lastType = (translationOrigin.originBeforeAdaptation) ? translationOrigin.originBeforeAdaptation.originType : null;
    var originTypes = {'interactive': true, 'source': true};

    if (originTypes[translationOrigin.originType] &&
        translationOrigin.matchPercent === 0 &&
        (translationOrigin.originBeforeAdaptation === null ||
         lastType === null || originTypes[lastType])) {
      return false;
    }

    return true;
  },

  originClass: function () {
    var translationOrigin = DataProvider.segmentsMap[this.segmentNumber].translationorigin,
        type = TranslationOrigin.originType(translationOrigin),
        className = translationOriginClass[type];

    if (className) {
      return className;
    }

    return translationOrigin.matchPercent < 100 ? 'yellow' : 'green';
  },

  originText: function () {
    var t = DataProvider.segmentsMap[this.segmentNumber].translationorigin;
    var type = TranslationOrigin.originType(t);
    var percent = t.matchPercent;

    //look for the first origin Type
    if (t.originBeforeAdaptation !== null && type === 'it') {
      var last = t.originBeforeAdaptation;
      type = TranslationOrigin.originType(last);
      percent = last.matchPercent;
    }

    var sIcon = '';
    var percentTypes = {'fm': true, 'em': true, 'tm': true, 'it': true, 'ap': true };

    if (percentTypes[type]) {
      sIcon = percent + '%';
    } else {
      sIcon = type.toUpperCase();
    }
    return sIcon;
  },

  /**
   * Get segment locked state
   */
  isLockedSegment: function () {
    return DataProvider.segmentsMap[this.segmentNumber].isLocked || false;
  },

  segmentInfo: function () {
    var segm = DataProvider.segmentsMap[this.segmentNumber];

    if (segm === undefined) {
      return '';
    }

    return TranslationOrigin.translationInfo(segm);
  },

  puid: function () {
    if (this.type === 'paragraph-unit') {
      return this.id;
    }

    if (this._parent) {
      return this._parent.puid();
    }

    return null;
  },

  childSegments: function () {
    return this.children ? this.children.filter(function (item) {
      return item.containsSegment();
    }) : [];
  },

  segments: function () {
    var segments = [],
        i = 0;
    if (this.type === 'paragraph-unit') {
      var sourceSegments = this.source.segments();
      var targetSegments = this.target.segments();
      for (i = 0; i < sourceSegments.length; i++) {
        segments.push({
          puid: this.id,
          source: sourceSegments[i],
          target: targetSegments[i]
        });
      }
    } else {
      var children = this.childSegments();

      for (i = 0; i < children.length; i++) {

        if (children[i].type === 'segment') {
          segments.push(children[i]);
        } else {

          var s = children[i].segments().map(function (segment) {
            var flat = this.clone();
            flat.children = [segment];
            return flat;
          }, children[i]);

          segments = segments.concat(s);
        }
      }
    }
    return segments;
  },

  clone: function () {
    return new NodeWrapper(this._attrs, this._parent);
  },

  showTags: function () {
    return this.type === 'tagPair' && this.canHide === false && this.isSegment();
  },

  query: function (callback) {
    var res = [];
    if (callback(this)) {
      res.push(this);
    }

    if (this.children && this.children.length) {
      var child_res = this.children.map(function (child) {
        return child.query(callback);
      });
      res = Array.prototype.concat.apply(res, child_res);
    }

    return res;
  }
});

module.exports = NodeWrapper;
},{"./DataProvider":3,"./Helpers":5,"./TranslationOrigin":22}],13:[function(require,module,exports){
/* File: Paragraphs.js */
/* jshint undef: true, unused: true */
/* globals $, require, module, Event */
'use strict';

/**
 *  Paragraphs module
 */

var DataProvider = require('./DataProvider');
var SegmentsWatcher = require('./SegmentsWatcher');
var SideBySideParagraphUnitsRenderer = require('./SideBySideParagraphUnitsRenderer');
var KeyboardBindings = require('./KeyboardBindings');

/**
 * Paragraphs module
 * Displays all Paragraphs from the storage, attaches event handlers
 */
var Paragraphs = (function () {
  var dataProvider = DataProvider,
      segmentsWatcher = SegmentsWatcher,
      formattingMap,
      statusIconClass,
      translationOriginClass;

  formattingMap = {
    'Bold' : 'font-weight: bold',
    'Italic' : 'font-style: italic',
    'Underline' : 'text-decoration: underline',
    'TextColor' : 'color: rgb({{s}})',
    'FontName' : 'font-family: {{s}}',
    'FontSize' : 'font-size: {{s}}px'
  };

  statusIconClass = {
    'NotTranslated': 'not-translated',
    'ApprovedSignOff': 'approved-sign-off',
    'ApprovedTranslation': 'approved-translation',
    'Draft': 'draft',
    'RejectedSignOff': 'rejected-sign-off',
    'RejectedTranslation': 'rejected-translation',
    'Translated': 'translated'
  };

  translationOriginClass = {
    'it': 'transparent',
    'at': 'blue',
    'pm': 'gray',
    'ap': 'yellow',
    'cm': 'green'
  };


  /**
   * Extract segment data from DOM
   * @param {DOMElement} el - an element representing a segment
   */
  function segmentData(el) {
    var data = el.dataset,
        otherSegmentData = dataProvider.segmentsMap[data.ordernumber];

    return {
      id:               data.id,
      puid:             data.puid,
      el:               el,
      otherSegmentData: otherSegmentData
    };
  }

  return {
     /**
     * Render the first set of paragraph units
     */
    renderFirstParagraphs: function () {
      var me = this;
      var cDoc = dataProvider.getCurrentDocument();
      var pOffset = 0;
      var pLimit = cDoc.paragraphCount;

      dataProvider.getParagraphs(cDoc.id, function (err, data) {

        var editorBody = $('#editor-body');
        editorBody.html('');

        me._renderParagraphs(data, cDoc);
      }, pLimit, pOffset);
    },

    _renderParagraphs: function (paragraphs, currentDocument) {
      var sideBySideRenderer = new SideBySideParagraphUnitsRenderer(paragraphs, currentDocument),
          editorBodyEl, keyboardBindings, sourceKeysBind;

      sideBySideRenderer.render();

      editorBodyEl = $(document.getElementById('editor-body'));
      editorBodyEl.append(sideBySideRenderer.sourceSectionEl);
      editorBodyEl.append(sideBySideRenderer.targetSectionEl);

      keyboardBindings = new KeyboardBindings(sideBySideRenderer.targetEditableColumn);
      keyboardBindings.bind();

      sourceKeysBind = new KeyboardBindings(sideBySideRenderer.sourceColumns);
      sourceKeysBind.bind();

      // Trigger window resize to make sure
      // the layout resizes to full page height
      // USE MEDIATOR TO TRIGGER THIS EVENT
      window.dispatchEvent(new Event('resize'));

      segmentsWatcher.resizeContainers();
    },

    /**
     * Load more paragraph units into the view
     *
     */
    loadMoreParagraphs: function () {
      var me = this;

      dataProvider.getNextParagraphs(function (err, data) {
        me.renderParagraphs(data);
      });
    }
  };
})();

module.exports = Paragraphs;
},{"./DataProvider":3,"./KeyboardBindings":7,"./SegmentsWatcher":17,"./SideBySideParagraphUnitsRenderer":19}],14:[function(require,module,exports){
/* File: Segment.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

var DataProvider = require('./DataProvider');
var TranslationOrigin = require('./TranslationOrigin');

var translationOriginClass = {
  'it': 'transparent',
  'at': 'blue',
  'pm': 'gray',
  'ap': 'yellow',
  'cm': 'green'
};

var dataProvider = DataProvider;
var translationOriginProvider = TranslationOrigin;

var Segment = function (initializer) {
  if (initializer) {
    this.segmentNumber = initializer.ordernumber;
  }

  this.segmentData = dataProvider.getSegmentBySegmentNumber(this.segmentNumber);
};

var proto = Segment.prototype;

proto.displayOriginIcon = function () {
  var me = this,
      lastType,
      originTypes,
      translationOrigin = me.segmentData.translationorigin;

  if (!translationOrigin || !translationOrigin.originType) {
    return false;
  }

  lastType = (translationOrigin.originBeforeAdaptation) ? translationOrigin.originBeforeAdaptation.originType : null;
  originTypes = {'interactive': true, 'source': true};

  if (originTypes[translationOrigin.originType] &&
      translationOrigin.matchPercent === 0 &&
      (translationOrigin.originBeforeAdaptation === null ||
      lastType === null || originTypes[lastType])) {
    return false;
  }

  return true;
};

proto.originClass = function () {
  var me = this,
      translationOrigin = me.segmentData.translationorigin,
      type = TranslationOrigin.originType(translationOrigin),
      className = translationOriginClass[type];

  if (className) {
    return className;
  }

  return translationOrigin.matchPercent < 100 ? 'yellow' : 'green';
};

proto.originText = function () {
  var me = this;

  var t = me.segmentData.translationorigin;
  var type = translationOriginProvider.originType(t);
  var percent = t.matchPercent;

  //look for the first origin Type
  if (t.originBeforeAdaptation !== null && type === 'it') {
    var last = t.originBeforeAdaptation;
    type = TranslationOrigin.originType(last);
    percent = last.matchPercent;
  }

  var sIcon = '';
  var percentTypes = {'fm': true, 'em': true, 'tm': true, 'it': true, 'ap': true };

  if (percentTypes[type]) {
    sIcon = percent + '%';
  } else {
    sIcon = type.toUpperCase();
  }

  return sIcon;
};

proto.segmentInfo = function () {
  var me = this;

  if (me.segmentData === undefined) {
    return '';
  }

  return translationOriginProvider.translationInfo(me.segmentData);
};

proto.statusIcon = function () {
  return this.segmentData.confirmationlevel || 'not-translated';
};

proto.isLockedSegment = function () {
  return this.segmentData.isLocked;
};

proto.isConfirmed = function () {
  var confirmedLevels = [
    'translated',
    'approved-translation',
    'approved-sign-off'
  ];

  var isConfirmed = confirmedLevels.indexOf(this.segmentData.confirmationlevel) !== -1;

  return isConfirmed;
};

proto.changeToDraft = function () {
  var me = this,
      translationOrigin;

  me.segmentData.confirmationlevel = 'draft';
  translationOrigin = me.segmentData.translationorigin;

  if (translationOrigin.originType !== 'interactive') {
    translationOrigin.originBeforeAdaptation = translationOriginProvider.clone(translationOrigin);
    translationOrigin.originType = 'interactive';
  }
};

module.exports = Segment;
},{"./DataProvider":3,"./TranslationOrigin":22}],15:[function(require,module,exports){
/* File: SegmentCleanup.js */
'use strict';
var SegmentWatcher = require('./SegmentsWatcher');
var NodeWalker = require('./selection/NodeWalker');
var Tmpl = require('./Tmpl');

var proto;

function SegmentCleanup(segmentNo) {
  this.segment = SegmentWatcher.getTargetEl(segmentNo);
  this.walker = new NodeWalker(this.segment);
}

proto = SegmentCleanup.prototype;

proto.cleanStructure = function () {
  var me = this,
    walker = me.walker;

  if (!walker.isSegment()) {
    throw 'The structure must begin processing at segment level.';
  }

  me.ensureInlineContentExists();
  me.processStartOfSegment();
  me.processEndOfSegment();

  me.processTextElements();

};

proto.ensureInlineContentExists = function () {
  var me = this,
    walker = me.walker;

  walker = walker.firstChild();
  while (!walker.isNull() && !walker.isInlineContent()) {
    walker = walker.next();
  }

  if (walker.isInlineContent()) {
    return;
  }

  walker = me.walker;

  walker.append(Tmpl.buildSegmentInlineContent());
};

proto.processStartOfSegment = function () {
  var me = this,
    walker = me.walker,
    collectElementsToBeMoved = [];

  walker = walker.firstChild();
  if (walker.isInlineContent()) {
    return;
  }

  while (!walker.isNull() && !walker.isInlineContent()) {
    collectElementsToBeMoved.push(walker.el);
    walker = walker.next();
  }

  collectElementsToBeMoved.forEach(function (val) {
    walker.prepend(val);
  });
};

proto.processEndOfSegment = function () {
  var me = this,
    walker = me.walker,
    collectElementsToBeMoved = [];

  walker = walker.lastChild();

  while (!walker.isNull() && !walker.isInlineContent()) {
    collectElementsToBeMoved.push(walker.el);
    walker = walker.prev();
  }

  collectElementsToBeMoved.forEach(function (val) {
    walker.append(val);
  });
};

proto.processTextElements = function () {
  var me = this,
    walker = me.walker,
    processQueue = [],
    transformationRequired = {},
    trackingId = 0,
    tagIdentified;

  processQueue.push(walker.firstChild());

  function pushToQueue(child) {
    processQueue.push(child);
  }

  while (processQueue.length > 0) {
    walker = processQueue.pop();
    if (!walker.isTextNode()) {
      walker.forEachChild(pushToQueue);
    }

    if (walker.isTag() && walker.parent().isText()) {
      tagIdentified = walker;
      walker = walker.parent();
      if (!walker.el.dataset.trackingId) {
        transformationRequired[trackingId] = tagIdentified;
        walker.el.dataset.trackingId = trackingId;
        trackingId++;
      }
    }
  }

  for (trackingId in transformationRequired) {
    var prev, next, parent;

    walker = transformationRequired[trackingId];
    prev = walker.prev();
    next = walker.next();
    parent = walker.parent();

    if (!prev.isNull() && prev.isTextNode()) {
      me.moveTextNodeOutside(prev);
    }

    if (walker.isPlaceholder()) {
      me.movePlaceholderOutside(walker);
    }

    if (!next.isNull() && next.isTextNode()) {
      me.moveTextNodeOutside(next);
    }

    parent.remove();
  }
};

proto.moveTextNodeOutside = function (nodeWalker) {
  var parent,
    parentEl,
    parentClone;

  parent = nodeWalker.parent();
  parentEl = parent.el;
  parentClone = parentEl.cloneNode(false);
  parentClone.appendChild(nodeWalker.el);
  parent.insertAfter(parentClone);
};

proto.movePlaceholderOutside = function (placeholder) {
  var parent = placeholder.parent();

  parent = placeholder.parent();
  parent.insertAfter(placeholder);
};
module.exports = SegmentCleanup;
},{"./SegmentsWatcher":17,"./Tmpl":21,"./selection/NodeWalker":35}],16:[function(require,module,exports){
/* File: SegmentStatusUpdater.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

var Mediator = require('./Mediator');
var DataProvider = require('./DataProvider');
var Segment = require('./Segment');
var SegmentsWatcher = require('./SegmentsWatcher');
var SideBySideParagraphUnitsRenderer = require('./SideBySideParagraphUnitsRenderer');

var renderer = new SideBySideParagraphUnitsRenderer();

function segmentStatusUpdate (segmentData) {
  var segment,
      status,
      segmentContainer;

  // Stop changing the status when cursor is
  // in locked segment or locked content
  if (segmentData.stopEditing) {
    return;
  }

  segment = new Segment(segmentData);
  status = renderer.renderStatus(segment);
  segmentContainer = SegmentsWatcher.getContainerBySegmentNumber(segment.segmentNumber);

  segmentContainer.replaceStatusEl(status);
  SegmentsWatcher.resize(segment.segmentNumber);
  SegmentsWatcher.markContainerAsActive(segment.segmentNumber);
};

function jumpToNextUnConfirmedSegment (segmentData) {
  var initialSegment,
      segment;

  initialSegment = segment = new Segment(segmentData);

  do {
    var nextSegmentData = DataProvider.getSegmentBySegmentNumber(+segment.segmentNumber + 1);
    segment = null;

    if (nextSegmentData) {
      segment = new Segment(nextSegmentData);
    }

  } while (segment !== null && segment.isConfirmed());

  if (segment === null) {
    return;
  }

  SegmentsWatcher.markContainerAsInactive(initialSegment.segmentNumber);
  SegmentsWatcher.markContainerAsActive(segment.segmentNumber);
  SegmentsWatcher.focusTarget(segment.segmentNumber);
};

var SegmentStatusUpdater = function () {
  Mediator.subscribe('segment:confirmationLevelChanged', segmentStatusUpdate);
  Mediator.subscribe('segment:jumpToNextUnConfirmed', jumpToNextUnConfirmedSegment);

  Mediator.subscribe('segment:lock', segmentStatusUpdate);
  Mediator.subscribe('segment:unlock', segmentStatusUpdate);

  Mediator.subscribe('segment:stopEditingInLockedContent', segmentStatusUpdate);
};

module.exports = SegmentStatusUpdater();
},{"./DataProvider":3,"./Mediator":10,"./Segment":14,"./SegmentsWatcher":17,"./SideBySideParagraphUnitsRenderer":19}],17:[function(require,module,exports){
/* File: SegmentWatcher.js */
/* jshint undef: true, unused: true */
/* globals $, _, module */
'use strict';

var SegmentsWatcher = (function () {
  var resizeCalls,
      groups = {},
      tagPairs = {},
      currentContainer = {};

  function segmentContainer() {
    this.sourceEl = null;
    this.targetEl = null;
    this.statusEl = null;

    this.sourceInlineContentEl = null;
    this.targetInlineContentEl = null;
    this.linkedElements = [];

    this.isHeightComputed = false;
  }

  segmentContainer.prototype.push = function (item) {
    this.linkedElements.push(item);
  };

  segmentContainer.prototype.replaceStatusEl = function (statusEl) {
    var me = this;
    var statusPosition = me.linkedElements.indexOf(me.statusEl);
    if (statusPosition === -1) {
      throw 'Invalid state, linkedElement does not exist';
    }

    me.statusEl.replaceWith(statusEl);
    me.statusEl = statusEl;

    me.linkedElements[statusPosition] = me.statusEl;
  };

  function _resizeContainer(container) {
    var MIN_HEIGHT = 27,
        sourceInlineContent = container.sourceInlineContentEl || $(container.sourceEl[0].firstChild), //$(':first-child', container.sourceEl),
        targetInlineContent = container.targetInlineContentEl || $(container.targetEl[0].firstChild), //$(':first-child', container.targetEl),
        sourceHeight = parseInt(sourceInlineContent.css('height'), 10),
        targetHeight = parseInt(targetInlineContent.css('height'), 10),
        maxHeight = Math.max(sourceHeight, targetHeight),
        targetedHeight = Math.max(MIN_HEIGHT, maxHeight);

    container.linkedElements.forEach(function (item) {
      item.css('height', targetedHeight + 'px');
    });
  }

  resizeCalls = 0;

  window.onresize = function () {
    SegmentsWatcher.resizeContainers();
  };

  return {
    resizeCalls: 0,
    /*
    * @elementGroup - list of elements that must have the same height
    */
    watchSegment: function (segmentNumber) {
      if (groups[segmentNumber] === undefined) {
        groups[segmentNumber] = new segmentContainer();
      }

      currentContainer = groups[segmentNumber];

      return this;
    },

    groupAdd: function (element) {
      currentContainer.push(element);

      return this;
    },

    setSource: function (sourceEl) {
      currentContainer.sourceEl = sourceEl;
      this.groupAdd(sourceEl);

      return this;
    },

    setStatus: function (statusEl) {
      currentContainer.statusEl = statusEl;
      this.groupAdd(statusEl);

      return this;
    },

    setTarget: function (targetEl) {
      currentContainer.targetEl = targetEl;
      this.groupAdd(targetEl);

      return this;
    },

    addTagPair: function (tagPairId, tagPairElements) {
      tagPairs[tagPairId] = tagPairElements;
    },

    removeTagPair: function (tagPairId) {
      var exists = tagPairId in tagPairs,
          element;

      if (!exists) {
        return;
      }

      tagPairs[tagPairId].forEach(function (element) {
        element.remove();
      });
    },

    resizeContainers: function () {
      _(groups).forOwn(_resizeContainer);

      if (this.resizeCalls < 3) {
        window.setTimeout(function () {
          SegmentsWatcher.resizeContainers();
        }, 500);
        this.resizeCalls++;
      }
    },

    resize: function (containerId) {
      _resizeContainer(groups[containerId]);
    },

    getContainerBySegmentNumber: function (segmentNumber) {
      return groups[segmentNumber];
    },

    markContainerAsActive: function (segmentNumber) {
      var container = this.getContainerBySegmentNumber(segmentNumber);

      if (container === undefined) {
        return;
      }

      container.linkedElements.forEach(function (linkedEl) {
        linkedEl.addClass('ue-row-active');
      });
    },

    markContainerAsInactive: function (segmentNumber) {
      var container = this.getContainerBySegmentNumber(segmentNumber);

      if (container === undefined) {
        return;
      }

      container.linkedElements.forEach(function (linkedEl) {
        linkedEl.removeClass('ue-row-active');
      });
    },

    focusTarget: function (segmentNumber) {
      var container = this.getContainerBySegmentNumber(segmentNumber);
      var range = document.createRange();
      range.setStartBefore(container.targetEl[0]);

      var selection = document.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      range.collapse();
    },

    getTargetEl: function (segmentNumber) {
      var container = this.getContainerBySegmentNumber(segmentNumber),
        targetEl;

      if (container === undefined) {
        return null;
      }

      targetEl = container.targetEl;

      return targetEl;
    },

    destroy: function () {

    }

  };

})();

module.exports = SegmentsWatcher;
},{}],18:[function(require,module,exports){
/* File: Selection.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

var nodeWalker = require('./selection/NodeWalker');
var tagPair = require('./selection/TagPair');
var selectionContext = require('./selection/SelectionContext');


module.exports = {
  NodeWalker: nodeWalker,
  SelectionContext: selectionContext,
  TagPair: tagPair
};
},{"./selection/NodeWalker":35,"./selection/SelectionContext":36,"./selection/TagPair":37}],19:[function(require,module,exports){
/* File: SideBySideParagraphUnitsRenderer.js */
/* jshint undef: true, unused: true */
/* globals _, console, require, module */
'use strict';

var config = require('./config');
var Helpers = require('./Helpers');
var Tmpl = require('./Tmpl');
var SegmentsWatcher = require('./SegmentsWatcher');
var NodeWrapper = require('./NodeWrapper');
var TagContentBuilder = require('./renderer/TagContentBuilder');
var StylesMap = require('./renderer/StylesMap');

var SideBySideParagraphUnitsRenderer = function (paragraphs, ueDocument) {
  var me = this;

  me.paragraphs = paragraphs;
  me.ueDocument = ueDocument;

  me.tmpl = Tmpl;
  me.segmentsWatcher = SegmentsWatcher;

  me.sourceSectionEl = $(me.tmpl.sourceSection);
  me.targetSectionEl = $(me.tmpl.targetSection);

  me.segmentNumbers = $(me.tmpl.gutterColumn);
  me.sourceColumns = $(me.tmpl.sourceColumn);
  me.segmentStatus = $(me.tmpl.statusColumn);
  me.targetColumns = $(me.tmpl.targetColumn);

  me.sourceEditableColumn = $(me.tmpl.editableFalse);
  me.targetEditableColumn = $(me.tmpl.editableTrue);

  me.fileStart = $(me.tmpl.fileTagStart);
  me.fileEnd = $(me.tmpl.fileTagEnd);

  me.isTagCopyAllowed = false;

};

var renderer = SideBySideParagraphUnitsRenderer;

renderer.prototype.render = function () {
  var me = this;

  me.assignEditableColumnsLang();
  me.assignDocumentName();
  me.appendStructure();
  me.appendFileStart();
  me.appendEditableColumns();
  me.processParagraphs();
  me.appendFileEnd();
};


/**
 * Add lang attribute to content editable elements
 */
renderer.prototype.assignEditableColumnsLang = function () {
  var me = this,
      docData = me.ueDocument.data,
  columns = {
    source: me.sourceColumns,
    target: me.targetColumns
  };

  _.forEach(columns, function (column, columnName) {
    column.prop('lang',
      docData[columnName + 'LanguageCode']);
  });
};

renderer.prototype.assignDocumentName = function () {
  var me = this;
  [me.fileStart, me.fileEnd].forEach(function (fileTag) {
    fileTag[0].firstChild.dataset.displayContent = me.ueDocument.data.name;
  });
};

renderer.prototype.appendStructure = function () {
  var me = this;

  me.sourceSectionEl.append(me.segmentNumbers);
  me.sourceSectionEl.append(me.sourceColumns);
  me.targetSectionEl.append(me.segmentStatus);
  me.targetSectionEl.append(me.targetColumns);
};

renderer.prototype.appendFileStart = function () {
  var me = this;

  me.segmentNumbers.append($(me.tmpl.cell).html(me.tmpl.zwnj));
  me.sourceEditableColumn.append(me.fileStart);
  me.segmentStatus.append($(me.tmpl.cell).html(me.tmpl.zwnj));
  me.targetEditableColumn.append(me.fileStart.clone());
};

renderer.prototype.appendEditableColumns = function () {
  var me = this;

  me.sourceColumns.append(me.sourceEditableColumn);
  me.targetColumns.append(me.targetEditableColumn);
};

renderer.prototype.processParagraphs = function () {
  var me = this,
      paragraphSegments;

  me.paragraphs.forEach(function (paragraphItem) {
    paragraphSegments = new NodeWrapper(paragraphItem).segments();
    me.renderSegments(paragraphSegments);
  });
};

renderer.prototype.renderSegments = function (paragraphSegments) {
  var me = this;

  paragraphSegments.forEach(function (paragraph) {
    me.renderSource(paragraph.source);
    me.renderTarget(paragraph.target);
  });
};

renderer.prototype.renderSource = function (source) {
  var me = this,
      segment = source,
      segmentData, formatting, segmentNumberEl,
      segmentSourceEl, segmentStatusEl;

  me.isTagCopyAllowed = true;

  if (source.type === 'tagPair') {
    segmentData = me._findSegment(source);
    segment = segmentData.segment;
    formatting = segmentData.formatting || {};
  }

  me.segmentsWatcher.watchSegment(segment.segmentNumber);

  segmentNumberEl = me.renderSegmentNumber(segment);
  segmentSourceEl = me.renderSourceSegment(segment, formatting);
  segmentStatusEl = me.renderStatus(segment);

  me.segmentNumbers.append(segmentNumberEl);
  me.sourceEditableColumn.append(segmentSourceEl);
  me.segmentStatus.append(segmentStatusEl);
  me.segmentsWatcher.setSource(segmentSourceEl);
  me.segmentsWatcher.groupAdd(segmentNumberEl);
  me.segmentsWatcher.setStatus(segmentStatusEl);
};

renderer.prototype.renderTarget = function (target) {
  var me = this,
      segment = target,
      segmentData, formatting, segmentTargetEl;

  me.isTagCopyAllowed = false;

  if (target.type === 'tagPair') {
    segmentData = me._findSegment(target);
    segment = segmentData.segment;
    formatting = segmentData.formatting || {};
  }

  me.segmentsWatcher.watchSegment(segment.segmentNumber);
  segmentTargetEl = me.renderTargetSegment(segment, formatting);
  me.targetEditableColumn.append(segmentTargetEl);
  me.segmentsWatcher.setTarget(segmentTargetEl);
};

renderer.prototype._findSegment = function (container) {
  var segment = container,
      formatting = segment.formattingGroup || {}; // cache tagpair formatting

  while (segment !== null && segment.type === 'tagPair') {
    if (segment.children.length === 0) {
      return null;
    }

    segment = segment.children[0];
  }

  // return segment and tagpair formatting
  return {
    segment: segment,
    formatting: formatting
  };
};

renderer.prototype.renderSegmentNumber = function (segment) {
  var me = this,
      segmentNumberEl = $(me.tmpl.cell);

  segmentNumberEl.html(segment.segmentNumber);

  return segmentNumberEl;
};

renderer.prototype.renderSourceSegment = function (segment, formatting) {
  var me = this,
      segmentSourceEl = $(me.tmpl.segment),
      inlineContent = me._renderInlineContent(segment.children),
      sourceDataset;

  // If segment is locked, add 'ue-locked' class to segment element
  if (segment.isLocked) {
    segmentSourceEl[0].classList.add('ue-segment-locked');
    segmentSourceEl[0].dataset.isLocked = segment.isLocked;
  }

  if (formatting) {
    inlineContent[0].dataset.style = JSON.stringify(formatting.items);
    inlineContent[0].style.cssText = me._prepareFormatting(formatting);
  }

  segmentSourceEl.append(inlineContent);

  sourceDataset = segmentSourceEl[0].dataset;
  sourceDataset.sourceSegmentNumber = segment.segmentNumber;
  sourceDataset.sourcePuid = segment.puid();

  return segmentSourceEl;
};

renderer.prototype.renderStatus = function (segment) {
  var me = this,
      segmentStatusEl = $(me.tmpl.cell),
      segmentStatusContent = me._renderSegmentStatus(segment);

  segmentStatusEl.append(segmentStatusContent);
  segmentStatusEl.attr('title', segment.segmentInfo());

  return segmentStatusEl;
};

renderer.prototype.renderTargetSegment = function (segment, formatting) {
  var me = this,
      segmentTargetEl = me.tmpl.targetSegmentBuilder(),
      inlineContent = me._renderInlineContent(segment.children),
      targetDataset;

  // If segment is locked, add 'ue-segment-locked' class to segment element
  if (segment.isLocked) {
    segmentTargetEl[0].classList.add('ue-segment-locked');
    segmentTargetEl[0].dataset.isLocked = segment.isLocked;
    segmentTargetEl[0].dataset.segmentNumber = segment.segmentNumber;
  }

  // If we have formating add it to the inline content
  if (formatting) {
    inlineContent[0].dataset.style = JSON.stringify(formatting.items);
    inlineContent[0].style.cssText = me._prepareFormatting(formatting);
  }

  // Add Zero Width Non-Joiner as the first character
  // inside first "ue-inline-content" container
  inlineContent.prepend(me.tmpl.zwnj);
  segmentTargetEl.append(inlineContent);

  targetDataset = segmentTargetEl[0].dataset;
  targetDataset.segmentNumber = segment.segmentNumber;
  targetDataset.puid = segment.puid();

  return segmentTargetEl;
};

renderer.prototype.appendFileEnd = function () {
  var me = this;

  me.segmentNumbers.append($(me.tmpl.cell).html(me.tmpl.zwnj));
  me.sourceEditableColumn.append($(me.fileEnd));
  me.segmentStatus.append($(me.tmpl.cell).html(me.tmpl.zwnj));
  me.targetEditableColumn.append(me.fileEnd.clone());
};

renderer.prototype._renderSegmentStatus = function (segment) {
  var me = this,
      info = me._renderSegmentStatusIcon(segment),
      origin = me._renderSegmentOrigin(segment),
      status = me._renderSegmentStateIcon(segment);

  return [ info, origin, status ];
};

renderer.prototype._renderSegmentStatusIcon = function (segment) {
  var me = this,
      statusIconEl = $('<i/>').addClass('status-icon-' + segment.statusIcon());

  return $(me.tmpl.statusColumnWrapper('first')).append(statusIconEl);
};

renderer.prototype._renderSegmentOrigin = function (segment) {
  var me = this,
      segmentOriginEl = $('<div/>');

  if (segment.displayOriginIcon()) {
    segmentOriginEl = $('<div class="ue-translation-origin-' +
                          segment.originClass() + '">' +
                          segment.originText() + '</div>');
  }

  return $(me.tmpl.statusColumnWrapper('second')).append(segmentOriginEl);
};

/**
 * Render status third column icon
 * @param  {Object} segment
 * @return {Array}  jQuery wrapped set
 */
renderer.prototype._renderSegmentStateIcon = function (segment) {
  var me = this,
      segmentStateEl,
      isLocked = segment.isLockedSegment();

  if (isLocked) {
    segmentStateEl = $(me.tmpl.statusIconSegmentLocked);
  }

  return $(me.tmpl.statusColumnWrapper('third')).html(segmentStateEl);
};

renderer.prototype._renderInlineContent = function (children) {
  var me = this,
      content = [],
      inlineItems;

  if (!children) {
    return content;
  }

  children.forEach(function (inline) {
    inlineItems = me._renderInline(inline);
    content = content.concat(inlineItems);
  });

  return $(me.tmpl.inlineContentWrapper).append(content);
};


/**
 * Render text
 * @param  {Object} data
 * @return {Array}
 */
renderer.prototype._renderText = function (data) {
  var me = this,
      tmpl = me.tmpl,
      html = Helpers.stringToHTMLElement(tmpl.text),
      htmlEl = $(html);

  html.dataset.type = 'text';
  htmlEl.html(data.text);

  return [ htmlEl ];
};

/**
 * Render tags
 * @param  {Object} data
 * @return {Array}
 */
renderer.prototype._renderTagPair = function (data) {
  var me = this,
      tagPairStart,
      tagPairEnd,
      tagPair = [],
      inlineContent,
      inlineContentEl,
      tagPairStartContent,
      tagPairEndContent,
      tagPairContent = (new TagContentBuilder(config.tagDisplayContext.tagDisplayMode)).build(data),
      escapeHTML = Helpers.escapeHTML,
      tagDisplayContext = (config.tagDisplayContext.showFormatting === false);

  if (typeof tagPairContent === 'object') {
    tagPairStartContent = tagPairContent.tagStart;
    tagPairEndContent = tagPairContent.tagEnd;
  } else {
    tagPairStartContent = tagPairEndContent = tagPairContent;
  }

  // Build start & end tag
  tagPairStart = me.tmpl.tagPairStartBuilder();
  tagPairEnd = me.tmpl.tagPairEndBuilder();

  // This needs to be changed
  tagPairStart[0].childNodes[0].dataset.displayContent = tagPairStartContent;
  tagPairEnd[0].childNodes[0].dataset.displayContent = tagPairEndContent;

  // Add data-* attributes to tagpair
  tagPairStart[0].dataset.tagCopy = me.isTagCopyAllowed;
  tagPairEnd[0].dataset.tagCopy = me.isTagCopyAllowed;

  tagPairStart[0].dataset.id = data.id;
  tagPairEnd[0].dataset.id = data.id;

  tagPairStart[0].dataset.metadata = data.metadata;
  tagPairEnd[0].dataset.metadata = data.metadata;

  // If we have canHide property, add it to the tags
  if (data.canHide !== undefined) {
    tagPairStart[0].dataset.canHide = data.canHide;
    tagPairEnd[0].dataset.canHide = data.canHide;

    if (tagDisplayContext && data.canHide) {
      tagPairStart[0].classList.add('hide');
      tagPairEnd[0].classList.add('hide');
    }
  }

  tagPair.push(tagPairStart);

  inlineContent = me._renderInlineContent(data.children);
  inlineContent.addClass('ue-tagpair-content');

  inlineContentEl = inlineContent[0];
  inlineContentEl.dataset.type = 'tagpair';
  inlineContentEl.dataset.id = data.id;
  inlineContentEl.dataset.definitionid = data.tagPairDefinitionId;
  inlineContentEl.dataset.metadata = data.metadata;

  tagPairStart[0].dataset.id = data.id;
  tagPairEnd[0].dataset.id = data.id;

  // Reder styles if we have a formattingGroup
  if (data.formattingGroup) {
    inlineContent[0].dataset.style = JSON.stringify(data.formattingGroup.items);
    inlineContent[0].style.cssText = me._prepareFormatting(data.formattingGroup);
  }

  tagPair.push(inlineContent);
  tagPair.push(tagPairEnd);

  me.segmentsWatcher.addTagPair(data.id, [tagPairStart, tagPairEnd]);

  return tagPair;
};


/**
 * Render placeholders
 * @param  {Object} data
 * @return {Array}
 */
renderer.prototype._renderPlaceholder = function (data) {
  var me = this,
      tmpl = me.tmpl,
      placeholder,
      placeholderEl,
      placeholderContent = (new TagContentBuilder(config.tagDisplayContext.tagDisplayMode)).build(data),
      escapeHTML = Helpers.escapeHTML;

  // This needs to be changed
  placeholder = me.tmpl.placeholderTagBuilder();
  placeholder[0].childNodes[0].dataset.displayContent = placeholderContent;

  placeholderEl = placeholder[0];
  placeholderEl.dataset.type = 'placeholder';
  placeholderEl.dataset.id = data.id;
  placeholderEl.dataset.definitionid = data.placeholderTagDefinitionId;
  placeholderEl.dataset.metadata = data.metadata;
  placeholderEl.dataset.tagCopy = me.isTagCopyAllowed;

  return [ placeholder ];
};


/**
 * Render locked content inside a segment
 * @param  {Object} data
 * @return {Array}
 */
renderer.prototype._renderLockedContent = function (data) {
  var me = this,
      tmpl = me.tmpl,
      lockedContentStart,
      lockedContentEnd,
      lockedInlineContent;

  if (!data) {
    return;
  }

  lockedContentStart = tmpl.lockedContentStartTagBuilder();
  lockedContentEnd = tmpl.lockedContentEndTagBuilder();
  lockedInlineContent = me._renderInlineContent(data);

  lockedInlineContent[0].dataset.isLocked = true;
  lockedInlineContent[0].classList.add('ue-locked-content');

  return [
    lockedContentStart,
    lockedInlineContent,
    lockedContentEnd
  ];
};


renderer.prototype._renderInline = function (inline) {
  var me = this;

  // Render text
  if (inline.type === 'text') {
    return me._renderText(inline);
  }

  // Render tags and inline content
  if (inline.type === 'tagPair') {
    return me._renderTagPair(inline);
  }

  // Render placeholders
  if (inline.type === 'placeholderTag') {
    return me._renderPlaceholder(inline);
  }

  // Render locked content inside segments
  if (inline.type === 'locked') {
    return me._renderLockedContent(inline.children);
  }

  // Or return empty array
  return [];
};


/**
 * Prepares styles for tagpair formatting
 * @param  {object} formattingGroup
 * @return {string}
 */
renderer.prototype._prepareFormatting = function (formattingGroup) {
  var me = this,
      items = {},
      stylesList = [];

  if (formattingGroup) {
    items = formattingGroup.items;

    // Interate over formatting items
    _.forEach(items, function (item, key) {

      // Get all styles from StylesMap and build
      // the string for inline style attribute
      if (key && (key.toLowerCase() in StylesMap)) {
        _.forEach(StylesMap[key.toLowerCase()](items[key]), function (style, property) {
          stylesList.push([property, style].join(':'));
        });
      } else {
        // if the style doesn't exist in the StylesMap, log an error
        console.error('"' + key + '" does not exist in the styles map');
      }

    });
  }

  return stylesList.join(';');
};

module.exports = SideBySideParagraphUnitsRenderer;
},{"./Helpers":5,"./NodeWrapper":12,"./SegmentsWatcher":17,"./Tmpl":21,"./config":25,"./renderer/StylesMap":32,"./renderer/TagContentBuilder":33}],20:[function(require,module,exports){
/* File: Storage.js */
/* jshint undef: true, unused: true */
/* globals require, module */
'use strict';

var config = require('./config');
var Mediator = require('./Mediator');

module.exports = {
  StorageImplementation: (function () {
    var instance = null,
        base_url = config.baseUrl;

    var defaults = {
      limit: config.defaultLimit || 5,
      offset: config.defaultOffset || 0
    };


    /**
     * private search function
     *
     * @param {Array} list
     * @param {Function} function check constraints
     * @return {Number|Item} index|item
     */
    function search(list, fnc) {
      var len = list.length;

      if (!fnc || typeof(fnc) !== 'function') {
        return -1;
      }

      if (!list || !len || len < 1) {
        return -1;
      }

      for (var i = 0; i < len; i++) {
        if (fnc(list[i])) {
          return list[i];
        }
      }

      return -1;
    }

    /**
     * Single entry point to get data
     *
     * @dependency jQuery
     *
     * @param {String}    url
     * @param {Function}  callback success callback
     */
    function getData(url, callback) {
      var action = $.ajax({
        method: 'GET',
        url: base_url + url,
        dataType: 'json'
      });

      action.done(function (data) {
        if (callback) {
          callback(null, data);
        }
      });
    }

    function saveData(url, data) {
      var promise = $.Deferred();

      var action = $.ajax({
        method: 'PUT',
        url: base_url + url,
        contentType: 'application/json',
        data: JSON.stringify(data),
        dataType: 'text'
      });

      Mediator.publish('save:before');

      action.done(function (data) {

        promise.resolveWith(null, [data]);
        Mediator.publish('save:done');

      }).fail(function () {

        promise.rejectWith(null, [{
          // error object goes here
        }]);

        Mediator.publish('save:fail');
      });
      return promise;
    }

    function init() {

      return {
        currentParagraphIndex: 0,
        documents: [],
        paragraphs: [],
        currentDocument: {
          id: null,
          paragraphCount: 0,
          loadedParagraphs: 0,
          skeletons: []
        },
        /**
         * Get a paragraph
         *
         * @param {String} id
         * @param {Function} callback
         */
        getParagraph: function (id, callback) {
          if (!id) {
            callback(true, null);

            return;
          }

          if (paragraphUnits.length === 0) {
            callback(null, null);

            return;
          }

          if (paragraphUnits.length === 1 && paragraphUnits[0].id !== id) {
            callback(null, null);

            return;
          }

          var item = search(paragraphUnits, function (item) {
            return item.id === id;
          });

          //if search return -1
          if (!~item) {
            callback(null, null);
            return;
          }

          //return found item
          callback(null, item);
        },

        _getParagraphs: function (documentId, callback, limit, offset) {
          //if there is no local data, try to get data from the service
          if (paragraphUnits.length === 0) {
            getData('/api/paragraphunits', callback);

            return;
          }

          //if limit of offset exists create the query string and
          //ask the service for data
          if ((typeof limit) !== 'undefined' || (typeof offset) !== 'undefined') {
            //check if limit or offset are a valid number
            if (isNaN(+limit) || isNaN(+offset)) {
              callback(true);

              return;
            }

            //create the limit and offset query strings
            var l = (limit) ? '?limit=' + limit : '?limit=2';
            var o = (offset) ? '&offset=' + offset : '&offset=0';

            getData('/api/paragraphunits/' + l + o, callback);

            return;
          }

          callback(null, paragraphUnits);
        },
        /**
         * Gets all paragraph units for a specified document
         *
         * @param {String}    documentId
         * @param {Function}  callback
         * @param {Number}    limit
         * @param {Number}    offset
         */
        getParagraphs: function (documentId, callback, limit, offset) {
          var me = this;

          me.currentDocument.id = documentId;

          if ((typeof limit) !== 'undefined' || (typeof offset) !== 'undefined') {
            //sanity check
            if (isNaN(+limit) || isNaN(+offset) || limit === null || offset === null) {
              callback(true);

              return;
            }

            getData('/document/' + documentId + '/paragraphs/' + offset + '/' + limit, function (err, data) {
              me.currentDocument.loadedParagraphs = me.currentDocument.loadedParagraphs + data.length;
              me.paragraphs = me.paragraphs.concat(data);

              if (callback) {
                callback(err, data);
              }
            });

            return;
          }

          getData('/document/' + documentId + '/paragraphs/' + defaults.offset + '/' + defaults.limit, function (err, data) {
            me.currentDocument.loadedParagraphs = me.currentDocument.loadedParagraphs + data.length;

            me.paragraphs = me.paragraphs.concat(data);

            if (callback) {
              callback(err, data);
            }
          });
        },
        getNextParagraph: function (callback) {
          if (callback) {
            getData('/api/paragraphunits/?action=next', callback);
          }
        },
        getPrevParagraph: function (callback) {
          if (callback) {
            getData('/api/paragraphunits/?action=prev', callback);
          }
        },
        /**
         * Gets the next set of paragraph units from the storage
         *
         * @param {Function} callback
         */
        getNextParagraphs: function (callback) {
          var me = this,
              documentId = me.currentDocument.id;

          if (callback) {
            getData('/document/' + documentId + '/paragraphs/' + this.currentDocument.loadedParagraphs + '/' + defaults.limit, function (err, data) {
              me.currentDocument.loadedParagraphs = me.currentDocument.loadedParagraphs + data.length;

              me.paragraphs = me.paragraphs.concat(data);

              if (callback) {
                callback(err, data);
              }
            });
          }
        },
        /**
         * Get a list of documents
         *
         * @param {Function} callback
         */
        getDocuments: function (callback) {
          var me = this;

          if (callback) {
            getData('/documents', function (err, data) {
              //cache the documents
              me.documents = me.documents.concat(data);

              callback(err, data);
            });
          }
        },
        /**
         * Get a document by id
         *
         * @param {String} id
         * @param {Function} callback
         */
        getDocument: function (id, callback) {
          var me = this;

          if (callback) {
            getData('/document/' + id, function (err, data) {
              //cache data related to the document
              me.currentDocument.data = data;

              // count the number of paragraphs
              var nrParagraphs = 0;
              for (var i in data.files) {
                //get the regular paragraph unit count
                nrParagraphs += data.files[i].paragraphUnitCount - data.files[i].structureParagraphUnitCount;
              }

              me.currentDocument.paragraphCount = nrParagraphs;

              callback(err, data);
            });
          }
        },

        saveOperation: function (operations) { // arg 'callback' never used
          return saveData('/operation', {
            'actions' : operations
          });
        },

        getSkeleton: function (fileId, callback) {
          var me = this;
          if (!callback) {
            callback = function () {};
          }
          return getData('/skeleton/' + fileId, function (err, data) {
            me.currentDocument.skeletons.push(data);
            callback(err, data);
          });
        }
      };
    }

    function getInstance() {
      if (!instance) {
        instance = init();
      }

      return instance;
    }

    return {
      getInstance: getInstance,
      g: getInstance
    };
  })()
};
},{"./Mediator":10,"./config":25}],21:[function(require,module,exports){
/* File: Tmpl.js */
/* jshint undef: true, unused: true */
/* globals $, module */
'use strict';
var h = require ('./Helpers').stringToHTMLElement;

module.exports = {
  fileStatus: '<span data-type="status-message"><%= status %></span>',

  segment: '<div class="ue-segment"/>',
  cell: '<div class="ue-cell"/>',
  sourceSection: '<section class="col-xs-6 wrapper-west"/>',
  targetSection: '<section class="col-xs-6 wrapper-east"/>',

  gutterColumn: '<div class="ue-gutter"/>',
  sourceColumn: '<div class="ue-source" spellcheck="false"/>',
  statusColumn: '<div class="ue-status"/>',
  targetColumn: '<div class="ue-target" spellcheck="true"/>',

  editableTrue: '<div class="ue-editable" contenteditable="true"/>',
  editableFalse: '<div class="ue-editable" contenteditable="false"/>',

  fileTagStart: '<div class="ue-file"><span class="ue-tag ue-tag-start ue-tag-file"></span></div>',
  fileTagEnd: '<div class="ue-file"><span class="ue-tag ue-tag-end ue-tag-file"></span></div>',

  file: '<div class="ue-editable" contenteditable="true"/>',

  tagPairStart: '<span class="ue-tag ue-tag-start" contenteditable="false"/>',
  tagPairEnd: '<span class="ue-tag ue-tag-end" contenteditable="false"/>',

  placeholderTag: '<span class="ue-tag" contenteditable="false"/>',
  text: '<span class="ue-text"/>',

  tagLockedStart: '<span class="ue-tag ue-tag-locked-start" contenteditable="false"/>',
  tagLockedEnd: '<span class="ue-tag ue-tag-locked-end" contenteditable="false"/>',

  inlineContentWrapper: '<div class="ue-inline-content"></div>',
  lockedContentWrapper: '<div class="ue-locked-content"></div>',

  tagWrapper: '<span class="ue-tag-wrapper"/>',

  // Status icons
  statusIconSegmentLocked: '<i class="status-icon-segment-state-loked"/>',

  // Activity indicator
  // The message can be changed by overriding
  // data-activity-message attribute
  activityIndicator:
    '<div class="ue-activity-indicator-wrapper">' +
      '<div class="ue-activity-indicator" data-activity-message="Loading ...">' +
        '<div class="spinner"></div>' +
      '</div>' +
    '</div>',

  // zeroWidthNonJoiner - invisible character
  zwnj: '&zwnj;',
  zeroWidthNonJoinerCharCode: 8204,


  keyTab: {
    charCode: 9,
    unicode: '\u0009',
    entity: '&#09;'
  },

  statusColumnWrapper: function (order) {
    return '<div class="col-' + order + '"/>';
  },

  targetSegmentBuilder: function () {
    var me = this,
        targetSegment;

    targetSegment = $(me.segment);//.append(me.zwnj);

    return targetSegment;
  },

  tagPairStartBuilder: function (displayText) {
    var me = this,
        startTag,
        wrapper;

    startTag = $(me.tagPairStart);
    startTag.html(displayText);

    wrapper = $(me.tagWrapper).append(startTag).append(me.zwnj);
    wrapper[0].dataset.type = 'start-tag';

    return wrapper;
  },

  tagPairEndBuilder: function (displayText) {
    var me = this,
        endTag,
        wrapper;

    endTag = $(me.tagPairEnd);
    endTag.html(displayText);

    wrapper = $(me.tagWrapper).append(endTag).append(me.zwnj);
    wrapper[0].dataset.type = 'end-tag';

    return wrapper;
  },

  placeholderTagBuilder: function (displayText) {
    var me = this,
        placeholder,
        wrapper;

    placeholder = $(me.placeholderTag);
    placeholder.html(displayText);

    wrapper = $(me.tagWrapper).append(placeholder).append(me.zwnj);
    wrapper[0].dataset.type = 'placeholder';

    return wrapper;
  },

  lockedContentStartTagBuilder: function () {
    var me = this,
        startTag,
        wrapper;

    startTag = $(me.tagLockedStart);
    startTag.html(me.zwnj);

    wrapper = $(me.tagWrapper).append(startTag).append(me.zwnj);
    wrapper[0].dataset.type = 'start-tag';

    return wrapper;
  },

  lockedContentEndTagBuilder: function () {
    var me = this,
        endTag,
        wrapper;

    endTag = $(me.tagLockedEnd);
    endTag.html(me.zwnj);

    wrapper = $(me.tagWrapper).append(endTag).append(me.zwnj);
    wrapper[0].dataset.type = 'end-tag';

    return wrapper;
  },

  buildSegmentInlineContent: function () {
    var me = this,
        inlineContent = h(me.inlineContentWrapper);

    inlineContent.appendChild(h(me.zwnj));

    return inlineContent;
  }
};
},{"./Helpers":5}],22:[function(require,module,exports){
/* File: TranslationOrigin.js */
/* jshint undef: true, unused: true */
/* globals require, module */
'use strict';

var Helpers = require('./Helpers');

var TranslationOrigin = (function () {
  var __extend = Helpers._extend;

  var translationOrigin = {
    metadata :                null, // array of Objects = {name : String, value : String}
    originType :              null, // String
    originSystem:             null,
    matchPercent:             0,    // Int
    textContextMatchLevel:    null,
    originalTranslationHash:  null,
    originBeforeAdaptation:   null, // {object - translationOrigin type of object}
    isStructureContextMatch:  false // boolean
  };

  // Not used?
  // var formatOriginType = {
  //   'al':  'auto-aligned',
  //   'ap':  'auto-propagated',
  //   'at':  'mt',
  //   'nt':  'not-translated',
  //   'src': 'source',
  //   'un':  'unknown'
  // };

  var confirmationLevelText = {
    'not-translated':       'Not Translated',
    'NotTranslated':        'Not Translated',
    'approved-sign-off':    'Sign Off',
    'ApprovedSignOff':      'Sign Off',
    'approved-translation': 'Translation Approved',
    'ApprovedTranslation':  'Translation Approved',
    'draft':                'Draft',
    'Draft':                'Draft',
    'rejected-sign-off':    'Sign Off Rejected',
    'RejectedSignOff':      'Sign Off Rejected',
    'rejected-translation': 'Translation Rejected',
    'RejectedTranslation':  'Translation Rejected',
    'translated':           'Translated',
    'Translated':           'Translated'
  };

  var originText = {
    'al':  'Auto-aligned',
    'ap':  'Auto-propagated',
    'at':  'Automated Translation',
    'cm':  'Context Match',
    'em':  'Exact Match',
    'fm':  'Fuzzy Match',
    'it':  'Interactive',
    'nt':  'Not Translated',
    'pm':  'Perfect Match',
    'src': 'Copied From Source',
    'tm':  'Translation Memory',
    'un':  'Unknown'
  };

  function translationDetails(segmentData) {
    var info = 'Translation Details: ' + '\r\n',
        status = confirmationLevelText[segmentData.confirmationlevel] || 'Not Translated',
        type = TranslationOrigin.originType(segmentData.translationorigin);

    //add confirmation level info
    info += 'Status: ' + status + '\r\n';

    //add origin info
    info += 'Origin: ' + originText[type] + '\r\n';

    //add origin system
    if (type !== 'it') {
      info += 'System: ' + segmentData.translationorigin.originSystem + '\r\n';
    }

    //add percent info
    info += 'Score: ' + segmentData.translationorigin.matchPercent + '%' + '\r\n';

    return info;
  }

  function beforeInteractiveEditing(tObj) {
    var tO = tObj.originBeforeAdaptation,
        info, type;

    if (!isDifferent(tObj, tO)) {
      return '';
    }

    info = 'Before Interactive Editing: ' + '\r\n';
    type = TranslationOrigin.originType(tO);

    //add origin info
    info += 'Origin: ' + originText[type] + '\r\n';

    //add origin system
    if (tO.originSystem) {
      info += 'System: ' + tO.originSystem + '\r\n';
    }

    //add percent info
    info += 'Score: ' + tO.matchPercent + '%' + '\r\n';

    return info;
  }

  function isDifferent(tO, originalTO) {
    if (!tO.originType || !originalTO || !originalTO.originType) {
      return false;
    }

    if (tO.originType !== originalTO.originType) {
      return true;
    }

    if (tO.matchPercent !== originalTO.matchPercent) {
      return true;
    }

    // TO DO - not finished
    //textContextMatchLevel conpare

    return false;
  }

  return {
    create: function () {
      return translationOrigin;
    },

    originalFormat: function (trOrigin) {
      var cloneTrOrigin = __extend({}, trOrigin);
      delete cloneTrOrigin.wasChanged;

      return cloneTrOrigin;
    },

    /**
     * Clone | Duplicate translation Origin Object
     */
    clone: function (trOrigin) {
      return {
        metadata :               trOrigin.metadata,
        originType:              trOrigin.originType,
        originSystem:            trOrigin.originSystem,
        matchPercent:            trOrigin.matchPercent,
        textContextMatchLevel:   trOrigin.textContextMatchLevel,
        originalTranslationHash: trOrigin.originalTranslationHash,
        originBeforeAdaptation:  trOrigin.originBeforeAdaptation,
        isStructureContextMatch: trOrigin.isStructureContextMatch,
      };
    },

    translationInfo: function (data) {
      //translation details
      var details = translationDetails(data),
          moreDetails;

      //before interactive editing details
      if (data.translationorigin.originBeforeAdaptation !== null) {
        moreDetails = beforeInteractiveEditing(data.translationorigin, data.confirmationlevel);
        details += (moreDetails !== '') ? '\r\n' + moreDetails : '';
      }

      return details;
    },

    originType : function (translationObj) {
      var shortOriginType = 'it';

      if (translationObj === undefined || translationObj === [] || translationObj === {}) {
        return shortOriginType;
      }

      if (translationObj.originType === undefined || translationObj.originType === null || translationObj.originType === 'interactive') {
        return shortOriginType;
      }

      //!!!!! Do not change if order !!!!!
      if (translationObj.matchPercent !== null && translationObj.matchPercent === 100) {      //Exact Match case
        shortOriginType = 'em';
      } else if (translationObj.matchPercent !== null && translationObj.matchPercent < 100) { //Fuzzy Match case
        shortOriginType = 'fm';
      }

      switch (translationObj.originType) {
        case 'tm': //Translation Memory case
          shortOriginType = 'tm';

          if (translationObj.textContextMatchLevel !== null && translationObj.textContextMatchLevel.toLowerCase() === 'sourceandtarget') {
            shortOriginType = 'cm';
          }
          break;

        case 'document-match': //Perfect Match case
          if (translationObj.textContextMatchLevel !== null && translationObj.textContextMatchLevel.toLowerCase() === 'source') {
            shortOriginType = 'pm';
          }
          break;

        case 'mt': //Automated Translation case
          shortOriginType = 'at';
          break;

        case 'source': //Source case
          shortOriginType = 'src';
          break;

        case 'auto-propagated': //Source case
          shortOriginType = 'ap';
          break;

        case 'not-translated': //Not Translated case !!!!! NOT TREATED
          shortOriginType = 'nt';
          break;

        case 'auto-aligned': //Auto-aligned case !!!!! NOT TREATED
          shortOriginType = 'al';
          break;

        case 'unknown': //Unknown case !!!!! NOT TREATED
          shortOriginType = 'un';
          break;
      }

      return shortOriginType;
    }
  };
})();

module.exports = TranslationOrigin;
},{"./Helpers":5}],23:[function(require,module,exports){
/* File: ue.js */
/* jshint undef: true, unused: true */
/* globals $, require, module */

'use strict';

var config = require('./config');
var DataProvider = require('./DataProvider');
var Documents = require('./Documents');
var Layout = require('./Layout');
var CommandManager = require('./CommandManager');
var SegmentStatusUpdater = require('./SegmentStatusUpdater');


var App = module.exports = {};

// Rendering module
var ViewRenderer = (function () {
  return {
    init: function () {
      this.$body = $('body');

      Layout.init();
      Documents.init();
    }
  };
})();

// Default config
App.config = config;

// Default environment
App.config.environment = 'development';

// App initialization
App.init = function (options) {

  // Merge config if the case
  if (options.config && (typeof options.config === 'object')) {
    for (var key in options.config) {
      if (options.config.hasOwnProperty(key)) {
        App.config[key] = options.config[key];
      }
    }
  }

  DataProvider.init();
  ViewRenderer.init();
  Documents.openDocument(options.doc);
};

// Expose command mannager as an external API
App.CommandManager = CommandManager;
},{"./CommandManager":2,"./DataProvider":3,"./Documents":4,"./Layout":8,"./SegmentStatusUpdater":16,"./config":25}],24:[function(require,module,exports){
/* File: EditorCommands.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

var config = require('../config');

var cmds = {
  'paste': {
    handle: function (ev) {
      var text,
          rInvalidChars = /\r?\n/g,
          html = document.createElement('span'),
          clipboard = (ev.originalEvent || ev).clipboardData;

      ev.preventDefault();

      if (clipboard === undefined || clipboard === null) {
        text = window.clipboardData.getData('text') || '';

        if (text !== '') {
          text = text.replace(rInvalidChars, ' ');
          window.getSelection().getRangeAt(0).insertNode(html);
        }

      } else {
        text = clipboard.getData('text/plain') || '';

        if (text !== '') {
          text = text.replace(rInvalidChars, ' ');
          document.execCommand('insertText', false, text);
        }
      }
    }
  }
};

module.exports = cmds;
},{"../config":25}],25:[function(require,module,exports){
/* File: config.js */
/* jshint undef: true, unused: true */
/* globals module */
'use strict';

var config = {
  fullMode: true,

  //set the storage implementation module
  storage: 'StorageImplementation',

  //set display limit of paragraph units
  //defaultLimit: 50,
  defaultLimit: 1000, //trying to get load all paragraphs in file

  //set the default offset from where to get paragraph units
  defaultOffset: 0,

  baseUrl: 'http://clujeditor01:8080/wse/lue',//'http://localhost:8080/ce',
  //apiUrl: UE.config.baseUrl + '',
  apiUrl: 'http://clujeditor01:8080/wse/lue',

  tagDisplayContext: {
    // Determines how the tag pairs will be displayed
    //
    // Options:
    //    none    - No Tag Text
    //    partial - Partial Tag Text
    //    full    - Full Tag Text
    //    id      - Tag Id
    //
    // The default display mode is Partial Tag Text
    tagDisplayMode: 'partial',
    showFormatting: false
  }
};

module.exports = config;
},{}],26:[function(require,module,exports){
/* File: Keys.js */
/* jshint undef: true, unused: true */
/* globals module */

'use strict';

var FUNCTION_KEYS = {
  // Keyboard keys
  keyTab: 9,
  keyBackspace: 8,
  keyEnter: 13,
  keySpace: 32,

  keyPageUp: 33,
  keyPageDown: 34,
  keyEnd: 35,
  keyHome: 36,
  keyInsert: 45,
  keyDelete: 46,

  keyLeftArrow: 37,
  keyUpArrow: 38,
  keyRightArrow: 39,
  keyDownArrow: 40,

  keyShift: 16,
  keyCtrl: 17,
  keyAlt: 18,
  keyEsc: 27,

  keyCapsLock: 20,
  keyNumLock: 144,
  keyScrollLock: 145,

  keyF1: 112,
  keyF2: 113,
  keyF3: 114,
  keyF4: 115,
  keyF5: 116,
  keyF6: 117,
  keyF7: 118,
  keyF8: 119,
  keyF9: 120,
  keyF10: 121,
  keyF11: 122,
  keyF12: 123
};

var IGNORED_KEYS = [
  FUNCTION_KEYS.keyLeftArrow,
  FUNCTION_KEYS.keyUpArrow,
  FUNCTION_KEYS.keyRightArrow,
  FUNCTION_KEYS.keyDownArrow,
  FUNCTION_KEYS.keyCapsLock,
  FUNCTION_KEYS.keyScrollLock,
  FUNCTION_KEYS.keyNumLock,
  FUNCTION_KEYS.keyAlt,
  FUNCTION_KEYS.keyCtrl,
  FUNCTION_KEYS.keyShift,
  FUNCTION_KEYS.keyPageUp,
  FUNCTION_KEYS.keyPageDown,
  FUNCTION_KEYS.keyHome,
  FUNCTION_KEYS.keyEnd,
  FUNCTION_KEYS.keyEnter,
  FUNCTION_KEYS.keyEsc,
  FUNCTION_KEYS.keyInsert,
  FUNCTION_KEYS.keyF1,
  FUNCTION_KEYS.keyF2,
  FUNCTION_KEYS.keyF3,
  FUNCTION_KEYS.keyF4,
  FUNCTION_KEYS.keyF5,
  FUNCTION_KEYS.keyF6,
  FUNCTION_KEYS.keyF7,
  FUNCTION_KEYS.keyF8,
  FUNCTION_KEYS.keyF9,
  FUNCTION_KEYS.keyF10,
  FUNCTION_KEYS.keyF11,
  FUNCTION_KEYS.keyF12
];

var ALLOWED_IN_LOCKED_CONTENT = {
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'Left',
  38: 'Up',
  39: 'Right',
  40: 'Down',

  112: 'F1',
  113: 'F2',
  114: 'F3',
  115: 'F4',
  116: 'F5',
  117: 'F6',
  118: 'F7',
  119: 'F8',
  120: 'F9',
  121: 'F10',
  122: 'F11',
  123: 'F12'
};

var Keys = {
  functionKeys: FUNCTION_KEYS,
  ignoredKeys: IGNORED_KEYS,
  allowedKeysInLockedContent: ALLOWED_IN_LOCKED_CONTENT
};

module.exports = Keys;
},{}],27:[function(require,module,exports){
/* File: SegmentUnderCurrentSelection.js */
/* jshint undef: true, unused: true */
/* globals _ */
'use strict';
function SegmentUnderCurrentSelection() {
  var segmentNumber,
      segmentEl;

  var selection = document.getSelection();
  var focusNode = selection.focusNode;


  if (focusNode === null) {
    return {
      segmentNumber: undefined,
      segmentEl: undefined
    };
  }

  if (focusNode.dataset !== undefined) {
    segmentNumber = focusNode.dataset.segmentNumber;
    segmentEl = focusNode;
  }

  if (segmentNumber === undefined) {
    var parentSegment = $(selection.focusNode).parents('.ue-segment');
    var parentSegmentEl = _(parentSegment).first();

    segmentNumber = parentSegmentEl.dataset.segmentNumber;
    segmentEl = parentSegmentEl;
  }

  return {
    segmentNumber: segmentNumber,
    segmentEl: segmentEl
  };
}

module.exports = SegmentUnderCurrentSelection;
},{}],28:[function(require,module,exports){
/* File: ShiftEnterHandler.js */
/* jshint undef: true, unused: true */
/* globals require, module */
"use strict";

var Helpers = require('../Helpers');
var SegmentsWatcher = require('../SegmentsWatcher');
var KeyboardBindings = require('../KeyboardBindings');
var Keys = require('./Keys');
var Selection = require('../selection');

var ShiftEnterHandler = function (ev) {
  var me = this,
      isShiftKeyPressed = ev.shiftKey,
      isEnterPressed = ev.keyCode === Keys.functionKeys.keyEnter,
      isHandlingRequired = isShiftKeyPressed && isEnterPressed,
      selection = new Selection.SelectionContext(),
      focusNode = selection.focusNode;

  if (!isHandlingRequired) {
    return;
  }

  me.focus = new Selection.NodeWalker(focusNode);
  me.breakLinesOutsideOfText = [];

  me.moveFocusToTargetSegment();
  me.moveBreakLinesToTextContainers();

  SegmentsWatcher.resize(me.segmentNumber);
};

var proto = ShiftEnterHandler.prototype;

proto.moveFocusToTargetSegment = function () {
  var me = this,
      focus = me.focus;

  while (!focus.isNull() && !focus.isSegment()) {
    focus = focus.parent();
  }

  me.segmentNumber = focus.segmentNumber();
  me.focus = focus;
};

proto.moveBreakLinesToTextContainers = function () {
  var me = this,
      nodeWalker = me.focus;

  me.moveThrough(nodeWalker);
};

proto.moveThrough = function (container) {
  var me = this,
      nodeWalker = container;

  nodeWalker = nodeWalker.firstChild();
  while (!nodeWalker.isNull()) {

    if (nodeWalker.isInlineContent()) {
      me.insertBreakLinesAtStartOf(nodeWalker);
    }

    if (nodeWalker.isElement('br') && nodeWalker.parent().isSegment()) {
      me.breakLinesOutsideOfText.push(nodeWalker);
    }

    if (nodeWalker.isElement('br') && nodeWalker.parent().isTag()) {
      me.moveNodeAfterTheTag(nodeWalker);
    }

    if (nodeWalker.isElement()) {
      me.moveThrough(nodeWalker);
    }

    if (nodeWalker.isTag()) {
      me.exportNewLines(nodeWalker);
      me.insertBreakLinesAfter(nodeWalker);
    }

    if (nodeWalker.isText()) {
      me.convertCarriageReturnToBreak(nodeWalker);
    }

    nodeWalker = nodeWalker.next();
  }
};

proto.insertBreakLinesAtStartOf = function (nodeWalker) {
  var me = this,
      breakLineElement,
      firstChild = nodeWalker.firstChild();

  while (me.breakLinesOutsideOfText.length > 0) {
    breakLineElement = me.breakLinesOutsideOfText.pop();

    if (!firstChild.isNull()) {
      firstChild.insertBefore(breakLineElement);
    } else {
      nodeWalker.append(breakLineElement);
    }
  }
};

proto.insertBreakLinesAfter = function (nodeWalker) {
  var me = this,
      breakLineElement;

  while (me.breakLinesOutsideOfText.length > 0) {
    breakLineElement = me.breakLinesOutsideOfText.pop();

    nodeWalker.insertAfter(breakLineElement);
  }
};

proto.exportNewLines = function (container) {
  var me = this,
      textContent,
      newLinesCount,
      i,
      br;

  if (container.isNull()) {
    return;
  }

  textContent = container.textContent();
  newLinesCount = textContent.split('\n').length - 1;

  for (i = 0; i < newLinesCount; i++) {
    br = Helpers.stringToHTMLElement('<br>');
    me.breakLinesOutsideOfText.push(br);
  }

  if (newLinesCount > 0) {
    me.cleanCarriageReturnFrom(container);
  }
};

proto.cleanCarriageReturnFrom = function (container) {
  var processingQueue = [container],
      nodeValue;

  while (processingQueue.length > 0) {
    var item = processingQueue.pop();

    if (item.isTextNode()) {
      nodeValue = item.el.nodeValue;
      nodeValue = nodeValue.replace('\n', '');
      item.el.nodeValue = nodeValue;
    }

    if (!item.next().isNull()) {
      processingQueue.push(item.next());
    }

    if (!item.firstChild().isNull()) {
      processingQueue.push(item.firstChild());
    }
  }
};

proto.convertCarriageReturnToBreak = function (container) {
  var nodeWalker = container.firstChild();
  var nodeValue;
  var breakNode;
  var carriageReturnNode;
  var parentNode;

  while (!nodeWalker.isNull()) {
    if (nodeWalker.isTextNode()) {
      nodeValue = nodeWalker.el.nodeValue;
      carriageReturnNode = nodeWalker.el;
      parentNode = nodeWalker.el.parentNode;

      if (nodeValue === '\n') {
        breakNode = document.createElement('br');
        parentNode.replaceChild(breakNode, carriageReturnNode);
        nodeWalker.el = breakNode;
      }
    }

    nodeWalker = nodeWalker.next();
  }

};

proto.moveNodeAfterTheTag = function (brNode) {
  var tag = brNode.parent();

  tag.insertAfter(brNode);
};

module.exports = ShiftEnterHandler;
},{"../Helpers":5,"../KeyboardBindings":7,"../SegmentsWatcher":17,"../selection":34,"./Keys":26}],29:[function(require,module,exports){
/* File: RibbonMenuCommands.js */
/* jshint undef: true, unused: true */
/* globals $, require, module */

'use strict';

var config = require('../config');
var Mediator = require('../Mediator');
var CommandManager = require('../CommandManager');

var Storage = require('../Storage');
var DataProvider = require('../DataProvider');
var Paragraphs = require('../Paragraphs');

var cmdr = new CommandManager();

var RibbonMenuCommands = {
  setupListeners: function () {
    var me = this;

    var commands = {
      'toggle_formatting_tags': {
        handle: function (elem) {
          var target = $(elem),
              hidden = target.data('hidden'),
              showFormatting = config.tagDisplayContext.showFormatting;

          if (showFormatting) {
            target.data('hidden', false).addClass('active');
          }

          if (typeof hidden === 'undefined' || hidden) {
            target.data('hidden', false).addClass('active');
            me.showTags();
            config.tagDisplayContext.showFormatting = true;
          } else {
            target.data('hidden', true).removeClass('active');
            me.hideTags();
            config.tagDisplayContext.showFormatting = false;
          }
        }
      },

      'display_tag_none': {
        handle: function (elem) {
          me.toggleGroupedButtons(elem);
          me.switchDisplayMode('none');
        }
      },

      'display_tag_partial': {
        handle: function (elem) {
          me.toggleGroupedButtons(elem);
          me.switchDisplayMode('partial');
        }
      },

      'display_tag_full': {
        handle: function (elem) {
          me.toggleGroupedButtons(elem);
          me.switchDisplayMode('full');
        }
      },

      'display_tag_id': {
        handle: function (elem) {
          me.toggleGroupedButtons(elem);
          me.switchDisplayMode('id');
        }
      }
    };

    me.$ribbon.on('click', '[data-action]', function (ev) {
      var elem = ev.currentTarget;

      Mediator.publish('ribbon:command', {
        elem: elem,
        action: elem.dataset.action || null
      });
    });

    // Set up commands for the ribbon menu
    cmdr.addCommands(commands);

  },

  hideTags: function () {
    var me = this,
        elems = me.$editor.find('[data-can-hide="true"]');

    elems.addClass('hide').data('can-delete', false);
  },

  showTags: function () {
    var me = this,
        elems = me.$editor.find('[data-can-hide="true"]');

    elems.removeClass('hide').data('can-delete', true);
  },


  /**
   * Toggle grouped buttons state
   * @param  {HTMLElement} target - Clicked element
   *
   * TODO: it depends heavily on jQuery, this should be changed
   */
  toggleGroupedButtons: function (target) {
    var targetEl = $(target);

    if (!target.dataset.actionGroup) {
      return;
    }

    targetEl.parents('.nav-ribbon-panel')
            .find('[data-action-group]')
            .removeClass('active');

    targetEl.addClass('active');
  },


  /**
   * Switch the display mode for formatting tags
   * @param  {String} mode
   */
  switchDisplayMode: function (mode) {
    var me = this,
        storage = Storage[config.storage].getInstance(),
        currentDoc = DataProvider.getCurrentDocument();

    config.tagDisplayContext.tagDisplayMode = mode;

    me.$editor.html('');
    Paragraphs._renderParagraphs(storage.paragraphs, currentDoc);
  },


  init: function () {
    var me = this;

    me.$editor = $('#editor-body');
    me.$ribbon = $('.nav-ribbon');

    me.setupListeners();
  }
};

// Subscribe to ribbon commands and execute them
Mediator.subscribe('ribbon:command', function (data) {
  cmdr.execute(data.action, data.elem);
});

module.exports = RibbonMenuCommands;
},{"../CommandManager":2,"../DataProvider":3,"../Mediator":10,"../Paragraphs":13,"../Storage":20,"../config":25}],30:[function(require,module,exports){
/* File: CtrlClickHandler.js */
/* jshint undef: true, unused: true */
/* globals _ */
'use strict';
var helpers = require('../Helpers');
var dataProvider = require('../DataProvider');

var Mediator = require('../Mediator');
var Segment = require('../Segment');
var Keyboard = require('../Keyboard');
var NodeWalker = require('../selection').NodeWalker;
var TagPair = require('../selection').TagPair;
var SelectionContext = require('../selection').SelectionContext;

function MouseCtrlClickHandler() {
}
var proto = MouseCtrlClickHandler.prototype;

/**
 * Inserts tags or wraps selections with tags
 * @param  {Object} ev jQuery event object
 */
proto.handle = function (ev) {
  var me = this,
      tag, tags,
      placeholderClone,
      currentSegment = Keyboard.SegmentUnderCurrentSelection(),
      currentSegmentNumber = currentSegment.segmentNumber,
      isSelectionInSource, isCollapsed,
      segment, segmentData,
      startContainer;

  tag = new NodeWalker(ev.currentTarget);
  tags = document.createDocumentFragment();

  if (!tag.isTag()) {
    return;
  }

  if (tag.isPlaceholder()) {
    placeholderClone = tag.el.cloneNode(true);
    me.clearActiveClass(placeholderClone);
    me.disableTagCopy(placeholderClone);
    tags.appendChild(placeholderClone);
  } else {
    tag = new TagPair(tag);
    tags = tag.cloneStructure();
    me.clearActiveClass(tags.childNodes[0]);
    me.clearActiveClass(tags.childNodes[2]);

    me.disableTagCopy(tags.childNodes[0]);
    me.disableTagCopy(tags.childNodes[2]);
  }

  me.range = new SelectionContext();
  startContainer = me.range.startContainer;

  if (!startContainer) {
    return;
  }

  isCollapsed = me.range.isCollapsed();

  isSelectionInSource = helpers.hasParent(startContainer, 'ue-source');

  // Check if selection is in source
  if (isSelectionInSource) {
    return;
  }

  // If CTRL key is pressed and clicked
  // mouse button is left button, insert tag
  if (ev.ctrlKey && ev.which === 1) {
    if (isCollapsed) {
      me.insertTagAtCursor(tags);
    } else {
      me.insertTagOverSelection(tags);
    }

    // Change segment status to draft after tag insertion
    segmentData = dataProvider.getSegmentBySegmentNumber(currentSegmentNumber);
    segment = new Segment(segmentData);
    segment.changeToDraft();

    // Publish segment status has changed
    Mediator.publish('segment:confirmationLevelChanged', segmentData);
    ev.preventDefault();
  }
};

proto.clearActiveClass = function (tagWrapper) {
  var tag = tagWrapper.firstChild;
  tag.classList.remove('active');
};

proto.disableTagCopy = function (tagWrapper) {
  tagWrapper.dataset.tagCopy = false;
};

/**
 * Inserts the clicked tag at the current cursor position
 * @param  {DocumentFragment}  tags
 */
proto.insertTagAtCursor = function (tags) {
  var me = this,
      html = document.createDocumentFragment(),
      range = me.range,
      insertedNode = tags.firstChild,
      focusNode = insertedNode.lastChild;// I expect the invisible char to be here.

  html.appendChild(tags);

  range.insertNode(html);
  me.setCursorAt(focusNode);
};

proto.setCursorAt = function (focusNode){
  var me = this,
      range = me.range;

  if(focusNode === null || focusNode === undefined){
    return;
  }

  _.delay(function () {
    range.changeRange(function(newRange){
      var selectionOffset = 1;
      newRange.setStart(focusNode, selectionOffset);
      newRange.setEnd(focusNode, selectionOffset);

      return true;
    });
  });
};

/**
 * Wraps selection and inserts it at the current cursor position
 * @param  {DocumentFragment}  tags
 */
proto.insertTagOverSelection = function (tags) {
  var me = this,
      html = document.createDocumentFragment(),
      range = me.range,
      documentFragment,
      inlineContent;

  documentFragment = range.cloneContents();

  html.appendChild(tags);

  inlineContent = html.querySelector('.ue-inline-content');
  if (inlineContent !== null) {
    inlineContent.appendChild(documentFragment);
  }

  range.deleteContents();
  range.insertNode(html);
  me.selectContent(inlineContent);
};

proto.selectContent = function (inlineContent) {
  var me = this,
      range = me.range;

  if(inlineContent === undefined || inlineContent === null){
    return;
  }

  range.changeRange(function (range) {
    range.selectNodeContents(inlineContent);

    return true;
  });
};

module.exports = MouseCtrlClickHandler;
},{"../DataProvider":3,"../Helpers":5,"../Keyboard":6,"../Mediator":10,"../Segment":14,"../selection":34}],31:[function(require,module,exports){
/* File: CtrlHoverHandler.js */
/* jshint undef: true, unused: true */
'use strict';

function MouseCtrlHoverHandler() {
}

var proto = MouseCtrlHoverHandler.prototype;

proto.mouseOver = function (ev) {
  if (!ev.ctrlKey || ev.type !== 'mouseover') {
    return;
  }
  $(ev.currentTarget).children().addClass('active');
};

proto.mouseLeave = function (ev) {
  if (ev.type !== 'mouseleave') {
    return;
  }
  $(ev.currentTarget).children().removeClass('active');
};
module.exports = MouseCtrlHoverHandler;
},{}],32:[function(require,module,exports){
/* File: StylesMap.js */
/* jshint undef: true, unused: true */
/* globals module */

'use strict';

// Used to map different represetations
// of a true/false strings
var booleanMap = {
  'FALSE': false,
  'False': false,
  'false': false,
  'TRUE': true,
  'True': true,
  'true': true
};

// Map text position names to multiple CSS properties,
// because 'super' and 'sub' values of 'vertical-align' property are not enough
var textPositionMap = {
  'Superscript': {
    'font-size': '0.8em',
    'vertical-align': '0.6em'
  },
  'Subscript': {
    'font-size': '0.8em',
    'vertical-align': '-0.3em'
  },
  'Normal': {
    'font-size': 'inherit',
    'vertical-align': 'inherit'
  }
};

var StylesMap = {
  'textcolor': function (value) {
    var values = value.split(','),
        rgbRegexp = /(^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*)$/i,
        rgbTest, rgbText;

    // In case TextColor format is '"TextColor": "0, 112, 48, 160"'
    if (values.length > 3) {
      values.shift();
    }

    // If "TextColor":"Transparent"
    // it happens when white text has background color in a MS Word document
    if (typeof value === 'string' && value.toLowerCase() === 'transparent') {
      value = 'rgb(255, 255, 255)';
    }

    rgbText = values.toString();
    rgbTest = rgbText.match(rgbRegexp);

    return {
      'color': rgbTest ? 'rgb(' + rgbText + ')' : value.toLowerCase()
    };
  },

  'fontsize': function (value) {
    var str = value.match(/\s*(\d{1,3})px/);

    return {
      'font-size': str ? value : value + 'px'
    };
  },

  'bold': function (value) {
    return {
      'font-weight': value ? 'bold' : 'normal'
    };
  },

  'italic': function (value) {
    return {
      'font-style': value ? 'italic' : 'none'
    };
  },

  'fontname': function (value) {
    return {
      'font-family': value
    };
  },

  'underline': function (value) {
    return {
      'text-decoration': booleanMap[value] ? 'underline' : 'none'
    };
  },

  'strikethrough': function (value) {
    return {
      'text-decoration': booleanMap[value] ? 'line-through' : 'none'
    };
  },

  'textposition': function (value) {
    return textPositionMap[value];
  },

  'backgroundcolor': function (value) {
    var values = value.split(','),
        rgbRegexp = /(^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*)$/i,
        rgbTest, rgbText;

    // In case TextColor format is '"TextColor": "0, 112, 48, 160"'
    if (values.length > 3) {
      values.shift();
    }

    rgbText = values.toString();
    rgbTest = rgbText.match(rgbRegexp);

    return {
      'background-color': rgbTest ? 'rgb(' + rgbText + ')' : value.toLowerCase()
    };
  },

  'shadow': function () {},
  'rstyle': function () {},
  'w14:prstdash': function () {},
  'w14:reflection': function () {},
  'w14:glow': function () {},
  'fonttheme': function () {},
  'w14:props3d': function () {}
};

module.exports = StylesMap;
},{}],33:[function(require,module,exports){
/* File: TagContentBuilder.js */
/* jshint undef: true, unused: true */
/* globals require, module */

'use strict';

var strategies = {
  none: function () {
    return String.fromCharCode(8204);
  },

  id: function (data) {
    return data.tagPairDefinitionId || data.placeholderTagDefinitionId;
  },

  partial: function (data) {
    if (data.type === 'tagPair') {
      return {
        tagStart: data.startTagDisplayText,
        tagEnd: data.endTagDisplayText
      };
    }

    return data.displayText;
  },

  full: function (data) {
    if (data.type === 'tagPair') {
      return {
        tagStart: data.startTagContent,
        tagEnd: data.endTagContent
      };
    }

    return data.tagContent;
  }
};

var TagContentBuilder = function (strategy) {
  this.strategy = strategies[strategy];
};

TagContentBuilder.prototype.build = function (data) {
  return this.strategy(data);
};

module.exports = TagContentBuilder;
},{}],34:[function(require,module,exports){
module.exports=require(18)
},{"./selection/NodeWalker":35,"./selection/SelectionContext":36,"./selection/TagPair":37}],35:[function(require,module,exports){
/* File: NodeWalker.js */
/* jshint undef: true, unused: true */
/* globals $, module, require */
'use strict';

var Tmpl = require('../Tmpl');

var NodeWalker = function (node) {
  var me = this;

  me.el = node;
  me.returnNode = null;
};

var proto = NodeWalker.prototype;

proto.tagId = function () {
  var me = this,
      el = me.el;

  if (me.isNull() || me.isTextNode()) {
    return null;
  }

  return el.dataset.id;
};

proto.isSegment = function () {
  var me = this;

  if (me.isNull() || me.isTextNode()) {
    return false;
  }

  return me.el.classList.contains('ue-segment');
};

proto.isInlineContent = function () {
  var me = this;

  if (me.isNull() || me.isTextNode()) {
    return false;
  }

  return me.el.classList.contains('ue-inline-content');
};

proto.isText = function () {
  var me = this;

  if (me.isNull() || me.isTextNode()) {
    return false;
  }

  return me.el.classList.contains('ue-text');
};

proto.isTextNode = function () {
  var me = this;

  if (me.isNull()) {
    return false;
  }

  return me.el.nodeType === 3;
};

proto.isTagPairContainer = function () {
  var me = this;

  if (me.isNull() || me.isTextNode()) {
    return false;
  }

  return me.el.classList.contains('ue-tagpair-content');
};

proto.isTag = function () {
  var me = this;

  if (me.isNull() || me.isTextNode()) {
    return false;
  }

  return me.el.classList.contains('ue-tag-wrapper');
};

proto.isStartTag = function () {
  var me = this;

  if (me.isNull() || me.isTextNode()) {
    return false;
  }

  return me.el.dataset.type === 'start-tag';
};

proto.isEndTag = function () {
  var me = this;

  if (me.isNull() || me.isTextNode()) {
    return false;
  }

  return me.el.dataset.type === 'end-tag';
};

proto.isPlaceholder = function () {
  var me = this;

  if (me.isNull()) {
    return false;
  }

  return me.el.dataset.type === 'placeholder';
};

proto.canHide = function () {
  var me = this;

  if (me.isNull() || me.isTextNode()) {
    return false;
  }

  return me.el.dataset.canHide;
};

/**
 * Loop over parents and return true if isLoked property is set
 * @return {Boolean} returns true if element or parent is locked
 */
proto.isLocked = function () {
  var me = this,
      node = me.el,
      isLocked = (node.hasOwnProperty('dataset') && node.dataset.isLocked) ? node.dataset.isLocked : false;

  while (!isLocked && node.nodeType !== 9) {
    isLocked = (node.hasOwnProperty('dataset') && node.dataset.isLocked) ? node.dataset.isLocked : false;
    node = node.parentNode;
  }

  return isLocked;
};

proto.isWrapperFor = function (node) {
  var me = this,
      el = me.el;

  return el === node;
};


/**
 * Tests if the cursor is in an empty segment
 * that contains only Zero Width Non-Joiner char
 *
 * @return {Boolean} true if it's an empty segment
 */
proto.isInvisibleChar = function () {
  var me = this,
      el = me.el,
      tmpl = Tmpl,
      textContent = el.textContent,
      isInvisibleChar;

  isInvisibleChar = textContent.length === 1 &&
    textContent.charCodeAt(0) === tmpl.zeroWidthNonJoinerCharCode;

  return isInvisibleChar;
};


proto.isElement = function (name) {
  var me = this,
      el = me.el,
      isElementType = me.el.nodeType === 1,
      checkName = name !== undefined && name !== null,
      result;

  result = isElementType;
  if (checkName) {
    result = result && el.nodeName.toLowerCase() === name;
  }

  return result;
};

proto.isNull = function () {
  var me = this;

  return me.el === null || me.el === undefined;
};

proto.hasChildren = function () {
  var me = this,
      childNodes = me.el.childNodes;

  return childNodes.length !== 0;
};

proto.equals = function (nodeWalker) {
  var me = this;

  if (me.isNull() && nodeWalker.isNull()) {
    return true;
  }

  return me.el === nodeWalker.el;
};

proto.textContent = function () {
  var me = this,
      el = me.el;

  return el.textContent;
};

proto.parent = function () {
  var me = this,
      returnNode = me.el,
      walker;

  walker = new NodeWalker(me.el.parentNode);
  walker.returnNode = returnNode;

  return walker;
};

proto.returnToPrevious = function () {
  var me = this,
      returnNode = me.el,
      walker;

  walker = new NodeWalker(me.returnNode);
  walker.returnNode = returnNode;

  return walker;
};

proto.next = function () {
  var me = this,
      returnNode = me.el,
      walker;

  walker = new NodeWalker(me.el.nextSibling);
  walker.returnNode = returnNode;

  return walker;
};

proto.prev = function () {
  var me = this,
      returnNode = me.el,
      walker;

  walker = new NodeWalker(me.el.previousSibling);
  walker.returnNode = returnNode;

  return walker;
};

proto.remove = function () {
  var me = this,
      parent = me.el.parentNode;
  parent.removeChild(me.el);
};

proto.firstChild = function () {
  var me = this,
      el = me.el,
      firstChild = me.el.firstChild,
      walker;

  walker = new NodeWalker(firstChild);
  walker.returnNode = el;

  return walker;
};

proto.lastChild = function () {
  var me = this,
      el = me.el,
      lastChild = me.el.lastChild,
      walker;

  walker = new NodeWalker(lastChild);
  walker.returnNode = el;

  return walker;
};

proto.replaceWithInnerContent = function () {
  var me = this,
      $el = $(me.el);

  $el.replaceWith($el.children());

  me.el = null;
};

proto.insertBefore = function (node) {
  var me = this,
      el = me.el,
      parent = el.parentNode,
      nodeEl;

  if (node instanceof NodeWalker) {
    nodeEl = node.el;
  } else {
    nodeEl = node;
  }

  parent.insertBefore(nodeEl, el);
};

proto.insertAfter = function (node) {
  var me = this,
      el = me.el,
      parent = el.parentNode,
      nextSibling = el.nextSibling,
      nodeEl;

  if (node instanceof NodeWalker) {
    nodeEl = node.el;
  } else {
    nodeEl = node;
  }

  parent.insertBefore(nodeEl, nextSibling);
};

proto.append = function (node) {
  var me = this,
      el = me.el,
      nodeEl;

  if (node instanceof NodeWalker) {
    nodeEl = node.el;
  } else {
    nodeEl = node;
  }

  el.appendChild(nodeEl);
};

proto.prepend = function (node) {
  var me = this,
      el = me.el,
      nodeEl;

  if (node instanceof NodeWalker) {
    nodeEl = node.el;
  } else {
    nodeEl = node;
  }

  el.insertBefore(nodeEl, el.firstChild);
};

proto.segmentNumber = function () {
  var me = this,
      el = me.el;

  return el.dataset.segmentNumber;
};

proto.setCanCopy = function (value) {
  var me = this,
      el = me.el;
  el.dataset.canCopy = value;
};

proto.canCopy = function () {
  var me = this,
      el = me.el;
  return el.dataset.canCopy;
};

proto.hasClass = function (cssClass) {
  var me = this,
      el = me.el;

  return el.classList.contains(cssClass);
};

proto.addClass = function (cssClass) {
  var me = this,
      el = me.el;

  el.classList.add(cssClass);
};

proto.removeClass = function (cssClass) {
  var me = this,
      el = me.el;
  el.classList.remove(cssClass);
};

proto.forEachChild = function (callback) {
  var me = this,
      walker = me.firstChild();

  while (!walker.isNull()) {
    callback(walker);

    walker = walker.next();
  }
};
module.exports = NodeWalker;
},{"../Tmpl":21}],36:[function(require,module,exports){
/* File: SelectionContext.js */
/* jshint undef: true, unused: true */
/* globals require, module */
'use strict';

var TextNodeType = 3;
var ElementNodeType = 1;

var SelectionContext = function () {
  var me = this;

  me.selection = document.getSelection();
  me.range = me.selection.getRangeAt(0);

  me.commonAncestorContainer = me.range.commonAncestorContainer;
  me.startContainer = me.range.startContainer;
  me.startOffset = me.range.startOffset;
  me.endContainer = me.range.endContainer;
  me.endOffset = me.range.endOffset;

  me.focusNode = me.selection.focusNode;
  me.focusOffset = me.selection.focusOffset;
  me.focusNodeParents = [];

  me.hasFocusNodeParent = me.focusNode !== null && me.focusNode.parentNode !== null;
  if (me.hasFocusNodeParent) {
    me.focusNodeParent = me.focusNode.parentNode;
  }

  me.isFocusTextNode = me.focusNode.nodeType === TextNodeType;
  me.isStartContainerTextNode = me.startContainer.nodeType === TextNodeType;
  me.isEndContainerTextNode = me.endContainer.nodeType === TextNodeType;
};

var proto = SelectionContext.prototype;

proto.isCollapsed = function () {
  var me = this;
  return me.range.collapsed;
};

proto.cloneContents = function () {
  var me = this;
  return me.range.cloneContents();
};

proto.deleteContents = function () {
  var me = this;

  me.range.deleteContents();
};

proto.insertNode = function (node) {
  var me = this;

  me.range.insertNode(node);
};

proto.hasCommonAncestorClass = function (className) {
  var me = this,
      commonAncestorContainer = me.commonAncestorContainer,
      result;

  if (commonAncestorContainer.nodeType === 3 || commonAncestorContainer === null) {
    return;
  }

  result = commonAncestorContainer.classList.contains(className);
  return result;
};

proto.changeRange = function (changeCallback) {
  var me = this,
    selection = me.selection,
    newRange = document.createRange();

  if (!changeCallback) {
    return;
  }

  if(!changeCallback(newRange)){
    return;
  }

  selection.removeAllRanges();
  selection.addRange(newRange);
};

module.exports = SelectionContext;
},{}],37:[function(require,module,exports){
/* File: MouseCtrlClickHandler_test.js */
/* jshint undef: true, unused: true */
'use strict';
var NodeWalker = require('./NodeWalker');

var proto;
/*
 * Creates a tag pair formed of start-tag,
 * end-tag, inner-content.
 * @param {HTMLNode} el - can be any start-tag, inline-content,
 * or end-tag
 */
function TagPair(el) {
  if (el instanceof NodeWalker) {
    el = el.el;
  }
  this.el = el;
  this.walker = new NodeWalker(el);

  this.valid = (!this.walker.isPlaceholder()) && (this.walker.isTag() || this.walker.isTagPairContainer());

  if (this.walker.isStartTag()) {
    this.processFromStartTag();
  } else if (this.walker.isTagPairContainer()) {
    this.processFromTagPairContainer();
  } else if (this.walker.isEndTag()) {
    this.processFromEndTag();
  }
}
proto = TagPair.prototype;
/*
 * @returns {boolean}
 */
proto.isValid = function () {
  return this.valid;
};

proto.processFromStartTag = function () {
  this.startTagEl = this.walker.el;
  this.walker = this.walker.next();
  this.inlineContentEl = this.walker.el;
  this.walker = this.walker.next();
  this.endTagEl = this.walker.el;
};

proto.processFromTagPairContainer = function () {
  this.walker = this.walker.prev();
  this.processFromStartTag();
};

proto.processFromEndTag = function () {
  this.walker = this.walker.prev();
  this.processFromTagPairContainer();
};
/*
 * clones the Tag Pair structure
 * @returns {DocumentFragment} documentFragment
 */
proto.cloneStructure = function () {
  var me = this,
      startTagClone,
      inlineContentClone,
      endTagClone,
      documentFragment = document.createDocumentFragment();

  startTagClone = me.startTagEl.cloneNode(true);
  inlineContentClone = me.inlineContentEl.cloneNode(false);
  endTagClone = me.endTagEl.cloneNode(true);

  documentFragment.appendChild(startTagClone);
  documentFragment.appendChild(inlineContentClone);
  documentFragment.appendChild(endTagClone);

  return documentFragment;
};

proto.toArray = function () {
  return [
    this.startTagEl,
    this.inlineContentEl,
    this.endTagEl
  ];
};

module.exports = TagPair;

},{"./NodeWalker":35}],38:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":39,"ieee754":40}],39:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],40:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],41:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],42:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],43:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],44:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],45:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("d:\\xampp\\htdocs\\universal-editor-web\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\process\\browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":44,"d:\\xampp\\htdocs\\universal-editor-web\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\process\\browser.js":43,"inherits":42}],46:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":47}],47:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '1.9.1';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":48,"./chai/config":49,"./chai/core/assertions":50,"./chai/interface/assert":51,"./chai/interface/expect":52,"./chai/interface/should":53,"./chai/utils":64,"assertion-error":73}],48:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String} message to display if fails
   * @param {String} negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":49}],49:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded,
   * the value is truncated.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],50:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val)
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , value = flag(this, 'deep')
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate && undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength, assertLengthChain);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('match', function (re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, 'negate') && !flag(this, 'contains')) {
      ok = ok && keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(', ') + ', and ' + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'object' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('respondTo', function (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('satisfy', function (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        matcher(obj)
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , matcher(obj)
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });
};

},{}],51:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
      throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('Throw', 'throw')
  ('Throw', 'throws');
};

},{}],52:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


},{}],53:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number) {
        return new Assertion(this.constructor(this), null, shouldGetter);
      } else if (this instanceof Boolean) {
        return new Assertion(this == true, null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],54:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":49,"./flag":57,"./transferFlags":71}],55:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":49,"./flag":57}],56:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],57:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],58:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],59:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],60:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":57,"./getActual":58,"./inspect":65,"./objDisplay":66}],61:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],62:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, '.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

},{}],63:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],64:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('./type');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":54,"./addMethod":55,"./addProperty":56,"./flag":57,"./getActual":58,"./getMessage":60,"./getName":61,"./getPathValue":62,"./inspect":65,"./objDisplay":66,"./overwriteChainableMethod":67,"./overwriteMethod":68,"./overwriteProperty":69,"./test":70,"./transferFlags":71,"./type":72,"deep-eql":74}],65:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// https://gist.github.com/1044128/
var getOuterHTML = function(element) {
  if ('outerHTML' in element) return element.outerHTML;
  var ns = "http://www.w3.org/1999/xhtml";
  var container = document.createElementNS(ns, '_');
  var elemProto = (window.HTMLElement || window.Element).prototype;
  var xmlSerializer = new XMLSerializer();
  var html;
  if (document.xmlVersion) {
    return xmlSerializer.serializeToString(element);
  } else {
    container.appendChild(element.cloneNode(false));
    html = container.innerHTML.replace('><', '>' + element.innerHTML + '<');
    container.innerHTML = '';
    return html;
  }
};

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If it's DOM elem, get outer HTML.
  if (isDOMElement(value)) {
    return getOuterHTML(value);
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":59,"./getName":61,"./getProperties":63}],66:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":49,"./inspect":65}],67:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],68:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],69:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],70:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":57}],71:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],72:[function(require,module,exports){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Arguments]': 'arguments'
  , '[object Array]': 'array'
  , '[object Date]': 'date'
  , '[object Function]': 'function'
  , '[object Number]': 'number'
  , '[object RegExp]': 'regexp'
  , '[object String]': 'string'
};

/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
};

},{}],73:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],74:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":75}],75:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":38,"type-detect":76}],76:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":77}],77:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],78:[function(require,module,exports){
/*jslint eqeqeq: false, onevar: false, forin: true, nomen: false, regexp: false, plusplus: false*/
/*global module, require, __dirname, document*/
/**
 * Sinon core utilities. For internal use only.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

var sinon = (function (formatio) {
    var div = typeof document != "undefined" && document.createElement("div");
    var hasOwn = Object.prototype.hasOwnProperty;

    function isDOMNode(obj) {
        var success = false;

        try {
            obj.appendChild(div);
            success = div.parentNode == obj;
        } catch (e) {
            return false;
        } finally {
            try {
                obj.removeChild(div);
            } catch (e) {
                // Remove failed, not much we can do about that
            }
        }

        return success;
    }

    function isElement(obj) {
        return div && obj && obj.nodeType === 1 && isDOMNode(obj);
    }

    function isFunction(obj) {
        return typeof obj === "function" || !!(obj && obj.constructor && obj.call && obj.apply);
    }

    function isReallyNaN(val) {
        return typeof val === 'number' && isNaN(val);
    }

    function mirrorProperties(target, source) {
        for (var prop in source) {
            if (!hasOwn.call(target, prop)) {
                target[prop] = source[prop];
            }
        }
    }

    function isRestorable (obj) {
        return typeof obj === "function" && typeof obj.restore === "function" && obj.restore.sinon;
    }

    var sinon = {
        wrapMethod: function wrapMethod(object, property, method) {
            if (!object) {
                throw new TypeError("Should wrap property of object");
            }

            if (typeof method != "function") {
                throw new TypeError("Method wrapper should be function");
            }

            var wrappedMethod = object[property],
                error;

            if (!isFunction(wrappedMethod)) {
                error = new TypeError("Attempted to wrap " + (typeof wrappedMethod) + " property " +
                                    property + " as function");
            }

            if (wrappedMethod.restore && wrappedMethod.restore.sinon) {
                error = new TypeError("Attempted to wrap " + property + " which is already wrapped");
            }

            if (wrappedMethod.calledBefore) {
                var verb = !!wrappedMethod.returns ? "stubbed" : "spied on";
                error = new TypeError("Attempted to wrap " + property + " which is already " + verb);
            }

            if (error) {
                if (wrappedMethod._stack) {
                    error.stack += '\n--------------\n' + wrappedMethod._stack;
                }
                throw error;
            }

            // IE 8 does not support hasOwnProperty on the window object and Firefox has a problem
            // when using hasOwn.call on objects from other frames.
            var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);
            object[property] = method;
            method.displayName = property;
            // Set up a stack trace which can be used later to find what line of
            // code the original method was created on.
            method._stack = (new Error('Stack Trace for original')).stack;

            method.restore = function () {
                // For prototype properties try to reset by delete first.
                // If this fails (ex: localStorage on mobile safari) then force a reset
                // via direct assignment.
                if (!owned) {
                    delete object[property];
                }
                if (object[property] === method) {
                    object[property] = wrappedMethod;
                }
            };

            method.restore.sinon = true;
            mirrorProperties(method, wrappedMethod);

            return method;
        },

        extend: function extend(target) {
            for (var i = 1, l = arguments.length; i < l; i += 1) {
                for (var prop in arguments[i]) {
                    if (arguments[i].hasOwnProperty(prop)) {
                        target[prop] = arguments[i][prop];
                    }

                    // DONT ENUM bug, only care about toString
                    if (arguments[i].hasOwnProperty("toString") &&
                        arguments[i].toString != target.toString) {
                        target.toString = arguments[i].toString;
                    }
                }
            }

            return target;
        },

        create: function create(proto) {
            var F = function () {};
            F.prototype = proto;
            return new F();
        },

        deepEqual: function deepEqual(a, b) {
            if (sinon.match && sinon.match.isMatcher(a)) {
                return a.test(b);
            }

            if (typeof a != 'object' || typeof b != 'object') {
                if (isReallyNaN(a) && isReallyNaN(b)) {
                    return true;
                } else {
                    return a === b;
                }
            }

            if (isElement(a) || isElement(b)) {
                return a === b;
            }

            if (a === b) {
                return true;
            }

            if ((a === null && b !== null) || (a !== null && b === null)) {
                return false;
            }

            if (a instanceof RegExp && b instanceof RegExp) {
              return (a.source === b.source) && (a.global === b.global) &&
                (a.ignoreCase === b.ignoreCase) && (a.multiline === b.multiline);
            }

            var aString = Object.prototype.toString.call(a);
            if (aString != Object.prototype.toString.call(b)) {
                return false;
            }

            if (aString == "[object Date]") {
                return a.valueOf() === b.valueOf();
            }

            var prop, aLength = 0, bLength = 0;

            if (aString == "[object Array]" && a.length !== b.length) {
                return false;
            }

            for (prop in a) {
                aLength += 1;

                if (!deepEqual(a[prop], b[prop])) {
                    return false;
                }
            }

            for (prop in b) {
                bLength += 1;
            }

            return aLength == bLength;
        },

        functionName: function functionName(func) {
            var name = func.displayName || func.name;

            // Use function decomposition as a last resort to get function
            // name. Does not rely on function decomposition to work - if it
            // doesn't debugging will be slightly less informative
            // (i.e. toString will say 'spy' rather than 'myFunc').
            if (!name) {
                var matches = func.toString().match(/function ([^\s\(]+)/);
                name = matches && matches[1];
            }

            return name;
        },

        functionToString: function toString() {
            if (this.getCall && this.callCount) {
                var thisValue, prop, i = this.callCount;

                while (i--) {
                    thisValue = this.getCall(i).thisValue;

                    for (prop in thisValue) {
                        if (thisValue[prop] === this) {
                            return prop;
                        }
                    }
                }
            }

            return this.displayName || "sinon fake";
        },

        getConfig: function (custom) {
            var config = {};
            custom = custom || {};
            var defaults = sinon.defaultConfig;

            for (var prop in defaults) {
                if (defaults.hasOwnProperty(prop)) {
                    config[prop] = custom.hasOwnProperty(prop) ? custom[prop] : defaults[prop];
                }
            }

            return config;
        },

        format: function (val) {
            return "" + val;
        },

        defaultConfig: {
            injectIntoThis: true,
            injectInto: null,
            properties: ["spy", "stub", "mock", "clock", "server", "requests"],
            useFakeTimers: true,
            useFakeServer: true
        },

        timesInWords: function timesInWords(count) {
            return count == 1 && "once" ||
                count == 2 && "twice" ||
                count == 3 && "thrice" ||
                (count || 0) + " times";
        },

        calledInOrder: function (spies) {
            for (var i = 1, l = spies.length; i < l; i++) {
                if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {
                    return false;
                }
            }

            return true;
        },

        orderByFirstCall: function (spies) {
            return spies.sort(function (a, b) {
                // uuid, won't ever be equal
                var aCall = a.getCall(0);
                var bCall = b.getCall(0);
                var aId = aCall && aCall.callId || -1;
                var bId = bCall && bCall.callId || -1;

                return aId < bId ? -1 : 1;
            });
        },

        log: function () {},

        logError: function (label, err) {
            var msg = label + " threw exception: ";
            sinon.log(msg + "[" + err.name + "] " + err.message);
            if (err.stack) { sinon.log(err.stack); }

            setTimeout(function () {
                err.message = msg + err.message;
                throw err;
            }, 0);
        },

        typeOf: function (value) {
            if (value === null) {
                return "null";
            }
            else if (value === undefined) {
                return "undefined";
            }
            var string = Object.prototype.toString.call(value);
            return string.substring(8, string.length - 1).toLowerCase();
        },

        createStubInstance: function (constructor) {
            if (typeof constructor !== "function") {
                throw new TypeError("The constructor should be a function.");
            }
            return sinon.stub(sinon.create(constructor.prototype));
        },

        restore: function (object) {
            if (object !== null && typeof object === "object") {
                for (var prop in object) {
                    if (isRestorable(object[prop])) {
                        object[prop].restore();
                    }
                }
            }
            else if (isRestorable(object)) {
                object.restore();
            }
        }
    };

    var isNode = typeof module !== "undefined" && module.exports;
    var isAMD = typeof define === 'function' && typeof define.amd === 'object' && define.amd;

    if (isAMD) {
        define(function(){
            return sinon;
        });
    } else if (isNode) {
        try {
            formatio = require("formatio");
        } catch (e) {}
        module.exports = sinon;
        module.exports.spy = require("./sinon/spy");
        module.exports.spyCall = require("./sinon/call");
        module.exports.behavior = require("./sinon/behavior");
        module.exports.stub = require("./sinon/stub");
        module.exports.mock = require("./sinon/mock");
        module.exports.collection = require("./sinon/collection");
        module.exports.assert = require("./sinon/assert");
        module.exports.sandbox = require("./sinon/sandbox");
        module.exports.test = require("./sinon/test");
        module.exports.testCase = require("./sinon/test_case");
        module.exports.assert = require("./sinon/assert");
        module.exports.match = require("./sinon/match");
    }

    if (formatio) {
        var formatter = formatio.configure({ quoteStrings: false });
        sinon.format = function () {
            return formatter.ascii.apply(formatter, arguments);
        };
    } else if (isNode) {
        try {
            var util = require("util");
            sinon.format = function (value) {
                return typeof value == "object" && value.toString === Object.prototype.toString ? util.inspect(value) : value;
            };
        } catch (e) {
            /* Node, but no util module - would be very old, but better safe than
             sorry */
        }
    }

    return sinon;
}(typeof formatio == "object" && formatio));

},{"./sinon/assert":79,"./sinon/behavior":80,"./sinon/call":81,"./sinon/collection":82,"./sinon/match":83,"./sinon/mock":84,"./sinon/sandbox":85,"./sinon/spy":86,"./sinon/stub":87,"./sinon/test":88,"./sinon/test_case":89,"formatio":91,"util":45}],79:[function(require,module,exports){
(function (global){
/**
 * @depend ../sinon.js
 * @depend stub.js
 */
/*jslint eqeqeq: false, onevar: false, nomen: false, plusplus: false*/
/*global module, require, sinon*/
/**
 * Assertions matching the test spy retrieval interface.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

(function (sinon, global) {
    var commonJSModule = typeof module !== "undefined" && module.exports;
    var slice = Array.prototype.slice;
    var assert;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    function verifyIsStub() {
        var method;

        for (var i = 0, l = arguments.length; i < l; ++i) {
            method = arguments[i];

            if (!method) {
                assert.fail("fake is not a spy");
            }

            if (typeof method != "function") {
                assert.fail(method + " is not a function");
            }

            if (typeof method.getCall != "function") {
                assert.fail(method + " is not stubbed");
            }
        }
    }

    function failAssertion(object, msg) {
        object = object || global;
        var failMethod = object.fail || assert.fail;
        failMethod.call(object, msg);
    }

    function mirrorPropAsAssertion(name, method, message) {
        if (arguments.length == 2) {
            message = method;
            method = name;
        }

        assert[name] = function (fake) {
            verifyIsStub(fake);

            var args = slice.call(arguments, 1);
            var failed = false;

            if (typeof method == "function") {
                failed = !method(fake);
            } else {
                failed = typeof fake[method] == "function" ?
                    !fake[method].apply(fake, args) : !fake[method];
            }

            if (failed) {
                failAssertion(this, fake.printf.apply(fake, [message].concat(args)));
            } else {
                assert.pass(name);
            }
        };
    }

    function exposedName(prefix, prop) {
        return !prefix || /^fail/.test(prop) ? prop :
            prefix + prop.slice(0, 1).toUpperCase() + prop.slice(1);
    }

    assert = {
        failException: "AssertError",

        fail: function fail(message) {
            var error = new Error(message);
            error.name = this.failException || assert.failException;

            throw error;
        },

        pass: function pass(assertion) {},

        callOrder: function assertCallOrder() {
            verifyIsStub.apply(null, arguments);
            var expected = "", actual = "";

            if (!sinon.calledInOrder(arguments)) {
                try {
                    expected = [].join.call(arguments, ", ");
                    var calls = slice.call(arguments);
                    var i = calls.length;
                    while (i) {
                        if (!calls[--i].called) {
                            calls.splice(i, 1);
                        }
                    }
                    actual = sinon.orderByFirstCall(calls).join(", ");
                } catch (e) {
                    // If this fails, we'll just fall back to the blank string
                }

                failAssertion(this, "expected " + expected + " to be " +
                              "called in order but were called as " + actual);
            } else {
                assert.pass("callOrder");
            }
        },

        callCount: function assertCallCount(method, count) {
            verifyIsStub(method);

            if (method.callCount != count) {
                var msg = "expected %n to be called " + sinon.timesInWords(count) +
                    " but was called %c%C";
                failAssertion(this, method.printf(msg));
            } else {
                assert.pass("callCount");
            }
        },

        expose: function expose(target, options) {
            if (!target) {
                throw new TypeError("target is null or undefined");
            }

            var o = options || {};
            var prefix = typeof o.prefix == "undefined" && "assert" || o.prefix;
            var includeFail = typeof o.includeFail == "undefined" || !!o.includeFail;

            for (var method in this) {
                if (method != "export" && (includeFail || !/^(fail)/.test(method))) {
                    target[exposedName(prefix, method)] = this[method];
                }
            }

            return target;
        },

        match: function match(actual, expectation) {
            var matcher = sinon.match(expectation);
            if (matcher.test(actual)) {
                assert.pass("match");
            } else {
                var formatted = [
                    "expected value to match",
                    "    expected = " + sinon.format(expectation),
                    "    actual = " + sinon.format(actual)
                ]
                failAssertion(this, formatted.join("\n"));
            }
        }
    };

    mirrorPropAsAssertion("called", "expected %n to have been called at least once but was never called");
    mirrorPropAsAssertion("notCalled", function (spy) { return !spy.called; },
                          "expected %n to not have been called but was called %c%C");
    mirrorPropAsAssertion("calledOnce", "expected %n to be called once but was called %c%C");
    mirrorPropAsAssertion("calledTwice", "expected %n to be called twice but was called %c%C");
    mirrorPropAsAssertion("calledThrice", "expected %n to be called thrice but was called %c%C");
    mirrorPropAsAssertion("calledOn", "expected %n to be called with %1 as this but was called with %t");
    mirrorPropAsAssertion("alwaysCalledOn", "expected %n to always be called with %1 as this but was called with %t");
    mirrorPropAsAssertion("calledWithNew", "expected %n to be called with new");
    mirrorPropAsAssertion("alwaysCalledWithNew", "expected %n to always be called with new");
    mirrorPropAsAssertion("calledWith", "expected %n to be called with arguments %*%C");
    mirrorPropAsAssertion("calledWithMatch", "expected %n to be called with match %*%C");
    mirrorPropAsAssertion("alwaysCalledWith", "expected %n to always be called with arguments %*%C");
    mirrorPropAsAssertion("alwaysCalledWithMatch", "expected %n to always be called with match %*%C");
    mirrorPropAsAssertion("calledWithExactly", "expected %n to be called with exact arguments %*%C");
    mirrorPropAsAssertion("alwaysCalledWithExactly", "expected %n to always be called with exact arguments %*%C");
    mirrorPropAsAssertion("neverCalledWith", "expected %n to never be called with arguments %*%C");
    mirrorPropAsAssertion("neverCalledWithMatch", "expected %n to never be called with match %*%C");
    mirrorPropAsAssertion("threw", "%n did not throw exception%C");
    mirrorPropAsAssertion("alwaysThrew", "%n did not always throw exception%C");

    if (commonJSModule) {
        module.exports = assert;
    } else {
        sinon.assert = assert;
    }
}(typeof sinon == "object" && sinon || null, typeof window != "undefined" ? window : (typeof self != "undefined") ? self : global));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../sinon":78}],80:[function(require,module,exports){
(function (process){
/**
 * @depend ../sinon.js
 */
/*jslint eqeqeq: false, onevar: false*/
/*global module, require, sinon, process, setImmediate, setTimeout*/
/**
 * Stub behavior
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @author Tim Fischbach (mail@timfischbach.de)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    var slice = Array.prototype.slice;
    var join = Array.prototype.join;
    var proto;

    var nextTick = (function () {
        if (typeof process === "object" && typeof process.nextTick === "function") {
            return process.nextTick;
        } else if (typeof setImmediate === "function") {
            return setImmediate;
        } else {
            return function (callback) {
                setTimeout(callback, 0);
            };
        }
    })();

    function throwsException(error, message) {
        if (typeof error == "string") {
            this.exception = new Error(message || "");
            this.exception.name = error;
        } else if (!error) {
            this.exception = new Error("Error");
        } else {
            this.exception = error;
        }

        return this;
    }

    function getCallback(behavior, args) {
        var callArgAt = behavior.callArgAt;

        if (callArgAt < 0) {
            var callArgProp = behavior.callArgProp;

            for (var i = 0, l = args.length; i < l; ++i) {
                if (!callArgProp && typeof args[i] == "function") {
                    return args[i];
                }

                if (callArgProp && args[i] &&
                    typeof args[i][callArgProp] == "function") {
                    return args[i][callArgProp];
                }
            }

            return null;
        }

        return args[callArgAt];
    }

    function getCallbackError(behavior, func, args) {
        if (behavior.callArgAt < 0) {
            var msg;

            if (behavior.callArgProp) {
                msg = sinon.functionName(behavior.stub) +
                    " expected to yield to '" + behavior.callArgProp +
                    "', but no object with such a property was passed.";
            } else {
                msg = sinon.functionName(behavior.stub) +
                    " expected to yield, but no callback was passed.";
            }

            if (args.length > 0) {
                msg += " Received [" + join.call(args, ", ") + "]";
            }

            return msg;
        }

        return "argument at index " + behavior.callArgAt + " is not a function: " + func;
    }

    function callCallback(behavior, args) {
        if (typeof behavior.callArgAt == "number") {
            var func = getCallback(behavior, args);

            if (typeof func != "function") {
                throw new TypeError(getCallbackError(behavior, func, args));
            }

            if (behavior.callbackAsync) {
                nextTick(function() {
                    func.apply(behavior.callbackContext, behavior.callbackArguments);
                });
            } else {
                func.apply(behavior.callbackContext, behavior.callbackArguments);
            }
        }
    }

    proto = {
        create: function(stub) {
            var behavior = sinon.extend({}, sinon.behavior);
            delete behavior.create;
            behavior.stub = stub;

            return behavior;
        },

        isPresent: function() {
            return (typeof this.callArgAt == 'number' ||
                    this.exception ||
                    typeof this.returnArgAt == 'number' ||
                    this.returnThis ||
                    this.returnValueDefined);
        },

        invoke: function(context, args) {
            callCallback(this, args);

            if (this.exception) {
                throw this.exception;
            } else if (typeof this.returnArgAt == 'number') {
                return args[this.returnArgAt];
            } else if (this.returnThis) {
                return context;
            }

            return this.returnValue;
        },

        onCall: function(index) {
            return this.stub.onCall(index);
        },

        onFirstCall: function() {
            return this.stub.onFirstCall();
        },

        onSecondCall: function() {
            return this.stub.onSecondCall();
        },

        onThirdCall: function() {
            return this.stub.onThirdCall();
        },

        withArgs: function(/* arguments */) {
            throw new Error('Defining a stub by invoking "stub.onCall(...).withArgs(...)" is not supported. ' +
                            'Use "stub.withArgs(...).onCall(...)" to define sequential behavior for calls with certain arguments.');
        },

        callsArg: function callsArg(pos) {
            if (typeof pos != "number") {
                throw new TypeError("argument index is not number");
            }

            this.callArgAt = pos;
            this.callbackArguments = [];
            this.callbackContext = undefined;
            this.callArgProp = undefined;
            this.callbackAsync = false;

            return this;
        },

        callsArgOn: function callsArgOn(pos, context) {
            if (typeof pos != "number") {
                throw new TypeError("argument index is not number");
            }
            if (typeof context != "object") {
                throw new TypeError("argument context is not an object");
            }

            this.callArgAt = pos;
            this.callbackArguments = [];
            this.callbackContext = context;
            this.callArgProp = undefined;
            this.callbackAsync = false;

            return this;
        },

        callsArgWith: function callsArgWith(pos) {
            if (typeof pos != "number") {
                throw new TypeError("argument index is not number");
            }

            this.callArgAt = pos;
            this.callbackArguments = slice.call(arguments, 1);
            this.callbackContext = undefined;
            this.callArgProp = undefined;
            this.callbackAsync = false;

            return this;
        },

        callsArgOnWith: function callsArgWith(pos, context) {
            if (typeof pos != "number") {
                throw new TypeError("argument index is not number");
            }
            if (typeof context != "object") {
                throw new TypeError("argument context is not an object");
            }

            this.callArgAt = pos;
            this.callbackArguments = slice.call(arguments, 2);
            this.callbackContext = context;
            this.callArgProp = undefined;
            this.callbackAsync = false;

            return this;
        },

        yields: function () {
            this.callArgAt = -1;
            this.callbackArguments = slice.call(arguments, 0);
            this.callbackContext = undefined;
            this.callArgProp = undefined;
            this.callbackAsync = false;

            return this;
        },

        yieldsOn: function (context) {
            if (typeof context != "object") {
                throw new TypeError("argument context is not an object");
            }

            this.callArgAt = -1;
            this.callbackArguments = slice.call(arguments, 1);
            this.callbackContext = context;
            this.callArgProp = undefined;
            this.callbackAsync = false;

            return this;
        },

        yieldsTo: function (prop) {
            this.callArgAt = -1;
            this.callbackArguments = slice.call(arguments, 1);
            this.callbackContext = undefined;
            this.callArgProp = prop;
            this.callbackAsync = false;

            return this;
        },

        yieldsToOn: function (prop, context) {
            if (typeof context != "object") {
                throw new TypeError("argument context is not an object");
            }

            this.callArgAt = -1;
            this.callbackArguments = slice.call(arguments, 2);
            this.callbackContext = context;
            this.callArgProp = prop;
            this.callbackAsync = false;

            return this;
        },


        "throws": throwsException,
        throwsException: throwsException,

        returns: function returns(value) {
            this.returnValue = value;
            this.returnValueDefined = true;

            return this;
        },

        returnsArg: function returnsArg(pos) {
            if (typeof pos != "number") {
                throw new TypeError("argument index is not number");
            }

            this.returnArgAt = pos;

            return this;
        },

        returnsThis: function returnsThis() {
            this.returnThis = true;

            return this;
        }
    };

    // create asynchronous versions of callsArg* and yields* methods
    for (var method in proto) {
        // need to avoid creating anotherasync versions of the newly added async methods
        if (proto.hasOwnProperty(method) &&
            method.match(/^(callsArg|yields)/) &&
            !method.match(/Async/)) {
            proto[method + 'Async'] = (function (syncFnName) {
                return function () {
                    var result = this[syncFnName].apply(this, arguments);
                    this.callbackAsync = true;
                    return result;
                };
            })(method);
        }
    }

    if (commonJSModule) {
        module.exports = proto;
    } else {
        sinon.behavior = proto;
    }
}(typeof sinon == "object" && sinon || null));
}).call(this,require("d:\\xampp\\htdocs\\universal-editor-web\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\process\\browser.js"))
},{"../sinon":78,"d:\\xampp\\htdocs\\universal-editor-web\\node_modules\\browserify\\node_modules\\insert-module-globals\\node_modules\\process\\browser.js":43}],81:[function(require,module,exports){
/**
  * @depend ../sinon.js
  * @depend match.js
  */
/*jslint eqeqeq: false, onevar: false, plusplus: false*/
/*global module, require, sinon*/
/**
  * Spy calls
  *
  * @author Christian Johansen (christian@cjohansen.no)
  * @author Maximilian Antoni (mail@maxantoni.de)
  * @license BSD
  *
  * Copyright (c) 2010-2013 Christian Johansen
  * Copyright (c) 2013 Maximilian Antoni
  */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;
    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    function throwYieldError(proxy, text, args) {
        var msg = sinon.functionName(proxy) + text;
        if (args.length) {
            msg += " Received [" + slice.call(args).join(", ") + "]";
        }
        throw new Error(msg);
    }

    var slice = Array.prototype.slice;

    var callProto = {
        calledOn: function calledOn(thisValue) {
            if (sinon.match && sinon.match.isMatcher(thisValue)) {
                return thisValue.test(this.thisValue);
            }
            return this.thisValue === thisValue;
        },

        calledWith: function calledWith() {
            for (var i = 0, l = arguments.length; i < l; i += 1) {
                if (!sinon.deepEqual(arguments[i], this.args[i])) {
                    return false;
                }
            }

            return true;
        },

        calledWithMatch: function calledWithMatch() {
            for (var i = 0, l = arguments.length; i < l; i += 1) {
                var actual = this.args[i];
                var expectation = arguments[i];
                if (!sinon.match || !sinon.match(expectation).test(actual)) {
                    return false;
                }
            }
            return true;
        },

        calledWithExactly: function calledWithExactly() {
            return arguments.length == this.args.length &&
                this.calledWith.apply(this, arguments);
        },

        notCalledWith: function notCalledWith() {
            return !this.calledWith.apply(this, arguments);
        },

        notCalledWithMatch: function notCalledWithMatch() {
            return !this.calledWithMatch.apply(this, arguments);
        },

        returned: function returned(value) {
            return sinon.deepEqual(value, this.returnValue);
        },

        threw: function threw(error) {
            if (typeof error === "undefined" || !this.exception) {
                return !!this.exception;
            }

            return this.exception === error || this.exception.name === error;
        },

        calledWithNew: function calledWithNew() {
            return this.proxy.prototype && this.thisValue instanceof this.proxy;
        },

        calledBefore: function (other) {
            return this.callId < other.callId;
        },

        calledAfter: function (other) {
            return this.callId > other.callId;
        },

        callArg: function (pos) {
            this.args[pos]();
        },

        callArgOn: function (pos, thisValue) {
            this.args[pos].apply(thisValue);
        },

        callArgWith: function (pos) {
            this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));
        },

        callArgOnWith: function (pos, thisValue) {
            var args = slice.call(arguments, 2);
            this.args[pos].apply(thisValue, args);
        },

        "yield": function () {
            this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));
        },

        yieldOn: function (thisValue) {
            var args = this.args;
            for (var i = 0, l = args.length; i < l; ++i) {
                if (typeof args[i] === "function") {
                    args[i].apply(thisValue, slice.call(arguments, 1));
                    return;
                }
            }
            throwYieldError(this.proxy, " cannot yield since no callback was passed.", args);
        },

        yieldTo: function (prop) {
            this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));
        },

        yieldToOn: function (prop, thisValue) {
            var args = this.args;
            for (var i = 0, l = args.length; i < l; ++i) {
                if (args[i] && typeof args[i][prop] === "function") {
                    args[i][prop].apply(thisValue, slice.call(arguments, 2));
                    return;
                }
            }
            throwYieldError(this.proxy, " cannot yield to '" + prop +
                "' since no callback was passed.", args);
        },

        toString: function () {
            var callStr = this.proxy.toString() + "(";
            var args = [];

            for (var i = 0, l = this.args.length; i < l; ++i) {
                args.push(sinon.format(this.args[i]));
            }

            callStr = callStr + args.join(", ") + ")";

            if (typeof this.returnValue != "undefined") {
                callStr += " => " + sinon.format(this.returnValue);
            }

            if (this.exception) {
                callStr += " !" + this.exception.name;

                if (this.exception.message) {
                    callStr += "(" + this.exception.message + ")";
                }
            }

            return callStr;
        }
    };

    callProto.invokeCallback = callProto.yield;

    function createSpyCall(spy, thisValue, args, returnValue, exception, id) {
        if (typeof id !== "number") {
            throw new TypeError("Call id is not a number");
        }
        var proxyCall = sinon.create(callProto);
        proxyCall.proxy = spy;
        proxyCall.thisValue = thisValue;
        proxyCall.args = args;
        proxyCall.returnValue = returnValue;
        proxyCall.exception = exception;
        proxyCall.callId = id;

        return proxyCall;
    }
    createSpyCall.toString = callProto.toString; // used by mocks

    if (commonJSModule) {
        module.exports = createSpyCall;
    } else {
        sinon.spyCall = createSpyCall;
    }
}(typeof sinon == "object" && sinon || null));


},{"../sinon":78}],82:[function(require,module,exports){
/**
 * @depend ../sinon.js
 * @depend stub.js
 * @depend mock.js
 */
/*jslint eqeqeq: false, onevar: false, forin: true*/
/*global module, require, sinon*/
/**
 * Collections of stubs, spies and mocks.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;
    var push = [].push;
    var hasOwnProperty = Object.prototype.hasOwnProperty;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    function getFakes(fakeCollection) {
        if (!fakeCollection.fakes) {
            fakeCollection.fakes = [];
        }

        return fakeCollection.fakes;
    }

    function each(fakeCollection, method) {
        var fakes = getFakes(fakeCollection);

        for (var i = 0, l = fakes.length; i < l; i += 1) {
            if (typeof fakes[i][method] == "function") {
                fakes[i][method]();
            }
        }
    }

    function compact(fakeCollection) {
        var fakes = getFakes(fakeCollection);
        var i = 0;
        while (i < fakes.length) {
          fakes.splice(i, 1);
        }
    }

    var collection = {
        verify: function resolve() {
            each(this, "verify");
        },

        restore: function restore() {
            each(this, "restore");
            compact(this);
        },

        verifyAndRestore: function verifyAndRestore() {
            var exception;

            try {
                this.verify();
            } catch (e) {
                exception = e;
            }

            this.restore();

            if (exception) {
                throw exception;
            }
        },

        add: function add(fake) {
            push.call(getFakes(this), fake);
            return fake;
        },

        spy: function spy() {
            return this.add(sinon.spy.apply(sinon, arguments));
        },

        stub: function stub(object, property, value) {
            if (property) {
                var original = object[property];

                if (typeof original != "function") {
                    if (!hasOwnProperty.call(object, property)) {
                        throw new TypeError("Cannot stub non-existent own property " + property);
                    }

                    object[property] = value;

                    return this.add({
                        restore: function () {
                            object[property] = original;
                        }
                    });
                }
            }
            if (!property && !!object && typeof object == "object") {
                var stubbedObj = sinon.stub.apply(sinon, arguments);

                for (var prop in stubbedObj) {
                    if (typeof stubbedObj[prop] === "function") {
                        this.add(stubbedObj[prop]);
                    }
                }

                return stubbedObj;
            }

            return this.add(sinon.stub.apply(sinon, arguments));
        },

        mock: function mock() {
            return this.add(sinon.mock.apply(sinon, arguments));
        },

        inject: function inject(obj) {
            var col = this;

            obj.spy = function () {
                return col.spy.apply(col, arguments);
            };

            obj.stub = function () {
                return col.stub.apply(col, arguments);
            };

            obj.mock = function () {
                return col.mock.apply(col, arguments);
            };

            return obj;
        }
    };

    if (commonJSModule) {
        module.exports = collection;
    } else {
        sinon.collection = collection;
    }
}(typeof sinon == "object" && sinon || null));

},{"../sinon":78}],83:[function(require,module,exports){
/* @depend ../sinon.js */
/*jslint eqeqeq: false, onevar: false, plusplus: false*/
/*global module, require, sinon*/
/**
 * Match functions
 *
 * @author Maximilian Antoni (mail@maxantoni.de)
 * @license BSD
 *
 * Copyright (c) 2012 Maximilian Antoni
 */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    function assertType(value, type, name) {
        var actual = sinon.typeOf(value);
        if (actual !== type) {
            throw new TypeError("Expected type of " + name + " to be " +
                type + ", but was " + actual);
        }
    }

    var matcher = {
        toString: function () {
            return this.message;
        }
    };

    function isMatcher(object) {
        return matcher.isPrototypeOf(object);
    }

    function matchObject(expectation, actual) {
        if (actual === null || actual === undefined) {
            return false;
        }
        for (var key in expectation) {
            if (expectation.hasOwnProperty(key)) {
                var exp = expectation[key];
                var act = actual[key];
                if (match.isMatcher(exp)) {
                    if (!exp.test(act)) {
                        return false;
                    }
                } else if (sinon.typeOf(exp) === "object") {
                    if (!matchObject(exp, act)) {
                        return false;
                    }
                } else if (!sinon.deepEqual(exp, act)) {
                    return false;
                }
            }
        }
        return true;
    }

    matcher.or = function (m2) {
        if (!arguments.length) {
            throw new TypeError("Matcher expected");
        } else if (!isMatcher(m2)) {
            m2 = match(m2);
        }
        var m1 = this;
        var or = sinon.create(matcher);
        or.test = function (actual) {
            return m1.test(actual) || m2.test(actual);
        };
        or.message = m1.message + ".or(" + m2.message + ")";
        return or;
    };

    matcher.and = function (m2) {
        if (!arguments.length) {
            throw new TypeError("Matcher expected");
        } else if (!isMatcher(m2)) {
            m2 = match(m2);
        }
        var m1 = this;
        var and = sinon.create(matcher);
        and.test = function (actual) {
            return m1.test(actual) && m2.test(actual);
        };
        and.message = m1.message + ".and(" + m2.message + ")";
        return and;
    };

    var match = function (expectation, message) {
        var m = sinon.create(matcher);
        var type = sinon.typeOf(expectation);
        switch (type) {
        case "object":
            if (typeof expectation.test === "function") {
                m.test = function (actual) {
                    return expectation.test(actual) === true;
                };
                m.message = "match(" + sinon.functionName(expectation.test) + ")";
                return m;
            }
            var str = [];
            for (var key in expectation) {
                if (expectation.hasOwnProperty(key)) {
                    str.push(key + ": " + expectation[key]);
                }
            }
            m.test = function (actual) {
                return matchObject(expectation, actual);
            };
            m.message = "match(" + str.join(", ") + ")";
            break;
        case "number":
            m.test = function (actual) {
                return expectation == actual;
            };
            break;
        case "string":
            m.test = function (actual) {
                if (typeof actual !== "string") {
                    return false;
                }
                return actual.indexOf(expectation) !== -1;
            };
            m.message = "match(\"" + expectation + "\")";
            break;
        case "regexp":
            m.test = function (actual) {
                if (typeof actual !== "string") {
                    return false;
                }
                return expectation.test(actual);
            };
            break;
        case "function":
            m.test = expectation;
            if (message) {
                m.message = message;
            } else {
                m.message = "match(" + sinon.functionName(expectation) + ")";
            }
            break;
        default:
            m.test = function (actual) {
              return sinon.deepEqual(expectation, actual);
            };
        }
        if (!m.message) {
            m.message = "match(" + expectation + ")";
        }
        return m;
    };

    match.isMatcher = isMatcher;

    match.any = match(function () {
        return true;
    }, "any");

    match.defined = match(function (actual) {
        return actual !== null && actual !== undefined;
    }, "defined");

    match.truthy = match(function (actual) {
        return !!actual;
    }, "truthy");

    match.falsy = match(function (actual) {
        return !actual;
    }, "falsy");

    match.same = function (expectation) {
        return match(function (actual) {
            return expectation === actual;
        }, "same(" + expectation + ")");
    };

    match.typeOf = function (type) {
        assertType(type, "string", "type");
        return match(function (actual) {
            return sinon.typeOf(actual) === type;
        }, "typeOf(\"" + type + "\")");
    };

    match.instanceOf = function (type) {
        assertType(type, "function", "type");
        return match(function (actual) {
            return actual instanceof type;
        }, "instanceOf(" + sinon.functionName(type) + ")");
    };

    function createPropertyMatcher(propertyTest, messagePrefix) {
        return function (property, value) {
            assertType(property, "string", "property");
            var onlyProperty = arguments.length === 1;
            var message = messagePrefix + "(\"" + property + "\"";
            if (!onlyProperty) {
                message += ", " + value;
            }
            message += ")";
            return match(function (actual) {
                if (actual === undefined || actual === null ||
                        !propertyTest(actual, property)) {
                    return false;
                }
                return onlyProperty || sinon.deepEqual(value, actual[property]);
            }, message);
        };
    }

    match.has = createPropertyMatcher(function (actual, property) {
        if (typeof actual === "object") {
            return property in actual;
        }
        return actual[property] !== undefined;
    }, "has");

    match.hasOwn = createPropertyMatcher(function (actual, property) {
        return actual.hasOwnProperty(property);
    }, "hasOwn");

    match.bool = match.typeOf("boolean");
    match.number = match.typeOf("number");
    match.string = match.typeOf("string");
    match.object = match.typeOf("object");
    match.func = match.typeOf("function");
    match.array = match.typeOf("array");
    match.regexp = match.typeOf("regexp");
    match.date = match.typeOf("date");

    if (commonJSModule) {
        module.exports = match;
    } else {
        sinon.match = match;
    }
}(typeof sinon == "object" && sinon || null));

},{"../sinon":78}],84:[function(require,module,exports){
/**
 * @depend ../sinon.js
 * @depend stub.js
 */
/*jslint eqeqeq: false, onevar: false, nomen: false*/
/*global module, require, sinon*/
/**
 * Mock functions.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;
    var push = [].push;
    var match;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    match = sinon.match;

    if (!match && commonJSModule) {
        match = require("./match");
    }

    function mock(object) {
        if (!object) {
            return sinon.expectation.create("Anonymous mock");
        }

        return mock.create(object);
    }

    sinon.mock = mock;

    sinon.extend(mock, (function () {
        function each(collection, callback) {
            if (!collection) {
                return;
            }

            for (var i = 0, l = collection.length; i < l; i += 1) {
                callback(collection[i]);
            }
        }

        return {
            create: function create(object) {
                if (!object) {
                    throw new TypeError("object is null");
                }

                var mockObject = sinon.extend({}, mock);
                mockObject.object = object;
                delete mockObject.create;

                return mockObject;
            },

            expects: function expects(method) {
                if (!method) {
                    throw new TypeError("method is falsy");
                }

                if (!this.expectations) {
                    this.expectations = {};
                    this.proxies = [];
                }

                if (!this.expectations[method]) {
                    this.expectations[method] = [];
                    var mockObject = this;

                    sinon.wrapMethod(this.object, method, function () {
                        return mockObject.invokeMethod(method, this, arguments);
                    });

                    push.call(this.proxies, method);
                }

                var expectation = sinon.expectation.create(method);
                push.call(this.expectations[method], expectation);

                return expectation;
            },

            restore: function restore() {
                var object = this.object;

                each(this.proxies, function (proxy) {
                    if (typeof object[proxy].restore == "function") {
                        object[proxy].restore();
                    }
                });
            },

            verify: function verify() {
                var expectations = this.expectations || {};
                var messages = [], met = [];

                each(this.proxies, function (proxy) {
                    each(expectations[proxy], function (expectation) {
                        if (!expectation.met()) {
                            push.call(messages, expectation.toString());
                        } else {
                            push.call(met, expectation.toString());
                        }
                    });
                });

                this.restore();

                if (messages.length > 0) {
                    sinon.expectation.fail(messages.concat(met).join("\n"));
                } else {
                    sinon.expectation.pass(messages.concat(met).join("\n"));
                }

                return true;
            },

            invokeMethod: function invokeMethod(method, thisValue, args) {
                var expectations = this.expectations && this.expectations[method];
                var length = expectations && expectations.length || 0, i;

                for (i = 0; i < length; i += 1) {
                    if (!expectations[i].met() &&
                        expectations[i].allowsCall(thisValue, args)) {
                        return expectations[i].apply(thisValue, args);
                    }
                }

                var messages = [], available, exhausted = 0;

                for (i = 0; i < length; i += 1) {
                    if (expectations[i].allowsCall(thisValue, args)) {
                        available = available || expectations[i];
                    } else {
                        exhausted += 1;
                    }
                    push.call(messages, "    " + expectations[i].toString());
                }

                if (exhausted === 0) {
                    return available.apply(thisValue, args);
                }

                messages.unshift("Unexpected call: " + sinon.spyCall.toString.call({
                    proxy: method,
                    args: args
                }));

                sinon.expectation.fail(messages.join("\n"));
            }
        };
    }()));

    var times = sinon.timesInWords;

    sinon.expectation = (function () {
        var slice = Array.prototype.slice;
        var _invoke = sinon.spy.invoke;

        function callCountInWords(callCount) {
            if (callCount == 0) {
                return "never called";
            } else {
                return "called " + times(callCount);
            }
        }

        function expectedCallCountInWords(expectation) {
            var min = expectation.minCalls;
            var max = expectation.maxCalls;

            if (typeof min == "number" && typeof max == "number") {
                var str = times(min);

                if (min != max) {
                    str = "at least " + str + " and at most " + times(max);
                }

                return str;
            }

            if (typeof min == "number") {
                return "at least " + times(min);
            }

            return "at most " + times(max);
        }

        function receivedMinCalls(expectation) {
            var hasMinLimit = typeof expectation.minCalls == "number";
            return !hasMinLimit || expectation.callCount >= expectation.minCalls;
        }

        function receivedMaxCalls(expectation) {
            if (typeof expectation.maxCalls != "number") {
                return false;
            }

            return expectation.callCount == expectation.maxCalls;
        }

        function verifyMatcher(possibleMatcher, arg){
            if (match && match.isMatcher(possibleMatcher)) {
                return possibleMatcher.test(arg);
            } else {
                return true;
            }
        }

        return {
            minCalls: 1,
            maxCalls: 1,

            create: function create(methodName) {
                var expectation = sinon.extend(sinon.stub.create(), sinon.expectation);
                delete expectation.create;
                expectation.method = methodName;

                return expectation;
            },

            invoke: function invoke(func, thisValue, args) {
                this.verifyCallAllowed(thisValue, args);

                return _invoke.apply(this, arguments);
            },

            atLeast: function atLeast(num) {
                if (typeof num != "number") {
                    throw new TypeError("'" + num + "' is not number");
                }

                if (!this.limitsSet) {
                    this.maxCalls = null;
                    this.limitsSet = true;
                }

                this.minCalls = num;

                return this;
            },

            atMost: function atMost(num) {
                if (typeof num != "number") {
                    throw new TypeError("'" + num + "' is not number");
                }

                if (!this.limitsSet) {
                    this.minCalls = null;
                    this.limitsSet = true;
                }

                this.maxCalls = num;

                return this;
            },

            never: function never() {
                return this.exactly(0);
            },

            once: function once() {
                return this.exactly(1);
            },

            twice: function twice() {
                return this.exactly(2);
            },

            thrice: function thrice() {
                return this.exactly(3);
            },

            exactly: function exactly(num) {
                if (typeof num != "number") {
                    throw new TypeError("'" + num + "' is not a number");
                }

                this.atLeast(num);
                return this.atMost(num);
            },

            met: function met() {
                return !this.failed && receivedMinCalls(this);
            },

            verifyCallAllowed: function verifyCallAllowed(thisValue, args) {
                if (receivedMaxCalls(this)) {
                    this.failed = true;
                    sinon.expectation.fail(this.method + " already called " + times(this.maxCalls));
                }

                if ("expectedThis" in this && this.expectedThis !== thisValue) {
                    sinon.expectation.fail(this.method + " called with " + thisValue + " as thisValue, expected " +
                        this.expectedThis);
                }

                if (!("expectedArguments" in this)) {
                    return;
                }

                if (!args) {
                    sinon.expectation.fail(this.method + " received no arguments, expected " +
                        sinon.format(this.expectedArguments));
                }

                if (args.length < this.expectedArguments.length) {
                    sinon.expectation.fail(this.method + " received too few arguments (" + sinon.format(args) +
                        "), expected " + sinon.format(this.expectedArguments));
                }

                if (this.expectsExactArgCount &&
                    args.length != this.expectedArguments.length) {
                    sinon.expectation.fail(this.method + " received too many arguments (" + sinon.format(args) +
                        "), expected " + sinon.format(this.expectedArguments));
                }

                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {

                    if (!verifyMatcher(this.expectedArguments[i],args[i])) {
                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +
                            ", didn't match " + this.expectedArguments.toString());
                    }

                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +
                            ", expected " + sinon.format(this.expectedArguments));
                    }
                }
            },

            allowsCall: function allowsCall(thisValue, args) {
                if (this.met() && receivedMaxCalls(this)) {
                    return false;
                }

                if ("expectedThis" in this && this.expectedThis !== thisValue) {
                    return false;
                }

                if (!("expectedArguments" in this)) {
                    return true;
                }

                args = args || [];

                if (args.length < this.expectedArguments.length) {
                    return false;
                }

                if (this.expectsExactArgCount &&
                    args.length != this.expectedArguments.length) {
                    return false;
                }

                for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {
                    if (!verifyMatcher(this.expectedArguments[i],args[i])) {
                        return false;
                    }

                    if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
                        return false;
                    }
                }

                return true;
            },

            withArgs: function withArgs() {
                this.expectedArguments = slice.call(arguments);
                return this;
            },

            withExactArgs: function withExactArgs() {
                this.withArgs.apply(this, arguments);
                this.expectsExactArgCount = true;
                return this;
            },

            on: function on(thisValue) {
                this.expectedThis = thisValue;
                return this;
            },

            toString: function () {
                var args = (this.expectedArguments || []).slice();

                if (!this.expectsExactArgCount) {
                    push.call(args, "[...]");
                }

                var callStr = sinon.spyCall.toString.call({
                    proxy: this.method || "anonymous mock expectation",
                    args: args
                });

                var message = callStr.replace(", [...", "[, ...") + " " +
                    expectedCallCountInWords(this);

                if (this.met()) {
                    return "Expectation met: " + message;
                }

                return "Expected " + message + " (" +
                    callCountInWords(this.callCount) + ")";
            },

            verify: function verify() {
                if (!this.met()) {
                    sinon.expectation.fail(this.toString());
                } else {
                    sinon.expectation.pass(this.toString());
                }

                return true;
            },

            pass: function(message) {
              sinon.assert.pass(message);
            },
            fail: function (message) {
                var exception = new Error(message);
                exception.name = "ExpectationError";

                throw exception;
            }
        };
    }());

    if (commonJSModule) {
        module.exports = mock;
    } else {
        sinon.mock = mock;
    }
}(typeof sinon == "object" && sinon || null));

},{"../sinon":78,"./match":83}],85:[function(require,module,exports){
/**
 * @depend ../sinon.js
 * @depend collection.js
 * @depend util/fake_timers.js
 * @depend util/fake_server_with_clock.js
 */
/*jslint eqeqeq: false, onevar: false, plusplus: false*/
/*global require, module*/
/**
 * Manages fake collections as well as fake utilities such as Sinon's
 * timers and fake XHR implementation in one convenient object.
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

if (typeof module !== 'undefined' && module.exports) {
    var sinon = require("../sinon");
    sinon.extend(sinon, require("./util/fake_timers"));
}

(function () {
    var push = [].push;

    function exposeValue(sandbox, config, key, value) {
        if (!value) {
            return;
        }

        if (config.injectInto && !(key in config.injectInto)) {
            config.injectInto[key] = value;
            sandbox.injectedKeys.push(key);
        } else {
            push.call(sandbox.args, value);
        }
    }

    function prepareSandboxFromConfig(config) {
        var sandbox = sinon.create(sinon.sandbox);

        if (config.useFakeServer) {
            if (typeof config.useFakeServer == "object") {
                sandbox.serverPrototype = config.useFakeServer;
            }

            sandbox.useFakeServer();
        }

        if (config.useFakeTimers) {
            if (typeof config.useFakeTimers == "object") {
                sandbox.useFakeTimers.apply(sandbox, config.useFakeTimers);
            } else {
                sandbox.useFakeTimers();
            }
        }

        return sandbox;
    }

    sinon.sandbox = sinon.extend(sinon.create(sinon.collection), {
        useFakeTimers: function useFakeTimers() {
            this.clock = sinon.useFakeTimers.apply(sinon, arguments);

            return this.add(this.clock);
        },

        serverPrototype: sinon.fakeServer,

        useFakeServer: function useFakeServer() {
            var proto = this.serverPrototype || sinon.fakeServer;

            if (!proto || !proto.create) {
                return null;
            }

            this.server = proto.create();
            return this.add(this.server);
        },

        inject: function (obj) {
            sinon.collection.inject.call(this, obj);

            if (this.clock) {
                obj.clock = this.clock;
            }

            if (this.server) {
                obj.server = this.server;
                obj.requests = this.server.requests;
            }

            return obj;
        },

        restore: function () {
            sinon.collection.restore.apply(this, arguments);
            this.restoreContext();
        },

        restoreContext: function () {
            if (this.injectedKeys) {
                for (var i = 0, j = this.injectedKeys.length; i < j; i++) {
                    delete this.injectInto[this.injectedKeys[i]];
                }
                this.injectedKeys = [];
            }
        },

        create: function (config) {
            if (!config) {
                return sinon.create(sinon.sandbox);
            }

            var sandbox = prepareSandboxFromConfig(config);
            sandbox.args = sandbox.args || [];
            sandbox.injectedKeys = [];
            sandbox.injectInto = config.injectInto;
            var prop, value, exposed = sandbox.inject({});

            if (config.properties) {
                for (var i = 0, l = config.properties.length; i < l; i++) {
                    prop = config.properties[i];
                    value = exposed[prop] || prop == "sandbox" && sandbox;
                    exposeValue(sandbox, config, prop, value);
                }
            } else {
                exposeValue(sandbox, config, "sandbox", value);
            }

            return sandbox;
        }
    });

    sinon.sandbox.useFakeXMLHttpRequest = sinon.sandbox.useFakeServer;

    if (typeof module !== 'undefined' && module.exports) {
        module.exports = sinon.sandbox;
    }
}());

},{"../sinon":78,"./util/fake_timers":90}],86:[function(require,module,exports){
/**
  * @depend ../sinon.js
  * @depend call.js
  */
/*jslint eqeqeq: false, onevar: false, plusplus: false*/
/*global module, require, sinon*/
/**
  * Spy functions
  *
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
  * Copyright (c) 2010-2013 Christian Johansen
  */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;
    var push = Array.prototype.push;
    var slice = Array.prototype.slice;
    var callId = 0;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    function spy(object, property) {
        if (!property && typeof object == "function") {
            return spy.create(object);
        }

        if (!object && !property) {
            return spy.create(function () { });
        }

        var method = object[property];
        return sinon.wrapMethod(object, property, spy.create(method));
    }

    function matchingFake(fakes, args, strict) {
        if (!fakes) {
            return;
        }

        for (var i = 0, l = fakes.length; i < l; i++) {
            if (fakes[i].matches(args, strict)) {
                return fakes[i];
            }
        }
    }

    function incrementCallCount() {
        this.called = true;
        this.callCount += 1;
        this.notCalled = false;
        this.calledOnce = this.callCount == 1;
        this.calledTwice = this.callCount == 2;
        this.calledThrice = this.callCount == 3;
    }

    function createCallProperties() {
        this.firstCall = this.getCall(0);
        this.secondCall = this.getCall(1);
        this.thirdCall = this.getCall(2);
        this.lastCall = this.getCall(this.callCount - 1);
    }

    var vars = "a,b,c,d,e,f,g,h,i,j,k,l";
    function createProxy(func) {
        // Retain the function length:
        var p;
        if (func.length) {
            eval("p = (function proxy(" + vars.substring(0, func.length * 2 - 1) +
                ") { return p.invoke(func, this, slice.call(arguments)); });");
        }
        else {
            p = function proxy() {
                return p.invoke(func, this, slice.call(arguments));
            };
        }
        return p;
    }

    var uuid = 0;

    // Public API
    var spyApi = {
        reset: function () {
            this.called = false;
            this.notCalled = true;
            this.calledOnce = false;
            this.calledTwice = false;
            this.calledThrice = false;
            this.callCount = 0;
            this.firstCall = null;
            this.secondCall = null;
            this.thirdCall = null;
            this.lastCall = null;
            this.args = [];
            this.returnValues = [];
            this.thisValues = [];
            this.exceptions = [];
            this.callIds = [];
            if (this.fakes) {
                for (var i = 0; i < this.fakes.length; i++) {
                    this.fakes[i].reset();
                }
            }
        },

        create: function create(func) {
            var name;

            if (typeof func != "function") {
                func = function () { };
            } else {
                name = sinon.functionName(func);
            }

            var proxy = createProxy(func);

            sinon.extend(proxy, spy);
            delete proxy.create;
            sinon.extend(proxy, func);

            proxy.reset();
            proxy.prototype = func.prototype;
            proxy.displayName = name || "spy";
            proxy.toString = sinon.functionToString;
            proxy._create = sinon.spy.create;
            proxy.id = "spy#" + uuid++;

            return proxy;
        },

        invoke: function invoke(func, thisValue, args) {
            var matching = matchingFake(this.fakes, args);
            var exception, returnValue;

            incrementCallCount.call(this);
            push.call(this.thisValues, thisValue);
            push.call(this.args, args);
            push.call(this.callIds, callId++);

            try {
                if (matching) {
                    returnValue = matching.invoke(func, thisValue, args);
                } else {
                    returnValue = (this.func || func).apply(thisValue, args);
                }

                var thisCall = this.getCall(this.callCount - 1);
                if (thisCall.calledWithNew() && typeof returnValue !== 'object') {
                    returnValue = thisValue;
                }
            } catch (e) {
                exception = e;
            }

            push.call(this.exceptions, exception);
            push.call(this.returnValues, returnValue);

            createCallProperties.call(this);

            if (exception !== undefined) {
                throw exception;
            }

            return returnValue;
        },

        getCall: function getCall(i) {
            if (i < 0 || i >= this.callCount) {
                return null;
            }

            return sinon.spyCall(this, this.thisValues[i], this.args[i],
                                    this.returnValues[i], this.exceptions[i],
                                    this.callIds[i]);
        },

        getCalls: function () {
            var calls = [];
            var i;

            for (i = 0; i < this.callCount; i++) {
                calls.push(this.getCall(i));
            }

            return calls;
        },

        calledBefore: function calledBefore(spyFn) {
            if (!this.called) {
                return false;
            }

            if (!spyFn.called) {
                return true;
            }

            return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];
        },

        calledAfter: function calledAfter(spyFn) {
            if (!this.called || !spyFn.called) {
                return false;
            }

            return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];
        },

        withArgs: function () {
            var args = slice.call(arguments);

            if (this.fakes) {
                var match = matchingFake(this.fakes, args, true);

                if (match) {
                    return match;
                }
            } else {
                this.fakes = [];
            }

            var original = this;
            var fake = this._create();
            fake.matchingAguments = args;
            fake.parent = this;
            push.call(this.fakes, fake);

            fake.withArgs = function () {
                return original.withArgs.apply(original, arguments);
            };

            for (var i = 0; i < this.args.length; i++) {
                if (fake.matches(this.args[i])) {
                    incrementCallCount.call(fake);
                    push.call(fake.thisValues, this.thisValues[i]);
                    push.call(fake.args, this.args[i]);
                    push.call(fake.returnValues, this.returnValues[i]);
                    push.call(fake.exceptions, this.exceptions[i]);
                    push.call(fake.callIds, this.callIds[i]);
                }
            }
            createCallProperties.call(fake);

            return fake;
        },

        matches: function (args, strict) {
            var margs = this.matchingAguments;

            if (margs.length <= args.length &&
                sinon.deepEqual(margs, args.slice(0, margs.length))) {
                return !strict || margs.length == args.length;
            }
        },

        printf: function (format) {
            var spy = this;
            var args = slice.call(arguments, 1);
            var formatter;

            return (format || "").replace(/%(.)/g, function (match, specifyer) {
                formatter = spyApi.formatters[specifyer];

                if (typeof formatter == "function") {
                    return formatter.call(null, spy, args);
                } else if (!isNaN(parseInt(specifyer, 10))) {
                    return sinon.format(args[specifyer - 1]);
                }

                return "%" + specifyer;
            });
        }
    };

    function delegateToCalls(method, matchAny, actual, notCalled) {
        spyApi[method] = function () {
            if (!this.called) {
                if (notCalled) {
                    return notCalled.apply(this, arguments);
                }
                return false;
            }

            var currentCall;
            var matches = 0;

            for (var i = 0, l = this.callCount; i < l; i += 1) {
                currentCall = this.getCall(i);

                if (currentCall[actual || method].apply(currentCall, arguments)) {
                    matches += 1;

                    if (matchAny) {
                        return true;
                    }
                }
            }

            return matches === this.callCount;
        };
    }

    delegateToCalls("calledOn", true);
    delegateToCalls("alwaysCalledOn", false, "calledOn");
    delegateToCalls("calledWith", true);
    delegateToCalls("calledWithMatch", true);
    delegateToCalls("alwaysCalledWith", false, "calledWith");
    delegateToCalls("alwaysCalledWithMatch", false, "calledWithMatch");
    delegateToCalls("calledWithExactly", true);
    delegateToCalls("alwaysCalledWithExactly", false, "calledWithExactly");
    delegateToCalls("neverCalledWith", false, "notCalledWith",
        function () { return true; });
    delegateToCalls("neverCalledWithMatch", false, "notCalledWithMatch",
        function () { return true; });
    delegateToCalls("threw", true);
    delegateToCalls("alwaysThrew", false, "threw");
    delegateToCalls("returned", true);
    delegateToCalls("alwaysReturned", false, "returned");
    delegateToCalls("calledWithNew", true);
    delegateToCalls("alwaysCalledWithNew", false, "calledWithNew");
    delegateToCalls("callArg", false, "callArgWith", function () {
        throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
    });
    spyApi.callArgWith = spyApi.callArg;
    delegateToCalls("callArgOn", false, "callArgOnWith", function () {
        throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
    });
    spyApi.callArgOnWith = spyApi.callArgOn;
    delegateToCalls("yield", false, "yield", function () {
        throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
    });
    // "invokeCallback" is an alias for "yield" since "yield" is invalid in strict mode.
    spyApi.invokeCallback = spyApi.yield;
    delegateToCalls("yieldOn", false, "yieldOn", function () {
        throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
    });
    delegateToCalls("yieldTo", false, "yieldTo", function (property) {
        throw new Error(this.toString() + " cannot yield to '" + property +
            "' since it was not yet invoked.");
    });
    delegateToCalls("yieldToOn", false, "yieldToOn", function (property) {
        throw new Error(this.toString() + " cannot yield to '" + property +
            "' since it was not yet invoked.");
    });

    spyApi.formatters = {
        "c": function (spy) {
            return sinon.timesInWords(spy.callCount);
        },

        "n": function (spy) {
            return spy.toString();
        },

        "C": function (spy) {
            var calls = [];

            for (var i = 0, l = spy.callCount; i < l; ++i) {
                var stringifiedCall = "    " + spy.getCall(i).toString();
                if (/\n/.test(calls[i - 1])) {
                    stringifiedCall = "\n" + stringifiedCall;
                }
                push.call(calls, stringifiedCall);
            }

            return calls.length > 0 ? "\n" + calls.join("\n") : "";
        },

        "t": function (spy) {
            var objects = [];

            for (var i = 0, l = spy.callCount; i < l; ++i) {
                push.call(objects, sinon.format(spy.thisValues[i]));
            }

            return objects.join(", ");
        },

        "*": function (spy, args) {
            var formatted = [];

            for (var i = 0, l = args.length; i < l; ++i) {
                push.call(formatted, sinon.format(args[i]));
            }

            return formatted.join(", ");
        }
    };

    sinon.extend(spy, spyApi);

    spy.spyCall = sinon.spyCall;

    if (commonJSModule) {
        module.exports = spy;
    } else {
        sinon.spy = spy;
    }
}(typeof sinon == "object" && sinon || null));

},{"../sinon":78}],87:[function(require,module,exports){
/**
 * @depend ../sinon.js
 * @depend spy.js
 * @depend behavior.js
 */
/*jslint eqeqeq: false, onevar: false*/
/*global module, require, sinon*/
/**
 * Stub functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    function stub(object, property, func) {
        if (!!func && typeof func != "function") {
            throw new TypeError("Custom stub should be function");
        }

        var wrapper;

        if (func) {
            wrapper = sinon.spy && sinon.spy.create ? sinon.spy.create(func) : func;
        } else {
            wrapper = stub.create();
        }

        if (!object && typeof property === "undefined") {
            return sinon.stub.create();
        }

        if (typeof property === "undefined" && typeof object == "object") {
            for (var prop in object) {
                if (typeof object[prop] === "function") {
                    stub(object, prop);
                }
            }

            return object;
        }

        return sinon.wrapMethod(object, property, wrapper);
    }

    function getDefaultBehavior(stub) {
        return stub.defaultBehavior || getParentBehaviour(stub) || sinon.behavior.create(stub);
    }

    function getParentBehaviour(stub) {
        return (stub.parent && getCurrentBehavior(stub.parent));
    }

    function getCurrentBehavior(stub) {
        var behavior = stub.behaviors[stub.callCount - 1];
        return behavior && behavior.isPresent() ? behavior : getDefaultBehavior(stub);
    }

    var uuid = 0;

    sinon.extend(stub, (function () {
        var proto = {
            create: function create() {
                var functionStub = function () {
                    return getCurrentBehavior(functionStub).invoke(this, arguments);
                };

                functionStub.id = "stub#" + uuid++;
                var orig = functionStub;
                functionStub = sinon.spy.create(functionStub);
                functionStub.func = orig;

                sinon.extend(functionStub, stub);
                functionStub._create = sinon.stub.create;
                functionStub.displayName = "stub";
                functionStub.toString = sinon.functionToString;

                functionStub.defaultBehavior = null;
                functionStub.behaviors = [];

                return functionStub;
            },

            resetBehavior: function () {
                var i;

                this.defaultBehavior = null;
                this.behaviors = [];

                delete this.returnValue;
                delete this.returnArgAt;
                this.returnThis = false;

                if (this.fakes) {
                    for (i = 0; i < this.fakes.length; i++) {
                        this.fakes[i].resetBehavior();
                    }
                }
            },

            onCall: function(index) {
                if (!this.behaviors[index]) {
                    this.behaviors[index] = sinon.behavior.create(this);
                }

                return this.behaviors[index];
            },

            onFirstCall: function() {
                return this.onCall(0);
            },

            onSecondCall: function() {
                return this.onCall(1);
            },

            onThirdCall: function() {
                return this.onCall(2);
            }
        };

        for (var method in sinon.behavior) {
            if (sinon.behavior.hasOwnProperty(method) &&
                !proto.hasOwnProperty(method) &&
                method != 'create' &&
                method != 'withArgs' &&
                method != 'invoke') {
                proto[method] = (function(behaviorMethod) {
                    return function() {
                        this.defaultBehavior = this.defaultBehavior || sinon.behavior.create(this);
                        this.defaultBehavior[behaviorMethod].apply(this.defaultBehavior, arguments);
                        return this;
                    };
                }(method));
            }
        }

        return proto;
    }()));

    if (commonJSModule) {
        module.exports = stub;
    } else {
        sinon.stub = stub;
    }
}(typeof sinon == "object" && sinon || null));

},{"../sinon":78}],88:[function(require,module,exports){
/**
 * @depend ../sinon.js
 * @depend stub.js
 * @depend mock.js
 * @depend sandbox.js
 */
/*jslint eqeqeq: false, onevar: false, forin: true, plusplus: false*/
/*global module, require, sinon*/
/**
 * Test function, sandboxes fakes
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon) {
        return;
    }

    function test(callback) {
        var type = typeof callback;

        if (type != "function") {
            throw new TypeError("sinon.test needs to wrap a test function, got " + type);
        }

        return function () {
            var config = sinon.getConfig(sinon.config);
            config.injectInto = config.injectIntoThis && this || config.injectInto;
            var sandbox = sinon.sandbox.create(config);
            var exception, result;
            var args = Array.prototype.slice.call(arguments).concat(sandbox.args);

            try {
                result = callback.apply(this, args);
            } catch (e) {
                exception = e;
            }

            if (typeof exception !== "undefined") {
                sandbox.restore();
                throw exception;
            }
            else {
                sandbox.verifyAndRestore();
            }

            return result;
        };
    }

    test.config = {
        injectIntoThis: true,
        injectInto: null,
        properties: ["spy", "stub", "mock", "clock", "server", "requests"],
        useFakeTimers: true,
        useFakeServer: true
    };

    if (commonJSModule) {
        module.exports = test;
    } else {
        sinon.test = test;
    }
}(typeof sinon == "object" && sinon || null));

},{"../sinon":78}],89:[function(require,module,exports){
/**
 * @depend ../sinon.js
 * @depend test.js
 */
/*jslint eqeqeq: false, onevar: false, eqeqeq: false*/
/*global module, require, sinon*/
/**
 * Test case, sandboxes all test functions
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

(function (sinon) {
    var commonJSModule = typeof module !== 'undefined' && module.exports;

    if (!sinon && commonJSModule) {
        sinon = require("../sinon");
    }

    if (!sinon || !Object.prototype.hasOwnProperty) {
        return;
    }

    function createTest(property, setUp, tearDown) {
        return function () {
            if (setUp) {
                setUp.apply(this, arguments);
            }

            var exception, result;

            try {
                result = property.apply(this, arguments);
            } catch (e) {
                exception = e;
            }

            if (tearDown) {
                tearDown.apply(this, arguments);
            }

            if (exception) {
                throw exception;
            }

            return result;
        };
    }

    function testCase(tests, prefix) {
        /*jsl:ignore*/
        if (!tests || typeof tests != "object") {
            throw new TypeError("sinon.testCase needs an object with test functions");
        }
        /*jsl:end*/

        prefix = prefix || "test";
        var rPrefix = new RegExp("^" + prefix);
        var methods = {}, testName, property, method;
        var setUp = tests.setUp;
        var tearDown = tests.tearDown;

        for (testName in tests) {
            if (tests.hasOwnProperty(testName)) {
                property = tests[testName];

                if (/^(setUp|tearDown)$/.test(testName)) {
                    continue;
                }

                if (typeof property == "function" && rPrefix.test(testName)) {
                    method = property;

                    if (setUp || tearDown) {
                        method = createTest(property, setUp, tearDown);
                    }

                    methods[testName] = sinon.test(method);
                } else {
                    methods[testName] = tests[testName];
                }
            }
        }

        return methods;
    }

    if (commonJSModule) {
        module.exports = testCase;
    } else {
        sinon.testCase = testCase;
    }
}(typeof sinon == "object" && sinon || null));

},{"../sinon":78}],90:[function(require,module,exports){
(function (global){
/*jslint eqeqeq: false, plusplus: false, evil: true, onevar: false, browser: true, forin: false*/
/*global module, require, window*/
/**
 * Fake timer API
 * setTimeout
 * setInterval
 * clearTimeout
 * clearInterval
 * tick
 * reset
 * Date
 *
 * Inspired by jsUnitMockTimeOut from JsUnit
 *
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2013 Christian Johansen
 */
"use strict";

if (typeof sinon == "undefined") {
    var sinon = {};
}

(function (global) {
    // node expects setTimeout/setInterval to return a fn object w/ .ref()/.unref()
    // browsers, a number.
    // see https://github.com/cjohansen/Sinon.JS/pull/436
    var timeoutResult = setTimeout(function() {}, 0);
    var addTimerReturnsObject = typeof timeoutResult === 'object';
    clearTimeout(timeoutResult);

    var id = 1;

    function addTimer(args, recurring) {
        if (args.length === 0) {
            throw new Error("Function requires at least 1 parameter");
        }

        if (typeof args[0] === "undefined") {
            throw new Error("Callback must be provided to timer calls");
        }

        var toId = id++;
        var delay = args[1] || 0;

        if (!this.timeouts) {
            this.timeouts = {};
        }

        this.timeouts[toId] = {
            id: toId,
            func: args[0],
            callAt: this.now + delay,
            invokeArgs: Array.prototype.slice.call(args, 2)
        };

        if (recurring === true) {
            this.timeouts[toId].interval = delay;
        }

        if (addTimerReturnsObject) {
            return {
                id: toId,
                ref: function() {},
                unref: function() {}
            };
        }
        else {
            return toId;
        }
    }

    function parseTime(str) {
        if (!str) {
            return 0;
        }

        var strings = str.split(":");
        var l = strings.length, i = l;
        var ms = 0, parsed;

        if (l > 3 || !/^(\d\d:){0,2}\d\d?$/.test(str)) {
            throw new Error("tick only understands numbers and 'h:m:s'");
        }

        while (i--) {
            parsed = parseInt(strings[i], 10);

            if (parsed >= 60) {
                throw new Error("Invalid time " + str);
            }

            ms += parsed * Math.pow(60, (l - i - 1));
        }

        return ms * 1000;
    }

    function createObject(object) {
        var newObject;

        if (Object.create) {
            newObject = Object.create(object);
        } else {
            var F = function () {};
            F.prototype = object;
            newObject = new F();
        }

        newObject.Date.clock = newObject;
        return newObject;
    }

    sinon.clock = {
        now: 0,

        create: function create(now) {
            var clock = createObject(this);

            if (typeof now == "number") {
                clock.now = now;
            }

            if (!!now && typeof now == "object") {
                throw new TypeError("now should be milliseconds since UNIX epoch");
            }

            return clock;
        },

        setTimeout: function setTimeout(callback, timeout) {
            return addTimer.call(this, arguments, false);
        },

        clearTimeout: function clearTimeout(timerId) {
            if (!this.timeouts) {
                this.timeouts = [];
            }

            if (timerId in this.timeouts) {
                delete this.timeouts[timerId];
            }
        },

        setInterval: function setInterval(callback, timeout) {
            return addTimer.call(this, arguments, true);
        },

        clearInterval: function clearInterval(timerId) {
            this.clearTimeout(timerId);
        },

        setImmediate: function setImmediate(callback) {
            var passThruArgs = Array.prototype.slice.call(arguments, 1);

            return addTimer.call(this, [callback, 0].concat(passThruArgs), false);
        },

        clearImmediate: function clearImmediate(timerId) {
            this.clearTimeout(timerId);
        },

        tick: function tick(ms) {
            ms = typeof ms == "number" ? ms : parseTime(ms);
            var tickFrom = this.now, tickTo = this.now + ms, previous = this.now;
            var timer = this.firstTimerInRange(tickFrom, tickTo);

            var firstException;
            while (timer && tickFrom <= tickTo) {
                if (this.timeouts[timer.id]) {
                    tickFrom = this.now = timer.callAt;
                    try {
                      this.callTimer(timer);
                    } catch (e) {
                      firstException = firstException || e;
                    }
                }

                timer = this.firstTimerInRange(previous, tickTo);
                previous = tickFrom;
            }

            this.now = tickTo;

            if (firstException) {
              throw firstException;
            }

            return this.now;
        },

        firstTimerInRange: function (from, to) {
            var timer, smallest = null, originalTimer;

            for (var id in this.timeouts) {
                if (this.timeouts.hasOwnProperty(id)) {
                    if (this.timeouts[id].callAt < from || this.timeouts[id].callAt > to) {
                        continue;
                    }

                    if (smallest === null || this.timeouts[id].callAt < smallest) {
                        originalTimer = this.timeouts[id];
                        smallest = this.timeouts[id].callAt;

                        timer = {
                            func: this.timeouts[id].func,
                            callAt: this.timeouts[id].callAt,
                            interval: this.timeouts[id].interval,
                            id: this.timeouts[id].id,
                            invokeArgs: this.timeouts[id].invokeArgs
                        };
                    }
                }
            }

            return timer || null;
        },

        callTimer: function (timer) {
            if (typeof timer.interval == "number") {
                this.timeouts[timer.id].callAt += timer.interval;
            } else {
                delete this.timeouts[timer.id];
            }

            try {
                if (typeof timer.func == "function") {
                    timer.func.apply(null, timer.invokeArgs);
                } else {
                    eval(timer.func);
                }
            } catch (e) {
              var exception = e;
            }

            if (!this.timeouts[timer.id]) {
                if (exception) {
                  throw exception;
                }
                return;
            }

            if (exception) {
              throw exception;
            }
        },

        reset: function reset() {
            this.timeouts = {};
        },

        Date: (function () {
            var NativeDate = Date;

            function ClockDate(year, month, date, hour, minute, second, ms) {
                // Defensive and verbose to avoid potential harm in passing
                // explicit undefined when user does not pass argument
                switch (arguments.length) {
                case 0:
                    return new NativeDate(ClockDate.clock.now);
                case 1:
                    return new NativeDate(year);
                case 2:
                    return new NativeDate(year, month);
                case 3:
                    return new NativeDate(year, month, date);
                case 4:
                    return new NativeDate(year, month, date, hour);
                case 5:
                    return new NativeDate(year, month, date, hour, minute);
                case 6:
                    return new NativeDate(year, month, date, hour, minute, second);
                default:
                    return new NativeDate(year, month, date, hour, minute, second, ms);
                }
            }

            return mirrorDateProperties(ClockDate, NativeDate);
        }())
    };

    function mirrorDateProperties(target, source) {
        if (source.now) {
            target.now = function now() {
                return target.clock.now;
            };
        } else {
            delete target.now;
        }

        if (source.toSource) {
            target.toSource = function toSource() {
                return source.toSource();
            };
        } else {
            delete target.toSource;
        }

        target.toString = function toString() {
            return source.toString();
        };

        target.prototype = source.prototype;
        target.parse = source.parse;
        target.UTC = source.UTC;
        target.prototype.toUTCString = source.prototype.toUTCString;

        for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            }
        }

        return target;
    }

    var methods = ["Date", "setTimeout", "setInterval",
                   "clearTimeout", "clearInterval"];

    if (typeof global.setImmediate !== "undefined") {
        methods.push("setImmediate");
    }

    if (typeof global.clearImmediate !== "undefined") {
        methods.push("clearImmediate");
    }

    function restore() {
        var method;

        for (var i = 0, l = this.methods.length; i < l; i++) {
            method = this.methods[i];

            if (global[method].hadOwnProperty) {
                global[method] = this["_" + method];
            } else {
                try {
                    delete global[method];
                } catch (e) {}
            }
        }

        // Prevent multiple executions which will completely remove these props
        this.methods = [];
    }

    function stubGlobal(method, clock) {
        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(global, method);
        clock["_" + method] = global[method];

        if (method == "Date") {
            var date = mirrorDateProperties(clock[method], global[method]);
            global[method] = date;
        } else {
            global[method] = function () {
                return clock[method].apply(clock, arguments);
            };

            for (var prop in clock[method]) {
                if (clock[method].hasOwnProperty(prop)) {
                    global[method][prop] = clock[method][prop];
                }
            }
        }

        global[method].clock = clock;
    }

    sinon.useFakeTimers = function useFakeTimers(now) {
        var clock = sinon.clock.create(now);
        clock.restore = restore;
        clock.methods = Array.prototype.slice.call(arguments,
                                                   typeof now == "number" ? 1 : 0);

        if (clock.methods.length === 0) {
            clock.methods = methods;
        }

        for (var i = 0, l = clock.methods.length; i < l; i++) {
            stubGlobal(clock.methods[i], clock);
        }

        return clock;
    };
}(typeof global != "undefined" && typeof global !== "function" ? global : this));

sinon.timers = {
    setTimeout: setTimeout,
    clearTimeout: clearTimeout,
    setImmediate: (typeof setImmediate !== "undefined" ? setImmediate : undefined),
    clearImmediate: (typeof clearImmediate !== "undefined" ? clearImmediate: undefined),
    setInterval: setInterval,
    clearInterval: clearInterval,
    Date: Date
};

if (typeof module !== 'undefined' && module.exports) {
    module.exports = sinon;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],91:[function(require,module,exports){
(function (global){
((typeof define === "function" && define.amd && function (m) {
    define("formatio", ["samsam"], m);
}) || (typeof module === "object" && function (m) {
    module.exports = m(require("samsam"));
}) || function (m) { this.formatio = m(this.samsam); }
)(function (samsam) {
    "use strict";

    var formatio = {
        excludeConstructors: ["Object", /^.$/],
        quoteStrings: true
    };

    var hasOwn = Object.prototype.hasOwnProperty;

    var specialObjects = [];
    if (typeof global !== "undefined") {
        specialObjects.push({ object: global, value: "[object global]" });
    }
    if (typeof document !== "undefined") {
        specialObjects.push({
            object: document,
            value: "[object HTMLDocument]"
        });
    }
    if (typeof window !== "undefined") {
        specialObjects.push({ object: window, value: "[object Window]" });
    }

    function functionName(func) {
        if (!func) { return ""; }
        if (func.displayName) { return func.displayName; }
        if (func.name) { return func.name; }
        var matches = func.toString().match(/function\s+([^\(]+)/m);
        return (matches && matches[1]) || "";
    }

    function constructorName(f, object) {
        var name = functionName(object && object.constructor);
        var excludes = f.excludeConstructors ||
                formatio.excludeConstructors || [];

        var i, l;
        for (i = 0, l = excludes.length; i < l; ++i) {
            if (typeof excludes[i] === "string" && excludes[i] === name) {
                return "";
            } else if (excludes[i].test && excludes[i].test(name)) {
                return "";
            }
        }

        return name;
    }

    function isCircular(object, objects) {
        if (typeof object !== "object") { return false; }
        var i, l;
        for (i = 0, l = objects.length; i < l; ++i) {
            if (objects[i] === object) { return true; }
        }
        return false;
    }

    function ascii(f, object, processed, indent) {
        if (typeof object === "string") {
            var qs = f.quoteStrings;
            var quote = typeof qs !== "boolean" || qs;
            return processed || quote ? '"' + object + '"' : object;
        }

        if (typeof object === "function" && !(object instanceof RegExp)) {
            return ascii.func(object);
        }

        processed = processed || [];

        if (isCircular(object, processed)) { return "[Circular]"; }

        if (Object.prototype.toString.call(object) === "[object Array]") {
            return ascii.array.call(f, object, processed);
        }

        if (!object) { return String((1/object) === -Infinity ? "-0" : object); }
        if (samsam.isElement(object)) { return ascii.element(object); }

        if (typeof object.toString === "function" &&
                object.toString !== Object.prototype.toString) {
            return object.toString();
        }

        var i, l;
        for (i = 0, l = specialObjects.length; i < l; i++) {
            if (object === specialObjects[i].object) {
                return specialObjects[i].value;
            }
        }

        return ascii.object.call(f, object, processed, indent);
    }

    ascii.func = function (func) {
        return "function " + functionName(func) + "() {}";
    };

    ascii.array = function (array, processed) {
        processed = processed || [];
        processed.push(array);
        var i, l, pieces = [];
        for (i = 0, l = array.length; i < l; ++i) {
            pieces.push(ascii(this, array[i], processed));
        }
        return "[" + pieces.join(", ") + "]";
    };

    ascii.object = function (object, processed, indent) {
        processed = processed || [];
        processed.push(object);
        indent = indent || 0;
        var pieces = [], properties = samsam.keys(object).sort();
        var length = 3;
        var prop, str, obj, i, l;

        for (i = 0, l = properties.length; i < l; ++i) {
            prop = properties[i];
            obj = object[prop];

            if (isCircular(obj, processed)) {
                str = "[Circular]";
            } else {
                str = ascii(this, obj, processed, indent + 2);
            }

            str = (/\s/.test(prop) ? '"' + prop + '"' : prop) + ": " + str;
            length += str.length;
            pieces.push(str);
        }

        var cons = constructorName(this, object);
        var prefix = cons ? "[" + cons + "] " : "";
        var is = "";
        for (i = 0, l = indent; i < l; ++i) { is += " "; }

        if (length + indent > 80) {
            return prefix + "{\n  " + is + pieces.join(",\n  " + is) + "\n" +
                is + "}";
        }
        return prefix + "{ " + pieces.join(", ") + " }";
    };

    ascii.element = function (element) {
        var tagName = element.tagName.toLowerCase();
        var attrs = element.attributes, attr, pairs = [], attrName, i, l, val;

        for (i = 0, l = attrs.length; i < l; ++i) {
            attr = attrs.item(i);
            attrName = attr.nodeName.toLowerCase().replace("html:", "");
            val = attr.nodeValue;
            if (attrName !== "contenteditable" || val !== "inherit") {
                if (!!val) { pairs.push(attrName + "=\"" + val + "\""); }
            }
        }

        var formatted = "<" + tagName + (pairs.length > 0 ? " " : "");
        var content = element.innerHTML;

        if (content.length > 20) {
            content = content.substr(0, 20) + "[...]";
        }

        var res = formatted + pairs.join(" ") + ">" + content +
                "</" + tagName + ">";

        return res.replace(/ contentEditable="inherit"/, "");
    };

    function Formatio(options) {
        for (var opt in options) {
            this[opt] = options[opt];
        }
    }

    Formatio.prototype = {
        functionName: functionName,

        configure: function (options) {
            return new Formatio(options);
        },

        constructorName: function (object) {
            return constructorName(this, object);
        },

        ascii: function (object, processed, indent) {
            return ascii(this, object, processed, indent);
        }
    };

    return Formatio.prototype;
});

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"samsam":92}],92:[function(require,module,exports){
((typeof define === "function" && define.amd && function (m) { define("samsam", m); }) ||
 (typeof module === "object" &&
      function (m) { module.exports = m(); }) || // Node
 function (m) { this.samsam = m(); } // Browser globals
)(function () {
    var o = Object.prototype;
    var div = typeof document !== "undefined" && document.createElement("div");

    function isNaN(value) {
        // Unlike global isNaN, this avoids type coercion
        // typeof check avoids IE host object issues, hat tip to
        // lodash
        var val = value; // JsLint thinks value !== value is "weird"
        return typeof value === "number" && value !== val;
    }

    function getClass(value) {
        // Returns the internal [[Class]] by calling Object.prototype.toString
        // with the provided value as this. Return value is a string, naming the
        // internal class, e.g. "Array"
        return o.toString.call(value).split(/[ \]]/)[1];
    }

    /**
     * @name samsam.isArguments
     * @param Object object
     *
     * Returns ``true`` if ``object`` is an ``arguments`` object,
     * ``false`` otherwise.
     */
    function isArguments(object) {
        if (getClass(object) === 'Arguments') { return true; }
        if (typeof object !== "object" || typeof object.length !== "number" ||
                getClass(object) === "Array") {
            return false;
        }
        if (typeof object.callee == "function") { return true; }
        try {
            object[object.length] = 6;
            delete object[object.length];
        } catch (e) {
            return true;
        }
        return false;
    }

    /**
     * @name samsam.isElement
     * @param Object object
     *
     * Returns ``true`` if ``object`` is a DOM element node. Unlike
     * Underscore.js/lodash, this function will return ``false`` if ``object``
     * is an *element-like* object, i.e. a regular object with a ``nodeType``
     * property that holds the value ``1``.
     */
    function isElement(object) {
        if (!object || object.nodeType !== 1 || !div) { return false; }
        try {
            object.appendChild(div);
            object.removeChild(div);
        } catch (e) {
            return false;
        }
        return true;
    }

    /**
     * @name samsam.keys
     * @param Object object
     *
     * Return an array of own property names.
     */
    function keys(object) {
        var ks = [], prop;
        for (prop in object) {
            if (o.hasOwnProperty.call(object, prop)) { ks.push(prop); }
        }
        return ks;
    }

    /**
     * @name samsam.isDate
     * @param Object value
     *
     * Returns true if the object is a ``Date``, or *date-like*. Duck typing
     * of date objects work by checking that the object has a ``getTime``
     * function whose return value equals the return value from the object's
     * ``valueOf``.
     */
    function isDate(value) {
        return typeof value.getTime == "function" &&
            value.getTime() == value.valueOf();
    }

    /**
     * @name samsam.isNegZero
     * @param Object value
     *
     * Returns ``true`` if ``value`` is ``-0``.
     */
    function isNegZero(value) {
        return value === 0 && 1 / value === -Infinity;
    }

    /**
     * @name samsam.equal
     * @param Object obj1
     * @param Object obj2
     *
     * Returns ``true`` if two objects are strictly equal. Compared to
     * ``===`` there are two exceptions:
     *
     *   - NaN is considered equal to NaN
     *   - -0 and +0 are not considered equal
     */
    function identical(obj1, obj2) {
        if (obj1 === obj2 || (isNaN(obj1) && isNaN(obj2))) {
            return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);
        }
    }


    /**
     * @name samsam.deepEqual
     * @param Object obj1
     * @param Object obj2
     *
     * Deep equal comparison. Two values are "deep equal" if:
     *
     *   - They are equal, according to samsam.identical
     *   - They are both date objects representing the same time
     *   - They are both arrays containing elements that are all deepEqual
     *   - They are objects with the same set of properties, and each property
     *     in ``obj1`` is deepEqual to the corresponding property in ``obj2``
     *
     * Supports cyclic objects.
     */
    function deepEqualCyclic(obj1, obj2) {

        // used for cyclic comparison
        // contain already visited objects
        var objects1 = [],
            objects2 = [],
        // contain pathes (position in the object structure)
        // of the already visited objects
        // indexes same as in objects arrays
            paths1 = [],
            paths2 = [],
        // contains combinations of already compared objects
        // in the manner: { "$1['ref']$2['ref']": true }
            compared = {};

        /**
         * used to check, if the value of a property is an object
         * (cyclic logic is only needed for objects)
         * only needed for cyclic logic
         */
        function isObject(value) {

            if (typeof value === 'object' && value !== null &&
                    !(value instanceof Boolean) &&
                    !(value instanceof Date)    &&
                    !(value instanceof Number)  &&
                    !(value instanceof RegExp)  &&
                    !(value instanceof String)) {

                return true;
            }

            return false;
        }

        /**
         * returns the index of the given object in the
         * given objects array, -1 if not contained
         * only needed for cyclic logic
         */
        function getIndex(objects, obj) {

            var i;
            for (i = 0; i < objects.length; i++) {
                if (objects[i] === obj) {
                    return i;
                }
            }

            return -1;
        }

        // does the recursion for the deep equal check
        return (function deepEqual(obj1, obj2, path1, path2) {
            var type1 = typeof obj1;
            var type2 = typeof obj2;

            // == null also matches undefined
            if (obj1 === obj2 ||
                    isNaN(obj1) || isNaN(obj2) ||
                    obj1 == null || obj2 == null ||
                    type1 !== "object" || type2 !== "object") {

                return identical(obj1, obj2);
            }

            // Elements are only equal if identical(expected, actual)
            if (isElement(obj1) || isElement(obj2)) { return false; }

            var isDate1 = isDate(obj1), isDate2 = isDate(obj2);
            if (isDate1 || isDate2) {
                if (!isDate1 || !isDate2 || obj1.getTime() !== obj2.getTime()) {
                    return false;
                }
            }

            if (obj1 instanceof RegExp && obj2 instanceof RegExp) {
                if (obj1.toString() !== obj2.toString()) { return false; }
            }

            var class1 = getClass(obj1);
            var class2 = getClass(obj2);
            var keys1 = keys(obj1);
            var keys2 = keys(obj2);

            if (isArguments(obj1) || isArguments(obj2)) {
                if (obj1.length !== obj2.length) { return false; }
            } else {
                if (type1 !== type2 || class1 !== class2 ||
                        keys1.length !== keys2.length) {
                    return false;
                }
            }

            var key, i, l,
                // following vars are used for the cyclic logic
                value1, value2,
                isObject1, isObject2,
                index1, index2,
                newPath1, newPath2;

            for (i = 0, l = keys1.length; i < l; i++) {
                key = keys1[i];
                if (!o.hasOwnProperty.call(obj2, key)) {
                    return false;
                }

                // Start of the cyclic logic

                value1 = obj1[key];
                value2 = obj2[key];

                isObject1 = isObject(value1);
                isObject2 = isObject(value2);

                // determine, if the objects were already visited
                // (it's faster to check for isObject first, than to
                // get -1 from getIndex for non objects)
                index1 = isObject1 ? getIndex(objects1, value1) : -1;
                index2 = isObject2 ? getIndex(objects2, value2) : -1;

                // determine the new pathes of the objects
                // - for non cyclic objects the current path will be extended
                //   by current property name
                // - for cyclic objects the stored path is taken
                newPath1 = index1 !== -1
                    ? paths1[index1]
                    : path1 + '[' + JSON.stringify(key) + ']';
                newPath2 = index2 !== -1
                    ? paths2[index2]
                    : path2 + '[' + JSON.stringify(key) + ']';

                // stop recursion if current objects are already compared
                if (compared[newPath1 + newPath2]) {
                    return true;
                }

                // remember the current objects and their pathes
                if (index1 === -1 && isObject1) {
                    objects1.push(value1);
                    paths1.push(newPath1);
                }
                if (index2 === -1 && isObject2) {
                    objects2.push(value2);
                    paths2.push(newPath2);
                }

                // remember that the current objects are already compared
                if (isObject1 && isObject2) {
                    compared[newPath1 + newPath2] = true;
                }

                // End of cyclic logic

                // neither value1 nor value2 is a cycle
                // continue with next level
                if (!deepEqual(value1, value2, newPath1, newPath2)) {
                    return false;
                }
            }

            return true;

        }(obj1, obj2, '$1', '$2'));
    }

    var match;

    function arrayContains(array, subset) {
        if (subset.length === 0) { return true; }
        var i, l, j, k;
        for (i = 0, l = array.length; i < l; ++i) {
            if (match(array[i], subset[0])) {
                for (j = 0, k = subset.length; j < k; ++j) {
                    if (!match(array[i + j], subset[j])) { return false; }
                }
                return true;
            }
        }
        return false;
    }

    /**
     * @name samsam.match
     * @param Object object
     * @param Object matcher
     *
     * Compare arbitrary value ``object`` with matcher.
     */
    match = function match(object, matcher) {
        if (matcher && typeof matcher.test === "function") {
            return matcher.test(object);
        }

        if (typeof matcher === "function") {
            return matcher(object) === true;
        }

        if (typeof matcher === "string") {
            matcher = matcher.toLowerCase();
            var notNull = typeof object === "string" || !!object;
            return notNull &&
                (String(object)).toLowerCase().indexOf(matcher) >= 0;
        }

        if (typeof matcher === "number") {
            return matcher === object;
        }

        if (typeof matcher === "boolean") {
            return matcher === object;
        }

        if (getClass(object) === "Array" && getClass(matcher) === "Array") {
            return arrayContains(object, matcher);
        }

        if (matcher && typeof matcher === "object") {
            var prop;
            for (prop in matcher) {
                var value = object[prop];
                if (typeof value === "undefined" &&
                        typeof object.getAttribute === "function") {
                    value = object.getAttribute(prop);
                }
                if (typeof value === "undefined" || !match(value, matcher[prop])) {
                    return false;
                }
            }
            return true;
        }

        throw new Error("Matcher was not a string, a number, a " +
                        "function, a boolean or an object");
    };

    return {
        isArguments: isArguments,
        isElement: isElement,
        isDate: isDate,
        isNegZero: isNegZero,
        identical: identical,
        deepEqual: deepEqualCyclic,
        match: match,
        keys: keys
    };
});

},{}],93:[function(require,module,exports){
"use strict";
var Selection = require('../../assets/js/ue/selection');
var KeyboardBindings = require('../../assets/js/ue/KeyboardBindings');
var FakeNode = require('./FakeNode');
var sinon = require('sinon');


var CrossSegmentSelectionObjectMother = function () {
  this.keyboardBindings = new KeyboardBindings('fake target');
};

var proto = CrossSegmentSelectionObjectMother.prototype;

proto.setupSelectionContextToHaveCommonAncestor = function (className) {
  var me = this;
  me.store = Selection.SelectionContext;
  me.stub = sinon.createStubInstance(Selection.SelectionContext);

  me.stub.commonAncestorContainer = new FakeNode().withClass(className);
  me.stub.hasCommonAncestorClass.restore();

  Selection.SelectionContext = function () {
    return me.stub;
  };
};

proto.resetSelectionContext = function () {
  var me = this;
  Selection.SelectionContext = me.store;
};

module.exports = CrossSegmentSelectionObjectMother;

},{"../../assets/js/ue/KeyboardBindings":7,"../../assets/js/ue/selection":34,"./FakeNode":96,"sinon":78}],94:[function(require,module,exports){
/* File: DataProviderObjectMother.js */
/* jshint undef: true, unused: true*/
'use strict';
var proto;
var DataProvider = require('../../assets/js/ue/DataProvider');

function DataProviderObjectMother() {
}

proto = DataProviderObjectMother.prototype;

proto.hackInitialization = function (paragraphs, ueDocument) {
  DataProvider.initData(ueDocument.id, ueDocument);
  DataProvider.mapSkeletonData(ueDocument.skeletons[0]);
};

module.exports = DataProviderObjectMother;

},{"../../assets/js/ue/DataProvider":3}],95:[function(require,module,exports){
/* File: FakeEvent.js */
/* jshint undef: true, unused: true */
'use strict';

function FakeEvent() {
  this.keyCode = -1;
  this.ctrlKey = false;
  this.shiftKey = false;
  this.type = '';
  this.which = undefined;

  this.hasPreventedDefault = false;
  this.hasStoppedPropagation = false;
}

FakeEvent.prototype.setKeyCode = function (value) {
  var me = this;

  me.keyCode = value;
};

FakeEvent.prototype.setShiftKey = function (value) {
  var me = this;

  me.shiftKey = value;
};

FakeEvent.prototype.setCtrlKey = function (value) {
  var me = this;

  me.ctrlKey = value;
};

FakeEvent.prototype.setType = function (value) {
  this.type = value;
};

FakeEvent.prototype.setCurrentTarget = function (target) {
  this.currentTarget = target;
};

FakeEvent.prototype.preventDefault = function () {
  var me = this;

  me.hasPreventedDefault = true;
};

FakeEvent.prototype.stopPropagation = function () {
  var me = this;

  me.hasStoppedPropagation = true;
};

FakeEvent.prototype.setLeftButtonPressed = function () {
  this.which = 1;
}

module.exports = FakeEvent;

},{}],96:[function(require,module,exports){
function FakeNode(){
  this.nodeType = -1;
  this.parentNode = null;

  this.firstChild = null;
  this.nextSibling = null;
  this.previousSibling = null;
  this.childNodes = [];

  this.classList = {
    contents: [],
    contains:function(className){
      return this.contents.indexOf(className) > -1;
    }
  };

  this.dataset = {};
}

FakeNode.prototype.textNode = function(){
  this.nodeType = 3;
  return this;
};

FakeNode.prototype.withClass = function(className){
  this.classList.contents.push(className);

  return this;
};

module.exports = FakeNode;


},{}],97:[function(require,module,exports){
var sinon = require('sinon');
var FakeNode = require('./FakeNode');

function FakeRange(){
  this.collapsed = false;
  this.commonAncestorContainer = new FakeNode();
  this.endContainer = new FakeNode();
  this.endOffset = 36;
  this.startContainer = new FakeNode();
  this.startOffset = 33;
}

FakeRange.prototype.cloneContents = sinon.stub();
FakeRange.prototype.deleteContents = sinon.spy();
FakeRange.prototype.insertNode = sinon.spy();

module.exports = FakeRange;
},{"./FakeNode":96,"sinon":78}],98:[function(require,module,exports){
var FakeNode = require('./FakeNode');
function FakeSelection(){
  this.anchorNode = new FakeNode();
  this.anchorOffset = 0;
  this.focusNode = new FakeNode();
  this.focusOffset = 0;
  this.isCollapsed = true;
  this.rangeCount = 0;

  this.ranges = {};
}

FakeSelection.prototype.getRangeAt = function(index){
  return this.ranges[index];
};

FakeSelection.prototype.setRangeAt = function(index, range){
  this.ranges[index] = range;
};

module.exports = FakeSelection;


},{"./FakeNode":96}],99:[function(require,module,exports){
var Helpers = require('../../assets/js/ue/Helpers');
var proto;

var HandleClearTagsFixtures = function () {
};

proto = HandleClearTagsFixtures.prototype;

proto.tagPairSample = function () {
  var result;
  result = Helpers.stringToHTMLElement('<div class="ue-inline-content">' +
    '<span class="ue-text">text</span>' +
    '<div class="ue-tag-wrapper" data-id="1" data-can-hide="true" data-type="start-tag">' +
    '<span class="ue-tag ue-tag-start">cf</span>&zwnj;' +
    '</div>' +
    '<div class="ue-inline-content ue-tagpair-content" data-id="1">' +
    '<span class="ue-text">inner content</span>' +
    '</div>' +
    '<div class="ue-tag-wrapper" data-id="1" data-can-hide="true" data-type="end-tag">' +
    '<span class="ue-tag ue-tag-end">cf</span>&zwnj;' +
    '</div>' +
    '<span class="ue-text">at end.</span>' +
    '</div>');

  return result;
};

module.exports = HandleClearTagsFixtures;

},{"../../assets/js/ue/Helpers":5}],100:[function(require,module,exports){
"use strict";
var Helpers = require('../../assets/js/ue/Helpers');
var KeyboardBindings = require('../../assets/js/ue/KeyboardBindings');
var sinon = require('sinon');

var KeyboardBindingsObjectMother = function KeyboardBindingsObjectMother () {
  this.kb = new KeyboardBindings();
};

var proto = KeyboardBindingsObjectMother.prototype;
proto.assignTagsContainer = function () {
  this.kb.tags = {};
  this.kb.moveTagsToFront = [];
  this.kb.moveTagsToEnd = [];
};

proto.deleteTagsContainer = function () {
  delete this.kb.tags;
  delete this.moveTagsToFront;
  delete this.moveTagsToEnd;
};

proto.hasCollectedTag = function (tagId) {
  return this.kb.tags.hasOwnProperty(tagId);
};

proto.getTag = function (tagId) {
  return this.kb.tags[tagId];
};

proto.setupSimpleContainer = function () {
  var result = Helpers.stringToHTMLElement('<div class="ue-inline-content">' +
    '<span class="ue-text">Some basic text here</span>' +
    '<span class="ue-text">end text</span>' +
    '</div>');

  return result;
};

proto.singleStartTagSample = function () {
  var result;
  result = Helpers.stringToHTMLElement('<div class="ue-inline-content">' +
    '<span class="ue-text">text</span>' +
    '<div class="ue-tag-wrapper" data-id="1" data-can-hide="true" data-type="start-tag">' +
    '<span class="ue-tag ue-tag-start">cf</span>&zwnj;' +
    '</div>' +
    '<div class="ue-inline-content ue-tagpair-content" data-id="1">' +
    '<span class="ue-text">inner content</span>' +
    '</div>' +
    '</div>');

  return result;
};

proto.singleEndTagSample = function () {
  var result;
  result = Helpers.stringToHTMLElement('<div class="ue-inline-content">' +
    '<div class="ue-tag-wrapper" data-id="1" data-can-hide="true" data-type="start-tag">' +
    '<span class="ue-tag ue-tag-start">cf</span>&zwnj;' +
    '</div>' +
    '<div class="ue-inline-content ue-tagpair-content">' +
    '<span class="ue-text">inner content</span>' +
    '</div>' +
    '<div class="ue-tag-wrapper" data-id="1" data-can-hide="true" data-type="end-tag">' +
    '<span class="ue-tag ue-tag-end">cf</span>&zwnj;' +
    '</div>' +
    '<span class="ue-text">text content</span>' +
    '</div>');

  return result;
};

proto.stubRemoveInline = function () {
  sinon.stub(this.kb, '_removeInline');
};

proto.resetRemoveInlineStub = function () {
  this.kb._removeInline.reset();
};
module.exports = KeyboardBindingsObjectMother;
},{"../../assets/js/ue/Helpers":5,"../../assets/js/ue/KeyboardBindings":7,"sinon":78}],101:[function(require,module,exports){
/* File: SegmentCleanupFixture.js */
'use strict';
var h = require('../../assets/js/ue/Helpers').stringToHTMLElement;
var proto;

function SegmentCleanupFixture() {
}

proto = SegmentCleanupFixture.prototype;

proto.contentBeforeInlineContent = function () {
  return h('<div class="ue-segment ue-row-active" data-segment-number="16" data-puid="deaf7b2d-f332-45f9-97f5-4e90e164837a" style="height: 27px;">' +
      'outside content<div class="ue-inline-content"></div>' +
    '</div>');
};

proto.segmentWithNoInlineContent = function () {
  return h('<div class="ue-segment ue-row-active" data-segment-number="16" data-puid="deaf7b2d-f332-45f9-97f5-4e90e164837a" style="height: 27px;">' +
    '</div>');
};

proto.contentAfterInlineContent = function () {

  return h('<div class="ue-segment ue-row-active" data-segment-number="16" data-puid="deaf7b2d-f332-45f9-97f5-4e90e164837a" style="height: 27px;">' +
    '<div class="ue-inline-content"></div> content outside' +
    '</div>');
};

proto.placeholderInsideText = function () {
  return h('<div class="ue-segment ue-row-active" data-segment-number="8" data-puid="94220b60-8ff9-46fe-b1a7-050770918d87" style="height: 27px;">' +
  '<div class="ue-inline-content">' +
    '<span class="ue-text" data-type="text">not<span class="ue-tag-wrapper" data-type="placeholder" data-id="44" data-definitionid="10" data-metadata="11344047-5376878-5467698" data-tag-copy="false"><span class="ue-tag" contenteditable="false" data-display-content="x"></span></span> empty</span>' +
  '</div></div>');
};

module.exports = SegmentCleanupFixture;
},{"../../assets/js/ue/Helpers":5}],102:[function(require,module,exports){
var KeyboardBindings = require('../../assets/js/ue/KeyboardBindings');
var FakeRange = require('./FakeRange');
var FakeNode = require('./FakeNode');
var FakeSelection = require('./FakeSelection');

var Selection = require('../../assets/js/ue/selection');
var Helpers = require('../../assets/js/ue/Helpers');

var sinon = require('sinon');

var fakeTarget = 'anything';

var SelectionContextObjectMother = function () {
  this.keyboardBindings = new KeyboardBindings(fakeTarget);
  this.fakeRange = new FakeRange();
  this.fakeSelection = new FakeSelection();

  this.fakeSelection.setRangeAt(0, this.fakeRange);
};

var proto = SelectionContextObjectMother.prototype;

proto.stubSelection = function () {
  var me = this;
  sinon.stub(document, 'getSelection', function () {
    return me.fakeSelection;
  });
};

proto.restoreSelection = function () {
  document.getSelection.restore();
};

proto.defineFocusNodeParent = function () {
  this.fakeSelection.focusNode.parentNode = new FakeNode();
};

proto.assignTextNodes = function () {
  this.fakeSelection.focusNode.textNode();
  this.fakeRange.startContainer.textNode();
  this.fakeRange.endContainer.textNode();
};

proto.setRangeCollapsed = function (state) {
  this.fakeRange.collapsed = state;
};

proto.setupEmptyCloneContents = function () {
  var me = this;

  me.fakeCloneContents = new FakeNode();

  me.fakeRange.cloneContents.returns(
    me.fakeCloneContents);
};

/**
 * setCrossSegmentSelectionTo sets the return value to @param value
 * @param value - the return value of the function
 * when value is null or undefined the original method is restored
 */
proto.setCrossSegmentSelectionTo = function (value) {
  var me = this;

  sinon.stub(me.keyboardBindings, 'isCrossSegmentSelection').
    returns(value);
  me.stubSelectionContext();
};

proto.resetCrossSegmentSelection = function () {
  var me = this;

  me.keyboardBindings.isCrossSegmentSelection.restore();
  me.restoreSelectionContext();
};

proto.setCollapsedSelection = function () {
  var me = this;
  me.stubSelectionContext();
  me.stubSelectionContext.isCollapsed.returns(true);
};

proto.setupSameContainerForSelection = function () {
  var me = this,
      fakeContainer;
  fakeContainer = document.createDocumentFragment();
  me.stubSelectionContext();

  me.stubSelectionContext.startContainer = me.stubSelectionContext.endContainer = fakeContainer;
  me.stubSelectionContext.commonAncestorContainer = fakeContainer;
};

proto.setupSimpleAncestorStartContainer = function () {
  var me = this,
      fakeContainer,
      startTextContainer,
      startTextNode;

  me.stubSelectionContext();

  fakeContainer = Helpers.stringToHTMLElement("<div class='ue-inline-content'>" +
    "<span class='ue-text'>start container is text node</span>" +
    "</div>");
  startTextContainer = fakeContainer.firstChild;
  startTextNode = startTextContainer.firstChild;

  me.stubSelectionContext.commonAncestorContainer = fakeContainer;
  me.stubSelectionContext.startContainer = startTextNode;
  me.stubSelectionContext.startOffset = 0;
  me.stubSelectionContext.endContainer = null;

  me.stubSelectionContext.cloneContents.returns(document.createDocumentFragment());
};

proto.commonAncestorToText = function () {
  var me = this;
  return me.stubSelectionContext.commonAncestorContainer.outerHTML;
};

proto.stubSelectionContext = function () {
  var me = this;

  me.originalSelectionContext = Selection.SelectionContext;
  me.stubSelectionContext = sinon.createStubInstance(Selection.SelectionContext);

  Selection.SelectionContext = function () {
    return me.stubSelectionContext;
  };

  return me.stubSelectionContext;
};

proto.restoreSelectionContext = function () {
  Selection.SelectionContext = this.originalSelectionContext;
};


proto.spyKeyboardBindingsMethod = function (method) {
  var me = this,
      keyboardBindings = me.keyboardBindings;

  sinon.spy(keyboardBindings, method);
};

proto.restoreKeyboardBindingsMethod = function (method) {
  var me = this,
      keyboardBindings = me.keyboardBindings;

  keyboardBindings[method].restore();
};

proto.keyboardBindingsSpy = function (method) {
  var me = this,
      keyboardBindings = me.keyboardBindings;

  return keyboardBindings[method];
};

proto.attachMoveTagsToEndStub = function () {
  var me = this,
      kb = me.keyboardBindings,
      transformTagsOriginalMethod = kb.transformTags;
  me.nodeWalkerStub = sinon.createStubInstance(Selection.NodeWalker);

  kb.transformTags = function () {
    kb.moveTagsToEnd = [me.nodeWalkerStub];
    kb.transformTags = transformTagsOriginalMethod;
  };
};

proto.attachMoveTagsToFrontStub = function () {
  var me = this,
      kb = me.keyboardBindings,
      transformTagsOriginalMethod = kb.transformTags;
  me.nodeWalkerStub = sinon.createStubInstance(Selection.NodeWalker);

  kb.transformTags = function () {
    kb.moveTagsToFront = [me.nodeWalkerStub];
    kb.transformTags = transformTagsOriginalMethod;
  };
};
module.exports = SelectionContextObjectMother;

},{"../../assets/js/ue/Helpers":5,"../../assets/js/ue/KeyboardBindings":7,"../../assets/js/ue/selection":34,"./FakeNode":96,"./FakeRange":97,"./FakeSelection":98,"sinon":78}],103:[function(require,module,exports){
var Helpers = require('../../assets/js/ue/Helpers');
var proto;

var ShiftEnterHandlerFixture = function () {
};

proto = ShiftEnterHandlerFixture.prototype;

proto.segmentWithTextSample = function () {
  var sample;

  sample = Helpers.stringToHTMLElement('<div class="ue-segment" data-segment-number="1">' +
    '&zwnj;' +
    '<div class="ue-inline-content">' +
    '<span class="ue-text">text</span>' +
    '</div>' +
    '</div>')
  return sample;
};

proto.breakAtSegmentStartSample = function () {
  var sample;

  sample = Helpers.stringToHTMLElement('<div class="ue-segment">' +
    '<br>' +
    '&zwnj;' +
    '<div class="ue-inline-content">' +
    '<span class="ue-text">text</span>' +
    '</div>' +
    '</div>')
  return sample;
};

proto.newLineInsideStartTagWrapperSample = function () {
  var sample;

  sample = Helpers.stringToHTMLElement('<div class="ue-segment" data-segment-number="1">' +
      '&zwnj;' +
      '<div class="ue-inline-content">' +
      '<span class="ue-tag-wrapper" data-type="start-tag" data-tag-copy="true" data-id="28" data-metadata="15901602-6591740-7060381" data-can-hide="true">' +
      '<span class="ue-tag ue-tag-start" contenteditable="false">cf</span>' +
      '\n' +
      '&zwnj;' +
      '</span>' +
      '<div class="ue-inline-content ue-tagpair-content" data-type="tagpair" data-id="28" data-definitionid="12" data-metadata="15901602-6591740-7060381" data-style="{&quot;FontName&quot;:&quot;Arial&quot;,&quot;FontSize&quot;:&quot;7&quot;,&quot;TextColor&quot;:&quot;0, 0, 112, 192&quot;}" style="font-family: Arial; font-size: 7px; color: rgb(0, 112, 192);">' +
      '<span class="ue-text" data-type="text">and </span>' +
      '</div>' +
      '</div>'
  );

  return sample;
};

proto.newLineInsideEndTagWrapperSample = function () {
  var sample;

  sample = Helpers.stringToHTMLElement('<div class="ue-segment" data-segment-number="1">' +
      '&zwnj;' +
      '<div class="ue-inline-content">' +
      '<span class="ue-tag-wrapper" data-type="start-tag" data-tag-copy="true" data-id="28" data-metadata="15901602-6591740-7060381" data-can-hide="true">' +
      '<span class="ue-tag ue-tag-start" contenteditable="false">cf</span>' +
      '&zwnj;' +
      '</span>' +
      '<div class="ue-inline-content ue-tagpair-content" data-type="tagpair" data-id="28" data-definitionid="12" data-metadata="15901602-6591740-7060381" data-style="{&quot;FontName&quot;:&quot;Arial&quot;,&quot;FontSize&quot;:&quot;7&quot;,&quot;TextColor&quot;:&quot;0, 0, 112, 192&quot;}" style="font-family: Arial; font-size: 7px; color: rgb(0, 112, 192);">' +
      '<span class="ue-text" data-type="text">and </span>' +
      '</div>' +
      '<span class="ue-tag-wrapper" data-type="end-tag" data-tag-copy="true" data-id="28" data-metadata="14382281-7833779-4176112" data-can-hide="true">' +
      '<span class="ue-tag ue-tag-end" contenteditable="false">cf</span>' +
      '\n' +
      '</span>' +
      '</div>'
  );

  return sample;
};

proto.newLinesInsideTextContainer = function () {
  var sample,
      inlineContent,
      textContainer;

  sample = Helpers.stringToHTMLElement('<div class="ue-segment" data-segment-number="1">' +
      '&zwnj;' +
      '<div class="ue-inline-content">' +
      '<span class="ue-text" data-type="text"></span>' +
      '</div>'
  );

  inlineContent = sample.childNodes[1];
  textContainer = inlineContent.firstChild;

  var start = document.createTextNode('It has survived not only five centuries'),
      middle = document.createTextNode('\n'),
      end = document.createTextNode(', but also the leap into electronic typesetting.');

  textContainer.appendChild(start);
  textContainer.appendChild(middle);
  textContainer.appendChild(end);

  return sample;
};

proto.startTagWithBreak = function () {
  var sample;

  sample = Helpers.stringToHTMLElement('<div class="ue-segment" data-segment-number="1">' +
      '&zwnj;' +
      '<div class="ue-inline-content">' +
      '<span class="ue-tag-wrapper" data-type="start-tag" data-tag-copy="true" data-id="28" data-metadata="15901602-6591740-7060381" data-can-hide="true">' +
      '<span class="ue-tag ue-tag-start" contenteditable="false">cf</span>' +

      '<br>' +

      '&zwnj;' +
      '</span>' +
      '<div class="ue-inline-content ue-tagpair-content" data-type="tagpair" data-id="28" data-definitionid="12" data-metadata="15901602-6591740-7060381" data-style="{&quot;FontName&quot;:&quot;Arial&quot;,&quot;FontSize&quot;:&quot;7&quot;,&quot;TextColor&quot;:&quot;0, 0, 112, 192&quot;}" style="font-family: Arial; font-size: 7px; color: rgb(0, 112, 192);">' +
      '<span class="ue-text" data-type="text">and </span>' +
      '</div>' +
      '<span class="ue-tag-wrapper" data-type="end-tag" data-tag-copy="true" data-id="28" data-metadata="14382281-7833779-4176112" data-can-hide="true">' +
      '<span class="ue-tag ue-tag-end" contenteditable="false">cf</span>' +
      '&zwnj;' +
      '</span>' +
      '</div>' +
      '</div>'
  );
  return sample;
};

proto.endTagWithBreak = function () {
  var sample;

  sample = Helpers.stringToHTMLElement('<div class="ue-segment" data-segment-number="1">' +
      '&zwnj;' +
      '<div class="ue-inline-content">' +
      '<span class="ue-tag-wrapper" data-type="start-tag" data-tag-copy="true" data-id="28" data-metadata="15901602-6591740-7060381" data-can-hide="true">' +
      '<span class="ue-tag ue-tag-start" contenteditable="false">cf</span>' +
      '&zwnj;' +
      '</span>' +
      '<div class="ue-inline-content ue-tagpair-content" data-type="tagpair" data-id="28" data-definitionid="12" data-metadata="15901602-6591740-7060381" data-style="{&quot;FontName&quot;:&quot;Arial&quot;,&quot;FontSize&quot;:&quot;7&quot;,&quot;TextColor&quot;:&quot;0, 0, 112, 192&quot;}" style="font-family: Arial; font-size: 7px; color: rgb(0, 112, 192);">' +
      '<span class="ue-text" data-type="text">and </span>' +
      '</div>' +
      '<span class="ue-tag-wrapper" data-type="end-tag" data-tag-copy="true" data-id="28" data-metadata="14382281-7833779-4176112" data-can-hide="true">' +
      '<span class="ue-tag ue-tag-end" contenteditable="false">cf</span>' +
      '&zwnj;' +

      '<br>' +

      '</span>' +
      '</div>' +
      '</div>'
  );

  return sample;
};

proto.emptySegment = function () {
  var sample;

  sample = Helpers.stringToHTMLElement('<div class="ue-segment" data-segment-number="1">' +
      '&zwnj;' +
      '<br>' +
      '<div class="ue-inline-content">' +
      '</div>'
  );

  return sample;
};

module.exports = ShiftEnterHandlerFixture;

},{"../../assets/js/ue/Helpers":5}],104:[function(require,module,exports){
/* File: SideBySideParagraphUnitsRendererFixture.js */
'use strict';
var proto;

function SideBySideParagraphUnitsRendererFixture() {
}
proto = SideBySideParagraphUnitsRendererFixture.prototype;

proto.defaultDocumentSample = function () {
  var ueDocument;

  ueDocument = {
    "data": {
      "files": [
        {
          "dependencyFiles": [
            {
              "fileName": "c:\\LocalFilesFps\\14b2a81db0884dbcacc1abf1c9d3d70f_WordWithFormatting.docx",
              "id": "inputfile",
              "location": "http://clujgwqa15:8080/gw-file-management-web/files/530b330684ae940a9ff276be/file?DOWNLOAD_TOKEN=Sp76WBzr1Xmi5WyadJO18w%3D%3D_1.0",
              "usage": "Generation"
            }
          ],
          "fileTypeDefinitionId": "Word 2007 v 2.0.0.0",
          "id": "4473d21495d446c5b0d22908a7de040c",
          "metadata": {
            "ExtractDocumentProperties": "False",
            "ExtractHyperlinks": "True",
            "ExtractShapeOrder": "TopLeftToBottomRightByRow",
            "ExtractTrackChangesMode": "Merge",
            "ProcessListItemValues": "False",
            "ProcessLockedContentControls": "False",
            "SDL:AutoClonedFlagSupported": "True",
            "SDL:CreationDate": "02/24/2014 13:54:42",
            "SDL:FileId": "aa798b1a-db2d-4229-afd5-d6305fcc5a04",
            "SDL:FileTypeDefinitionId": "Word 2007 v 2.0.0.0",
            "SDL:OriginalFilePath": "c:\\LocalFilesFps\\14b2a81db0884dbcacc1abf1c9d3d70f_WordWithFormatting.docx",
            "SDL:SourceLanguage": "en-GB",
            "SDL:TargetLanguage": "en-GB",
            "SkipAdvancedFontFormatting": "True",
            "SkipComplexScriptAndAsianTextFont": "True",
            "SkipNonAcceptedRejectedChanges": "False",
            "TranslateComments": "True",
            "WriteStudioCommentsToTarget": "True"
          },
          "originalFileName": "14b2a81db0884dbcacc1abf1c9d3d70f_WordWithFormatting.docx",
          "paragraphUnitCount": 1,
          "paragraphUnits": [
            null
          ],
          "structureParagraphUnitCount": 0
        }
      ],
      "id": "8e741443-d632-40b1-8809-064bcf5d1b0c",
      "name": "14b2a81db0884dbcacc1abf1c9d3d70f_WordWithFormatting.docx",
      "paragraphUnitCount": 1,
      "sourceLanguageCode": "en-GB",
      "sourceLanguageName": "English (United Kingdom)",
      "structureParagraphUnitCount": 0,
      "targetLanguageCode": "en-GB",
      "targetLanguageName": "English (United Kingdom)"
    },
    "id": "8e741443-d632-40b1-8809-064bcf5d1b0c",
    "loadedParagraphs": 4,
    "paragraphCount": 1,
    "skeletons": [
      {
        "comments": [],
        "contextDefinitions": [],
        "contexts": [],
        "fileId": "69b07a3475ba4d9687fd6bb80363cadb",
        "formattingGroups": [
          {
            "id": 1,
            "items": {
              "FontSize": "12"
            },
            "metadata": null
          },
          {
            "id": 2,
            "items": {
              "FontSize": "12",
              "TextColor": "0, 255, 0, 0"
            },
            "metadata": null
          },
          {
            "id": 3,
            "items": {
              "FontSize": "12",
              "TextColor": "0, 192, 80, 77"
            },
            "metadata": null
          },
          {
            "id": 4,
            "items": {
              "FontSize": "12",
              "Strikethrough": "True",
              "TextColor": "0, 192, 80, 77",
              "Underline": "True"
            },
            "metadata": null
          },
          {
            "id": 5,
            "items": {
              "FontSize": "12",
              "TextColor": "0, 0, 112, 192"
            },
            "metadata": null
          },
          {
            "id": 6,
            "items": {
              "Bold": "True",
              "FontSize": "12",
              "Strikethrough": "True"
            },
            "metadata": null
          },
          {
            "id": 7,
            "items": {
              "FontSize": "12",
              "TextColor": "Transparent"
            },
            "metadata": null
          },
          {
            "id": 8,
            "items": {
              "BackgroundColor": "0, 255, 0, 0",
              "FontSize": "12",
              "TextColor": "Transparent"
            },
            "metadata": null
          },
          {
            "id": 9,
            "items": {
              "BackgroundColor": "0, 0, 255, 0",
              "FontSize": "12"
            },
            "metadata": null
          },
          {
            "id": 10,
            "items": {
              "FontSize": "12",
              "Italic": "True",
              "Underline": "True"
            },
            "metadata": null
          },
          {
            "id": 11,
            "items": {
              "BackgroundColor": "0, 0, 0, 255",
              "FontSize": "12",
              "TextColor": "Transparent"
            },
            "metadata": null
          }
        ],
        "placeholderTagDefinitions": [],
        "structureTagDefinitions": [],
        "tagPairDefinitions": [
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 1,
            "id": 1,
            "metadata": null,
            "startTagContent": "<cf size=12>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 2,
            "id": 2,
            "metadata": null,
            "startTagContent": "<cf color=FF0000>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 3,
            "id": 3,
            "metadata": null,
            "startTagContent": "<cf color=C0504D size=12>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 4,
            "id": 4,
            "metadata": null,
            "startTagContent": "<cf strikethrough=single underline=single>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 5,
            "id": 5,
            "metadata": null,
            "startTagContent": "<cf color=0070C0 size=12>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 6,
            "id": 6,
            "metadata": null,
            "startTagContent": "<cf bold=True strikethrough=single>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 7,
            "id": 7,
            "metadata": null,
            "startTagContent": "<cf color=FFFFFF size=12>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 8,
            "id": 8,
            "metadata": null,
            "startTagContent": "<cf highlight=red>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 9,
            "id": 9,
            "metadata": null,
            "startTagContent": "<cf highlight=green>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 10,
            "id": 10,
            "metadata": null,
            "startTagContent": "<cf italic=True underline=single>",
            "startTagDisplayText": "cf",
            "subContent": []
          },
          {
            "canHide": true,
            "endTagContent": "</cf>",
            "endTagDisplayText": "cf",
            "formattingGroupId": 11,
            "id": 11,
            "metadata": null,
            "startTagContent": "<cf color=FFFFFF highlight=blue>",
            "startTagDisplayText": "cf",
            "subContent": []
          }
        ]
      }
    ]
  };
  return ueDocument;
};

proto.defaultParagraphsSample = function () {
  var paragraphs;

  paragraphs = [
    {
      "contextId": 0,
      "id": "f85f5518-e6df-4a76-9664-bf96b9aded0f",
      "index": 1,
      "isLocked": false,
      "isStructure": false,
      "parentFileId": "69b07a3475ba4d9687fd6bb80363cadb",
      "source": {
        "children": [
          {
            "canHide": false,
            "children": [
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "The European languages are members of the same family.",
                    "type": "text"
                  }
                ],
                "isLocked": true,
                "segmentNumber": "1",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Their separate existence is a myth.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "2",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "For science, music, sport, ",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "etc",
                        "type": "text"
                      }
                    ],
                    "id": "2",
                    "metadata": {
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "TextColor": "FF0000",
                      "frameworkOriginalTagId": "5",
                      "w:color": "<w:color w:val=\"FF0000\"/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 2,
                    "type": "tagPair"
                  },
                  {
                    "text": ", Europe uses the same vocabulary.",
                    "type": "text"
                  }
                ],
                "isLocked": true,
                "segmentNumber": "3",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "The languages only differ in their grammar, their ",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "canHide": false,
                        "children": [
                          {
                            "text": "pronunciation and their most common",
                            "type": "text"
                          }
                        ],
                        "id": "4",
                        "metadata": {
                          "FontSize": "12",
                          "ParentTag": "w:r",
                          "StartTag": "w:rPr",
                          "Strikethrough": "single",
                          "TextColor": "C0504D",
                          "Underline": "single",
                          "frameworkOriginalTagId": "11",
                          "w:color": "<w:color w:val=\"C0504D\" w:themeColor=\"accent2\"/>",
                          "w:strike": "<w:strike/>",
                          "w:sz": "<w:sz w:val=\"24\"/>",
                          "w:szCs": "<w:szCs w:val=\"24\"/>",
                          "w:u": "<w:u w:val=\"single\"/>"
                        },
                        "tagPairDefinitionId": 4,
                        "type": "tagPair"
                      },
                      {
                        "text": " ",
                        "type": "text"
                      }
                    ],
                    "id": "3",
                    "metadata": {
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "TextColor": "C0504D",
                      "frameworkOriginalTagId": "14",
                      "w:color": "<w:color w:val=\"C0504D\" w:themeColor=\"accent2\"/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 3,
                    "type": "tagPair"
                  },
                  {
                    "text": "words.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "4",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Everyone realizes why a new common language would be desirable: one could refuse to pay expensive translators.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "5",
                "type": "segment",
                "wordCount": 0
              }
            ],
            "id": "1",
            "metadata": {
              "FontSize": "12",
              "ParentTag": "w:r",
              "StartTag": "w:rPr",
              "frameworkOriginalTagId": "2",
              "w:sz": "<w:sz w:val=\"24\"/>",
              "w:szCs": "<w:szCs w:val=\"24\"/>"
            },
            "tagPairDefinitionId": 1,
            "type": "tagPair"
          }
        ],
        "type": "paragraph"
      },
      "target": {
        "children": [
          {
            "canHide": false,
            "children": [
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Limbile europene sunt membre ale aceleiasi familii lingvistice",
                    "type": "text"
                  }
                ],
                "confirmationLevel": "Draft",
                "isLocked": true,
                "segmentNumber": "1",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "cOXWu/3S5sgtIGpSc5gi3JYH/m8="
                  },
                  "originBeforeAdaptation": {
                    "isStructureContextMatch": false,
                    "matchPercent": 0,
                    "metadata": {
                      "SegmentIdentityHash": "cOXWu/3S5sgtIGpSc5gi3JYH/m8="
                    },
                    "originBeforeAdaptation": null,
                    "originSystem": null,
                    "originType": "interactive",
                    "originalTranslationHash": null,
                    "textContextMatchLevel": null
                  },
                  "originSystem": null,
                  "originType": "interactive",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Existen\u021ba lor separat\u0103 este un mit.",
                    "type": "text"
                  }
                ],
                "confirmationLevel": "Draft",
                "isLocked": false,
                "segmentNumber": "2",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "dpiKpPIDDjfG5rVT67mbQ8EZIaA="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": "interactive",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Pentru \u0219tiin\u021b\u0103, muzic\u0103, sport, ",
                    "type": "text"
                  },
                  {
                    "children": [
                      {
                        "text": " ",
                        "type": "text"
                      },
                      {
                        "canHide": false,
                        "children": [
                          {
                            "text": "etc",
                            "type": "text"
                          }
                        ],
                        "id": "6",
                        "metadata": {
                          "FontSize": "12",
                          "ParentTag": "w:r",
                          "StartTag": "w:rPr",
                          "TextColor": "FF0000",
                          "frameworkOriginalTagId": "5",
                          "w:color": "<w:color w:val=\"FF0000\"/>",
                          "w:sz": "<w:sz w:val=\"24\"/>",
                          "w:szCs": "<w:szCs w:val=\"24\"/>"
                        },
                        "tagPairDefinitionId": 2,
                        "type": "tagPair"
                      },
                      {
                        "text": ",",
                        "type": "text"
                      }
                    ],
                    "type": "locked"
                  },
                  {
                    "text": "Europa folose\u0219te acela\u0219i vocabular.",
                    "type": "text"
                  }
                ],
                "confirmationLevel": "Draft",
                "isLocked": true,
                "segmentNumber": "3",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "LgAmJoDpA7Xmh4E1eraRUCEKJgU="
                  },
                  "originBeforeAdaptation": {
                    "isStructureContextMatch": false,
                    "matchPercent": 0,
                    "metadata": {
                      "SegmentIdentityHash": "LgAmJoDpA7Xmh4E1eraRUCEKJgU="
                    },
                    "originBeforeAdaptation": null,
                    "originSystem": null,
                    "originType": "interactive",
                    "originalTranslationHash": null,
                    "textContextMatchLevel": null
                  },
                  "originSystem": null,
                  "originType": "interactive",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Limbile difer\u0103 doar \u00een gramatica lor, pronun\u021bie \u0219i cuvintele lor, cele mai comune.",
                    "type": "text"
                  }
                ],
                "confirmationLevel": "Draft",
                "isLocked": false,
                "segmentNumber": "4",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "q154Vbekc7Z8qbZgpTIQqztrWyU="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": "interactive",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "\t\t\t\tCu totii realizeaza ...",
                    "type": "text"
                  }
                ],
                "confirmationLevel": "Draft",
                "isLocked": false,
                "segmentNumber": "5",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "m1xdu6/UlYcTKPKYH4wY3miafjk="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": "interactive",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              }
            ],
            "id": "5",
            "metadata": {
              "FontSize": "12",
              "ParentTag": "w:r",
              "StartTag": "w:rPr",
              "frameworkOriginalTagId": "2",
              "w:sz": "<w:sz w:val=\"24\"/>",
              "w:szCs": "<w:szCs w:val=\"24\"/>"
            },
            "tagPairDefinitionId": 1,
            "type": "tagPair"
          }
        ],
        "type": "paragraph"
      }
    },
    {
      "contextId": 0,
      "id": "5d5abbbf-6ad1-42cd-a919-b343c1bfde86",
      "index": 2,
      "isLocked": false,
      "isStructure": false,
      "parentFileId": "69b07a3475ba4d9687fd6bb80363cadb",
      "source": {
        "children": [
          {
            "canHide": false,
            "children": [
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "To achieve this, it would be necessary to have uniform grammar, pronunciation and more common words.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "6",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "If several languages coalesce, the grammar of the resulting language is more simple and regular than that of the individual languages.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "7",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "The new common language will be more simple and regular than the existing European languages.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "8",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "It will be as simple as Occidental; in fact, it will be Occidental.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "9",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              }
            ],
            "id": "7",
            "metadata": {
              "FontSize": "12",
              "ParentTag": "w:r",
              "StartTag": "w:rPr",
              "TextColor": "0070C0",
              "frameworkOriginalTagId": "20",
              "w:color": "<w:color w:val=\"0070C0\"/>",
              "w:sz": "<w:sz w:val=\"24\"/>",
              "w:szCs": "<w:szCs w:val=\"24\"/>"
            },
            "tagPairDefinitionId": 5,
            "type": "tagPair"
          }
        ],
        "type": "paragraph"
      },
      "target": {
        "children": [
          {
            "canHide": false,
            "children": [
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "To achieve this, it would be necessary to have uniform grammar, pronunciation and more common words.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "6",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "h7RJ9nxQBpl4EBtBPiGVLurYiFY="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": "source",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "If several languages coalesce, the grammar of the resulting language is more simple and regular than that of the individual languages.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "7",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "jM/wS3KvMtgBO/uUe5x2IZLTXRg="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": "source",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "The new common language will be more simple and regular than the existing European languages.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "8",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "rrspF4Wzo0wljf1UAzTnYNtBTWQ="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": "source",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "It will be as simple as Occidental; in fact, it will be Occidental.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "9",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "rcM9RCYDVCb+SRa9TQThHRrX6zA="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": "source",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              }
            ],
            "id": "8",
            "metadata": {
              "FontSize": "12",
              "ParentTag": "w:r",
              "StartTag": "w:rPr",
              "TextColor": "0070C0",
              "frameworkOriginalTagId": "20",
              "w:color": "<w:color w:val=\"0070C0\"/>",
              "w:sz": "<w:sz w:val=\"24\"/>",
              "w:szCs": "<w:szCs w:val=\"24\"/>"
            },
            "tagPairDefinitionId": 5,
            "type": "tagPair"
          }
        ],
        "type": "paragraph"
      }
    },
    {
      "contextId": 0,
      "id": "a20a2ef4-d57c-4a60-9c93-698e1f95fbc8",
      "index": 3,
      "isLocked": false,
      "isStructure": false,
      "parentFileId": "69b07a3475ba4d9687fd6bb80363cadb",
      "source": {
        "children": [
          {
            "canHide": false,
            "children": [
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "To an English person, it will seem like simplified English, as a skeptical Cambridge friend of mine told me what Occidental is.",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "The European languages are members of the same family",
                        "type": "text"
                      }
                    ],
                    "id": "10",
                    "metadata": {
                      "Bold": "True",
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "Strikethrough": "single",
                      "frameworkOriginalTagId": "32",
                      "w:b": "<w:b/>",
                      "w:strike": "<w:strike/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 6,
                    "type": "tagPair"
                  },
                  {
                    "text": ".",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "10",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Their separate existence is a myth.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "11",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "For science, music, sport, etc, Europe uses the same vocabulary.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "12",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "The languages only differ in their grammar, their pronunciation and their most common words.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "13",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Everyone realizes why a new common language would be desirable: one could refuse to pay expensive translators.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "14",
                "type": "segment",
                "wordCount": 0
              }
            ],
            "id": "9",
            "metadata": {
              "FontSize": "12",
              "ParentTag": "w:r",
              "StartTag": "w:rPr",
              "frameworkOriginalTagId": "26",
              "w:sz": "<w:sz w:val=\"24\"/>",
              "w:szCs": "<w:szCs w:val=\"24\"/>"
            },
            "tagPairDefinitionId": 1,
            "type": "tagPair"
          }
        ],
        "type": "paragraph"
      },
      "target": {
        "children": [
          {
            "canHide": false,
            "children": [
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "To an English person, it will seem like simplified English, as a skeptical Cambridge friend of mine told me what Occidental is.",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "The ",
                        "type": "text"
                      },
                      {
                        "children": [
                          {
                            "text": "European",
                            "type": "text"
                          }
                        ],
                        "type": "locked"
                      },
                      {
                        "text": " languages are members of the same family",
                        "type": "text"
                      }
                    ],
                    "id": "12",
                    "metadata": {
                      "Bold": "True",
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "Strikethrough": "single",
                      "frameworkOriginalTagId": "32",
                      "w:b": "<w:b/>",
                      "w:strike": "<w:strike/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 6,
                    "type": "tagPair"
                  },
                  {
                    "text": ".",
                    "type": "text"
                  }
                ],
                "confirmationLevel": "Draft",
                "isLocked": false,
                "segmentNumber": "10",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "kBguG4Byt8KDzLkbntvGIHoJHFQ="
                  },
                  "originBeforeAdaptation": {
                    "isStructureContextMatch": false,
                    "matchPercent": 0,
                    "metadata": {
                      "SegmentIdentityHash": "kBguG4Byt8KDzLkbntvGIHoJHFQ="
                    },
                    "originBeforeAdaptation": {
                      "isStructureContextMatch": false,
                      "matchPercent": 0,
                      "metadata": null,
                      "originBeforeAdaptation": null,
                      "originSystem": null,
                      "originType": null,
                      "originalTranslationHash": null,
                      "textContextMatchLevel": null
                    },
                    "originSystem": null,
                    "originType": "source",
                    "originalTranslationHash": null,
                    "textContextMatchLevel": null
                  },
                  "originSystem": null,
                  "originType": "interactive",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "11",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "dpiKpPIDDjfG5rVT67mbQ8EZIaA="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": null,
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "12",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "13",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "14",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "m1xdu6/UlYcTKPKYH4wY3miafjk="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": null,
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              }
            ],
            "id": "11",
            "metadata": {
              "FontSize": "12",
              "ParentTag": "w:r",
              "StartTag": "w:rPr",
              "frameworkOriginalTagId": "26",
              "w:sz": "<w:sz w:val=\"24\"/>",
              "w:szCs": "<w:szCs w:val=\"24\"/>"
            },
            "tagPairDefinitionId": 1,
            "type": "tagPair"
          }
        ],
        "type": "paragraph"
      }
    },
    {
      "contextId": 0,
      "id": "c434586f-a4fe-4f2c-8f8a-39804236e291",
      "index": 4,
      "isLocked": false,
      "isStructure": false,
      "parentFileId": "69b07a3475ba4d9687fd6bb80363cadb",
      "source": {
        "children": [
          {
            "canHide": false,
            "children": [
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "One morning, when ",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "canHide": false,
                        "children": [
                          {
                            "text": "Gregor Samsa",
                            "type": "text"
                          }
                        ],
                        "id": "15",
                        "metadata": {
                          "BackgroundColor": "red",
                          "FontSize": "12",
                          "ParentTag": "w:r",
                          "StartTag": "w:rPr",
                          "TextColor": "FFFFFF",
                          "frameworkOriginalTagId": "50",
                          "w:color": "<w:color w:val=\"FFFFFF\" w:themeColor=\"background1\"/>",
                          "w:highlight": "<w:highlight w:val=\"red\"/>",
                          "w:sz": "<w:sz w:val=\"24\"/>",
                          "w:szCs": "<w:szCs w:val=\"24\"/>"
                        },
                        "tagPairDefinitionId": 8,
                        "type": "tagPair"
                      },
                      {
                        "text": " ",
                        "type": "text"
                      }
                    ],
                    "id": "14",
                    "metadata": {
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "TextColor": "FFFFFF",
                      "frameworkOriginalTagId": "59",
                      "w:color": "<w:color w:val=\"FFFFFF\" w:themeColor=\"background1\"/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 7,
                    "type": "tagPair"
                  },
                  {
                    "text": "woke from troubled dreams, he found himself transformed in his bed into a horrible vermin.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "15",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "He lay on his armour-like back, and if he lifted his head a little he could see ",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "his brown belly",
                        "type": "text"
                      }
                    ],
                    "id": "16",
                    "metadata": {
                      "BackgroundColor": "green",
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "frameworkOriginalTagId": "71",
                      "w:highlight": "<w:highlight w:val=\"green\"/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 9,
                    "type": "tagPair"
                  },
                  {
                    "text": ", slightly domed ",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "and divided",
                        "type": "text"
                      }
                    ],
                    "id": "17",
                    "metadata": {
                      "FontSize": "12",
                      "Italic": "True",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "Underline": "single",
                      "frameworkOriginalTagId": "77",
                      "w:i": "<w:i/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>",
                      "w:u": "<w:u w:val=\"single\"/>"
                    },
                    "tagPairDefinitionId": 10,
                    "type": "tagPair"
                  },
                  {
                    "text": " by arches into stiff sections.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "16",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "The bedding was hardly able to cover it and seemed ready to slide off any moment.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "17",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "His many legs, pitifully thin compared with the size of the rest of him, waved about helplessly as he looked.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "18",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "\"What's happened to me?\"",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "19",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "he thought",
                        "type": "text"
                      }
                    ],
                    "id": "18",
                    "metadata": {
                      "BackgroundColor": "blue",
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "TextColor": "FFFFFF",
                      "frameworkOriginalTagId": "83",
                      "w:color": "<w:color w:val=\"FFFFFF\" w:themeColor=\"background1\"/>",
                      "w:highlight": "<w:highlight w:val=\"blue\"/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 11,
                    "type": "tagPair"
                  },
                  {
                    "text": ".",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "20",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "It wasn't a dream.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "21",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "His room, a proper human room although a little too small, lay peacefully between its four familiar walls.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "22",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "A collection of textile samples lay spread out on the table - Samsa was a travelling salesman - and above it there hung a picture that he had recently cut out of an illustrated magazine and housed in a nice, gilded frame.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "23",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "It showed a lady fitted out with a fur hat and fur boa who sat upright, raising a heavy fur muff that covered the whole of her lower arm towards the viewer.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "24",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "Gregor then turned to look out the window at the dull weather.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "25",
                "type": "segment",
                "wordCount": 0
              }
            ],
            "id": "13",
            "metadata": {
              "FontSize": "12",
              "ParentTag": "w:r",
              "StartTag": "w:rPr",
              "frameworkOriginalTagId": "47",
              "w:sz": "<w:sz w:val=\"24\"/>",
              "w:szCs": "<w:szCs w:val=\"24\"/>"
            },
            "tagPairDefinitionId": 1,
            "type": "tagPair"
          }
        ],
        "type": "paragraph"
      },
      "target": {
        "children": [
          {
            "canHide": false,
            "children": [
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "15",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "text": "He lay on his armour-like back, and if he lifted his head a little he could see ",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "his brown belly",
                        "type": "text"
                      }
                    ],
                    "id": "20",
                    "metadata": {
                      "BackgroundColor": "green",
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "frameworkOriginalTagId": "71",
                      "w:highlight": "<w:highlight w:val=\"green\"/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 9,
                    "type": "tagPair"
                  },
                  {
                    "text": ", slightly domed ",
                    "type": "text"
                  },
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "and divided",
                        "type": "text"
                      }
                    ],
                    "id": "21",
                    "metadata": {
                      "FontSize": "12",
                      "Italic": "True",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "Underline": "single",
                      "frameworkOriginalTagId": "77",
                      "w:i": "<w:i/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>",
                      "w:u": "<w:u w:val=\"single\"/>"
                    },
                    "tagPairDefinitionId": 10,
                    "type": "tagPair"
                  },
                  {
                    "text": " by arches into stiff sections.",
                    "type": "text"
                  }
                ],
                "isLocked": false,
                "segmentNumber": "16",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "CFbKxT+0xPGx7znyTTTpqiKNRVE="
                  },
                  "originBeforeAdaptation": null,
                  "originSystem": null,
                  "originType": "source",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "17",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "18",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "19",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [
                  {
                    "canHide": false,
                    "children": [
                      {
                        "text": "s-a gandit el",
                        "type": "text"
                      }
                    ],
                    "id": "22",
                    "metadata": {
                      "BackgroundColor": "blue",
                      "FontSize": "12",
                      "ParentTag": "w:r",
                      "StartTag": "w:rPr",
                      "TextColor": "FFFFFF",
                      "frameworkOriginalTagId": "83",
                      "w:color": "<w:color w:val=\"FFFFFF\" w:themeColor=\"background1\"/>",
                      "w:highlight": "<w:highlight w:val=\"blue\"/>",
                      "w:sz": "<w:sz w:val=\"24\"/>",
                      "w:szCs": "<w:szCs w:val=\"24\"/>"
                    },
                    "tagPairDefinitionId": 11,
                    "type": "tagPair"
                  },
                  {
                    "text": ".",
                    "type": "text"
                  }
                ],
                "confirmationLevel": "Draft",
                "isLocked": false,
                "segmentNumber": "20",
                "translationOrigin": {
                  "isStructureContextMatch": false,
                  "matchPercent": 0,
                  "metadata": {
                    "SegmentIdentityHash": "53my/YbsFeOO7oM9YjPVb07rh6Y="
                  },
                  "originBeforeAdaptation": {
                    "isStructureContextMatch": false,
                    "matchPercent": 0,
                    "metadata": {
                      "SegmentIdentityHash": "53my/YbsFeOO7oM9YjPVb07rh6Y="
                    },
                    "originBeforeAdaptation": {
                      "isStructureContextMatch": false,
                      "matchPercent": 0,
                      "metadata": null,
                      "originBeforeAdaptation": null,
                      "originSystem": null,
                      "originType": null,
                      "originalTranslationHash": null,
                      "textContextMatchLevel": null
                    },
                    "originSystem": null,
                    "originType": "source",
                    "originalTranslationHash": null,
                    "textContextMatchLevel": null
                  },
                  "originSystem": null,
                  "originType": "interactive",
                  "originalTranslationHash": null,
                  "textContextMatchLevel": null
                },
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "21",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "22",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "23",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "24",
                "type": "segment",
                "wordCount": 0
              },
              {
                "text": " ",
                "type": "text"
              },
              {
                "characterCount": 0,
                "children": [],
                "isLocked": false,
                "segmentNumber": "25",
                "type": "segment",
                "wordCount": 0
              }
            ],
            "id": "19",
            "metadata": {
              "FontSize": "12",
              "ParentTag": "w:r",
              "StartTag": "w:rPr",
              "frameworkOriginalTagId": "47",
              "w:sz": "<w:sz w:val=\"24\"/>",
              "w:szCs": "<w:szCs w:val=\"24\"/>"
            },
            "tagPairDefinitionId": 1,
            "type": "tagPair"
          }
        ],
        "type": "paragraph"
      }
    }
  ];

  return paragraphs;
};

proto.simpleTagPair = function () {
  return {
    "canHide": false,
    "children": [
      {
        "text": "etc",
        "type": "text"
      }
    ],
    "id": "2",
    "metadata": {
      "FontSize": "12",
      "ParentTag": "w:r",
      "StartTag": "w:rPr",
      "TextColor": "FF0000",
      "frameworkOriginalTagId": "5",
      "w:color": "<w:color w:val=\"FF0000\"/>",
      "w:sz": "<w:sz w:val=\"24\"/>",
      "w:szCs": "<w:szCs w:val=\"24\"/>"
    },
    "tagPairDefinitionId": 2,
    "type": "tagPair"
  };
};

module.exports = SideBySideParagraphUnitsRendererFixture;
},{}],105:[function(require,module,exports){
/* File: CommandManager_test.js */
/* jshint undef: true, unused: true */
/* globals require, describe, it */

'use strict';

var CommandManager = require('../../assets/js/ue/CommandManager');

var sinon = require('sinon');
var assert = require('chai').assert;

describe('CommandManager', function () {
  var commander;

  var commands = {
    single: {
      'test_command': {
        handle: function () {
          return true;
        }
      }
    },

    multiple: {
      'first_test_command': {
        handle: function () {
          return true;
        }
      },
      'second_test_command': {
        handle: function () {
          return true;
        }
      }
    }
  };

  beforeEach(function () {
    commander = new CommandManager();
  });

  describe('constructor', function () {
    it('should instantiate the new class', function () {
      assert.instanceOf(commander, CommandManager, 'and commander will be CommandManager instance');
    });

    it('should have a default "options" property', function () {
      assert.property(commander, 'options');
    });

    it('should have a default "commands" property', function () {
      assert.property(commander, 'commands');
    });

    describe('CommandManager#methods', function () {
      it('should have a "execute" method', function () {
        assert.isFunction(commander.execute, 'CommandManager#execute exist');
      });

      it('should have an "addCommands" method', function () {
        assert.isFunction(commander.addCommands, '');
      });
    });
  });

  describe('CommandManager#addCommands', function () {
    it('should dynamically add one single command', function () {
      commander.addCommands(commands.single);
      assert.isFunction(commander.commands['test_command'].handle);
    });

    it('should dynamically add multiple commands', function () {
      commander.addCommands(commands.multiple);
      assert.isFunction(commander.commands['first_test_command'].handle);
      assert.isFunction(commander.commands['second_test_command'].handle);
    });
  });

  describe('CommandManager#deleteCommands', function () {
    it('should be able to delete commands', function () {
      commander.addCommands(commands.multiple);
      commander.deleteCommands('first_test_command', 'second_test_command');

      assert.isUndefined(commander.execute('first_test_command'), 'first_test_command was not executed');
      assert.isUndefined(commander.execute('second_test_command'), 'second_test_command was not executed');
    });

    it('should exit the execution if command is not available', function () {
      assert.isUndefined(commander.execute('unknown_test_command'), 'unknown_test_command was not executed');
    });
  });

  describe('CommandManager#execute', function () {
    it('should be able to execute available commands', function () {
      commander.addCommands(commands.multiple);
      assert.isTrue(commander.execute('first_test_command'), 'first_test_command was executed');
      assert.isTrue(commander.execute('second_test_command'), 'second_test_command was executed');
    });

    it('should exit the execution if command is not available', function () {
      assert.isUndefined(commander.execute('unknown_test_command'), 'unknown_test_command was not executed');
    });
  });
});
},{"../../assets/js/ue/CommandManager":2,"chai":46,"sinon":78}],106:[function(require,module,exports){
/* File: DataProvider_test.js */
/* jshint undef: true, unused: true */
/* globals require, describe, it, beforeEach, afterEach */
'use strict';
var DataProvider = require('../../assets/js/ue/DataProvider');
var Mediator = require('../../assets/js/ue/Mediator');
var DataProviderObjectMother = require('../support/DataProviderObjectMother');
var h = require('../../assets/js/ue/Helpers').stringToHTMLElement;

var sinon = require('sinon');
var assert = require('chai').assert;

describe('DataProvider', function () {
  var dataProviderObjectMother;
  beforeEach(function () {
    dataProviderObjectMother = new DataProviderObjectMother();
    DataProvider.init();
  });

  describe('when receives the segment:end-edit message', function () {
    beforeEach(function() {
      sinon.stub(DataProvider, 'saveSegmentChange');
      Mediator.publish('segment:start-edit', {
        el: h('<div class="segment"/>'),
        segmentNumber: '1',
        otherSegmentData: {
          'confirmationlevel': 'draft'
        }
      });
    });

    afterEach(function () {
      DataProvider.saveSegmentChange.restore();
    });

    describe('when the content has changed', function () {
      it('calls DataProvider#saveSegmentChange', function () {
        Mediator.publish('segment:end-edit', {
          el: h('<div class="segment">content has changed</div>'),
          segmentNumber: '1',
          otherSegmentData: {
            'confirmationlevel': 'draft'
          }
        });

        assert(DataProvider.saveSegmentChange.called, 'DataProvider#saveSegmentChange has been called');
      });
    });

    describe('when the status has changed', function () {
      it('calls DataProvider#saveSegmentChange', function () {
        Mediator.publish('segment:end-edit', {
          el: h('<div class="segment"/>'),
          segmentNumber: '1',
          otherSegmentData: {
            'confirmationlevel': 'no-longer-draft'
          }
        });

        assert(DataProvider.saveSegmentChange.called, 'DataProvider#saveSegmentChange has been called');
      });
    });

    describe('when the content and status is unchanged', function () {
      it('does not call DataProvider#saveSegmentChange', function () {
        Mediator.publish('segment:end-edit', {
          el: h('<div class="segment"/>'),
          segmentNumber: '1',
          otherSegmentData: {
            'confirmationlevel': 'draft'
          }
        });

        assert.isFalse(DataProvider.saveSegmentChange.called, 'DataProvider#saveSegmentChange has been called');
      });
    });
  });
});

},{"../../assets/js/ue/DataProvider":3,"../../assets/js/ue/Helpers":5,"../../assets/js/ue/Mediator":10,"../support/DataProviderObjectMother":94,"chai":46,"sinon":78}],107:[function(require,module,exports){
/* File: SegmentCleanup_test.js */
/* globals describe, beforeEach, it */
'use strict';
var SegmentsWatcher = require('../../assets/js/ue/SegmentsWatcher');
var SegmentCleanup = require('../../assets/js/ue/SegmentCleanup');
var NodeWalker = require('../../assets/js/ue/selection/NodeWalker');

var SegmentCleanupFixture = require('../support/SegmentCleanupFixture');

var assert = require('chai').assert;

describe('SegmentCleanup', function () {
  var segmentFixture = new SegmentCleanupFixture(),
      segmentNumber = '1',
      segmentCleanup,
      targetContent,
      walker;

  function cleanupSegment() {
    segmentCleanup = new SegmentCleanup(segmentNumber);
    segmentCleanup.cleanStructure();
  }

  function setupTargetContent(targetContent) {
    SegmentsWatcher.watchSegment(segmentNumber)
      .setTarget(targetContent);
  }

  describe('#cleanStructure', function () {
    describe('when content is before div.inline-content', function () {
      beforeEach(function () {
        targetContent = segmentFixture.contentBeforeInlineContent();
        setupTargetContent(targetContent);
      });

      it('moves content inside div.inline-content', function () {
        cleanupSegment();

        walker = new NodeWalker(targetContent.firstChild);
        assert.isFalse(walker.isTextNode(), 'text node has been moved');
      });
    });

    describe('when content is after div.inline-content', function () {
      beforeEach(function () {
        targetContent = segmentFixture.contentAfterInlineContent();
        setupTargetContent(targetContent);
      });

      it('moves content inside div.inline-content', function () {
        cleanupSegment();

        walker = new NodeWalker(targetContent.lastChild);
        assert.isFalse(walker.isTextNode(), 'text node has been moved');
      });
    });

    describe('when div.inline-content is missing from segment', function () {
      beforeEach(function () {
        targetContent = segmentFixture.segmentWithNoInlineContent();
        setupTargetContent(targetContent);
      });

      it('creates the inline content', function () {
        cleanupSegment();

        walker = new NodeWalker(targetContent.firstChild);
        assert.isTrue(walker.isInlineContent(), 'inline content has been created');
      });
    });

    describe('when text contains placeholder', function () {
      beforeEach(function () {
        targetContent = segmentFixture.placeholderInsideText();
        setupTargetContent(targetContent);
      });

      it('splits the text node', function () {
        var placeholder,
            walker,
            textBefore,
            textAfter;

        cleanupSegment();

        placeholder = targetContent.querySelector('.ue-tag-wrapper');
        walker = new NodeWalker(placeholder);
        textBefore = walker.prev();
        textAfter = walker.next();

        assert(textBefore.isText(), 'text was split before');
        assert(textAfter.isText(), 'text was split after');
      });
    });
  });

});

},{"../../assets/js/ue/SegmentCleanup":15,"../../assets/js/ue/SegmentsWatcher":17,"../../assets/js/ue/selection/NodeWalker":35,"../support/SegmentCleanupFixture":101,"chai":46}],108:[function(require,module,exports){
/* File: SegmentWatcher_test.js */
/* globals describe, beforeEach, afterEach, it */
'use strict';

var h = require('../../assets/js/ue/Helpers').stringToHTMLElement;
var SegmentsWatcher = require('../../assets/js/ue/SegmentsWatcher');
var assert = require('chai').assert;

describe('SegmentWatcher', function () {
  var undefinedTargetSegmentNumber = '10',
      sourceEl = h('<div class="ue-segment"/>'),
      statusEl = h('<div class="ue-status"/>'),
      targetEl = h('<div class="ue-segment"/>');

  describe('getTargetEl', function () {
    var returnedTargetEl,
        segmentNumber = '1';

    it('returns null when the segment number is not watched', function () {

      returnedTargetEl = SegmentsWatcher.getTargetEl(undefinedTargetSegmentNumber);

      assert.isNull(returnedTargetEl, 'target segment has not been found');
    });

    describe('when the segment is watched', function () {
      beforeEach(function () {
        SegmentsWatcher.watchSegment(segmentNumber)
          .setSource(sourceEl)
          .setStatus(statusEl)
          .setTarget(targetEl);
      });

      it('returns the targetEl', function () {
        returnedTargetEl = SegmentsWatcher.getTargetEl(segmentNumber);

        assert.equal(targetEl, returnedTargetEl, 'target segment has been returned');
      });
    });
  });
});
},{"../../assets/js/ue/Helpers":5,"../../assets/js/ue/SegmentsWatcher":17,"chai":46}],109:[function(require,module,exports){
/* File: SideBySideParagraphUnitsRenderer_test.js */
/* jshint undef: true, unused: true */
/* globals require, describe, beforeEach, afterEach, it */
'use strict';
var assert = require('chai').assert;

var config = require('../../assets/js/ue/config');

var DataProviderObjectMother = require('../support/DataProviderObjectMother');
var SideBySideParagraphUnitsRenderer = require('../../assets/js/ue/SideBySideParagraphUnitsRenderer');
var SideBySideParagraphUnitsRendererFixture = require('../support/SideBySideParagraphUnitsRendererFixture');

describe('SideBySideParagraphUnitsRenderer ', function () {
  var renderer,
      fixture,
      dataProviderObjectMother,
      ueDocument,
      paragraphs;

  beforeEach(function () {
    fixture = new SideBySideParagraphUnitsRendererFixture();
    dataProviderObjectMother = new DataProviderObjectMother();

    ueDocument = fixture.defaultDocumentSample();
    paragraphs = fixture.defaultParagraphsSample();

    dataProviderObjectMother.hackInitialization(
      paragraphs, ueDocument);

    fixture = new SideBySideParagraphUnitsRendererFixture();
    renderer = new SideBySideParagraphUnitsRenderer(
      paragraphs,
      ueDocument);
  });

  describe('render', function () {
    it('generates the editor content in source and target columns', function () {
      var sourceEditableColumn,
          targetEditableColumn;

      renderer.render();

      sourceEditableColumn = renderer.sourceEditableColumn;
      targetEditableColumn = renderer.targetEditableColumn;

      assert.isNotNull(sourceEditableColumn, 'sourceEditableColumn is assigned to');
      assert.isNotNull(targetEditableColumn, 'targetEditableColumn is assigned to');

      assert.instanceOf(sourceEditableColumn, jQuery, 'sourceEditableColumn is jquery object');
      assert.instanceOf(targetEditableColumn, jQuery, 'targetEditableColumn is jquery object');
    });

  });

  describe('#_renderTagPair', function (){
    it('renders the elements that form a tag', function () {
      var tagPair = fixture.simpleTagPair(),
          tagPairRender;

      tagPairRender = renderer._renderTagPair(tagPair);

      assert.isNotNull(tagPairRender);
      assert.lengthOf(tagPairRender, 3, 'start-tag, content, end-tag are rendered');
    });

    it('renders the elements as jQuery objects', function () {
      var tagPair = fixture.simpleTagPair(),
          tagPairRender;

      tagPairRender = renderer._renderTagPair(tagPair);

      assert.instanceOf(tagPairRender[0], jQuery, 'start-tag is rendered as a jQuery object');
      assert.instanceOf(tagPairRender[1], jQuery, 'start-tag is rendered as a jQuery object');
      assert.instanceOf(tagPairRender[2], jQuery, 'start-tag is rendered as a jQuery object');
    });

    it('adds the canHide as a data attribute', function () {
      var tagPair = fixture.simpleTagPair(),
          tagPairRender,
          startTag, startTagEl,
          endTag, endTagEl;

      tagPairRender = renderer._renderTagPair(tagPair);

      startTag = tagPairRender[0];
      startTagEl = startTag[0];
      endTag = tagPairRender[2];
      endTagEl = endTag[0];

      assert.equal(startTagEl.dataset.canHide, 'false', 'startTag has canHide');
      assert.equal(endTagEl.dataset.canHide, 'false', 'endTag has canHide');
    });

    describe('when canHideIsTrue and tag formatting is hidden by default', function () {
      var tagPair,
          tagPairRender,
          startTag, startTagEl,
          endTag, endTagEl;

      beforeEach(function () {
        config.tagDisplayContext.showFormatting = false;
        tagPair = fixture.simpleTagPair();
        tagPair.canHide = true;
      });

      afterEach(function () {
        tagPair.canHide = false;
      });

      it('adds .hide as a CSS class', function () {

        tagPairRender = renderer._renderTagPair(tagPair);

        startTag = tagPairRender[0];
        startTagEl = startTag[0];
        endTag = tagPairRender[2];
        endTagEl = endTag[0];

        assert.isTrue(startTagEl.classList.contains('hide'), 'startTag has CSS class hide');
        assert.isTrue(endTagEl.classList.contains('hide'), 'endTag has CSS class hide');
      });
    });

    describe('when canHideIsTrue and tag formatting is not hidden by default', function () {
      var tagPair,
          tagPairRender,
          startTag, startTagEl,
          endTag, endTagEl;

      beforeEach(function () {
        config.tagDisplayContext.showFormatting = true;
        tagPair = fixture.simpleTagPair();
        tagPair.canHide = true;
      });

      afterEach(function () {
        tagPair.canHide = false;
      });

      it('does not add .hide as a CSS class', function () {

        tagPairRender = renderer._renderTagPair(tagPair);

        startTag = tagPairRender[0];
        startTagEl = startTag[0];
        endTag = tagPairRender[2];
        endTagEl = endTag[0];

        assert.isFalse(startTagEl.classList.contains('hide'), 'startTag has no CSS class hide');
        assert.isFalse(endTagEl.classList.contains('hide'), 'endTag has no CSS class hide');
      });
    });
  });
});
},{"../../assets/js/ue/SideBySideParagraphUnitsRenderer":19,"../../assets/js/ue/config":25,"../support/DataProviderObjectMother":94,"../support/SideBySideParagraphUnitsRendererFixture":104,"chai":46}],110:[function(require,module,exports){
/* File: Tmpl_test.js */
/* globals describe, beforeEach, it*/
'use strict';
var Tmpl = require('../../assets/js/ue/Tmpl');
var NodeWalker = require('../../assets/js/ue/selection/NodeWalker');

var assert = require('chai').assert;

describe('Tmpl', function () {
  describe('#buldSegmentInlineContent', function () {
    var inlineContent,
        nodeWalker;

    beforeEach(function () {
      inlineContent = Tmpl.buildSegmentInlineContent();
      nodeWalker = new NodeWalker(inlineContent);
    });

    it('builds the inline content for a segment', function () {
      assert.isTrue(nodeWalker.isInlineContent(), 'inline content has been built');
    });

    it('adds a zwnj character as the first child', function () {
      nodeWalker = nodeWalker.firstChild();

      assert.isTrue(nodeWalker.isInvisibleChar(), 'invisible character was added to the structure');
    });
  });
});
},{"../../assets/js/ue/Tmpl":21,"../../assets/js/ue/selection/NodeWalker":35,"chai":46}],111:[function(require,module,exports){
var assert = require('chai').assert;
var sinon = require('sinon');

var KeyboardBindings = require('../../../assets/js/ue/KeyboardBindings');
var SegmentsWatcher = require('../../../assets/js/ue/SegmentsWatcher');
var ShiftEnterHandler = require('../../../assets/js/ue/keyboard/ShiftEnterHandler');

var FakeEvent = require('../../support/FakeEvent');
var ShiftEnterHandlerFixture = require('../../support/ShiftEnterHandlerFixture');
var SelectionContextObjectMother = require('../../support/SelectionContextObjectMother');
var Selection = require('../../../assets/js/ue/selection');

describe('Keyboard: ShiftEnterHandler', function () {
  "use strict";
  var fakeEvent,
      handle,
      keys = KeyboardBindings.prototype,
      selectionObjectMother,
      selectionContext,
      fixture = new ShiftEnterHandlerFixture(),
      sample;

  beforeEach(function () {
    handle = function (ev) {
      new ShiftEnterHandler(ev);
    };

    selectionObjectMother = new SelectionContextObjectMother();
    selectionContext = selectionObjectMother.stubSelectionContext();

    sinon.stub(SegmentsWatcher, 'resize');
  });

  afterEach(function () {
    selectionObjectMother.restoreSelectionContext();
    SegmentsWatcher.resize.restore();
  });

  describe('when the expected shift+enter combination was pressed', function () {

    function breakIsMovedWithinInlineContentBeforeText () {
      var brIsInsideInlineContent,
          inlineContent = sample.childNodes[1],
          nodeWalker = new Selection.NodeWalker(inlineContent.firstChild);

      brIsInsideInlineContent = nodeWalker.isElement('br');

      return brIsInsideInlineContent;
    }

    beforeEach(function () {
      fakeEvent = new FakeEvent();
      fakeEvent.setShiftKey(true);
      fakeEvent.setKeyCode(keys.keyEnter);
    });
    describe('Chrome generates a <br> at the invisible character position inside the ue-segment container', function () {
      beforeEach(function () {
        sample = fixture.breakAtSegmentStartSample();
        selectionContext.focusNode = sample.firstChild;
      });

      afterEach(function () {
      });

      it('moves the segment start <br> inside inline content container to allow it to be processed', function () {
        handle(fakeEvent);

        assert.isTrue(breakIsMovedWithinInlineContentBeforeText(), '<br> is moved to the proper container');
      });

    });

    describe('when Chrome inserts carriage return inside span ue-tag', function () {
      it('converts the \n inside start tag to <br> and moves it after the tag-wrapper', function () {
        // Arrange
        sample = fixture.newLineInsideStartTagWrapperSample();
        selectionContext.focusNode = sample.firstChild;

        // Act
        handle(fakeEvent);

        // Assert
        assert.isTrue(breakIsAddedToInlineContent(), '<br> is moved to the proper container');
      });

      it('converts the \n inside end tag to <br> and moves it after the tag-wrapper', function () {
        // Arrange
        sample = fixture.newLineInsideEndTagWrapperSample();
        selectionContext.focusNode = sample.firstChild;

        // Act
        handle(fakeEvent);

        // Assert
        assert.isTrue(breakIsAddedToInlineContent(), '<br> is moved to the proper container');
      });

      function breakIsAddedToInlineContent(){
        var nodeWalker=  new Selection.NodeWalker(sample);
        var processingQueue = [nodeWalker];
        var breakFoundInsideInlineContent;

        while(processingQueue.length > 0){
          nodeWalker = processingQueue.pop();

          if(!nodeWalker.next().isNull()){
            processingQueue.push(nodeWalker.next());
          }

          if(!nodeWalker.firstChild().isNull()){
            processingQueue.push(nodeWalker.firstChild());
          }

          if(nodeWalker.isElement("br") && nodeWalker.parent().isInlineContent()){
            breakFoundInsideInlineContent = true;
          }
        }
        return breakFoundInsideInlineContent;
      }
    });

    describe('when Chrome inserts carriage return inside a text', function () {

      it('converts those carriage returns to <br> elements', function () {
        var sample = fixture.newLinesInsideTextContainer();
        var breakElementsInserted;
        selectionContext.focusNode = sample.firstChild;

        handle(fakeEvent);

        breakElementsInserted = sample.querySelectorAll('br');
        assert.lengthOf(breakElementsInserted, 1, 'new line converted to break');
      });

    });

    describe('when Firefox inserts <br> inside ue-tag-wrapper', function () {
      it('moves <br> after the start tag-wrapper', function () {
        var sample = fixture.startTagWithBreak();
        var breakElement;
        var nodeWalker;
        selectionContext.focusNode = sample;

        handle(fakeEvent);

        breakElement = sample.querySelector('br');
        nodeWalker = new Selection.NodeWalker(breakElement);
        nodeWalker = nodeWalker.prev();

        assert.isTrue(nodeWalker.isStartTag(), '<br> was moved after end tag');
      });

      it('moves <br> after the end tag-wrapper', function () {
        var sample = fixture.endTagWithBreak();
        var breakElement;
        var nodeWalker;
        selectionContext.focusNode = sample;

        handle(fakeEvent);

        breakElement = sample.querySelector('br');
        nodeWalker = new Selection.NodeWalker(breakElement);
        nodeWalker = nodeWalker.prev();

        assert.isTrue(nodeWalker.isEndTag(), '<br> was moved after end tag');
      });
    });

    describe('when segment is empty', function () {
      it('moves the br inside the inline content', function(){
        var sample = fixture.emptySegment();
        var breakElement,
            nodeWalker;
        selectionContext.focusNode = sample;

        handle(fakeEvent);

        breakElement = sample.querySelector('br');
        nodeWalker = new Selection.NodeWalker(breakElement);
        assert.isTrue(nodeWalker.parent().isInlineContent(), 'br was moved to the empty inline content')
      });
    });
  });

  describe('when shift+enter is not pressed', function () {
    beforeEach(function () {
      fakeEvent = new FakeEvent();
    });

    it('does nothing when enter is pressed', function () {
      fakeEvent.setKeyCode(keys.keyEnter);

      handle(fakeEvent);

      assert.isFalse(fakeEvent.hasPreventedDefault, 'Event#preventDefault has not been called');
    });

    it('does nothing when shift is pressed', function () {
      fakeEvent.setShiftKey(true);

      handle(fakeEvent);

      assert.isFalse(fakeEvent.hasPreventedDefault, 'Event#preventDefault has not been called');
    });
  });


});
},{"../../../assets/js/ue/KeyboardBindings":7,"../../../assets/js/ue/SegmentsWatcher":17,"../../../assets/js/ue/keyboard/ShiftEnterHandler":28,"../../../assets/js/ue/selection":34,"../../support/FakeEvent":95,"../../support/SelectionContextObjectMother":102,"../../support/ShiftEnterHandlerFixture":103,"chai":46,"sinon":78}],112:[function(require,module,exports){
var assert = require('chai').assert;

var SelectionContextObjectMother = require('../../support/SelectionContextObjectMother');
var FakeEvent = require('../../support/FakeEvent');

describe('KeyboardBindings#handleClearTagsShortcutPreventsDefault', function () {
  "use strict";

  var
    handleClearTagsShortcutPreventsDefault,

    objectMother,
    fakeEvent;

  beforeEach(function () {
    objectMother = new SelectionContextObjectMother();

    fakeEvent = new FakeEvent();

    fakeEvent.setCtrlKey(true);
    fakeEvent.setKeyCode(objectMother.keyboardBindings.keySpace);

    objectMother.setupEmptyCloneContents();
    handleClearTagsShortcutPreventsDefault = function () {
      objectMother.keyboardBindings.handleClearTagsShortcutPreventsDefault(fakeEvent);
    };
  });

  afterEach(function () {
  });


  describe("when the current selection is cross segment selection", function () {
    beforeEach(function () {
      objectMother.setCrossSegmentSelectionTo(true);
    });

    afterEach(function () {
      objectMother.resetCrossSegmentSelection();
    });

    it('does nothing', function () {
      handleClearTagsShortcutPreventsDefault();

      assert.isFalse(fakeEvent.hasPreventedDefault, 'KeyboardEvent#PreventDefault has been called');
    });
  });

  describe('when the current selection is collapsed', function () {

    beforeEach(function () {
      objectMother.setCollapsedSelection();
    });

    afterEach(function () {
      objectMother.restoreSelectionContext();
    });

    it('does nothing', function () {
      handleClearTagsShortcutPreventsDefault();

      assert.isFalse(fakeEvent.hasPreventedDefault, 'KeyboardEvent#PreventDefault has been called');
    });
  });

  describe('when the CTRL + Space combination is not pressed', function () {
    beforeEach(function () {
      objectMother.stubSelectionContext();
      fakeEvent.ctrlKey = false;
    });
    afterEach(function(){
      objectMother.restoreSelectionContext();
    });

    it('does nothing', function () {
      handleClearTagsShortcutPreventsDefault();

      assert.isFalse(fakeEvent.hasPreventedDefault, 'KeyboardEvent#PreventDefault has been called');
    });
  });

  describe('when the commonAncestor is same as endContainer and startContainer ', function () {
    beforeEach(function () {
      objectMother.setupSameContainerForSelection();
    });

    afterEach(function () {
      objectMother.restoreSelectionContext();
    });

    it('prevents the default browser action', function () {
      handleClearTagsShortcutPreventsDefault();
      assert.isTrue(fakeEvent.hasPreventedDefault, 'KeyboardEvent#PreventDefault has been called');
    });
  });
});

},{"../../support/FakeEvent":95,"../../support/SelectionContextObjectMother":102,"chai":46}],113:[function(require,module,exports){
var assert = require('chai').assert;

var Helpers = require('../../../assets/js/ue/Helpers');
var FakeEvent = require('../../support/FakeEvent');
var HandleClearTagsFixtures = require('../../support/HandleClearTagsFixtures')
var KeyboardBindings = require('../../../assets/js/ue/KeyboardBindings');
var Selection = require('../../../assets/js/ue/selection');
var SegmentsWatcher = require('../../../assets/js/ue/SegmentsWatcher');

describe('KeyboardBindings#handleClearTags acceptance', function(){
  var body,
    fixtureHost,
    fixtures,
    tagPairSample,
    selection,
    range;

  var kb, fakeEvent;

  beforeEach(function(){
    body = document.body;
    fixtureHost = Helpers.stringToHTMLElement('<div class="fixture-host hidden ue-editable" contenteditable="on"></div>');
    fixtures = new HandleClearTagsFixtures();
    tagPairSample = fixtures.tagPairSample();

    body.appendChild(fixtureHost);

    kb = new KeyboardBindings();

    fakeEvent = new FakeEvent();
    fakeEvent.setCtrlKey(true);
    fakeEvent.setKeyCode(kb.keySpace);
  });

  describe('when selection starts before a tag pair, and ends inside tag pair', function(){
    beforeEach(function(){
      var ueTextStart,
          ueTagPairContent,
          ueTagPairText,
          startTextNode,
          endTextNode;

      fixtureHost.appendChild(tagPairSample);
      selection = document.getSelection();
      range = newRange();
      ueTextStart = tagPairSample.firstChild;
      ueTagPairContent = tagPairSample.childNodes[2];
      ueTagPairText = ueTagPairContent.firstChild;

      startTextNode = ueTextStart.firstChild;
      endTextNode = ueTagPairText.firstChild;

      assignRange(startTextNode, endTextNode);
    });

    afterEach(function () {
      selection.removeAllRanges();
      fixtureHost.innerHTML = "";
    });

    it('will break the text at the start of the selection in two parts', function(){
      kb.handleClearTags(fakeEvent);

      var ueText = new Selection.NodeWalker(tagPairSample.firstChild.nextSibling);
      assert.equal(ueText.el.textContent, "xt");
    });

    it('will move the text selected in the tag pair, outside', function(){
      kb.handleClearTags(fakeEvent);

      var nodeWalker = new Selection.NodeWalker(tagPairSample.firstChild.nextSibling);
      var ueText = nodeWalker.next();
      assert(ueText.isText(), 'The sample has ue-text as the third child');
      assert.equal(ueText.el.textContent, "inner ");
    });

    it('will move the tag pair start wrapper after the selected text', function(){
      kb.handleClearTags(fakeEvent);

      var nodeWalker = new Selection.NodeWalker(tagPairSample.firstChild.nextSibling.nextSibling);
      var startTagWrapper = nodeWalker.next();
      assert(startTagWrapper.isStartTag(), 'The sample has startTag as the fourth child"');
    });
  });

  describe('when selection starts inside a tag pair and continues outside of it', function(){
    beforeEach(function () {
      var tagPairContent,
        ueTextEnd,
        ueTextStart,
        startTextNode,
        endTextNode;

      fixtureHost.appendChild(tagPairSample);

      tagPairContent = tagPairSample.childNodes[2];
      ueTextEnd = tagPairSample.lastChild;

      ueTextStart = tagPairContent.firstChild;

      startTextNode = ueTextStart.firstChild;
      endTextNode = ueTextEnd.firstChild;

      assignRange(startTextNode, endTextNode);
    });

    afterEach(function(){
      selection.removeAllRanges();
      fixtureHost.innerHTML = "";
    });

    it('moves the end tag at the front of the selection', function(){
      kb.handleClearTags(fakeEvent);
      var nodeWalker = new Selection.NodeWalker(tagPairSample.childNodes[3]);
      assert(nodeWalker.isEndTag(), 'end tag preserved before the start of the selection');
    });

    it('moves content out of the tag pair container', function(){
      kb.handleClearTags(fakeEvent);
      var ueText = new Selection.NodeWalker(tagPairSample.childNodes[4]);
      assert(ueText.isText(), 'text was moved outside of the tag pair container');
      assert.equal(ueText.el.textContent, 'content');
    });
  });

  describe('when tag pair is inside selection', function(){

    beforeEach(function(){
      var ueTextStart,
        ueTextEnd, startTextNode, endTextNode,
        tagPairStart, tagPairEnd,
        segmentWatcher;
      segmentWatcher = SegmentsWatcher;
      tagPairStart = tagPairSample.childNodes[1];
      tagPairEnd = tagPairSample.childNodes[3];
      segmentWatcher.addTagPair(tagPairStart.dataset.id, [tagPairStart, tagPairEnd]);

      fixtureHost.appendChild(tagPairSample);

      ueTextStart = tagPairSample.firstChild;
      ueTextEnd = tagPairSample.lastChild;

      startTextNode = ueTextStart.firstChild;
      endTextNode = ueTextEnd.firstChild;

      assignRange(startTextNode, endTextNode);
    });

    afterEach(function(){
      selection.removeAllRanges();
      fixtureHost.innerHTML = "";
    });


    it('remove the tag pair', function(){
      var nw = Selection.NodeWalker,
          hasTagPair;

      kb.handleClearTags(fakeEvent);

      hasTagPair = _(tagPairSample.childNodes).any(function(node){
        var nodeWalker = new nw(node);

        return nodeWalker.isTagPairContainer() || nodeWalker.isTag();
      });

      assert.isFalse(hasTagPair, 'no tag pair found in transformed sample');
    });
  });

  function assignRange(startTextNode, endTextNode){
    range = newRange();

    range.setStart(startTextNode, startTextNode.length /2);
    range.setEnd(endTextNode, endTextNode.length / 2);

    selection.addRange(range);
  }

  function newRange(){
    return document.createRange();
  }
});
},{"../../../assets/js/ue/Helpers":5,"../../../assets/js/ue/KeyboardBindings":7,"../../../assets/js/ue/SegmentsWatcher":17,"../../../assets/js/ue/selection":34,"../../support/FakeEvent":95,"../../support/HandleClearTagsFixtures":99,"chai":46}],114:[function(require,module,exports){
var assert = require('chai').assert;
var SelectionContextObjectMother = require('../../support/SelectionContextObjectMother');
var FakeEvent = require('../../support/FakeEvent');

describe('KeyboardBindings#handleClearTags', function () {
  "use strict";

  var
      handleClearTags,

      objectMother,
      fakeEvent;

  beforeEach(function () {
    objectMother = new SelectionContextObjectMother();
    objectMother.stubSelection();

    fakeEvent = new FakeEvent();

    fakeEvent.setCtrlKey(true);
    fakeEvent.setKeyCode(objectMother.keyboardBindings.keySpace);

    objectMother.setupEmptyCloneContents();
    handleClearTags = function () {
      objectMother.keyboardBindings.handleClearTags(fakeEvent);
    };
  });

  afterEach(function () {
    objectMother.restoreSelection();
  });

  describe("when the current selection is cross segment selection", function () {
    beforeEach(function () {
      objectMother.setCrossSegmentSelectionTo(true);
    });

    afterEach(function () {
      objectMother.resetCrossSegmentSelection();
    });

    it('does nothing', function () {
      handleClearTags();

      assert.isFalse(objectMother.stubSelectionContext.deleteContents.called, 'SelectionContext#deleteContents was called')
    });
  });

  describe('when the current selection is collapsed', function () {

    beforeEach(function () {
      objectMother.setCollapsedSelection();
    });

    afterEach(function () {
      objectMother.restoreSelectionContext();
    });

    it('does nothing', function () {
      handleClearTags();

      assert.isFalse(objectMother.stubSelectionContext.deleteContents.called, 'SelectionContext#deleteContents was called')
    });
  });

  describe('when the CTRL + Space combination is not pressed', function () {
    beforeEach(function () {
      objectMother.stubSelectionContext();
      fakeEvent.ctrlKey = false;
    });
    afterEach(function(){
      objectMother.restoreSelectionContext();
    });

    it('does nothing', function () {
      handleClearTags();

      assert.isFalse(objectMother.stubSelectionContext.deleteContents.called, 'SelectionContext#deleteContents was called')
    });
  });

  describe('when the commonAncestor is same as endContainer and startContainer ', function () {
    beforeEach(function () {
      objectMother.setupSameContainerForSelection();
    });

    afterEach(function () {
      objectMother.restoreSelectionContext();
    });

    it('does nothing', function () {
      handleClearTags();

      assert.isFalse(objectMother.stubSelectionContext.deleteContents.called, 'SelectionContext#deleteContents was called')
    });
  });

  describe('when the startContainer is different from commonAncestor', function () {
    beforeEach(function () {
      objectMother.setupSimpleAncestorStartContainer();
      objectMother.spyKeyboardBindingsMethod('identifyTagsInContainer');
      objectMother.spyKeyboardBindingsMethod('transformTags');
    });
    afterEach(function () {
      objectMother.restoreSelectionContext();
      objectMother.restoreKeyboardBindingsMethod('identifyTagsInContainer');
      objectMother.restoreKeyboardBindingsMethod('transformTags');
    });

    it('calls identifyTagsInContainer', function () {
      handleClearTags();
      assert(objectMother.keyboardBindingsSpy('identifyTagsInContainer').called,
          'expected identifyTagsInContainer to have been called');
    });

    it('calls transformTags', function () {
      handleClearTags();
      assert(objectMother.keyboardBindingsSpy('transformTags').called,
          'expected identifyTagsInContainer to have been called');
    });

    describe('when transformTags has tags that need to be move', function () {
      it('calls NodeWalker#remove for tags in moveTagsToEnd', function () {
        objectMother.attachMoveTagsToEndStub();

        handleClearTags();

        assert(objectMother.nodeWalkerStub.remove.called, 'NodeWalker#remove is called');
      });

      it('calls NodeWalker#remove for tags in moveTagsToStart', function () {
        objectMother.attachMoveTagsToFrontStub();

        handleClearTags();

        assert(objectMother.nodeWalkerStub.remove.called, 'NodeWalker#remove is called');

      });

      it('calls SelectionContext#deleteContents when there are tags to move', function () {
        objectMother.attachMoveTagsToFrontStub();

        handleClearTags();

        assert(objectMother.stubSelectionContext.deleteContents.called, 'SelectionContext#deleteContents was called')
      });
    });
  });


});
},{"../../support/FakeEvent":95,"../../support/SelectionContextObjectMother":102,"chai":46}],115:[function(require,module,exports){
var assert = require('chai').assert;
var KeyboardBindingsObjectMother = require('../../support/KeyboardBindingsObjectMother');
var Selection = require('../../../assets/js/ue/selection');

describe('KeyboardBindings#identifyTagsInContainer', function () {
  "use strict";
  var objectMother,
      identifyTagsInContainer,
      nodeWalker,
      end,
      fakeContainerEl,
      startContainer,
      endContainer;

  beforeEach(function () {
    objectMother = new KeyboardBindingsObjectMother();

    objectMother.assignTagsContainer();

    identifyTagsInContainer = function () {
      objectMother.kb.identifyTagsInContainer(nodeWalker, end);
    }
  });

  afterEach(function () {
    objectMother.deleteTagsContainer();
  });

  it('will walk through all nodes', function () {
    var textContainer,
        kb = objectMother.kb;

    // arrange
    fakeContainerEl = objectMother.setupSimpleContainer();
    textContainer = fakeContainerEl.firstChild;
    end = new Selection.NodeWalker(fakeContainerEl.lastChild);

    nodeWalker = new Selection.NodeWalker(textContainer);
    // act
    identifyTagsInContainer();

    //assert
    assert.isTrue(kb.endContainerReached, 'expected to reach end container');
  });

  describe('when collecting start tags', function () {
    var collectedTag;

    beforeEach(function(){
      fakeContainerEl = objectMother.singleStartTagSample();
      startContainer = fakeContainerEl.firstChild;
      endContainer = fakeContainerEl.lastChild;

      nodeWalker = new Selection.NodeWalker(startContainer);
      end = new Selection.NodeWalker(endContainer);
    });

    it('will collect start tags if they can hide', function () {
      // arrange
      // act
      identifyTagsInContainer();
      // assert
      assert.isTrue(objectMother.hasCollectedTag("1"));
    });

    it('does not register end tag', function () {
      // arrange
      // act
      identifyTagsInContainer();
      // assert
      collectedTag = objectMother.getTag("1");
      assert.isNull(collectedTag.endTag);
    });

    it('stores the startTag as a NodeWalker', function(){
      // arrange
      // act
      identifyTagsInContainer();
      // assert
      collectedTag = objectMother.getTag("1");
      assert.instanceOf(collectedTag.startTag, Selection.NodeWalker, 'start tag is instance of NodeWalker');
    });
  });

  describe('when collecting endTags', function(){
    var collectedTag;

    beforeEach(function(){
      fakeContainerEl = objectMother.singleEndTagSample();
      startContainer = fakeContainerEl.firstChild.nextSibling;// selection starts in tag-pair-container
      endContainer = fakeContainerEl.lastChild;// ends in text node

      nodeWalker = new Selection.NodeWalker(startContainer);
      end = new Selection.NodeWalker(endContainer);
    });

    it('will collect end tags if they can hide', function () {
      // arrange
      // act
      identifyTagsInContainer();
      // assert
      assert.isTrue(objectMother.hasCollectedTag("1"));
    });

    it('does not register start tag', function () {
      // arrange
      // act
      identifyTagsInContainer();
      // assert
      collectedTag = objectMother.getTag("1");
      assert.isNull(collectedTag.startTag);
    });

    it('stores the endTag as a NodeWalker', function(){
      // arrange
      // act
      identifyTagsInContainer();
      // assert
      collectedTag = objectMother.getTag("1");
      assert.instanceOf(collectedTag.endTag, Selection.NodeWalker, 'end tag is instance of NodeWalker');
    });
  });

  describe('when start tag and end tag are inside the same container', function(){
    var kb;
    beforeEach(function(){
      fakeContainerEl = objectMother.singleEndTagSample();
      startContainer = fakeContainerEl.firstChild;
      endContainer = fakeContainerEl.lastChild;

      nodeWalker = new Selection.NodeWalker(startContainer);
      end = new Selection.NodeWalker(endContainer);

      objectMother.stubRemoveInline();
      kb = objectMother.kb;
    });

    afterEach(function(){
      objectMother.resetRemoveInlineStub();
    });

    it('calls KeyboardBindings#_removeInline with end tag element', function(){
      // arrange
      // act
      identifyTagsInContainer();
      // assert
      var element = kb._removeInline.getCall(0).args[0];
      assert(kb._removeInline.called, '_remove inline method was called');
      assert.equal(element.dataset.type, 'end-tag');
    });

    it('removes the tagId from tags', function(){
      // arrange
      // act
      identifyTagsInContainer();
      // assert
      assert.isUndefined(objectMother.getTag('1'));
    });
  });
});
},{"../../../assets/js/ue/selection":34,"../../support/KeyboardBindingsObjectMother":100,"chai":46}],116:[function(require,module,exports){
var assert = require('chai').assert;
var CrossSegmentSelectionObjectMother = require('../../support/CrossSegmentSelectionObjectMother');

describe('KeyboardBindings#isCrossSegmentSelection', function(){
  var isCrossSegmentSelection,
      objectMother,
      result;

  isCrossSegmentSelection = function(){
    return objectMother.keyboardBindings.isCrossSegmentSelection();
  };

  beforeEach(function(){
    objectMother = new CrossSegmentSelectionObjectMother();
  });

  describe(' when commonAncestor is ue-editable', function(){
    beforeEach(function(){
      objectMother.setupSelectionContextToHaveCommonAncestor('ue-editable');
    });

    afterEach(function(){
      objectMother.resetSelectionContext();
    });

    it('returns true', function(){
      result = isCrossSegmentSelection();

      assert.isTrue(result);
    });
  });

  describe(' when commonAncestor is not ue-editable', function(){
    beforeEach(function(){
      objectMother.setupSelectionContextToHaveCommonAncestor('ue-inline-content');
    });

    afterEach(function(){
      objectMother.resetSelectionContext();
    });

    it('returns false', function(){
      result = isCrossSegmentSelection();

      assert.isFalse(result);
    });
  });
});

},{"../../support/CrossSegmentSelectionObjectMother":93,"chai":46}],117:[function(require,module,exports){
var assert = require('chai').assert;
var KeyboardBindingsObjectMother = require('../../support/KeyboardBindingsObjectMother');
var Selection = require('../../../assets/js/ue/selection');
var Helpers = require('../../../assets/js/ue/Helpers');

describe('KeyboardBindings#transformTags',function(){
  "use strict";

  var objectMother,
      transformTags,
      documentFragmentWalker,
      documentFragment;

  beforeEach(function(){
    objectMother = new KeyboardBindingsObjectMother();

    transformTags = function(){
      documentFragmentWalker = new Selection.NodeWalker(documentFragment);
      objectMother.kb.transformTags(documentFragmentWalker);
    };

    objectMother.assignTagsContainer();

    setupCodeSample();
  });

  afterEach(function(){
    objectMother.deleteTagsContainer();
  });

  describe('when tags contain the tag id', function(){
    beforeEach(function(){
      objectMother.kb.tags["1"] = {};
    });
    afterEach(function(){
      delete objectMother.kb.tags["1"];
    });
    it('replaces tag pair content with inner content', function(){
      // arrange
      // act
      transformTags();
      // assert
      assert(!tagPairFoundInDocumentFragment(), 'there are no tag containers in document fragment');
    });
    it('moves start tags to the end tags collection', function(){
      // arrange
      // act
      transformTags();
      // assert
      assert.lengthOf(objectMother.kb.moveTagsToEnd, 1);

    });
    it('moves end tags to the start tags collection', function(){
      // arrange
      // act
      transformTags();
      // assert
      assert.lengthOf(objectMother.kb.moveTagsToFront, 1);
    });
  });

  function tagPairFoundInDocumentFragment(){
    var walker,
        foundTagContainer = false;
    walker = new Selection.NodeWalker(documentFragment).firstChild();

    do{
      if(walker.isTagPairContainer()){
        foundTagContainer = true;
      }
      walker = walker.next();
    }while(!walker.isNull());
    return foundTagContainer;
  }

  function setupCodeSample(){
    var sample,
        child;

    documentFragment = document.createDocumentFragment();
    sample = Helpers.stringToHTMLElement('<div><span class="ue-text">text</span>'+
    '<span class="ue-tag-wrapper" data-id="1" data-type="start-tag">'+
      '<span class="ue-tag ue-tag-start">cf</span>' +
      '&zwnj;'+
    '</span>' +
    '<div class="ue-inline-content ue-tagpair-content" data-type="tagpair" data-id="1">'+
        '<span class="ue-text">sample</span>' +
    '</div>' +
    '<span class="ue-tag-wrapper" data-id="1" data-type="end-tag">'+
        '<span class="ue-tag ue-tag-start">cf</span>' +
        '&zwnj;'+
    '</span></div>'
    );

    while(sample.childNodes.length > 0){
      child = sample.childNodes[0];
      documentFragment.appendChild(child);
    }
  }
});
},{"../../../assets/js/ue/Helpers":5,"../../../assets/js/ue/selection":34,"../../support/KeyboardBindingsObjectMother":100,"chai":46}],118:[function(require,module,exports){
/* File: MouseCtrlClickHandler_acceptance_test.js */
/* jshint undef: true, unused: true */
/* globals describe, it, beforeEach, afterEach */
'use strict';

var assert = require('chai').assert;
var h = require('../../../assets/js/ue/Helpers').stringToHTMLElement;
var MouseHandlerFixture = require('./MouseHandlersFixture');
var MouseCtrlClickHandler = require('../../../assets/js/ue/mouse/CtrlClickHandler');
var FakeEvent = require('../../support/FakeEvent');
var NodeWalker = require('../../../assets/js/ue/selection').NodeWalker;

describe('MouseCtrlClickHandler:acceptance', function () {
  var source = h('<div class="ue-source"/>'),
    target = h('<div class="ue-target"/>'),
    fixture,
    fixtureEl,
    clickedTag,
    targetNode,
    targetOffsetRangeStart = 2,
    targetOffsetRangeEnd = 5,
    selection,
    range,
    ctrlClickHandler,
    ev = new FakeEvent(),
    expectedTagInTarget;

  function tagPairFixtureSetup() {
    source.appendChild(fixture.sourceWithTagPair());
    target.appendChild(fixture.targetWithText());

    clickedTag = source.querySelector('.ue-tag-wrapper');
    targetNode = target.querySelector('.ue-text').childNodes[0];

    fixtureEl.appendChild(source);
    fixtureEl.appendChild(target);
    document.body.appendChild(fixtureEl);

    ctrlClickHandler = new MouseCtrlClickHandler();

    ev.setCurrentTarget(clickedTag);
    ev.setCtrlKey(true);
    ev.setLeftButtonPressed();
  }

  function placeholderFixtureSetup() {
    source.appendChild(fixture.sourceWithPlaceholder());
    target.appendChild(fixture.targetWithText());


    clickedTag = source.querySelector('.ue-tag-wrapper');
    targetNode = target.querySelector('.ue-text').childNodes[0];

    fixtureEl.appendChild(source);
    fixtureEl.appendChild(target);
    document.body.appendChild(fixtureEl);

    ctrlClickHandler = new MouseCtrlClickHandler();

    ev.setCurrentTarget(clickedTag);
    ev.setCtrlKey(true);
    ev.setLeftButtonPressed();
  }

  function rangeSelection() {
    selection = document.getSelection();
    range = document.createRange();
    // caret selection
    range.setStart(targetNode, targetOffsetRangeStart);
    range.setEnd(targetNode, targetOffsetRangeEnd);

    selection.removeAllRanges();
    selection.addRange(range);
  }

  function caretSelection() {
    selection = document.getSelection();
    range = document.createRange();
    // caret selection
    range.setStart(targetNode, targetOffsetRangeStart);
    range.setEnd(targetNode, targetOffsetRangeStart);

    selection.removeAllRanges();
    selection.addRange(range);
  }

  function documentCleanup() {
    document.body.removeChild(fixtureEl);
    source.innerHTML = '';
    target.innerHTML = '';
    fixture.innerHTML = '';
  }

  beforeEach(function () {
    fixture = new MouseHandlerFixture();
    fixtureEl = h('<div id="fixture"/>');
  });

  describe('tag pair copy behavior', function () {
    afterEach(function () {
      documentCleanup();
    });

    beforeEach(function () {
      tagPairFixtureSetup();
      rangeSelection();
    });

    it('copies selected start tag pair from source to target', function () {

      ctrlClickHandler.handle(ev);

      expectedTagInTarget = target.querySelector('.ue-tag-wrapper');

      assert.equal(expectedTagInTarget.dataset.type, 'start-tag', 'start tag is moved in target segment');
    });

    it('removes .active css class from start tag', function () {
      clickedTag.firstChild.classList.add('active');

      ctrlClickHandler.handle(ev);

      expectedTagInTarget = target.querySelector('.ue-tag-wrapper').firstChild;

      assert.isFalse(expectedTagInTarget.classList.contains('active'), '.active css class was removed from start tag');
    });

    it('changes the canCopy attribute to false on tag start', function () {
      var startTag;

      ctrlClickHandler.handle(ev);

      startTag = target.querySelector('.ue-tag-start').parentNode;
      assert.equal(startTag.dataset.tagCopy, 'false', 'tag copy is set to false');
    });

    it('changes the canCopy attribute to false on tag end', function () {
      var endTag;

      ctrlClickHandler.handle(ev);

      endTag = target.querySelector('.ue-tag-end').parentNode;
      assert.equal(endTag.dataset.tagCopy, 'false', 'tag copy is set to false');
    });

    it('copies selected end tag pair from source to target', function () {
      clickedTag = source.querySelectorAll('.ue-tag-wrapper').item(1);
      ev.setCurrentTarget(clickedTag);

      ctrlClickHandler.handle(ev);

      expectedTagInTarget = target.querySelectorAll('.ue-tag-wrapper').item(1);

      assert.equal(expectedTagInTarget.dataset.type, 'end-tag', 'start tag is moved in target segment');
    });

    it('removes the .active css class from end-tag', function () {
      clickedTag = source.querySelectorAll('.ue-tag-wrapper').item(1);
      clickedTag.firstChild.classList.add('active');
      ev.setCurrentTarget(clickedTag);

      ctrlClickHandler.handle(ev);

      expectedTagInTarget = target.querySelectorAll('.ue-tag-wrapper').item(1).firstChild;

      assert.isFalse(expectedTagInTarget.classList.contains('active'), '.active css class was removed');
    });
  });


  describe('placeholder copy behavior', function () {
    beforeEach(function () {

      placeholderFixtureSetup();

      rangeSelection();
    });

    afterEach(function () {
      documentCleanup();
    });

    it('copies the placeholder from source to target', function () {
      ctrlClickHandler.handle(ev);

      expectedTagInTarget = target.querySelector('.ue-tag-wrapper');

      assert.equal(expectedTagInTarget.dataset.type, 'placeholder', 'start tag is moved in target segment');
    });

    it('removes the .active css class from the placeholder', function () {
      clickedTag.firstChild.classList.add('active');

      ctrlClickHandler.handle(ev);

      expectedTagInTarget = target.querySelector('.ue-tag-wrapper').firstChild;

      assert.isFalse(expectedTagInTarget.classList.contains('active'), '.active css class was removed');
    });

    it('changes the tagCopy to false on placeholder', function () {
      ctrlClickHandler.handle(ev);

      expectedTagInTarget = target.querySelector('.ue-tag-wrapper');

      assert.equal(expectedTagInTarget.dataset.tagCopy, 'false', 'tagCopy has been changed to false');
    });

  });

  describe('placeholder caret position after copy', function () {
    var focusNode;

    beforeEach(function () {
      placeholderFixtureSetup();
      caretSelection();
    });

    afterEach(function () {
      documentCleanup();
    });

    it('places the cursor after the placeholder on the invisible character', function (doneAsync) {
      ctrlClickHandler.handle(ev);

      _.delay(function () {
        selection = document.getSelection();
        focusNode = new NodeWalker(selection.focusNode);
        assert.isTrue(focusNode.isInvisibleChar(), 'focus is set on invisible char');
        doneAsync();
      });
    });

    it('places the cursor inside the placeholder tag', function (doneAsync) {
      var parentNode;
      ctrlClickHandler.handle(ev);

      _.delay(function () {
        selection = document.getSelection();
        focusNode = new NodeWalker(selection.focusNode);
        parentNode = focusNode.parent();
        assert.isTrue(parentNode.isPlaceholder(), 'focus is inside placeholder');
        doneAsync();
      });
    });
  });

  describe('tag pair caret position after copy', function () {
    var focusNode,
        parentNode;

    beforeEach(function () {
      tagPairFixtureSetup();
      caretSelection();
    });

    afterEach(function () {
      documentCleanup();
    });

    it('places the cursor on the invisible character', function (doneAsync) {

      ctrlClickHandler.handle(ev);

      _.delay(function () {
        selection = document.getSelection();
        focusNode = new NodeWalker(selection.focusNode);
        assert.isTrue(focusNode.isInvisibleChar(), 'focus is set on invisible char');
        doneAsync();
      });
    });

    it('places the cursor inside the start tag', function (doneAsync) {

      ctrlClickHandler.handle(ev);

      _.delay(function () {
        selection = document.getSelection();
        focusNode = new NodeWalker(selection.focusNode);
        parentNode = focusNode.parent();
        assert.isTrue(parentNode.isStartTag(), 'invisible text node parent is start tag');
        doneAsync();
      });
    });
  });

  describe('tag pair content selection', function () {
    var focusNode,
        parentNode;

    beforeEach(function () {
      tagPairFixtureSetup();
      rangeSelection();
    });

    afterEach(function () {
      documentCleanup();
    });

    it('selects the inner content', function () {

      ctrlClickHandler.handle(ev);

      selection = document.getSelection();
      focusNode = new NodeWalker(selection.focusNode);
      parentNode = focusNode.parent();
      assert.isTrue(focusNode.isTextNode(), 'focus is set on text node');
      assert.isTrue(parentNode.isInlineContent(), 'focus is inside inline content');
    });

  });
});

},{"../../../assets/js/ue/Helpers":5,"../../../assets/js/ue/mouse/CtrlClickHandler":30,"../../../assets/js/ue/selection":34,"../../support/FakeEvent":95,"./MouseHandlersFixture":121,"chai":46}],119:[function(require,module,exports){
/* File: MouseCtrlClickHandler_test.js */
/* jshint undef: true, unused: true */
/* globals describe, beforeEach, it */
'use strict';
var MouseCtrlClickHandler = require('../../../assets/js/ue/Mouse').CtrlClickHandler;
var MouseHandlersFixture = require('./MouseHandlersFixture');
var assert = require('chai').assert;

describe('MouseCtrlClickHandler', function () {
  var ctrlClickHandler,
      fixture,
      html,
      siblingTag,
      startTagPair,
      endTagPair,
      placeholder,
      inlineContent,
      inlineContentClone,
      tagElements;

  beforeEach(function () {
    ctrlClickHandler = new MouseCtrlClickHandler();
    fixture = new MouseHandlersFixture();
  });

});

},{"../../../assets/js/ue/Mouse":11,"./MouseHandlersFixture":121,"chai":46}],120:[function(require,module,exports){
/* File: CtrlHoverHandler.js */
/* jshint undef: true, unused: true */
/* globals describe, beforeEach, it*/
'use strict';
var Mouse = require('../../../assets/js/ue/Mouse');
var FakeEvent = require('../../support/FakeEvent');

var assert = require('chai').assert;
var h = require('../../../assets/js/ue/Helpers').stringToHTMLElement;

describe('MouseCtrlHoverHandler', function () {
  var mouseEvent,
      currentTarget,
      child,
      mouseCtrlHoverHandler;

  describe('#mouseOver', function () {
    beforeEach(function () {
      currentTarget = h('<div class="ue-tag-wrapper"><span class="ue-tag"/></div>');
      child = currentTarget.firstChild;

      mouseEvent = new FakeEvent();
      mouseEvent.setCtrlKey(true);
      mouseEvent.setType('mouseover');

      mouseEvent.setCurrentTarget(currentTarget);

      mouseCtrlHoverHandler = new Mouse.CtrlHoverHandler();
    });

    it('adds the .active css class to currentTarget children', function () {
      mouseCtrlHoverHandler.mouseOver(mouseEvent);

      assert(child.classList.contains('active'), '.active class has been added to the current target child node');
    });

    describe('when ctrl is not pressed', function () {
      beforeEach(function () {
        mouseEvent.setCtrlKey(false);
      });

      it('does not add the .active css class to currentTarget children', function () {
        mouseCtrlHoverHandler.mouseOver(mouseEvent);

        assert.isFalse(child.classList.contains('active'), '.active class has been added to the current target child node');
      });
    });

    describe('when event.type is not mouseover', function () {
      beforeEach(function () {
        mouseEvent.setType('something-else');
      });

      it('does not add the .active css class to currentTarget children', function () {
        mouseCtrlHoverHandler.mouseOver(mouseEvent);

        assert.isFalse(child.classList.contains('active'), '.active class has been added to the current target child node');
      });
    });
  });

  describe('#mouseLeave', function () {
    beforeEach(function () {
      currentTarget = h('<div class="ue-tag-wrapper"><span class="ue-tag active"/></div>');
      child = currentTarget.firstChild;

      mouseEvent = new FakeEvent();
      mouseEvent.setCtrlKey(true);
      mouseEvent.setType('mouseleave');

      mouseEvent.setCurrentTarget(currentTarget);

      mouseCtrlHoverHandler = new Mouse.CtrlHoverHandler();
    });

    it('removes the .active css class from the current target child nodes', function () {
      mouseCtrlHoverHandler.mouseLeave(mouseEvent);

      assert.isFalse(child.classList.contains('active'), 'the .active class has been removed from the current target child node');
    });

    describe('when the event.type is not mouseleave', function () {
      beforeEach(function () {
        mouseEvent.setType('something-else');
      });
      it('does not remove the .active class', function () {
        mouseCtrlHoverHandler.mouseLeave(mouseEvent);

        assert(child.classList.contains('active'), 'the .active class has been preserved from the current target child node');
      });
    });
  });
});



},{"../../../assets/js/ue/Helpers":5,"../../../assets/js/ue/Mouse":11,"../../support/FakeEvent":95,"chai":46}],121:[function(require,module,exports){
/* File: MouseHandlersFixture.js */
/* jshint undef: true, unused: true */
'use strict';
var proto;
var h;

h = require('../../../assets/js/ue/Helpers').stringToHTMLElement;

function MouseHandlersFixture() {
}

proto = MouseHandlersFixture.prototype;

proto.sourceWithTagPair = function () {
  var result;

  result = h(
    '<div class="ue-segment" data-source-segment-number="3" data-source-puid="d5827fd9-db8b-4d05-9c53-8e0244c8b3bb" style="height: 27px;">' +
      '<div class="ue-inline-content">' +
        '<span class="ue-tag-wrapper" data-type="start-tag" data-tag-copy="true" data-id="19" data-metadata="undefined" data-can-hide="false">' +
          '<span class="ue-tag ue-tag-start" contenteditable="false">[start-tag]</span>' +
        '</span>' +
      '<div class="ue-inline-content ue-tagpair-content" data-type="tagpair" data-id="19" data-definitionid="5" data-metadata="undefined">' +
          '<span class="ue-text" data-type="text"> is an organized collection of </span>' +
          '<span class="ue-text" data-type="text">.</span>' +
      '</div>' +
      '<span class="ue-tag-wrapper" data-type="end-tag" data-tag-copy="true" data-id="19" data-metadata="undefined" data-can-hide="false">' +
        '<span class="ue-tag ue-tag-end" contenteditable="false">[end-tag]</span>' +
      '</span>' +
      '</div>' +
    '</div>'
  );

  return result;
};

proto.sourceWithPlaceholder = function () {
  var result;

  result = h(
      '<div class="ue-segment" data-source-segment-number="3" data-source-puid="d5827fd9-db8b-4d05-9c53-8e0244c8b3bb" style="height: 27px;">' +
        '<div class="ue-inline-content">' +
          '<span class="ue-tag-wrapper" data-type="placeholder" data-id="42" data-definitionid="9" data-metadata="8500022-14032959-2509131" data-tag-copy="true">' +
            '<span class="ue-tag" contenteditable="false">x</span>' +
          '</span>' +
        '</div>' +
      '</div>'
  );

  return result;

};

proto.targetWithText = function () {
  var sample;

  sample = h(
    '<div class="ue-segment ue-row-active" data-segment-number="2" data-puid="b52674d3-9dc4-4252-a821-38667613c042" style="height: 27px;">' +
      '<div class="ue-inline-content">' +
        '<span class="ue-text" data-type="text">Banco fornecaedores</span>' +
      '</div>' +
    '</div>'
  );

  return sample;
};

module.exports = MouseHandlersFixture;

},{"../../../assets/js/ue/Helpers":5}],122:[function(require,module,exports){
/* File: TagContentBuilder_test.js */
/* jshint undef: true, unused: true */
/* globals require, describe, it */

'use strict';

var TagContentBuilder = require('../../../assets/js/ue/renderer/TagContentBuilder');

var sinon = require('sinon');
var assert = require('chai').assert;

describe('TagContentBuilder', function () {
  var builder = new TagContentBuilder();
  var strategies = {
    test_strategy: function () { return true; }
  };

  describe('constructor', function () {
    it('should instantiate the new class', function () {
      assert.instanceOf(builder, TagContentBuilder, 'and builder will be a TagContentBuilder instance');
    });
  });
});
},{"../../../assets/js/ue/renderer/TagContentBuilder":33,"chai":46,"sinon":78}],123:[function(require,module,exports){
/* File: NodeWalker_test.js */
/* globals describe, it */
'use strict';

var assert = require('chai').assert;
var Helpers = require('../../../assets/js/ue/Helpers');
var h = Helpers.stringToHTMLElement;
var Tmpl = require('../../../assets/js/ue/Tmpl');
var Selection = require('../../../assets/js/ue/Selection');

describe('Selection.NodeWalker', function () {
  describe('#append( node )', function () {
    it('adds the given node as a child', function () {
      var nodeEl,
          carriageReturnNode,
          node;

      nodeEl = Helpers.stringToHTMLElement('<div/>');
      carriageReturnNode = Helpers.stringToHTMLElement('\n');
      node = new Selection.NodeWalker(nodeEl);

      node.append(carriageReturnNode);

      assert(carriageReturnNode.parentNode === nodeEl, 'carriageReturn node is a child of node');
    });
  });

  describe('#prepend( node )', function () {
    it('adds the given node as the first child', function () {
      var nodeEl = h('<div/>'),
          node = new Selection.NodeWalker(nodeEl),
          prependedNode1 = h('<span class="first"/>'),
          prependedNode2 = h('<span class="second"/>');

      node.prepend(prependedNode1);
      node.prepend(prependedNode2);

      assert.equal(node.firstChild().el, prependedNode2, 'second element has been inserted before the first');
      assert.equal(node.lastChild().el, prependedNode1, 'first element is at the end of the container');
    });
  });

  describe('#isInvisibleChar ()', function () {
    it('returns true when the the node is composed of the zero width non-joiner character', function () {
      var el,
          node,
          isInvisibleChar;

      el = Helpers.stringToHTMLElement(Tmpl.zwnj);
      node = new Selection.NodeWalker(el);
      isInvisibleChar = node.isInvisibleChar();

      assert.isTrue(isInvisibleChar, 'node is an invisible character');
    });
  });

  describe('#isInlineContent ()', function () {
    it('return true when the node has ue-inline-content', function () {
      var el,
          node;

      el = Helpers.stringToHTMLElement('<div class="ue-inline-content"/>');
      node = new Selection.NodeWalker(el);

      assert.isTrue(node.isInlineContent(), 'node is inline content');
    });
  });

  describe('#isElement (name)', function () {
    describe('when name is not provided', function () {
      it('only checks if the nodeType is Element', function () {
        var node = Helpers.stringToHTMLElement('<br/>');
        var nodeWalker = new Selection.NodeWalker(node);
        var result;

        result = nodeWalker.isElement();

        assert.isTrue(result, 'node is reported as element');
      });
    });

    describe('when name is provided', function () {
      it('also checks the nodeName for a match', function () {
        var node = Helpers.stringToHTMLElement('<br/>');
        var nodeWalker = new Selection.NodeWalker(node);
        var result;

        result = nodeWalker.isElement("br");

        assert.isTrue(result, 'node is reported as element');
      });
    });

  });

  describe('#insertAfter', function () {
    it('inserts the specified HTML node after the current one', function () {
      var node = Helpers.stringToHTMLElement('<test/>');
      var insertedAfter = Helpers.stringToHTMLElement('<demo/>');
      var nodeWalker = new Selection.NodeWalker(node);

      nodeWalker.insertAfter(insertedAfter);

      assert.equal(nodeWalker.next().el, insertedAfter, 'the node has been inserted after');
    });

    it('inserts the specified NodeWalker node after the current one', function () {
      var node = Helpers.stringToHTMLElement('<test/>');
      var insertedAfter = Helpers.stringToHTMLElement('<demo/>');
      var nodeWalker = new Selection.NodeWalker(node);
      var insertedAfterNodeWalker = new Selection.NodeWalker(insertedAfter);

      nodeWalker.insertAfter(insertedAfterNodeWalker);

      assert(nodeWalker.next().equals(insertedAfterNodeWalker), 'the node has been inserted after');
    });
  });

  describe('#append', function () {
    it('appends a HTML node', function () {
      var node = Helpers.stringToHTMLElement('<test/>');
      var appendedNode = Helpers.stringToHTMLElement('<demo/>');
      var nodeWalker = new Selection.NodeWalker(node);

      nodeWalker.append(appendedNode);

      assert.equal(nodeWalker.firstChild().el, appendedNode, 'the node has been appended');
    });

    it('appends a NodeWalker node', function () {

      var node = Helpers.stringToHTMLElement('<test/>');
      var appendedNode = Helpers.stringToHTMLElement('<demo/>');
      var nodeWalker = new Selection.NodeWalker(node);
      var appendedNodeWalker = new Selection.NodeWalker(appendedNode);

      nodeWalker.append(appendedNodeWalker);

      assert(nodeWalker.firstChild().equals(appendedNodeWalker), 'the node has been appended');
    });
  });

  describe('#textContent', function () {
    it('returns the textContent of the node', function () {
      var exampleNode = Helpers.stringToHTMLElement('<test>text</test>');
      var nodeWalker = new Selection.NodeWalker(exampleNode);

      assert.equal('text', nodeWalker.textContent());
    });
  });

  describe('#forEachChild( callback(NodeWalker) )', function () {
    it('iterates through all childNodes and passes the child as a reference to the callback', function () {
      var container = h('<container><node1></node1>' +
        '<node2></node2>' +
        '<node3><node4/></node3>' +
        '</container>'),
        walker = new Selection.NodeWalker(container),
        collectedChildren = [];

      walker.forEachChild(function (childWalker) {
        collectedChildren.push(childWalker);
      });

      assert.equal(3, collectedChildren.length, 'all children have been given');
    });
  });

});
},{"../../../assets/js/ue/Helpers":5,"../../../assets/js/ue/Selection":18,"../../../assets/js/ue/Tmpl":21,"chai":46}],124:[function(require,module,exports){
/* File: SelectionContext_test.js */
/* jshint undef: true, unused: true */
/* globals describe, it, beforeEach, afterEach */
'use strict';
var assert = require('chai').assert;
var SelectionContextObjectMother = require('../../support/SelectionContextObjectMother');
var Selection = require('../../../assets/js/ue/selection');
var FakeNode = require('../../support/FakeNode');

describe('SelectionContext', function () {
  var selectionContext,
      selection,
      objectMother,
      htmlFragment;
  beforeEach(function () {
    objectMother = new SelectionContextObjectMother();

    objectMother.stubSelection();

    selectionContext = new Selection.SelectionContext();
    htmlFragment = document.createDocumentFragment();
  });

  afterEach(function () {
    objectMother.restoreSelection();
  });

  it('calls document#getSelection', function () {
    assert(document.getSelection.called, 'document#getSelection was expected to be called');
  });

  it('assigns selection instance', function () {
    assert.isNotNull(selectionContext.selection, 'selection instance should have been assigned');
  });

  it('assigns range instance', function () {
    assert.isNotNull(selectionContext.range, 'range instance should have been assigned');
  });

  it('assigns focusNode and focusOffset', function () {
    assert.isNotNull(selectionContext.focusNode, 'focusNode should have been assigned');
    assert.equal(selectionContext.focusOffset, 0);
  });

  it('assigns range properties', function () {
    assert.isNotNull(selectionContext.commonAncestorContainer);
    assert.isNotNull(selectionContext.startContainer);
    assert.isNotNull(selectionContext.endContainer);
    assert.equal(selectionContext.startOffset, objectMother.fakeRange.startOffset);
    assert.equal(selectionContext.endOffset, objectMother.fakeRange.endOffset);
  });

  describe('when focusNode#parentNode is null', function () {
    it('assigns false to hasFocusNodeParent ', function () {
      assert.isFalse(selectionContext.hasFocusNodeParent);
    });

    it('does not assign to focusNodeParent', function () {
      assert.isUndefined(selectionContext.focusNodeParent);
    });
  });

  describe('when focusNode#parentNode is not null', function () {
    beforeEach(function () {
      objectMother.defineFocusNodeParent();
      selectionContext = new Selection.SelectionContext();
    });

    it('assigns true to hasFocusNodeParent', function () {
      assert.isTrue(selectionContext.hasFocusNodeParent);
    });

    it('assigns focusNodeParent', function () {
      assert.isNotNull(selectionContext.focusNodeParent);
    });

  });

  describe('focusNode, startContainer, endContainer have nodeType different from TextNodeType(value: 3)', function () {
    it('sets isFocusTextNode to false', function () {
      assert.isFalse(selectionContext.isFocusTextNode);
    });

    it('sets isStartContainerTextNode to false', function () {
      assert.isFalse(selectionContext.isStartContainerTextNode);
    });

    it('sets isEndContainerTextNode to false', function () {
      assert.isFalse(selectionContext.isEndContainerTextNode);
    });
  });

  describe('focusNode, startContainer, endContainer have nodeType TextNode(value:3)', function () {
    beforeEach(function () {
      objectMother.assignTextNodes();
      selectionContext = new Selection.SelectionContext();
    });
    it('sets isFocusTextNode to false', function () {
      assert.isTrue(selectionContext.isFocusTextNode);
    });

    it('sets isStartContainerTextNode to false', function () {
      assert.isTrue(selectionContext.isStartContainerTextNode);
    });

    it('sets isEndContainerTextNode to false', function () {
      assert.isTrue(selectionContext.isEndContainerTextNode);
    });
  });

  describe('#isCollapsed', function () {
    describe('when range is not collapsed', function () {
      beforeEach(function () {
        objectMother.setRangeCollapsed(false);
        selectionContext = new Selection.SelectionContext();
      });

      it('returns false', function () {
        assert.isFalse(selectionContext.isCollapsed());
      });
    });

    describe('when range is collapsed', function () {
      beforeEach(function () {
        objectMother.setRangeCollapsed(true);
        selectionContext = new Selection.SelectionContext();
      });

      it('returns true', function () {
        assert.isTrue(selectionContext.isCollapsed());
      });
    });
  });

  describe('#cloneContents', function () {
    it('calls range#cloneContents', function () {
      selectionContext.cloneContents();

      assert(selectionContext.range.cloneContents.called, 'range#cloneContents was not called');
    });
  });

  describe('#deleteContents', function () {
    it('calls range#deleteContents', function () {
      selectionContext.deleteContents();

      assert(selectionContext.range.deleteContents.called, 'range#deleteContents was not called');
    });
  });

  describe('#insertNode', function () {
    it('calls range#insertNode', function () {
      selectionContext.insertNode(htmlFragment);

      assert(selectionContext.range.insertNode.called, 'range#insertNode was called');
    });
  });

  describe('#hasCommonAncestorClass', function () {
    it('checks the commonAncestorContainer to see if it has the given class', function () {
      selectionContext.commonAncestorContainer = new FakeNode().withClass('ue-editable');

      assert.isTrue(selectionContext.hasCommonAncestorClass('ue-editable'));
    });

    it("returns false when commonAncestorContainer doesn't have the provided className", function () {
      selectionContext.commonAncestorContainer = new FakeNode().withClass('ue-inline-content');

      assert.isFalse(selectionContext.hasCommonAncestorClass('ue-editable'));
    });
  });

});

},{"../../../assets/js/ue/selection":34,"../../support/FakeNode":96,"../../support/SelectionContextObjectMother":102,"chai":46}],125:[function(require,module,exports){
/* File: MouseCtrlClickHandler_test.js */
/* jshint undef: true, unused: true */
/* globals describe, beforeEach, it */
'use strict';
var h = require('../../../assets/js/ue/Helpers').stringToHTMLElement,
    assert = require('chai').assert,
    NodeWalker = require('../../../assets/js/ue/selection').NodeWalker,
    TagPair = require('../../../assets/js/ue/selection').TagPair;


describe('TagPair', function () {
  var startTag,
      inlineContent,
      endTag,
      segmentContent,
      segment,
      tagPair,
      tagElements,
      placeholder,
      tagStructure;

  beforeEach(function () {
    segment = h(
        '<div class="ue-segment" data-source-segment-number="3" data-source-puid="d5827fd9-db8b-4d05-9c53-8e0244c8b3bb" style="height: 27px;">' +
          '<div class="ue-inline-content">' +
            '<span class="ue-tag-wrapper" data-type="start-tag" data-tag-copy="true" data-id="19" data-metadata="undefined" data-can-hide="false">' +
              '<span class="ue-tag ue-tag-start" contenteditable="false">[start-tag]</span>' +
            '</span>' +
            '<div class="ue-inline-content ue-tagpair-content" data-type="tagpair" data-id="19" data-definitionid="5" data-metadata="undefined">' +
              '<span class="ue-text" data-type="text"> is an organized collection of </span>' +
              '<span class="ue-text" data-type="text">.</span>' +
            '</div>' +
            '<span class="ue-tag-wrapper" data-type="end-tag" data-tag-copy="true" data-id="19" data-metadata="undefined" data-can-hide="false">' +
              '<span class="ue-tag ue-tag-end" contenteditable="false">[end-tag]</span>' +
            '</span>' +
            '<span class="ue-tag-wrapper" data-type="placeholder" data-id="42" data-definitionid="9" data-metadata="8500022-14032959-2509131" data-tag-copy="true">' +
              '<span class="ue-tag" contenteditable="false">x</span>' +
            '</span>' +
          '</div>' +
        '</div>'
    );
    segmentContent = segment.firstChild;
    startTag = segmentContent.firstChild;
    inlineContent = segmentContent.childNodes[1];
    endTag = segmentContent.childNodes[2];
    placeholder = segmentContent.childNodes[3];
  });

  it('creates a valid instance, from start-tag', function () {
    tagPair = new TagPair(startTag);

    assert(tagPair.isValid(), 'valid tag pair created');
  });

  it('creates a valid instance, from inlineContent', function () {
    tagPair = new TagPair(inlineContent);

    assert(tagPair.isValid(), 'valid tag pair created');
  });

  it('creates a valid instance, from end-tag', function () {
    tagPair = new TagPair(endTag);

    assert(tagPair.isValid(), 'valid tag pair created');
  });

  it('creates a valid instance, from a node walker', function () {
    tagPair = new TagPair(new NodeWalker(startTag));

    assert(tagPair.isValid(), 'valid tag pair created');
  });

  it('can\'t create a valid instance from placeholder', function () {
    tagPair = new TagPair(placeholder);

    assert.isFalse(tagPair.isValid(), 'valid tag pair can\'t be created from placeholder');
  });

  describe('#cloneStructure', function () {
    it('clones all the tags, and returns a documentFragment with the tags', function () {
      tagPair = new TagPair(inlineContent);

      tagStructure = tagPair.cloneStructure();
      assert.isNotNull(tagStructure.childNodes[0], 'startTagEl is assigned to');
      assert.isNotNull(tagStructure.childNodes[1], 'inlineContentEl is assigned to');
      assert.isNotNull(tagStructure.childNodes[2], 'endTagEl is assigned to');
    });

    it('does not keep the inline content', function () {
      tagPair = new TagPair(inlineContent);

      tagStructure = tagPair.cloneStructure();

      assert.equal(0, tagStructure.childNodes[1].childNodes.length, 'valid tag pair clone was created');
    });
  });

  describe('#toArray', function () {
    tagPair = new TagPair(startTag);

    tagElements = tagPair.toArray();

    assert.lengthOf(tagElements, 3, 'three elements are returned');
    assert(tagPair.startTagEl === tagElements[0], 'first element is start tag');
    assert(tagPair.inlineContentEl === tagElements[1], 'second element is start tag');
    assert(tagPair.endTagEl === tagElements[2], 'third element is start tag');
  });
});

},{"../../../assets/js/ue/Helpers":5,"../../../assets/js/ue/selection":34,"chai":46}]},{},[1,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsImFzc2V0c1xcanNcXGFwcGxpY2F0aW9uLmpzIiwiYXNzZXRzXFxqc1xcdWVcXENvbW1hbmRNYW5hZ2VyLmpzIiwiYXNzZXRzXFxqc1xcdWVcXERhdGFQcm92aWRlci5qcyIsImFzc2V0c1xcanNcXHVlXFxEb2N1bWVudHMuanMiLCJhc3NldHNcXGpzXFx1ZVxcSGVscGVycy5qcyIsImFzc2V0c1xcanNcXHVlXFxLZXlib2FyZC5qcyIsImFzc2V0c1xcanNcXHVlXFxLZXlib2FyZEJpbmRpbmdzLmpzIiwiYXNzZXRzXFxqc1xcdWVcXExheW91dC5qcyIsImFzc2V0c1xcanNcXHVlXFxNYXJrdXBEYXRhRmFjdG9yeS5qcyIsImFzc2V0c1xcanNcXHVlXFxNZWRpYXRvci5qcyIsImFzc2V0c1xcanNcXHVlXFxNb3VzZS5qcyIsImFzc2V0c1xcanNcXHVlXFxOb2RlV3JhcHBlci5qcyIsImFzc2V0c1xcanNcXHVlXFxQYXJhZ3JhcGhzLmpzIiwiYXNzZXRzXFxqc1xcdWVcXFNlZ21lbnQuanMiLCJhc3NldHNcXGpzXFx1ZVxcU2VnbWVudENsZWFudXAuanMiLCJhc3NldHNcXGpzXFx1ZVxcU2VnbWVudFN0YXR1c1VwZGF0ZXIuanMiLCJhc3NldHNcXGpzXFx1ZVxcU2VnbWVudHNXYXRjaGVyLmpzIiwiYXNzZXRzXFxqc1xcdWVcXFNlbGVjdGlvbi5qcyIsImFzc2V0c1xcanNcXHVlXFxTaWRlQnlTaWRlUGFyYWdyYXBoVW5pdHNSZW5kZXJlci5qcyIsImFzc2V0c1xcanNcXHVlXFxTdG9yYWdlLmpzIiwiYXNzZXRzXFxqc1xcdWVcXFRtcGwuanMiLCJhc3NldHNcXGpzXFx1ZVxcVHJhbnNsYXRpb25PcmlnaW4uanMiLCJhc3NldHNcXGpzXFx1ZVxcVUUuanMiLCJhc3NldHNcXGpzXFx1ZVxcY29tbWFuZHNcXEVkaXRvckNvbW1hbmRzLmpzIiwiYXNzZXRzXFxqc1xcdWVcXGNvbmZpZy5qcyIsImFzc2V0c1xcanNcXHVlXFxrZXlib2FyZFxcS2V5cy5qcyIsImFzc2V0c1xcanNcXHVlXFxrZXlib2FyZFxcU2VnbWVudFVuZGVyQ3VycmVudFNlbGVjdGlvbi5qcyIsImFzc2V0c1xcanNcXHVlXFxrZXlib2FyZFxcU2hpZnRFbnRlckhhbmRsZXIuanMiLCJhc3NldHNcXGpzXFx1ZVxcbGF5b3V0XFxSaWJib25NZW51Q29tbWFuZHMuanMiLCJhc3NldHNcXGpzXFx1ZVxcbW91c2VcXEN0cmxDbGlja0hhbmRsZXIuanMiLCJhc3NldHNcXGpzXFx1ZVxcbW91c2VcXEN0cmxIb3ZlckhhbmRsZXIuanMiLCJhc3NldHNcXGpzXFx1ZVxccmVuZGVyZXJcXFN0eWxlc01hcC5qcyIsImFzc2V0c1xcanNcXHVlXFxyZW5kZXJlclxcVGFnQ29udGVudEJ1aWxkZXIuanMiLCJhc3NldHNcXGpzXFx1ZVxcc2VsZWN0aW9uXFxOb2RlV2Fsa2VyLmpzIiwiYXNzZXRzXFxqc1xcdWVcXHNlbGVjdGlvblxcU2VsZWN0aW9uQ29udGV4dC5qcyIsImFzc2V0c1xcanNcXHVlXFxzZWxlY3Rpb25cXFRhZ1BhaXIuanMiLCJub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcYnVmZmVyXFxpbmRleC5qcyIsIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxidWZmZXJcXG5vZGVfbW9kdWxlc1xcYmFzZTY0LWpzXFxsaWJcXGI2NC5qcyIsIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxidWZmZXJcXG5vZGVfbW9kdWxlc1xcaWVlZTc1NFxcaW5kZXguanMiLCJub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcZXZlbnRzXFxldmVudHMuanMiLCJub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcaW5oZXJpdHNcXGluaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcaW5zZXJ0LW1vZHVsZS1nbG9iYWxzXFxub2RlX21vZHVsZXNcXHByb2Nlc3NcXGJyb3dzZXIuanMiLCJub2RlX21vZHVsZXNcXGJyb3dzZXJpZnlcXG5vZGVfbW9kdWxlc1xcdXRpbFxcc3VwcG9ydFxcaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzXFxicm93c2VyaWZ5XFxub2RlX21vZHVsZXNcXHV0aWxcXHV0aWwuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGluZGV4LmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxsaWJcXGNoYWkuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcYXNzZXJ0aW9uLmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxsaWJcXGNoYWlcXGNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFxjb3JlXFxhc3NlcnRpb25zLmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxsaWJcXGNoYWlcXGludGVyZmFjZVxcYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxsaWJcXGNoYWlcXGludGVyZmFjZVxcZXhwZWN0LmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxsaWJcXGNoYWlcXGludGVyZmFjZVxcc2hvdWxkLmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxsaWJcXGNoYWlcXHV0aWxzXFxhZGRDaGFpbmFibGVNZXRob2QuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXGFkZE1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFx1dGlsc1xcYWRkUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXGZsYWcuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXGdldEFjdHVhbC5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFx1dGlsc1xcZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXGdldE1lc3NhZ2UuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXGdldE5hbWUuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXGdldFBhdGhWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFx1dGlsc1xcZ2V0UHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFx1dGlsc1xcaW5kZXguanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXGluc3BlY3QuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXG9iakRpc3BsYXkuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXGxpYlxcY2hhaVxcdXRpbHNcXG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFx1dGlsc1xcb3ZlcndyaXRlTWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxsaWJcXGNoYWlcXHV0aWxzXFxvdmVyd3JpdGVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFx1dGlsc1xcdGVzdC5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFx1dGlsc1xcdHJhbnNmZXJGbGFncy5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbGliXFxjaGFpXFx1dGlsc1xcdHlwZS5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbm9kZV9tb2R1bGVzXFxhc3NlcnRpb24tZXJyb3JcXGluZGV4LmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxub2RlX21vZHVsZXNcXGRlZXAtZXFsXFxpbmRleC5qcyIsIm5vZGVfbW9kdWxlc1xcY2hhaVxcbm9kZV9tb2R1bGVzXFxkZWVwLWVxbFxcbGliXFxlcWwuanMiLCJub2RlX21vZHVsZXNcXGNoYWlcXG5vZGVfbW9kdWxlc1xcZGVlcC1lcWxcXG5vZGVfbW9kdWxlc1xcdHlwZS1kZXRlY3RcXGluZGV4LmpzIiwibm9kZV9tb2R1bGVzXFxjaGFpXFxub2RlX21vZHVsZXNcXGRlZXAtZXFsXFxub2RlX21vZHVsZXNcXHR5cGUtZGV0ZWN0XFxsaWJcXHR5cGUuanMiLCJub2RlX21vZHVsZXNcXHNpbm9uXFxsaWJcXHNpbm9uLmpzIiwibm9kZV9tb2R1bGVzXFxzaW5vblxcbGliXFxzaW5vblxcYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzXFxzaW5vblxcbGliXFxzaW5vblxcYmVoYXZpb3IuanMiLCJub2RlX21vZHVsZXNcXHNpbm9uXFxsaWJcXHNpbm9uXFxjYWxsLmpzIiwibm9kZV9tb2R1bGVzXFxzaW5vblxcbGliXFxzaW5vblxcY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlc1xcc2lub25cXGxpYlxcc2lub25cXG1hdGNoLmpzIiwibm9kZV9tb2R1bGVzXFxzaW5vblxcbGliXFxzaW5vblxcbW9jay5qcyIsIm5vZGVfbW9kdWxlc1xcc2lub25cXGxpYlxcc2lub25cXHNhbmRib3guanMiLCJub2RlX21vZHVsZXNcXHNpbm9uXFxsaWJcXHNpbm9uXFxzcHkuanMiLCJub2RlX21vZHVsZXNcXHNpbm9uXFxsaWJcXHNpbm9uXFxzdHViLmpzIiwibm9kZV9tb2R1bGVzXFxzaW5vblxcbGliXFxzaW5vblxcdGVzdC5qcyIsIm5vZGVfbW9kdWxlc1xcc2lub25cXGxpYlxcc2lub25cXHRlc3RfY2FzZS5qcyIsIm5vZGVfbW9kdWxlc1xcc2lub25cXGxpYlxcc2lub25cXHV0aWxcXGZha2VfdGltZXJzLmpzIiwibm9kZV9tb2R1bGVzXFxzaW5vblxcbm9kZV9tb2R1bGVzXFxmb3JtYXRpb1xcbGliXFxmb3JtYXRpby5qcyIsIm5vZGVfbW9kdWxlc1xcc2lub25cXG5vZGVfbW9kdWxlc1xcZm9ybWF0aW9cXG5vZGVfbW9kdWxlc1xcc2Ftc2FtXFxsaWJcXHNhbXNhbS5qcyIsInRlc3RcXHN1cHBvcnRcXENyb3NzU2VnbWVudFNlbGVjdGlvbk9iamVjdE1vdGhlci5qcyIsInRlc3RcXHN1cHBvcnRcXERhdGFQcm92aWRlck9iamVjdE1vdGhlci5qcyIsInRlc3RcXHN1cHBvcnRcXEZha2VFdmVudC5qcyIsInRlc3RcXHN1cHBvcnRcXEZha2VOb2RlLmpzIiwidGVzdFxcc3VwcG9ydFxcRmFrZVJhbmdlLmpzIiwidGVzdFxcc3VwcG9ydFxcRmFrZVNlbGVjdGlvbi5qcyIsInRlc3RcXHN1cHBvcnRcXEhhbmRsZUNsZWFyVGFnc0ZpeHR1cmVzLmpzIiwidGVzdFxcc3VwcG9ydFxcS2V5Ym9hcmRCaW5kaW5nc09iamVjdE1vdGhlci5qcyIsInRlc3RcXHN1cHBvcnRcXFNlZ21lbnRDbGVhbnVwRml4dHVyZS5qcyIsInRlc3RcXHN1cHBvcnRcXFNlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXIuanMiLCJ0ZXN0XFxzdXBwb3J0XFxTaGlmdEVudGVySGFuZGxlckZpeHR1cmUuanMiLCJ0ZXN0XFxzdXBwb3J0XFxTaWRlQnlTaWRlUGFyYWdyYXBoVW5pdHNSZW5kZXJlckZpeHR1cmUuanMiLCJ0ZXN0XFx1ZVxcQ29tbWFuZE1hbmFnZXJfdGVzdC5qcyIsInRlc3RcXHVlXFxEYXRhUHJvdmlkZXJfdGVzdC5qcyIsInRlc3RcXHVlXFxTZWdtZW50Q2xlYW51cF90ZXN0LmpzIiwidGVzdFxcdWVcXFNlZ21lbnRXYXRjaGVyX3Rlc3QuanMiLCJ0ZXN0XFx1ZVxcU2lkZUJ5U2lkZVBhcmFncmFwaFVuaXRzUmVuZGVyZXJfdGVzdC5qcyIsInRlc3RcXHVlXFxUbXBsX3Rlc3QuanMiLCJ0ZXN0XFx1ZVxca2V5Ym9hcmRcXFNoaWZ0RW50ZXJIYW5kbGVyX3Rlc3QuanMiLCJ0ZXN0XFx1ZVxca2V5Ym9hcmRcXGhhbmRsZUNsZWFyVGFnc1Nob3J0Y3V0UHJldmVudHNEZWZhdWx0X3Rlc3QuanMiLCJ0ZXN0XFx1ZVxca2V5Ym9hcmRcXGhhbmRsZUNsZWFyVGFnc19hY2NlcHRhbmNlX3Rlc3QuanMiLCJ0ZXN0XFx1ZVxca2V5Ym9hcmRcXGhhbmRsZUNsZWFyVGFnc190ZXN0LmpzIiwidGVzdFxcdWVcXGtleWJvYXJkXFxpZGVudGlmeVRhZ3NJbkNvbnRhaW5lcl90ZXN0LmpzIiwidGVzdFxcdWVcXGtleWJvYXJkXFxpc0Nyb3NzU2VnbWVudFNlbGVjdGlvbl90ZXN0LmpzIiwidGVzdFxcdWVcXGtleWJvYXJkXFx0cmFuc2Zvcm1UYWdzX3Rlc3QuanMiLCJ0ZXN0XFx1ZVxcbW91c2VcXE1vdXNlQ3RybENsaWNrSGFuZGxlcl9hY2NlcHRhbmNlX3Rlc3QuanMiLCJ0ZXN0XFx1ZVxcbW91c2VcXE1vdXNlQ3RybENsaWNrSGFuZGxlcl90ZXN0LmpzIiwidGVzdFxcdWVcXG1vdXNlXFxNb3VzZUN0cmxIb3ZlckhhbmRsZXJfdGVzdC5qcyIsInRlc3RcXHVlXFxtb3VzZVxcTW91c2VIYW5kbGVyc0ZpeHR1cmUuanMiLCJ0ZXN0XFx1ZVxccmVuZGVyZXJcXFRhZ0NvbnRlbnRCdWlsZGVyX3Rlc3QuanMiLCJ0ZXN0XFx1ZVxcc2VsZWN0aW9uXFxOb2RlV2Fsa2VyX3Rlc3QuanMiLCJ0ZXN0XFx1ZVxcc2VsZWN0aW9uXFxTZWxlY3Rpb25Db250ZXh0X3Rlc3QuanMiLCJ0ZXN0XFx1ZVxcc2VsZWN0aW9uXFxUYWdQYWlyX3Rlc3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWtCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyNERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qIEZpbGU6IGFwcGxpY2F0aW9uLmpzICovXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xuLyogZ2xvYmFscyByZXF1aXJlLCBtb2R1bGUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdWUvVUUuanMnKTsiLCIvKiBGaWxlOiBDb21tYW5kTWFuYWdlci5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi9jb21tYW5kcy9FZGl0b3JDb21tYW5kcycpO1xyXG5cclxuZnVuY3Rpb24gQ29tbWFuZE1hbmFnZXIob3B0aW9ucykge1xyXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbnVsbDtcclxuICB0aGlzLmNvbW1hbmRzID0gQ29tbWFuZHMgfHwgbnVsbDtcclxufVxyXG5cclxudmFyIHByb3RvID0gQ29tbWFuZE1hbmFnZXIucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIEV4c2N1dGVzIGNvbW1hbmRzIGZyb20gdGhlIGRlZmF1bHQgY29tbWFuZCBvYmplY3RcclxuICogb3IgY29tbWFuZHMgYWRkZWQgb24gdGhlIGZseVxyXG4gKlxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGNvbW1hbmQgLSBvYmplY3QgcHJvcGVydHkgcmVwcmVzZW50aW5nIGEgY29tbWFuZFxyXG4gKiBAcGFyYW0gIHtBbnl9IGFyZ3NcclxuICovXHJcbnByb3RvLmV4ZWN1dGUgPSBmdW5jdGlvbiAoY29tbWFuZCwgYXJncykge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGNtZHMgPSBtZS5jb21tYW5kcztcclxuXHJcbiAgLy8gRXhpdCwgbm90aGluZyB0byBleGVjdXRlIG9yIGNvbW1hbmQgbm90IGF2YWlsYWJsZVxyXG4gIGlmICghY29tbWFuZCB8fCAhY21kc1tjb21tYW5kXSB8fCAoIWNtZHNbY29tbWFuZF0uaGFzT3duUHJvcGVydHkoJ2hhbmRsZScpICYmICEodHlwZW9mIGNtZHNbY29tbWFuZF0uaGFuZGxlID09PSAnZnVuY3Rpb24nKSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgY29tbWFuZCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBjbWRzW2NvbW1hbmRdLmhhbmRsZS5jYWxsKG1lLCBhcmdzIHx8IG51bGwpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIER5bmFtaWNhbGx5IGFkZHMgY29tbWFuZHMgdG8gdGhlIGNvbW1hbmRzIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29tbWFuZHNMaXN0XHJcbiAqL1xyXG5wcm90by5hZGRDb21tYW5kcyA9IGZ1bmN0aW9uIChjb21tYW5kc0xpc3QpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBjb21tYW5kcyA9IG1lLmNvbW1hbmRzLFxyXG4gICAgICBjb21tYW5kO1xyXG5cclxuICBmb3IgKGNvbW1hbmQgaW4gY29tbWFuZHNMaXN0KSB7XHJcbiAgICBpZiAoY29tbWFuZHNMaXN0Lmhhc093blByb3BlcnR5KGNvbW1hbmQpKSB7XHJcbiAgICAgIGNvbW1hbmRzW2NvbW1hbmRdID0gY29tbWFuZHNMaXN0W2NvbW1hbmRdO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWxldGUgY29tbWFuZHMgZnJvbSB0aGUgY29tbWFuZHMgb2JqZWN0XHJcbiAqL1xyXG5wcm90by5kZWxldGVDb21tYW5kcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBjb21tYW5kcyA9IG1lLmNvbW1hbmRzLFxyXG4gICAgICBjb21tYW5kc0xpc3QgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xyXG5cclxuICBjb21tYW5kc0xpc3QuZm9yRWFjaChmdW5jdGlvbiAoY29tbWFuZCkge1xyXG4gICAgZGVsZXRlIGNvbW1hbmRzW2NvbW1hbmRdO1xyXG4gIH0pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21tYW5kTWFuYWdlcjsiLCIvKiBGaWxlOiBEYXRhUHJvdmlkZXIuanMgKi9cbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXG4vKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGF0YSBwcm92aWRlciBtb2R1bGVcbiAqXG4gKiBQcm92aWRlcyBkYXRhIGZvciB0aGUgYXBwbGljYXRpb24ncyBtb2R1bGVzLiBDcmVhdGVzIGFuIGludGVyZmFjZSB0byBjb21tdW5pY2F0ZSB3aXRoXG4gKiB0aGUgU3RvcmFnZS4gUmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHVwZGF0ZSBmcmFnbWVudHMgYnkgZXh0cmFjdGluZyB0aGUgc2VnbWVudHMgZm9yIGEgbm9kZS5cbiAqL1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgSGVscGVycyA9IHJlcXVpcmUoJy4vSGVscGVycycpO1xuXG52YXIgU3RvcmFnZSA9IHJlcXVpcmUoJy4vU3RvcmFnZScpO1xudmFyIE1hcmt1cERhdGFGYWN0b3J5ID0gcmVxdWlyZSgnLi9NYXJrdXBEYXRhRmFjdG9yeScpO1xudmFyIFRyYW5zbGF0aW9uT3JpZ2luID0gcmVxdWlyZSgnLi9UcmFuc2xhdGlvbk9yaWdpbicpO1xudmFyIE1lZGlhdG9yID0gcmVxdWlyZSgnLi9NZWRpYXRvcicpO1xuXG52YXIgRGF0YVByb3ZpZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0b3JhZ2UgPSBTdG9yYWdlW2NvbmZpZy5zdG9yYWdlXS5nZXRJbnN0YW5jZSgpLFxuICAgICAgY3JlYXRlTWFya3VwRGF0YSA9IE1hcmt1cERhdGFGYWN0b3J5LmNyZWF0ZSxcbiAgICAgIHRyYW5zT3JpZ2luID0gVHJhbnNsYXRpb25PcmlnaW4sXG4gICAgICBfcmFuZCA9IEhlbHBlcnMuX3JhbmQ7XG5cblxuICBmdW5jdGlvbiBVcGRhdGVGcmFnbWVudCAocGFyYWdyYXBoSWQsIHNlZ21lbnRJZCwgY2hpbGRyZW4sIGlzVGFyZ2V0LCBkYXRhKSB7XG4gICAgdGhpcy50eXBlID0gJ1VQREFURSc7XG4gICAgdGhpcy5wYXJhZ3JhcGhVbml0VVVJRCA9IHBhcmFncmFwaElkO1xuICAgIHRoaXMuc2VnbWVudCA9IHt9O1xuICAgIHRoaXMuc2VnbWVudC5pZCA9IHNlZ21lbnRJZDtcbiAgICB0aGlzLnNlZ21lbnQuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLnNlZ21lbnQudHlwZSA9ICdzZWdtZW50JztcbiAgICB0aGlzLnNlZ21lbnQudHJhbnNsYXRpb25PcmlnaW4gPSAoZGF0YSkgPyBkYXRhLnRyYW5zbGF0aW9uT3JpZ2luIDoge307XG4gICAgdGhpcy5zZWdtZW50LnNlZ21lbnROdW1iZXIgPSAoZGF0YSkgPyBkYXRhLnNlZ21lbnROdW1iZXIgOiAwO1xuICAgIHRoaXMuc2VnbWVudC5jb25maXJtYXRpb25MZXZlbCA9IChkYXRhKSA/IGRhdGEuY29uZmlybWF0aW9uTGV2ZWwgOiAnJztcbiAgICB0aGlzLnNlZ21lbnQuaXNMb2NrZWQgPSAoZGF0YSkgPyBkYXRhLmlzTG9ja2VkIDogZmFsc2U7XG4gICAgdGhpcy5pc1RhcmdldCA9IGlzVGFyZ2V0IHx8IHRydWU7XG4gIH1cblxuXG4gIFVwZGF0ZUZyYWdtZW50LnByb3RvdHlwZS5hZGRDaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIGlmIChjaGlsZHJlbi5pbnN0YW5jZU9mKCdBcnJheScpKSB7XG4gICAgICB0aGlzLnNlZ21lbnQuY2hpbGRyZW4uY29uY2F0KGNoaWxkcmVuKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2VnbWVudC5jaGlsZHJlbi5wdXNoKGNoaWxkcmVuKTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGNoaWxkcmVuIHRvIGJlIGFkZGVkIHRvIHRoZVxuICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gc2VnbWVudCBjaGlsZHJlblxuICAgKi9cbiAgZnVuY3Rpb24gcHJlcGFyZU5vZGUgKGVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZXMgPSBlbGVtZW50LmNoaWxkcmVuLFxuICAgICAgICBjaGlsZHJlbiA9IFtdLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgbCA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgIGlmIChub2Rlc1tpXS5kYXRhc2V0LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZU1hcmt1cERhdGEoe1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICBpZDogbm9kZXNbaV0uZGF0YXNldC5pZCxcbiAgICAgICAgICB0ZXh0OiBub2Rlc1tpXS50ZXh0Q29udGVudCxcbiAgICAgICAgICBtZXRhZGF0YTogbm9kZXNbaV0uZGF0YXNldC5tZXRhZGF0YVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiBub2Rlc1tpXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJyXCIpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVNYXJrdXBEYXRhKHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgdGV4dDogJ1xcclxcbidcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXNbaV0uZGF0YXNldC50eXBlID09PSAndGFncGFpcicpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVNYXJrdXBEYXRhKHtcbiAgICAgICAgICB0eXBlOiAndGFnUGFpcicsXG4gICAgICAgICAgaWQ6IG5vZGVzW2ldLmRhdGFzZXQuaWQsXG4gICAgICAgICAgY2hpbGRyZW46IHByZXBhcmVOb2RlKG5vZGVzW2ldKSxcbiAgICAgICAgICBtZXRhZGF0YTogbm9kZXNbaV0uZGF0YXNldC5tZXRhZGF0YSxcbiAgICAgICAgICB0YWdQYWlyRGVmaW5pdGlvbklkOiBub2Rlc1tpXS5kYXRhc2V0LmRlZmluaXRpb25pZFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc1tpXS5kYXRhc2V0LnR5cGUgPT09ICdsb2NrZWQnKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlTWFya3VwRGF0YSh7XG4gICAgICAgICAgdHlwZTogJ2xvY2tlZCcsXG4gICAgICAgICAgY2hpbGRyZW46IHByZXBhcmVOb2RlKG5vZGVzW2ldKVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc1tpXS5kYXRhc2V0LnR5cGUgPT09ICdwbGFjZWhvbGRlcicpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVNYXJrdXBEYXRhKHtcbiAgICAgICAgICB0eXBlOiAncGxhY2Vob2xkZXJUYWcnLFxuICAgICAgICAgIGlkOiBub2Rlc1tpXS5kYXRhc2V0LmlkLFxuICAgICAgICAgIG1ldGFkYXRhOiBub2Rlc1tpXS5kYXRhc2V0Lm1ldGFkYXRhLFxuICAgICAgICAgIHBsYWNlaG9sZGVyVGFnRGVmaW5pdGlvbklkOiBub2Rlc1tpXS5kYXRhc2V0LmRlZmluaXRpb25pZFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cblxuICAvKipcbiAgICogUHJlcGFyZSBzZWdtZW50IGRhdGEgdG8gYmUgc2VudCBiYWNrIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtICB7c2VnbWVudEVsfSBjdXJyZW50IHNlZ21lbnQgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgIHVwZGF0ZWQgZnJhZ21lbnQgb2JqZWN0XG4gICAqL1xuICBmdW5jdGlvbiBwcmVwYXJlU2VnbWVudCAoc2VnbWVudEVsKSB7XG4gICAgdmFyIHNlZ21lbnRJbm5lckVsZW1lbnQgPSBzZWdtZW50RWwuY2hpbGRyZW5bMF0sXG4gICAgICAgIG5vZGVzID0gc2VnbWVudElubmVyRWxlbWVudC5jaGlsZHJlbixcbiAgICAgICAgY2hpbGRyZW4gPSBbXSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGwgPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIG90aGVyU2VnbWVudERhdGEgPSB7fTtcblxuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcblxuICAgICAgaWYgKG5vZGVzW2ldLmRhdGFzZXQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlTWFya3VwRGF0YSh7XG4gICAgICAgICAgdGV4dDogbm9kZXNbaV0udGV4dENvbnRlbnQsXG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIG1ldGFkYXRhOiBub2Rlc1tpXS5kYXRhc2V0Lm1ldGFkYXRhXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzW2ldLm5vZGVUeXBlID09PSAxICYmIG5vZGVzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYnJcIikge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZU1hcmt1cERhdGEoe1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB0ZXh0OiAnXFxyXFxuJ1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc1tpXS5kYXRhc2V0LnR5cGUgPT09ICd0YWdwYWlyJykge1xuICAgICAgICAvL0dldCB0YWctY29udGVudCBmcm9tIHRhZy1wYWlyIG5vZGVcbiAgICAgICAgdmFyIHRhZ0NvbnRlbnQgPSBub2Rlc1tpXTtcblxuICAgICAgICAvL2NyZWF0ZSBhIG5ldyB0YWctcGFpciBtYXJrdXBkYXRhXG4gICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlTWFya3VwRGF0YSh7XG4gICAgICAgICAgdHlwZTogJ3RhZ1BhaXInLFxuICAgICAgICAgIGlkOiBub2Rlc1tpXS5kYXRhc2V0LmlkLFxuICAgICAgICAgIGNoaWxkcmVuOiBwcmVwYXJlTm9kZSh0YWdDb250ZW50KSxcbiAgICAgICAgICBtZXRhZGF0YTogbm9kZXNbaV0uZGF0YXNldC5tZXRhZGF0YSxcbiAgICAgICAgICB0YWdQYWlyRGVmaW5pdGlvbklkOiBub2Rlc1tpXS5kYXRhc2V0LmRlZmluaXRpb25pZFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc1tpXS5kYXRhc2V0LnR5cGUgPT09ICdsb2NrZWQnKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlTWFya3VwRGF0YSh7XG4gICAgICAgICAgdHlwZTogJ2xvY2tlZCcsXG4gICAgICAgICAgY2hpbGRyZW46IHByZXBhcmVOb2RlKG5vZGVzW2ldKVxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlc1tpXS5kYXRhc2V0LnR5cGUgPT09ICdwbGFjZWhvbGRlcicpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjcmVhdGVNYXJrdXBEYXRhKHtcbiAgICAgICAgICB0eXBlOiAncGxhY2Vob2xkZXJUYWcnLFxuICAgICAgICAgIGlkOiBub2Rlc1tpXS5kYXRhc2V0LmlkLFxuICAgICAgICAgIG1ldGFkYXRhOiBub2Rlc1tpXS5kYXRhc2V0Lm1ldGFkYXRhLFxuICAgICAgICAgIHBsYWNlaG9sZGVyVGFnRGVmaW5pdGlvbklkOiBub2Rlc1tpXS5kYXRhc2V0LmRlZmluaXRpb25pZFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNlZ21lbnREYXRhID0gc2VnbWVudEVsLmRhdGFzZXQ7XG4gICAgdmFyIHNlZ21lbnROdW1iZXIgPSBzZWdtZW50RGF0YS5zZWdtZW50TnVtYmVyO1xuICAgIHZhciBzZWdtZW50ID0gRGF0YVByb3ZpZGVyLnNlZ21lbnRzTWFwW3NlZ21lbnROdW1iZXJdO1xuXG4gICAgLy8gb3RoZXIgc2VnbWVudCBkYXRhXG4gICAgb3RoZXJTZWdtZW50RGF0YSA9IHtcbiAgICAgIHRyYW5zbGF0aW9uT3JpZ2luOiB0cmFuc09yaWdpbi5vcmlnaW5hbEZvcm1hdChzZWdtZW50LnRyYW5zbGF0aW9ub3JpZ2luKSxcbiAgICAgIGNvbmZpcm1hdGlvbkxldmVsOiBmb3JtYXRDb25maXJtYXRpb25MZXZlbChzZWdtZW50LmNvbmZpcm1hdGlvbmxldmVsKSxcbiAgICAgIHNlZ21lbnROdW1iZXI6IHNlZ21lbnROdW1iZXIsXG4gICAgICBpc0xvY2tlZDogc2VnbWVudERhdGEuaXNMb2NrZWQgPyBzZWdtZW50RGF0YS5pc0xvY2tlZCA6IGZhbHNlXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgVXBkYXRlRnJhZ21lbnQoc2VnbWVudEVsLmRhdGFzZXQucHVpZCwgc2VnbWVudEVsLmRhdGFzZXQuc2VnbWVudE51bWJlciwgY2hpbGRyZW4sIHRydWUsIG90aGVyU2VnbWVudERhdGEpO1xuICB9XG5cblxuICBmdW5jdGlvbiBmb3JtYXRDb25maXJtYXRpb25MZXZlbCAodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlICdub3QtdHJhbnNsYXRlZCc6XG4gICAgICAgIHJldHVybiAnTm90VHJhbnNsYXRlZCc7XG4gICAgICBjYXNlICdhcHByb3ZlZC1zaWduLW9mZic6XG4gICAgICAgIHJldHVybiAnQXBwcm92ZWRTaWduT2ZmJztcbiAgICAgIGNhc2UgJ2FwcHJvdmVkLXRyYW5zbGF0aW9uJzpcbiAgICAgICAgcmV0dXJuICdBcHByb3ZlZFRyYW5zbGF0aW9uJztcbiAgICAgIGNhc2UgJ2RyYWZ0JzpcbiAgICAgICAgcmV0dXJuICdEcmFmdCc7XG4gICAgICBjYXNlICdyZWplY3RlZC1zaWduLW9mZic6XG4gICAgICAgIHJldHVybiAnUmVqZWN0ZWRTaWduT2ZmJztcbiAgICAgIGNhc2UgJ3JlamVjdGVkLXRyYW5zbGF0aW9uJzpcbiAgICAgICAgcmV0dXJuICdSZWplY3RlZFRyYW5zbGF0aW9uJztcbiAgICAgIGNhc2UgJ3RyYW5zbGF0ZWQnOlxuICAgICAgICByZXR1cm4gJ1RyYW5zbGF0ZWQnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdOb3RUcmFuc2xhdGVkJztcbiAgICB9XG4gIH1cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb25NYXAgKGRhdGEpIHtcbiAgICB2YXIgbWFwID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBtYXBbZGF0YVtpXS5pZF0gPSBkYXRhW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNlZ21lbnRzTWFwOiB7fSxcbiAgICBzZWdtZW50c01hcExlbmd0aDogMCxcbiAgICBzYXZlUXVldWU6IHt9LFxuICAgIG1ldGFkYXRhTWFwOiB7fSxcblxuICAgIGNhY2hlTWV0YWRhdGE6IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgdmFyIGtleSA9IF9yYW5kKCkgKyAnLScgKyBfcmFuZCgpICsgJy0nICsgX3JhbmQoKTtcbiAgICAgIHRoaXMubWV0YWRhdGFNYXBba2V5XSA9IG1ldGFkYXRhO1xuXG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEFkZCB0byBzYXZlIHF1ZXVlIHRoZSB1c2VyIGFjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlZ21lbnRJZCAtIGlkIG9mIHNlZ21lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYWdyYXBoSWQgLSBpZCBvZiBwYXJhZ3JhcGggdW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fERPTW5vZGV9IGh0bWwgLSBodG1sIGNvbnRlbnQgb2YgdGhlIERPTSBub2RlXG4gICAgICovXG4gICAgYWRkU2F2ZVF1ZXVlOiBmdW5jdGlvbiAoc2VnbWVudElkLCBwYXJhZ3JhcGhJZCwgaHRtbCkge1xuICAgICAgdGhpcy5zYXZlUXVldWVbcGFyYWdyYXBoSWRdID0ge1xuICAgICAgICBzZWdtZW50SWQ6IHNlZ21lbnRJZCxcbiAgICAgICAgaHRtbDogaHRtbFxuICAgICAgfTtcbiAgICB9LFxuXG5cbiAgICBzYXZlQWxsQ2hhbmdlczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHEgPSB0aGlzLnNhdmVRdWV1ZSxcbiAgICAgICAgICBzZWdtZW50cyA9IFtdLFxuICAgICAgICAgIHByb21pc2UgPSBzdG9yYWdlLnNhdmVPcGVyYXRpb24oc2VnbWVudHMpO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHEpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChwcmVwYXJlU2VnbWVudChxW2ldLmh0bWwpKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdTYXZlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcnKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cblxuICAgIHNhdmVTZWdtZW50Q2hhbmdlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW3ByZXBhcmVTZWdtZW50KGRhdGEuZWwsIGRhdGEub3RoZXJTZWdtZW50RGF0YSldLFxuICAgICAgICAgIHByb21pc2UgPSBzdG9yYWdlLnNhdmVPcGVyYXRpb24oc2VnbWVudHMpO1xuXG4gICAgICBwcm9taXNlLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmluZm8oJ1NhdmVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgfSkuZmFpbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZycpO1xuICAgICAgfSk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtOiAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm46IHtPYmplY3R9IGRvY3VtZW50XG4gICAgICovXG4gICAgZ2V0Q3VycmVudERvY3VtZW50OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBzdG9yYWdlLmN1cnJlbnREb2N1bWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9yYWdlLmN1cnJlbnREb2N1bWVudDtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbToge1N0cmluZ30gaWQgLSBkb2N1bWVudCBpZFxuICAgICAqIEBwYXJhbToge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIC8vIFRPRE86IFRvIGJlIHJlZmFjdG9yZWQgd2hlbiBpdCBwcm92ZXMgZXZlbiBtb3JlIHBhaW5mdWxcbiAgICBzZXRDdXJyZW50RG9jdW1lbnQ6IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBtZSA9IHRoaXMsIGluZGV4LCBtYXA7XG5cbiAgICAgIC8vIEluamVjdCBjdXJyZW50IGRvY3VtZW50XG4gICAgICBzdG9yYWdlLmdldERvY3VtZW50KGlkLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG5cbiAgICAgICAgbWUuaW5pdERhdGEoaWQsIGRhdGEpO1xuXG4gICAgICAgIG1hcCA9IGZ1bmN0aW9uIChlcnIsIHNrZWxldG9uKSB7XG5cbiAgICAgICAgICBtZS5tYXBTa2VsZXRvbkRhdGEoc2tlbGV0b24pO1xuXG4gICAgICAgICAgaWYgKCgraW5kZXggKyAxKSA9PT0gbWUuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RvcmFnZS5jdXJyZW50RG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCBpbiBtZS5maWxlcykge1xuICAgICAgICAgIHN0b3JhZ2UuZ2V0U2tlbGV0b24obWUuZmlsZXNbaW5kZXhdLmlkLCBtYXApO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBpbml0RGF0YTogZnVuY3Rpb24gKGlkLCBkYXRhKSB7XG4gICAgICB0aGlzLmZpbGVzID0gZGF0YS5maWxlcztcbiAgICAgIHN0b3JhZ2UuY3VycmVudERvY3VtZW50LmlkID0gaWQ7XG4gICAgfSxcblxuICAgIG1hcFNrZWxldG9uRGF0YTogZnVuY3Rpb24gKHNrZWxldG9uKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBtZS50YWdQYWlyTWFwID0gY3JlYXRlRGVmaW5pdGlvbk1hcChza2VsZXRvbi50YWdQYWlyRGVmaW5pdGlvbnMpO1xuICAgICAgbWUuZm9ybWF0aW5nR3JvdXBNYXAgPSBjcmVhdGVEZWZpbml0aW9uTWFwKHNrZWxldG9uLmZvcm1hdHRpbmdHcm91cHMpO1xuICAgICAgbWUucGxhY2Vob2xkZXJNYXAgPSBjcmVhdGVEZWZpbml0aW9uTWFwKHNrZWxldG9uLnBsYWNlaG9sZGVyVGFnRGVmaW5pdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgUGFyYWdyYXBoIGZyb20gc3RvcmFnZVxuICAgICAqXG4gICAgICogQHBhcmFtOiB7U3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbToge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIGdldFBhcmFncmFwaDogZnVuY3Rpb24gKGlkLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFpZCAmJiBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHN0b3JhZ2UuZ2V0UGFyYWdyYXBoKGlkLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHNldCBvZiBwYXJhZ3JhcGhzIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW06IHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXROZXh0UGFyYWdyYXBoczogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICBzdG9yYWdlLmdldE5leHRQYXJhZ3JhcGhzKGNhbGxiYWNrKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHBhcmFncmFwaHMgZnJvbSBzdG9yYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW06IHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBnZXRQYXJhZ3JhcGhzOiBmdW5jdGlvbiAoZG9jdW1lbnRJZCwgY2FsbGJhY2ssIGxpbWl0LCBvZmZzZXQpIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RvcmFnZS5nZXRQYXJhZ3JhcGhzKGRvY3VtZW50SWQsIGNhbGxiYWNrLCBsaW1pdCwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGRvY3VtZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtOiB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgZ2V0RG9jdW1lbnRzOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RvcmFnZS5nZXREb2N1bWVudHMoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb25lIGRvY3VtZW50IGZyb20gdGhlIGxpc3Qgb2YgZG9jdW1lbnRzXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXREb2N1bWVudEluZm86IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHN0b3JhZ2UuZG9jdW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MuaWQgPT09IGlkO1xuICAgICAgfSlbMF07XG4gICAgfSxcblxuXG4gICAgZ2V0U2VnbWVudEJ5U2VnbWVudE51bWJlcjogZnVuY3Rpb24gKHNlZ21lbnROdW1iZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRzTWFwW3NlZ21lbnROdW1iZXJdO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEJpbmRzIGhhbmRsZXJzIGZvciBzYXZpbmcgdGhlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBiaW5kSGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgICAgY2hhbmdlcyA9IHt9O1xuXG4gICAgICBNZWRpYXRvci5zdWJzY3JpYmUoXG4gICAgICAgICdzZWdtZW50OnN0YXJ0LWVkaXQnLCAvLyBGaXJlZCBieSBtYXJrQ3VycmVudFNlZ21lbnQoKSBpbiBLZXlib2FyZEJpbmRpbmdzXG4gICAgICAgIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgY2hhbmdlc1tkYXRhLnNlZ21lbnROdW1iZXJdID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBkYXRhLm90aGVyU2VnbWVudERhdGEuY29uZmlybWF0aW9ubGV2ZWwsXG4gICAgICAgICAgICBodG1sOiBkYXRhLmVsLmlubmVySFRNTFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICBNZWRpYXRvci5zdWJzY3JpYmUoXG4gICAgICAgICdzZWdtZW50OmVuZC1lZGl0JywgLy8gRmlyZWQgYnkgbWFya0N1cnJlbnRTZWdtZW50KCkgaW4gS2V5Ym9hcmRCaW5kaW5nc1xuICAgICAgICBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHZhciBodG1sID0gZGF0YS5lbC5pbm5lckhUTUwsXG4gICAgICAgICAgICAgIHN0YXR1cyA9IGRhdGEub3RoZXJTZWdtZW50RGF0YS5jb25maXJtYXRpb25sZXZlbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWwgPSBjaGFuZ2VzW2RhdGEuc2VnbWVudE51bWJlcl07XG5cbiAgICAgICAgICBpZiAoaHRtbCAhPT0gb3JpZ2luYWwuaHRtbCB8fCBzdGF0dXMgIT09IG9yaWdpbmFsLnN0YXR1cykge1xuICAgICAgICAgICAgbWUuc2F2ZVNlZ21lbnRDaGFuZ2UoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5iaW5kSGFuZGxlcnMoKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFQcm92aWRlcjtcbiIsIi8qIEZpbGU6IERvY3VtZW50cy5qcyAqL1xuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbi8qIGdsb2JhbHMgcmVxdWlyZSwgbW9kdWxlICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRG9jdW1lbnRzIG1vZHVsZVxuICpcbiAqIERpc3BsYXlzIGFsbCBkb2N1bWVudHMgZnJvbSB0aGUgc3RvcmFnZSwgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlXG4gKiBkb2N1bWVudHMgZm9yIG9wZW5pbmcgdGhlbVxuICpcbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciBIZWxwZXJzID0gcmVxdWlyZSgnLi9IZWxwZXJzJyk7XG52YXIgRGF0YVByb3ZpZGVyID0gcmVxdWlyZSgnLi9EYXRhUHJvdmlkZXInKTtcbnZhciBQYXJhZ3JhcGhzID0gcmVxdWlyZSgnLi9QYXJhZ3JhcGhzJyk7XG5cblxuXG52YXIgRG9jdW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZGF0YVByb3ZpZGVyID0gRGF0YVByb3ZpZGVyO1xuXG4gIC8vIE5vdCB1c2VkP1xuICAvLyBmdW5jdGlvbiBjcmVhdGVOb2RlKHRhZywgY29udGVudCwgY2xhc3NOYW1lLCBzdHlsZSkge1xuICAvLyAgIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIC8vICAgaWYgKGNsYXNzTmFtZSkge1xuICAvLyAgICAgZWxtLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpZiAoc3R5bGUpIHtcbiAgLy8gICAgIGVsbS5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiAoY29udGVudCkgPT09ICdzdHJpbmcnKSB7XG4gIC8vICAgICBhZGRUZXh0KGVsbSwgY29udGVudCk7XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKGNvbnRlbnQgJiYgY29udGVudC5ub2RlTmFtZSkge1xuICAvLyAgICAgZWxtLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAvLyAgIH1cblxuICAvLyAgIHJldHVybiBlbG07XG4gIC8vIH1cblxuICAvLyBmdW5jdGlvbiBhZGRUZXh0KGVsbSwgdGV4dCkge1xuICAvLyAgIGVsbS5pbm5lckhUTUwgPSB0ZXh0O1xuICAvLyB9XG5cbiAgcmV0dXJuIHtcblxuICAgIC8qXG4gICAgICBUaGUgbGlzdCBvZiBkb2N1bWVudHNcbiAgICAqL1xuICAgIGRvY3VtZW50czogW10sXG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgZG9jdW1lbnQgaW4gdGhlIHZpZXdcbiAgICAgKlxuICAgICAqL1xuICAgIG9wZW5Eb2N1bWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBkYXRhUHJvdmlkZXIuc2V0Q3VycmVudERvY3VtZW50KGlkLCBmdW5jdGlvbiAoZXJyLCBkb2MpIHtcbiAgICAgICAgUGFyYWdyYXBocy5yZW5kZXJGaXJzdFBhcmFncmFwaHMoKTtcbiAgICAgICAgbWUuc2hvd0RvY3VtZW50SW5mbyhkb2MuZGF0YSk7XG4gICAgICB9KTtcblxuICAgIH0sXG5cbiAgICBzaG93RG9jdW1lbnRJbmZvOiBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbJy51ZS10cmFuc2xhdGlvbi1pbmZvcm1hdGlvbiddO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWwgPSAkKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgZWwuaHRtbChIZWxwZXJzLnRlbXBsYXRlKGVsLmRhdGEoJ3RtcGwnKSwgZG9jKSk7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbGwgdGhlIGRvY3VtZW50c1xuICAgICAqXG4gICAgICovXG4gICAgcmVuZGVyRG9jdW1lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGRvY3VtZW50c0xpc3QgPSB0aGlzLiRkb2N1bWVudHNMaXN0LCBtZSA9IHRoaXM7XG4gICAgICBEYXRhUHJvdmlkZXIuZ2V0RG9jdW1lbnRzKGZ1bmN0aW9uIChlcnIsIGRvY3VtZW50cykge1xuICAgICAgICB2YXIgcmV2ZXJzZURvY3MgPSBkb2N1bWVudHMucmV2ZXJzZSgpO1xuICAgICAgICBtZS5kb2N1bWVudHMgPSByZXZlcnNlRG9jcztcbiAgICAgICAgJGRvY3VtZW50c0xpc3QuaHRtbChcbiAgICAgICAgICBIZWxwZXJzLnRlbXBsYXRlKCd0bXBsLWRvY3VtZW50cy1saXN0JywgeyBkb2N1bWVudHM6IHJldmVyc2VEb2NzIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgc2hvd0RvY3VtZW50TGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy4kZG9jdW1lbnRzTGlzdC5zbGlkZURvd24oKTtcbiAgICAgICQoJy5kb2N1bWVudHMtY29udHJvbCcpLmFkZENsYXNzKCdzbGlkZXVwJyk7XG4gICAgICB0aGlzLiRlZGl0b3IuYWRkQ2xhc3MoJ2ZhZGVkJyk7XG4gICAgfSxcblxuICAgIGhpZGVEb2N1bWVudExpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJGRvY3VtZW50c0xpc3Quc2xpZGVVcCgpO1xuICAgICAgJCgnLmRvY3VtZW50cy1jb250cm9sJykucmVtb3ZlQ2xhc3MoJ3NsaWRldXAnKTtcbiAgICAgIHRoaXMuJGVkaXRvci5yZW1vdmVDbGFzcygnaGlkZGVuIGZhZGVkJyk7XG4gICAgfSxcblxuICAgIGJpbmRIYW5kbGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgdGhpcy4kYm9keS5vbignY2xpY2sub3BlbkRvYycsICdbZGF0YS1hY3Rpb249XCJvcGVuLWRvY3VtZW50XCJdJyxcbiAgICAgICAgY29uZmlnLmZ1bGxNb2RlID9cbiAgICAgICAgICBmdW5jdGlvbiAoKSB7IC8vIGFyZyB3YXMgJ2V2ZW50JyAtIG5vdCB1c2VkXG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAkKCcuZG9jdW1lbnRzLWNvbnRyb2wnKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICBtZS5vcGVuRG9jdW1lbnQoJHRoaXMuZGF0YSgnaWQnKSk7XG4gICAgICAgICAgICBtZS5oaWRlRG9jdW1lbnRMaXN0KCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IDpcbiAgICAgICAgICBmdW5jdGlvbiAoKSB7IC8vIGFyZyB3YXMgJ2V2ZW50JyAtIG5vdCB1c2VkXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSBjb25maWcuYmFzZVVybCArICcvc2hvdy8nICsgdGhpcy5kYXRhc2V0LmlkO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrLnNob3dEb2NzJywgJ1tkYXRhLWFjdGlvbj1cInNob3ctZG9jdW1lbnRzLWxpc3RcIl0nLCBmdW5jdGlvbiAoKSB7IC8vIGFyZyB3YXMgJ2V2ZW50JyAtIG5vdCB1c2VkXG4gICAgICAgIG1lLnNob3dEb2N1bWVudExpc3QoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJGJvZHkub24oJ2NsaWNrLmhpZGVEb2NzJywgJ1tkYXRhLWFjdGlvbj1cImhpZGUtZG9jdW1lbnRzLWxpc3RcIl0nLCBmdW5jdGlvbiAoKSB7IC8vIGFyZyB3YXMgJ2V2ZW50JyAtIG5vdCB1c2VkXG4gICAgICAgIG1lLmhpZGVEb2N1bWVudExpc3QoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuJGJvZHkgPSAkKCdib2R5Jyk7XG4gICAgICB0aGlzLiRkb2N1bWVudHNMaXN0ID0gdGhpcy4kYm9keS5maW5kKCcjZG9jdW1lbnRzLWxpc3QnKTtcbiAgICAgIHRoaXMuJGVkaXRvciA9ICQoJy5lZGl0b3Itd3JhcHBlcicpO1xuXG4gICAgICB2YXIgcm9vdCA9IGNvbmZpZy5iYXNlVXJsICsgJy8nO1xuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmID09PSByb290IHx8IHdpbmRvdy5sb2NhdGlvbi5oYXNoID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVuZGVyRG9jdW1lbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmluZEhhbmRsZXJzKCk7XG5cbiAgICAgIGlmICghY29uZmlnLmZ1bGxNb2RlICYmICFjb25maWcub25seURvY3MpIHtcbiAgICAgICAgdGhpcy4kZG9jdW1lbnRzTGlzdC5jc3Moe2Rpc3BsYXk6ICdub25lJ30pO1xuICAgICAgICB0aGlzLm9wZW5Eb2N1bWVudChIZWxwZXJzLnBhcmFtc0Zyb21VcmwoJy9kb2N1bWVudC86aWQnLCB3aW5kb3cubG9jYXRpb24uaHJlZilbMF0pO1xuICAgICAgICAkKCcuZG9jdW1lbnRzLWNvbnRyb2wnKS5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlZGl0b3IuYWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRzOyIsIi8qIEZpbGU6IERvY3VtZW50cy5qcyAqL1xuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbi8qIGdsb2JhbHMgcmVxdWlyZSwgbW9kdWxlLCBIYW5kbGViYXJzICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgSGVscGVycyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByb290ICAgICAgICAgID0gY29uZmlnLmJhc2VVcmwsXG4gICAgICBvcHRpb25hbFBhcmFtID0gL1xcKCguKj8pXFwpL2csXG4gICAgICBuYW1lZFBhcmFtICAgID0gLyhcXChcXD8pPzpcXHcrL2csXG4gICAgICBzcGxhdFBhcmFtICAgID0gL1xcKlxcdysvZyxcbiAgICAgIGVzY2FwZVJlZ0V4cCAgPSAvW1xcLXt9XFxbXFxdKz8uLFxcXFxcXF4kfCNcXHNdL2c7XG5cbiAgdmFyIFRFTVBMQVRFUyA9IHt9O1xuXG4gIEhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIoJ2lmQ29uZCcsIGZ1bmN0aW9uICh2MSwgdjIsIG9wdGlvbnMpIHtcbiAgICBpZiAodjEgPT09IHYyKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgfSk7XG5cbiAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcignd2hpY2hldmVyJywgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGFyZ3VtZW50c1tpXSkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfSk7XG5cbiAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcigndG9MYW5ndWFnZUNvZGVMb3dlckNhc2UnLCBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIG1pbmltdW1MYW5ndWFnZUNvZGVMZW5ndGggPSAyLFxuICAgICAgICBzdGFuZGFyc0lzb0xlbmd0aCA9IDU7XG5cbiAgICBpZiAoc3RyLmxlbmd0aCA8IG1pbmltdW1MYW5ndWFnZUNvZGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gbWluaW11bUxhbmd1YWdlQ29kZUxlbmd0aCkge1xuICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmIChzdHIubGVuZ3RoID09PSBzdGFuZGFyc0lzb0xlbmd0aCkge1xuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygzKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIF9yb3V0ZVRvUmVnRXhwKHJvdXRlKSB7XG4gICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgJ1xcXFwkJicpLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZShuYW1lZFBhcmFtLCBmdW5jdGlvbiAobWF0Y2gsIG9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXlxcL10rKSc7XG4gICAgICAgICAgICAgICAgICB9KS5yZXBsYWNlKHNwbGF0UGFyYW0sICcoLio/KScpO1xuXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnJCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2V4dHJhY3RQYXJhbWV0ZXJzKHJvdXRlLCBmcmFnbWVudCkge1xuICAgIHZhciByZXN1bHQgPSByb3V0ZS5leGVjKGZyYWdtZW50KTtcbiAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlY29tcGlsZVRlbXBsYXRlKHRlbXBsYXRlTmFtZSwgaXNQYXJ0aWFsKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGVtcGxhdGVOYW1lKTtcbiAgICB2YXIgc3RyID0gZWwuaW5uZXJIVE1MLFxuICAgICAgICBwYXJ0aWFscyA9IChlbC5kYXRhc2V0LnBhcnRpYWxzIHx8ICcnKS5zcGxpdCgvXFxzKy8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhcnRpYWxzW2ldKSB7XG4gICAgICAgIHByZWNvbXBpbGVUZW1wbGF0ZShwYXJ0aWFsc1tpXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzUGFydGlhbCkge1xuICAgICAgSGFuZGxlYmFycy5wYXJ0aWFsc1t0ZW1wbGF0ZU5hbWVdID0gSGFuZGxlYmFycy5jb21waWxlKHN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFRFTVBMQVRFU1t0ZW1wbGF0ZU5hbWVdID0gSGFuZGxlYmFycy5jb21waWxlKHN0cik7XG4gICAgfVxuICB9XG5cblxuICBmdW5jdGlvbiBrZXlDb2RlVG9TdHJpbmcoa2V5Q29kZSkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUNvZGUpLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgZG9jdW1lbnQgZnJhZ21lbnQgdG8gaHRtbCBzdHJpbmdcbiAgICogQHBhcmFtICB7RG9jdW1lbnRGcmFnbWVudH1cbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gZnJhZ21lbnRUb1N0cmluZyhmcmFnbWVudCkge1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIHN0cmluZyA9ICcnO1xuXG4gICAgaWYgKGZyYWdtZW50ICYmIGZyYWdtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgZWxlbS5hcHBlbmRDaGlsZChmcmFnbWVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgc3RyaW5nID0gZWxlbS5pbm5lckhUTUw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkb2N1bWVudEZyYWdtZW50IGZyb20gYSBIVE1MIFNyaW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZWxlbSBIVE1MIHN0cmluZyAnPGRpYyBjbGFzcz1cInNvbWVcIj48L2Rpdj4nXG4gICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdUb0hUTUxFbGVtZW50KGVsZW0pIHtcbiAgICB2YXIgZG9jID0gZG9jdW1lbnQsXG4gICAgICAgIGRpdiA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgZGl2LmlubmVySFRNTCA9IGVsZW07XG5cbiAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICB9XG5cblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgZWxlbWVudCBoYXMgcGFyZW50IHdpdGggZ2l2ZW4gY2xhc3MgbmFtZVxuICAgKiBAcGFyYW0gIHtIVE1MTm9kZX0gZWxlbVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgcGFyZW50Q2xhc3NcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1BhcmVudChlbGVtLCBwYXJlbnRDbGFzcykge1xuICAgIHdoaWxlIChlbGVtICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgJiYgKGVsZW0ubm9kZVR5cGUgIT09IDEgfHwgIWhhc0NsYXNzKGVsZW0sIHBhcmVudENsYXNzKSkpIHtcbiAgICAgIGVsZW0gPSBlbGVtLnBhcmVudE5vZGU7XG5cbiAgICAgIGlmIChlbGVtICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgaGFzQ2xhc3MoZWxlbSwgcGFyZW50Q2xhc3MpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhbiBlbGVtZW50IGhhcyBhIGdpdmVuIGNsYXNzXG4gICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxlbVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbSwgY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGVsZW0uY2xhc3NOYW1lLnJlcGxhY2UoL1tcXHRcXHJcXG5cXGZdL2csICcgJykuaW5kZXhPZihjbGFzc05hbWUpID49IDA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBFc2NhcGVzIGEgSFRNTCBzdHJpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfSBodG1sIC0gSFRNTCBzdHJpbmdcbiAgICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIGVzY2FwZWQgSFRNTCBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZUhUTUwoaHRtbCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICAnJicgIDogJyZhbXA7JyxcbiAgICAgICc8JyAgOiAnJmx0OycsXG4gICAgICAnPicgIDogJyZndDsnLFxuICAgICAgJ1wiJyAgOiAnJnF1b3Q7JyxcbiAgICAgICdcXCcnIDogJyYjeDI3OycsXG4gICAgICAnLycgIDogJyYjeDJGOycsXG4gICAgfTtcblxuICAgIHJldHVybiBTdHJpbmcoaHRtbCkucmVwbGFjZSgvWyY8PlwiJ1xcL10vZywgZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIG1hcFtzdHJdO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJhbXNGcm9tVXJsOiBmdW5jdGlvbiAocG9saWN5LCB1cmwpIHtcbiAgICAgIHBvbGljeSA9IF9yb3V0ZVRvUmVnRXhwKHBvbGljeSk7XG4gICAgICB1cmwgPSB1cmwuc3Vic3RyKHJvb3QubGVuZ3RoKTtcblxuICAgICAgcmV0dXJuIF9leHRyYWN0UGFyYW1ldGVycyhwb2xpY3ksIHVybCk7XG4gICAgfSxcblxuICAgIF9yYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGLCAxMCk7XG4gICAgfSxcblxuICAgIF9leHRlbmQ6IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uW3Byb3BlcnR5XSAmJiAodHlwZW9mKGRlc3RpbmF0aW9uW3Byb3BlcnR5XSkgPT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAoZGVzdGluYXRpb25bcHJvcGVydHldLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSAmJiBzb3VyY2VbcHJvcGVydHldKSB7XG4gICAgICAgICAgdGhpcy5fZXh0ZW5kKGRlc3RpbmF0aW9uW3Byb3BlcnR5XSwgc291cmNlW3Byb3BlcnR5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfSxcblxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgICBmdW5jdGlvbiBtaXhpbihvYmosIGF0dHIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBhdHRyKSB7XG4gICAgICAgICAgb2JqW2ldID0gYXR0cltpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXQpIHtcbiAgICAgICAgICB0aGlzLmluaXQuYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbWl4aW4oYy5wcm90b3R5cGUsIHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uICh0ZW1wbGF0ZU5hbWUsIGRhdGEpIHtcbiAgICAgIGlmICghVEVNUExBVEVTW3RlbXBsYXRlTmFtZV0pIHtcbiAgICAgICAgcHJlY29tcGlsZVRlbXBsYXRlKHRlbXBsYXRlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBURU1QTEFURVNbdGVtcGxhdGVOYW1lXShkYXRhKTtcbiAgICB9LFxuXG4gICAga2V5Q29kZVRvU3RyaW5nOiBrZXlDb2RlVG9TdHJpbmcsXG4gICAgZnJhZ21lbnRUb1N0cmluZzogZnJhZ21lbnRUb1N0cmluZyxcbiAgICBoYXNQYXJlbnQ6IGhhc1BhcmVudCxcbiAgICBoYXNDbGFzczogaGFzQ2xhc3MsXG4gICAgc3RyaW5nVG9IVE1MRWxlbWVudDogc3RyaW5nVG9IVE1MRWxlbWVudCxcbiAgICBlc2NhcGVIVE1MOiBlc2NhcGVIVE1MXG4gIH07XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlbHBlcnM7IiwiLyogRmlsZTogS2V5Ym9hcmQuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyByZXF1aXJlLCBtb2R1bGUgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBzaGlmdEVudGVySGFuZGxlciA9IHJlcXVpcmUoJy4va2V5Ym9hcmQvU2hpZnRFbnRlckhhbmRsZXInKTtcclxudmFyIHNlZ21lbnRVbmRlckN1cnJlbnRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL2tleWJvYXJkL1NlZ21lbnRVbmRlckN1cnJlbnRTZWxlY3Rpb24nKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIFNoaWZ0RW50ZXJIYW5kbGVyOiBzaGlmdEVudGVySGFuZGxlcixcclxuICBTZWdtZW50VW5kZXJDdXJyZW50U2VsZWN0aW9uOiBzZWdtZW50VW5kZXJDdXJyZW50U2VsZWN0aW9uXHJcbn07IiwiLyogRmlsZTogS2V5Ym9hcmRCaW5naW5ncy5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzICQsIF8sIHJlcXVpcmUsIG1vZHVsZSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgZGF0YVByb3ZpZGVyID0gcmVxdWlyZSgnLi9EYXRhUHJvdmlkZXInKTtcclxudmFyIHNlZ21lbnRXYXRjaGVyID0gcmVxdWlyZSgnLi9TZWdtZW50c1dhdGNoZXInKTtcclxudmFyIE1lZGlhdG9yID0gcmVxdWlyZSgnLi9NZWRpYXRvcicpO1xyXG52YXIgdG1wbCA9IHJlcXVpcmUoJy4vVG1wbCcpO1xyXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vSGVscGVycycpO1xyXG5cclxudmFyIFNlZ21lbnQgPSByZXF1aXJlKCcuL1NlZ21lbnQnKTtcclxudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vU2VsZWN0aW9uJyk7XHJcbnZhciBLZXlib2FyZCA9IHJlcXVpcmUoJy4vS2V5Ym9hcmQnKTtcclxudmFyIE1vdXNlID0gcmVxdWlyZSgnLi9Nb3VzZScpO1xyXG52YXIgQ29tbWFuZE1hbmFnZXIgPSByZXF1aXJlKCcuL0NvbW1hbmRNYW5hZ2VyJyk7XHJcblxyXG52YXIgS2V5Ym9hcmRCaW5kaW5ncyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG4gIG1lLnRhcmdldCA9IHRhcmdldDtcclxufTtcclxuXHJcbnZhciBwcm90byA9IEtleWJvYXJkQmluZGluZ3MucHJvdG90eXBlID0ge1xyXG4gIC8vIEtleWJvYXJkIGtleXNcclxuICBrZXlUYWI6IDksXHJcbiAga2V5QmFja3NwYWNlOiA4LFxyXG4gIGtleUVudGVyOiAxMyxcclxuICBrZXlTcGFjZTogMzIsXHJcblxyXG4gIGtleVBhZ2VVcDogMzMsXHJcbiAga2V5UGFnZURvd246IDM0LFxyXG4gIGtleUVuZDogMzUsXHJcbiAga2V5SG9tZTogMzYsXHJcbiAga2V5SW5zZXJ0OiA0NSxcclxuICBrZXlEZWxldGU6IDQ2LFxyXG5cclxuICBrZXlMZWZ0QXJyb3c6IDM3LFxyXG4gIGtleVVwQXJyb3c6IDM4LFxyXG4gIGtleVJpZ2h0QXJyb3c6IDM5LFxyXG4gIGtleURvd25BcnJvdzogNDAsXHJcblxyXG4gIGtleVNoaWZ0OiAxNixcclxuICBrZXlDdHJsOiAxNyxcclxuICBrZXlBbHQ6IDE4LFxyXG4gIGtleUVzYzogMjcsXHJcblxyXG4gIGtleUNhcHNMb2NrOiAyMCxcclxuICBrZXlOdW1Mb2NrOiAxNDQsXHJcbiAga2V5U2Nyb2xsTG9jazogMTQ1LFxyXG5cclxuICBrZXlGMTogMTEyLFxyXG4gIGtleUYyOiAxMTMsXHJcbiAga2V5RjM6IDExNCxcclxuICBrZXlGNDogMTE1LFxyXG4gIGtleUY1OiAxMTYsXHJcbiAga2V5RjY6IDExNyxcclxuICBrZXlGNzogMTE4LFxyXG4gIGtleUY4OiAxMTksXHJcbiAga2V5Rjk6IDEyMCxcclxuICBrZXlGMTA6IDEyMSxcclxuICBrZXlGMTE6IDEyMixcclxuICBrZXlGMTI6IDEyM1xyXG59O1xyXG5cclxucHJvdG8uaWdub3JlZEtleXMgPSBbXHJcbiAgcHJvdG8ua2V5TGVmdEFycm93LFxyXG4gIHByb3RvLmtleVVwQXJyb3csXHJcbiAgcHJvdG8ua2V5UmlnaHRBcnJvdyxcclxuICBwcm90by5rZXlEb3duQXJyb3csXHJcbiAgcHJvdG8ua2V5Q2Fwc0xvY2ssXHJcbiAgcHJvdG8ua2V5U2Nyb2xsTG9jayxcclxuICBwcm90by5rZXlOdW1Mb2NrLFxyXG4gIHByb3RvLmtleUFsdCxcclxuICBwcm90by5rZXlDdHJsLFxyXG4gIHByb3RvLmtleVNoaWZ0LFxyXG4gIHByb3RvLmtleVBhZ2VVcCxcclxuICBwcm90by5rZXlQYWdlRG93bixcclxuICBwcm90by5rZXlIb21lLFxyXG4gIHByb3RvLmtleUVuZCxcclxuICBwcm90by5rZXlFbnRlcixcclxuICBwcm90by5rZXlFc2MsXHJcbiAgcHJvdG8ua2V5SW5zZXJ0LFxyXG4gIHByb3RvLmtleUYxLFxyXG4gIHByb3RvLmtleUYyLFxyXG4gIHByb3RvLmtleUYzLFxyXG4gIHByb3RvLmtleUY0LFxyXG4gIHByb3RvLmtleUY1LFxyXG4gIHByb3RvLmtleUY2LFxyXG4gIHByb3RvLmtleUY3LFxyXG4gIHByb3RvLmtleUY4LFxyXG4gIHByb3RvLmtleUY5LFxyXG4gIHByb3RvLmtleUYxMCxcclxuICBwcm90by5rZXlGMTEsXHJcbiAgcHJvdG8ua2V5RjEyXHJcbl07XHJcblxyXG5wcm90by5hbGxvd2VkS2V5c0luTG9ja2VkQ29udGVudCA9IHtcclxuICAzMzogJ1BhZ2VVcCcsXHJcbiAgMzQ6ICdQYWdlRG93bicsXHJcbiAgMzU6ICdFbmQnLFxyXG4gIDM2OiAnSG9tZScsXHJcbiAgMzc6ICdMZWZ0JyxcclxuICAzODogJ1VwJyxcclxuICAzOTogJ1JpZ2h0JyxcclxuICA0MDogJ0Rvd24nLFxyXG5cclxuICAxMTI6ICdGMScsXHJcbiAgMTEzOiAnRjInLFxyXG4gIDExNDogJ0YzJyxcclxuICAxMTU6ICdGNCcsXHJcbiAgMTE2OiAnRjUnLFxyXG4gIDExNzogJ0Y2JyxcclxuICAxMTg6ICdGNycsXHJcbiAgMTE5OiAnRjgnLFxyXG4gIDEyMDogJ0Y5JyxcclxuICAxMjE6ICdGMTAnLFxyXG4gIDEyMjogJ0YxMScsXHJcbiAgMTIzOiAnRjEyJ1xyXG59O1xyXG5cclxucHJvdG8udGV4dE5vZGVUeXBlID0gMztcclxucHJvdG8uZWxlbWVudE5vZGVUeXBlID0gMTtcclxucHJvdG8uY3VycmVudFNlbGVjdGlvbiA9IG51bGw7XHJcbnByb3RvLmN1cnJlbnRFbGVtZW50SXNMb2NrZWQgPSBmYWxzZTtcclxuXHJcbnByb3RvLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgbWUudGFyZ2V0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5kaXNhYmxlRW50ZXJLZXkoZXYpOyB9KTtcclxuICBtZS50YXJnZXQub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIG1lLmRpc2FibGVCYWNrc3BhY2VBdFN0YXJ0T2ZTZWdtZW50KGV2KTsgfSk7XHJcbiAgbWUudGFyZ2V0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5kaXNhYmxlRGVsZXRlQXRFbmRPZlNlZ21lbnQoZXYpOyB9KTtcclxuICBtZS50YXJnZXQub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIG1lLmhhbmRsZUJhY2tzcGFjZUFjdGlvbihldik7IH0pO1xyXG4gIG1lLnRhcmdldC5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gbWUuaGFuZGxlRGVsZXRlQWN0aW9uKGV2KTsgfSk7XHJcbiAgbWUudGFyZ2V0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5oYW5kbGVSZW1vdmVPblNlbGVjdGlvbihldik7IH0pO1xyXG4gIG1lLnRhcmdldC5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gbWUucHJldmVudFRhZ3NSZW1vdmFsKGV2KTsgfSk7XHJcbiAgbWUudGFyZ2V0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS50b2dnbGVTZWdtZW50TG9ja1N0YXRlKGV2KTsgfSk7XHJcbiAgbWUudGFyZ2V0Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5oYW5kbGVDbGVhclRhZ3NTaG9ydGN1dFByZXZlbnRzRGVmYXVsdChldik7IH0pO1xyXG4gIG1lLnRhcmdldC5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gbWUuaGFuZGxlVGFiS2V5KGV2KTsgfSk7XHJcblxyXG4gIC8vIFRyaWdnZXIgbW91c2V1cCAmIGtleWRvd24gZXZlbnRzIGluIGxvY2tlZCBjb250ZW50IHRvIG1ha2Ugc3VyZSB3ZSBzdG9wIGVkaXRpbmdcclxuICBtZS50YXJnZXQub24oJ21vdXNldXAnLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIG1lLmhhbmRsZUNyb3NzU2VnbWVudFNlbGVjdGlvbihldik7IH0pO1xyXG4gIG1lLnRhcmdldC5vbigna2V5ZG93biBtb3VzZXVwJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5kaXNhYmxlRWRpdGluZyhldik7IH0pO1xyXG4gIG1lLnRhcmdldC5vbignbW91c2V1cCcsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gbWUubWFya0N1cnJlbnRTZWdtZW50KGV2KTsgfSk7XHJcblxyXG4gIG1lLnRhcmdldC5vbigna2V5dXAnLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIG1lLmhhbmRsZUNhcmV0UG9zaXRpb24oZXYpOyB9KTtcclxuICBtZS50YXJnZXQub24oJ2tleXVwJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5tYXJrQ3VycmVudFNlZ21lbnQoZXYpOyB9KTtcclxuICBtZS50YXJnZXQub24oJ2tleXVwJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5jaGFuZ2VTdGF0dXNUb0RyYWZ0KGV2KTsgfSk7XHJcbiAgbWUudGFyZ2V0Lm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChldikgeyByZXR1cm4gbWUuY2hhbmdlU3RhdHVzVG9Db25maXJtZWQoZXYpOyB9KTtcclxuICBtZS50YXJnZXQub24oJ2tleXVwJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5oYW5kbGVNaXNzaW5nVGV4dENvbnRhaW5lcihldik7IH0pO1xyXG4gIG1lLnRhcmdldC5vbigna2V5dXAnLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIG1lLmhhbmRsZUNsZWFyVGFncyhldik7IH0pO1xyXG4gIG1lLnRhcmdldC5vbigna2V5dXAnLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIG5ldyBLZXlib2FyZC5TaGlmdEVudGVySGFuZGxlcihldik7IH0pO1xyXG5cclxuICBtZS50YXJnZXQub24oJ2tleXVwIHBhc3RlJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBtZS5yZXNpemVDb250YWluZXIoZXYpOyB9KTtcclxuICBtZS50YXJnZXQub24oJ3Bhc3RlJywgZnVuY3Rpb24gKGV2KSB7IHJldHVybiAobmV3IENvbW1hbmRNYW5hZ2VyKCkpLmV4ZWN1dGUoJ3Bhc3RlJywgZXYpOyB9KTtcclxuXHJcbiAgLy8gSGFuZGVsIENUUkwrQ0xJQ0sgb24gdGFnc1xyXG4gIG1lLnRhcmdldC5vbignbW91c2Vkb3duJywgJ1tkYXRhLXRhZy1jb3B5PVwidHJ1ZVwiXScsXHJcbiAgICBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIG5ldyBNb3VzZS5DdHJsQ2xpY2tIYW5kbGVyKCkuaGFuZGxlKGV2KTsgfSk7XHJcblxyXG4gIG1lLnRhcmdldC5vbignbW91c2VvdmVyJywgJ1tkYXRhLXRhZy1jb3B5PVwidHJ1ZVwiXScsXHJcbiAgICBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIG5ldyBNb3VzZS5DdHJsSG92ZXJIYW5kbGVyKCkubW91c2VPdmVyKGV2KTsgfSk7XHJcblxyXG4gIG1lLnRhcmdldC5vbignbW91c2VsZWF2ZScsICdbZGF0YS10YWctY29weT1cInRydWVcIl0nLFxyXG4gICAgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBuZXcgTW91c2UuQ3RybEhvdmVySGFuZGxlcigpLm1vdXNlTGVhdmUoZXYpOyB9KTtcclxufTtcclxuXHJcbi8vIFRPRE8gb25jZSBLZXlib2FyZEJpbmRpbmdzIGlzIHJlZmFjdG9yZWQgdGhpcyBjYW4gYmUgcmVtb3ZlZFxyXG4vLyBTZWdtZW50VW5kZXJDdXJyZW50U2VsZWN0aW9uIGhhcyBiZWVuIG1vdmVkIHRvIGl0J3Mgb3duIG1vZHVsZVxyXG5wcm90by5fc2VnbWVudFVuZGVyQ3VycmVudFNlbGVjdGlvbiA9IEtleWJvYXJkLlNlZ21lbnRVbmRlckN1cnJlbnRTZWxlY3Rpb247XHJcblxyXG5cclxucHJvdG8uZGlzYWJsZUVudGVyS2V5ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgaWYgKGV2LnNoaWZ0S2V5KSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoZXYua2V5Q29kZSA9PT0gbWUua2V5RW50ZXIpIHtcclxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG59O1xyXG5cclxucHJvdG8uZGlzYWJsZUJhY2tzcGFjZUF0U3RhcnRPZlNlZ21lbnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcclxuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcclxuICB2YXIgc2VnbWVudEVsO1xyXG5cclxuICBpZiAoZXYua2V5Q29kZSAhPT0gbWUua2V5QmFja3NwYWNlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoIW1lLl9pc0ludmlzaWJsZUNoYXIoZm9jdXNOb2RlKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgc2VnbWVudEVsID0gJChmb2N1c05vZGUucGFyZW50Tm9kZSk7XHJcblxyXG4gIGlmIChmb2N1c05vZGUucHJldmlvdXNTaWJsaW5nID09PSBudWxsICYmXHJcbiAgICAgIHNlZ21lbnRFbC5oYXNDbGFzcygndWUtc2VnbWVudCcpKSB7XHJcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxufTtcclxuXHJcbnByb3RvLmRpc2FibGVEZWxldGVBdEVuZE9mU2VnbWVudCA9IGZ1bmN0aW9uIChldikge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpLFxyXG4gICAgICBmb2N1c05vZGUsXHJcbiAgICAgIGZvY3VzT2Zmc2V0O1xyXG5cclxuICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV2LmtleUNvZGUgIT09IG1lLmtleURlbGV0ZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcclxuICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcclxuXHJcbiAgaWYgKGZvY3VzTm9kZSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvY3VzTm9kZS5uZXh0U2libGluZyA9PT0gbnVsbCAmJlxyXG4gICAgICBmb2N1c05vZGUubGVuZ3RoID09PSBmb2N1c09mZnNldCAmJlxyXG4gICAgICBtZS5pc0xhc3RJblNlZ21lbnQoZm9jdXNOb2RlKSkge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcbn07XHJcblxyXG5wcm90by5pc0xhc3RJblNlZ21lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gIHZhciBwYXJlbnRFbCxcclxuICAgICAgbm9kZUVsLFxyXG4gICAgICBhdEluZGV4LFxyXG4gICAgICBudW1iZXJPZkNoaWxkcmVuO1xyXG5cclxuICBub2RlRWwgPSAkKG5vZGUpO1xyXG4gIHBhcmVudEVsID0gbm9kZUVsLnBhcmVudCgpO1xyXG5cclxuICB3aGlsZSAoIXBhcmVudEVsLmhhc0NsYXNzKCd1ZS1pbmxpbmUtY29udGVudCcpKSB7XHJcbiAgICBub2RlRWwgPSBwYXJlbnRFbDtcclxuICAgIHBhcmVudEVsID0gbm9kZUVsLnBhcmVudCgpO1xyXG4gIH1cclxuXHJcbiAgYXRJbmRleCA9IG5vZGVFbC5pbmRleCgpICsgMTtcclxuICBudW1iZXJPZkNoaWxkcmVuID0gcGFyZW50RWwuY2hpbGRyZW4oKS5sZW5ndGg7XHJcblxyXG4gIHJldHVybiBhdEluZGV4ID09PSBudW1iZXJPZkNoaWxkcmVuO1xyXG59O1xyXG5cclxucHJvdG8uaGFuZGxlQmFja3NwYWNlQWN0aW9uID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCksXHJcbiAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXHJcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0LFxyXG4gICAgICBwcmV2aW91c1NpYmxpbmcsXHJcbiAgICAgIGlubGluZUVsZW1lbnQsXHJcbiAgICAgIHRhZyxcclxuICAgICAgaXNTdGFydFRhZztcclxuXHJcbiAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChmb2N1c05vZGUgPT09IG51bGwpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmICgkKGZvY3VzTm9kZSkuaGFzQ2xhc3MoJ3VlLXRhZ3BhaXItY29udGVudCcpICYmIGZvY3VzT2Zmc2V0ID09PSAwKSB7XHJcbiAgICBzZWxlY3Rpb24ubW9kaWZ5KCdtb3ZlJywgJ2JhY2t3YXJkJywgJ2NoYXJhY3RlcicpO1xyXG4gICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcclxuICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xyXG4gIH1cclxuXHJcbiAgaWYgKCFtZS5faXNJbnZpc2libGVDaGFyKGZvY3VzTm9kZSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlubGluZUVsZW1lbnQgPSBmb2N1c05vZGUucGFyZW50Tm9kZTtcclxuICB0YWcgPSBmb2N1c05vZGUucHJldmlvdXNTaWJsaW5nO1xyXG5cclxuICBpZiAoZXYua2V5Q29kZSAhPT0gbWUua2V5QmFja3NwYWNlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoaW5saW5lRWxlbWVudCA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKCQoaW5saW5lRWxlbWVudCkuaGFzQ2xhc3MoJ3VlLXNlZ21lbnQnKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvY3VzT2Zmc2V0ID09PSAwKSB7XHJcbiAgICBzZWxlY3Rpb24ubW9kaWZ5KCdtb3ZlJywgJ2ZvcndhcmQnLCAnY2hhcmFjdGVyJyk7XHJcbiAgfVxyXG5cclxuICBpc1N0YXJ0VGFnID0gJCh0YWcpLmhhc0NsYXNzKCd1ZS10YWctc3RhcnQnKTtcclxuXHJcbiAgaWYgKGlzU3RhcnRUYWcpIHtcclxuICAgIHZhciB1ZVRhZ1dyYXBwZXIgPSBpbmxpbmVFbGVtZW50O1xyXG4gICAgcHJldmlvdXNTaWJsaW5nID0gdWVUYWdXcmFwcGVyLnByZXZpb3VzU2libGluZztcclxuXHJcbiAgICB2YXIgcGFyZW50SXNBbm90aGVyVGFnID0gJCh1ZVRhZ1dyYXBwZXIucGFyZW50Tm9kZSkuaGFzQ2xhc3MoJ3VlLXRhZ3BhaXItY29udGVudCcpO1xyXG4gICAgaWYgKHBhcmVudElzQW5vdGhlclRhZykge1xyXG4gICAgICB2YXIgdWVUYWdQYWlyQ29udGVudCA9IHVlVGFnV3JhcHBlci5wYXJlbnROb2RlO1xyXG4gICAgICBwcmV2aW91c1NpYmxpbmcgPSB1ZVRhZ1BhaXJDb250ZW50LnByZXZpb3VzU2libGluZztcclxuICAgIH1cclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIHByZXZpb3VzU2libGluZyA9IGlubGluZUVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmxhc3RDaGlsZDtcclxuICB9XHJcblxyXG4gIG1lLl9yZW1vdmVJbmxpbmUoaW5saW5lRWxlbWVudCwgZXYpO1xyXG5cclxuICBpZiAocHJldmlvdXNTaWJsaW5nID09PSBudWxsKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG5cclxuICByYW5nZS5zZXRTdGFydEFmdGVyKHByZXZpb3VzU2libGluZyk7XHJcblxyXG4gIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG5cclxuICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxufTtcclxuXHJcblxyXG5wcm90by5oYW5kbGVEZWxldGVBY3Rpb24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSxcclxuICAgICAgZm9jdXNOb2RlLFxyXG4gICAgICBmb2N1c05vZGVQYXJlbnQsXHJcbiAgICAgIGZvY3VzT2Zmc2V0LFxyXG4gICAgICBuZXh0U2libGluZyxcclxuICAgICAgdWVUZXh0UGFyZW50RWwsXHJcbiAgICAgIGlzTmV4dFNpYmxpbmdUYWcsXHJcbiAgICAgIGlzTmV4dFNpYmxpbmdUYWdIaWRkZW4sXHJcbiAgICAgIGlzRm9jdXNPblRleHQsXHJcbiAgICAgIGlzQXRFbmRPZlRleHROb2RlLFxyXG4gICAgICBpc0ZvY3VzSW5zaWRlU3RhcnRUYWcsXHJcbiAgICAgIGlzRm9jdXNPbkludmlzaWJsZUNoYXIsXHJcbiAgICAgIGlzRm9jdXNJbnNpZGVQcmV2aW91c1RhZyxcclxuICAgICAgaXNGb2N1c0F0U3RhcnRPZlNlZ21lbnQsXHJcbiAgICAgIHNlbGVjdGlvblJhbmdlUG9zaXRpb24sXHJcbiAgICAgIHJhbmdlO1xyXG5cclxuICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV2LmtleUNvZGUgIT09IG1lLmtleURlbGV0ZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcclxuICBmb2N1c05vZGVQYXJlbnQgPSBmb2N1c05vZGUucGFyZW50Tm9kZTtcclxuICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcclxuXHJcbiAgaXNGb2N1c09uVGV4dCA9IGZvY3VzTm9kZS5ub2RlVHlwZSA9PT0gbWUudGV4dE5vZGVUeXBlO1xyXG4gIGlzQXRFbmRPZlRleHROb2RlID0gZm9jdXNPZmZzZXQgPT09IGZvY3VzTm9kZS5sZW5ndGg7XHJcbiAgaXNGb2N1c09uSW52aXNpYmxlQ2hhciA9IG1lLl9pc0ludmlzaWJsZUNoYXIoZm9jdXNOb2RlKTtcclxuICBpc0ZvY3VzSW5zaWRlU3RhcnRUYWcgPSBpc0ZvY3VzT25JbnZpc2libGVDaGFyICYmICQoZm9jdXNOb2RlLnByZXZpb3VzU2libGluZykuaGFzQ2xhc3MoJ3VlLXRhZy1zdGFydCcpO1xyXG4gIGlzRm9jdXNJbnNpZGVQcmV2aW91c1RhZyA9IGlzRm9jdXNPbkludmlzaWJsZUNoYXIgJiYgJChmb2N1c05vZGUucHJldmlvdXNTaWJsaW5nKS5oYXNDbGFzcygndWUtdGFnJyk7XHJcbiAgaXNGb2N1c0F0U3RhcnRPZlNlZ21lbnQgPSBpc0ZvY3VzT25JbnZpc2libGVDaGFyICYmICQoZm9jdXNOb2RlKS5pbmRleCgpID09PSAwO1xyXG5cclxuICBuZXh0U2libGluZyA9IGZvY3VzTm9kZS5uZXh0U2libGluZztcclxuXHJcbiAgaWYgKGlzRm9jdXNPbkludmlzaWJsZUNoYXIgJiYgZm9jdXNPZmZzZXQgPT09IDApIHtcclxuICAgIHNlbGVjdGlvbi5tb2RpZnkoJ21vdmUnLCAnZm9yd2FyZCcsICdjaGFyYWN0ZXInKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0ZvY3VzT25UZXh0ICYmICFpc0ZvY3VzT25JbnZpc2libGVDaGFyKSB7XHJcbiAgICBpZiAoIWlzQXRFbmRPZlRleHROb2RlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB1ZVRleHRQYXJlbnRFbCA9ICQoZm9jdXNOb2RlUGFyZW50KTtcclxuXHJcbiAgICBpZiAodWVUZXh0UGFyZW50RWwuaGFzQ2xhc3MoJ3VlLXRleHQnKSkgeyAvLyB3ZSBhcmUgaW4gdGV4dCBiZWZvcmUgc3RhcnQgdGFnXHJcbiAgICAgIG5leHRTaWJsaW5nID0gZm9jdXNOb2RlLnBhcmVudE5vZGUubmV4dFNpYmxpbmc7IC8vIHVlLXRhZy13cmFwcGVyIGZvciBzdGFydCB0YWdcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93ICd1bmV4cGVjdGVkIGNhc2Ugd2hlcmUgc2VsZWN0aW9uIGlzIHRleHQsIGJ1dCBpcyBub3QgY29udGFpbmVkIGluIGEgdGV4dCBub2RlJztcclxuICAgIH1cclxuXHJcbiAgICAvLyB3ZSBhcmUgaW4gdGV4dCBpbnNpZGUgYSB0YWcgcGFpclxyXG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsICYmICQoZm9jdXNOb2RlUGFyZW50LnBhcmVudE5vZGUpLmhhc0NsYXNzKCd1ZS10YWdwYWlyLWNvbnRlbnQnKSkge1xyXG4gICAgICBuZXh0U2libGluZyA9IGZvY3VzTm9kZVBhcmVudC5wYXJlbnROb2RlLm5leHRTaWJsaW5nOyAvLyB1ZS10YWctd3JhcHBlciBmb3IgZW5kIHRhZ1xyXG4gICAgICBzZWxlY3Rpb25SYW5nZVBvc2l0aW9uID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7IC8vIHdoYXQgY29tZXMgYWZ0ZXIgdGhlIGVuZC10YWdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChpc0ZvY3VzSW5zaWRlU3RhcnRUYWcpIHtcclxuICAgIHZhciBjb250ZW50RXhpc3RzID0gZm9jdXNOb2RlUGFyZW50Lm5leHRTaWJsaW5nLmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgaWYgKGNvbnRlbnRFeGlzdHMpIHtcclxuXHJcbiAgICAgIGlmICgkKGNvbnRlbnRFeGlzdHMpLmhhc0NsYXNzKCd1ZS10ZXh0JykpIHtcclxuICAgICAgICAvLyBwb3NpdGlvbiBjdXJzb3IgYW5kIGxldCB0aGUgZGVmYXVsdCBiZWhhdmlvclxyXG4gICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuICAgICAgICByYW5nZS5zZXRTdGFydEJlZm9yZShjb250ZW50RXhpc3RzKTtcclxuXHJcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCQoY29udGVudEV4aXN0cykuaGFzQ2xhc3MoJ3VlLXRhZy13cmFwcGVyJykpIHtcclxuICAgICAgICBuZXh0U2libGluZyA9IGNvbnRlbnRFeGlzdHM7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2UgeyAvLyB3ZSBkZWxldGUgdGhlIGN1cnJlbnQgdGFnXHJcbiAgICAgIG5leHRTaWJsaW5nID0gZm9jdXNOb2RlUGFyZW50O1xyXG4gICAgfVxyXG5cclxuICB9IGVsc2UgaWYgKGlzRm9jdXNJbnNpZGVQcmV2aW91c1RhZykge1xyXG4gICAgbmV4dFNpYmxpbmcgPSBmb2N1c05vZGVQYXJlbnQubmV4dFNpYmxpbmc7XHJcbiAgfSBlbHNlIGlmIChpc0ZvY3VzQXRTdGFydE9mU2VnbWVudCkge1xyXG4gICAgbmV4dFNpYmxpbmcgPSBmb2N1c05vZGUubmV4dFNpYmxpbmcuZmlyc3RDaGlsZDtcclxuICB9XHJcblxyXG4gIGlzTmV4dFNpYmxpbmdUYWcgPSAkKG5leHRTaWJsaW5nKS5oYXNDbGFzcygndWUtdGFnLXdyYXBwZXInKTtcclxuICBpc05leHRTaWJsaW5nVGFnSGlkZGVuID0gaXNOZXh0U2libGluZ1RhZyAmJiAkKG5leHRTaWJsaW5nKS5oYXNDbGFzcygnaGlkZScpO1xyXG5cclxuICBpZiAoaXNOZXh0U2libGluZ1RhZ0hpZGRlbikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzTmV4dFNpYmxpbmdUYWcpIHtcclxuICAgIG1lLl9yZW1vdmVJbmxpbmUobmV4dFNpYmxpbmcsIGV2KTtcclxuICB9XHJcblxyXG4gIGlmIChzZWxlY3Rpb25SYW5nZVBvc2l0aW9uKSB7XHJcbiAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICByYW5nZS5zZXRTdGFydEJlZm9yZShzZWxlY3Rpb25SYW5nZVBvc2l0aW9uKTtcclxuXHJcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG4gIH1cclxufTtcclxuXHJcbnByb3RvLl9yZW1vdmVJbmxpbmUgPSBmdW5jdGlvbiAoaW5saW5lRWxlbWVudCwgZXYpIHtcclxuICB2YXIgdGFnUGFpcklkLFxyXG4gICAgICB0YWdQYWlyQ29udGVudCxcclxuICAgICAgdGFnUGFpckNvbnRlbnRFbCxcclxuICAgICAgaXNFbmRUYWdQYWlyLFxyXG4gICAgICBpc1N0YXJ0VGFnUGFpcixcclxuICAgICAgaXNUYWdQYWlyLFxyXG4gICAgICBpc1BsYWNlaG9sZGVyO1xyXG5cclxuICBpc1BsYWNlaG9sZGVyID0gaW5saW5lRWxlbWVudC5kYXRhc2V0LnR5cGUgPT09ICdwbGFjZWhvbGRlcic7XHJcbiAgaXNFbmRUYWdQYWlyID0gaW5saW5lRWxlbWVudC5kYXRhc2V0LnR5cGUgPT09ICdlbmQtdGFnJztcclxuICBpc1N0YXJ0VGFnUGFpciA9IGlubGluZUVsZW1lbnQuZGF0YXNldC50eXBlID09PSAnc3RhcnQtdGFnJztcclxuICBpc1RhZ1BhaXIgPSBpc1N0YXJ0VGFnUGFpciB8fCBpc0VuZFRhZ1BhaXI7XHJcblxyXG4gIGlmIChpc1BsYWNlaG9sZGVyKSB7XHJcbiAgICBpbmxpbmVFbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoIWlzVGFnUGFpcikge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzRW5kVGFnUGFpcikge1xyXG4gICAgdGFnUGFpckNvbnRlbnQgPSBpbmxpbmVFbGVtZW50LnByZXZpb3VzU2libGluZztcclxuICAgIHRhZ1BhaXJJZCA9IHRhZ1BhaXJDb250ZW50LmRhdGFzZXQuaWQ7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNTdGFydFRhZ1BhaXIpIHtcclxuICAgIHRhZ1BhaXJDb250ZW50ID0gIGlubGluZUVsZW1lbnQubmV4dFNpYmxpbmc7XHJcbiAgICB0YWdQYWlySWQgPSB0YWdQYWlyQ29udGVudC5kYXRhc2V0LmlkO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzVGFnUGFpcikge1xyXG4gICAgc2VnbWVudFdhdGNoZXIucmVtb3ZlVGFnUGFpcih0YWdQYWlySWQpO1xyXG4gICAgdGFnUGFpckNvbnRlbnRFbCA9ICQodGFnUGFpckNvbnRlbnQpO1xyXG4gICAgdGFnUGFpckNvbnRlbnRFbC5yZXBsYWNlV2l0aCh0YWdQYWlyQ29udGVudEVsLmNoaWxkcmVuKCkpO1xyXG5cclxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfVxyXG59O1xyXG5cclxucHJvdG8uaGFuZGxlUmVtb3ZlT25TZWxlY3Rpb24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSxcclxuICAgICAgcmFuZ2UsXHJcbiAgICAgIGN1cnJlbnRSYW5nZSxcclxuICAgICAgcmFuZ2VDb250ZW50LFxyXG4gICAgICBjb21tb25BbmNlc3RvckNvbnRhaW5lcixcclxuICAgICAgc3RhcnRDb250YWluZXI7XHJcblxyXG4gIGlmIChzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5jb2xsYXBzZWQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChldi5rZXlDb2RlICE9PSBtZS5rZXlEZWxldGUgJiYgZXYua2V5Q29kZSAhPT0gbWUua2V5QmFja3NwYWNlKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAobWUuaXNDcm9zc1NlZ21lbnRTZWxlY3Rpb24oKSkge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XHJcbiAgcmFuZ2VDb250ZW50ID0gcmFuZ2UuY2xvbmVDb250ZW50cygpO1xyXG5cclxuICBpZiAocmFuZ2VDb250ZW50LmZpcnN0Q2hpbGQgPT09IHJhbmdlQ29udGVudC5sYXN0Q2hpbGQgJiZcclxuICAgICAgcmFuZ2VDb250ZW50LmZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IG1lLnRleHROb2RlVHlwZSkge1xyXG5cclxuICAgIHJldHVybjsvLyBhbGxvdyBkZWZhdWx0IGRlbGV0ZSBhY3Rpb25cclxuICB9XHJcblxyXG4gIG1lLmNsZWFudXBTdHJhdGVneShyYW5nZUNvbnRlbnQpO1xyXG5cclxuXHJcbiAgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XHJcbiAgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSBjdXJyZW50UmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XHJcbiAgc3RhcnRDb250YWluZXIgPSBjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXI7XHJcblxyXG4gIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XHJcblxyXG4gIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuICByYW5nZS5zZWxlY3ROb2RlKHN0YXJ0Q29udGFpbmVyKTtcclxuICByYW5nZS5jb2xsYXBzZSgpO1xyXG5cclxuICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcclxuXHJcbiAgbWUuaW5zZXJ0UmFuZ2VDb250ZW50KHJhbmdlQ29udGVudCwgY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xyXG5cclxuICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG59O1xyXG5cclxucHJvdG8uaXNDcm9zc1NlZ21lbnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCgpLFxyXG4gICAgICByZXN1bHQ7XHJcblxyXG4gIHJlc3VsdCA9IHNlbGVjdGlvbi5oYXNDb21tb25BbmNlc3RvckNsYXNzKCd1ZS1lZGl0YWJsZScpO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxucHJvdG8uY2xlYW51cFN0cmF0ZWd5ID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIG1lLnJlbW92ZUVsZW1lbnRRdWV1ZSA9IFtdO1xyXG4gIG1lLl9jbGVhbnVwKGNvbnRhaW5lcik7XHJcbiAgbWUucmVtb3ZlRWxlbWVudFF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIGl0ZW0ucmVtb3ZlKCk7XHJcbiAgfSk7XHJcblxyXG4gIG1lLnJlbW92ZUVsZW1lbnRRdWV1ZSA9IG51bGw7XHJcbn07XHJcblxyXG5wcm90by5fY2xlYW51cCA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBpID0gMCxcclxuICAgICAgZWw7XHJcblxyXG4gIGZvciAoOyBpIDwgY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGVsID0gY29udGFpbmVyLmNoaWxkTm9kZXNbaV07XHJcblxyXG4gICAgbWUucmVtb3ZlVGV4dChlbCk7XHJcbiAgICBtZS5yZW1vdmVQYWlyZWRUYWdzKGVsLCBjb250YWluZXIpO1xyXG4gICAgbWUuY2xlYW5UYWdQYWlyQ29udGFpbmVyKGVsKTtcclxuICB9XHJcbn07XHJcblxyXG5wcm90by5yZW1vdmVUZXh0ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgJGVsID0gJChlbCk7XHJcblxyXG4gIGlmICgkZWwuaGFzQ2xhc3MoJ3VlLXRleHQnKSkge1xyXG4gICAgbWUucmVtb3ZlRWxlbWVudFF1ZXVlLnB1c2goJGVsKTtcclxuICB9XHJcbn07XHJcblxyXG5wcm90by5yZW1vdmVQYWlyZWRUYWdzID0gZnVuY3Rpb24gKGVsLCBjb250YWluZXIpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICAkZWwgPSAkKGVsKTtcclxuXHJcbiAgaWYgKGVsLmRhdGFzZXQudHlwZSAhPT0gJ3N0YXJ0LXRhZycpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBpZCA9IGVsLmRhdGFzZXQuaWQ7XHJcbiAgdmFyIG1hdGNoZWRFbmRUYWcgPSBfKGNvbnRhaW5lci5jaGlsZE5vZGVzKS5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICB2YXIgaXNUYWdXcmFwcGVyID0gJChpdGVtKS5oYXNDbGFzcygndWUtdGFnLXdyYXBwZXInKSxcclxuXHJcbiAgICBpc0hpZGRlbiA9IGlzVGFnV3JhcHBlciAmJiAkKGl0ZW0pLmhhc0NsYXNzKCdoaWRlJyksXHJcbiAgICBkYXRhc2V0ID0gaXRlbS5kYXRhc2V0IHx8IHt9LFxyXG4gICAgaXNFbmRUYWcsXHJcbiAgICBoYXNNYXRjaGluZ0lkLFxyXG4gICAgaXNPaztcclxuXHJcbiAgICBpc0VuZFRhZyA9IGRhdGFzZXQudHlwZSA9PT0gJ2VuZC10YWcnO1xyXG4gICAgaGFzTWF0Y2hpbmdJZCA9IGRhdGFzZXQuaWQgPT09IGlkO1xyXG5cclxuICAgIGlzT2sgPSBpc1RhZ1dyYXBwZXIgJiYgIWlzSGlkZGVuICYmIGlzRW5kVGFnICYmIGhhc01hdGNoaW5nSWQ7XHJcblxyXG4gICAgaWYgKGlzT2spIHtcclxuICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSk7XHJcblxyXG4gIHZhciBtYXRjaGVkVGFnUGFpciA9IF8oY29udGFpbmVyLmNoaWxkTm9kZXMpLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHZhciBpc1RhZ1BhaXJDb250YWluZXIgPSAkKGl0ZW0pLmhhc0NsYXNzKCd1ZS10YWdwYWlyLWNvbnRlbnQnKSxcclxuICAgIGRhdGFzZXQgPSBpdGVtLmRhdGFzZXQgfHwge30sXHJcbiAgICBpc1RhZ1BhaXIsXHJcbiAgICBoYXNNYXRjaGluZ0lkLFxyXG4gICAgaXNPaztcclxuXHJcbiAgICBpc1RhZ1BhaXIgPSBkYXRhc2V0LnR5cGUgPT09ICd0YWdwYWlyJztcclxuICAgIGhhc01hdGNoaW5nSWQgPSBkYXRhc2V0LmlkID09PSBpZDtcclxuXHJcbiAgICBpc09rID0gIGlzVGFnUGFpckNvbnRhaW5lciAmJiBpc1RhZ1BhaXIgJiYgaGFzTWF0Y2hpbmdJZDtcclxuXHJcbiAgICBpZiAoaXNPaykge1xyXG4gICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm47XHJcbiAgfSk7XHJcblxyXG4gIGlmIChtYXRjaGVkRW5kVGFnICE9PSB1bmRlZmluZWQpIHtcclxuICAgIG1lLnJlbW92ZUVsZW1lbnRRdWV1ZS5wdXNoKCRlbCk7XHJcbiAgICBtZS5yZW1vdmVFbGVtZW50UXVldWUucHVzaCgkKG1hdGNoZWRFbmRUYWcpKTtcclxuICAgIG1lLnJlbW92ZUVsZW1lbnRRdWV1ZS5wdXNoKCQobWF0Y2hlZFRhZ1BhaXIpKTtcclxuICB9XHJcbn07XHJcblxyXG5wcm90by5jbGVhblRhZ1BhaXJDb250YWluZXIgPSBmdW5jdGlvbiAoZWwpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBpc1RhZ1BhaXIgPSAkKGVsKS5oYXNDbGFzcygndWUtdGFncGFpci1jb250ZW50Jyk7XHJcblxyXG4gIGlmICghaXNUYWdQYWlyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBtZS5fY2xlYW51cChlbCk7XHJcbn07XHJcblxyXG5wcm90by5pbnNlcnRSYW5nZUNvbnRlbnQgPSBmdW5jdGlvbiAocmFuZ2VDb250ZW50LCBjb21tb25BbmNlc3RvckNvbnRhaW5lcikge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpLFxyXG4gICAgICBmb2N1c05vZGUsXHJcbiAgICAgIGNoaWxkTm9kZSxcclxuICAgICAgbmV4dFNpYmxpbmcsXHJcbiAgICAgIGFoZWFkU2libGluZztcclxuXHJcbiAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcclxuXHJcbiAgaWYgKHJhbmdlQ29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvY3VzTm9kZSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gYWRkIGNvbnRlbnQgYmFja1xyXG4gIHdoaWxlIChmb2N1c05vZGUucGFyZW50Tm9kZSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIpIHtcclxuICAgIGZvY3VzTm9kZSA9IGZvY3VzTm9kZS5wYXJlbnROb2RlO1xyXG4gIH1cclxuXHJcbiAgY2hpbGROb2RlID0gcmFuZ2VDb250ZW50LmNoaWxkTm9kZXNbMF07XHJcblxyXG4gIHZhciBmaXJzdENoaWxkRWwgPSAkKGNoaWxkTm9kZSk7XHJcbiAgaWYgKGZpcnN0Q2hpbGRFbC5oYXNDbGFzcygndWUtdGFnLXdyYXBwZXInKSkge1xyXG4gICAgLy8gc2ltcGxlIGNhc2UsIGp1c3QgYWRkIHRoZSBjb250ZW50IGJhY2tcclxuICAgICQoZm9jdXNOb2RlKS5hZnRlcihmaXJzdENoaWxkRWxbMF0pO1xyXG4gICAgbmV4dFNpYmxpbmcgPSBmb2N1c05vZGUubmV4dFNpYmxpbmc7XHJcbiAgfSBlbHNlIGlmIChtZS5fbmVlZFRvTWVyZ2VDb250YWluZXJzKGNoaWxkTm9kZSwgZm9jdXNOb2RlKSkge1xyXG4gICAgbWUubWVyZ2VDb250ZW50QXRFbmRPZihjaGlsZE5vZGUsIGZvY3VzTm9kZSk7XHJcbiAgICBuZXh0U2libGluZyA9IGZvY3VzTm9kZTtcclxuICB9XHJcblxyXG4gIHdoaWxlIChyYW5nZUNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBjaGlsZE5vZGUgPSByYW5nZUNvbnRlbnQuY2hpbGROb2Rlc1swXTtcclxuICAgIGFoZWFkU2libGluZyA9IG5leHRTaWJsaW5nLm5leHRTaWJsaW5nO1xyXG5cclxuICAgIGlmIChtZS5fbmVlZFRvTWVyZ2VDb250YWluZXJzKGNoaWxkTm9kZSwgYWhlYWRTaWJsaW5nKSkge1xyXG4gICAgICBtZS5tZXJnZUNvbnRlbnRBaGVhZE9mKGNoaWxkTm9kZSwgYWhlYWRTaWJsaW5nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICQobmV4dFNpYmxpbmcpLmFmdGVyKGNoaWxkTm9kZSk7XHJcbiAgICAgIG5leHRTaWJsaW5nID0gY2hpbGROb2RlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn07XHJcblxyXG5wcm90by5fbmVlZFRvTWVyZ2VDb250YWluZXJzID0gZnVuY3Rpb24gKGNoaWxkTm9kZSwgYWhlYWRTaWJsaW5nKSB7XHJcbiAgdmFyIGlzQ2hpbGROb2RlVGFnQ29udGFpbmVyLFxyXG4gICAgICBpc0FoZWFkU2liaWxpbmdUYWdDb250YWluZXIsXHJcbiAgICAgIGNoaWxkTm9kZVRhZ0lkLFxyXG4gICAgICBhaGVhZFNpYmxpbmdUYWdJZCxcclxuICAgICAgaXNNZXJnZU5lZWRlZDtcclxuXHJcbiAgaXNDaGlsZE5vZGVUYWdDb250YWluZXIgPSAkKGNoaWxkTm9kZSkuaGFzQ2xhc3MoJ3VlLXRhZ3BhaXItY29udGVudCcpO1xyXG4gIGlzQWhlYWRTaWJpbGluZ1RhZ0NvbnRhaW5lciA9ICQoYWhlYWRTaWJsaW5nKS5oYXNDbGFzcygndWUtdGFncGFpci1jb250ZW50Jyk7XHJcblxyXG4gIGlmICghaXNDaGlsZE5vZGVUYWdDb250YWluZXIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmICghaXNBaGVhZFNpYmlsaW5nVGFnQ29udGFpbmVyKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBjaGlsZE5vZGVUYWdJZCA9IGNoaWxkTm9kZS5kYXRhc2V0LmlkO1xyXG4gIGFoZWFkU2libGluZ1RhZ0lkID0gYWhlYWRTaWJsaW5nLmRhdGFzZXQuaWQ7XHJcblxyXG4gIGlzTWVyZ2VOZWVkZWQgPSBjaGlsZE5vZGVUYWdJZCA9PT0gYWhlYWRTaWJsaW5nVGFnSWQ7XHJcblxyXG4gIHJldHVybiBpc01lcmdlTmVlZGVkO1xyXG59O1xyXG5cclxucHJvdG8ubWVyZ2VDb250ZW50QWhlYWRPZiA9IGZ1bmN0aW9uIChjaGlsZE5vZGUsIGFoZWFkU2libGluZykge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHBvc2l0aW9uRWw7XHJcblxyXG4gIHBvc2l0aW9uRWwgPSAkKGNoaWxkTm9kZS5jaGlsZE5vZGVzWzBdKTtcclxuICBwb3NpdGlvbkVsLnByZXBlbmRUbyhhaGVhZFNpYmxpbmcpO1xyXG5cclxuICBtZS5tb3ZlQ29udGVudHMoY2hpbGROb2RlLCBwb3NpdGlvbkVsKTtcclxuXHJcbiAgJChjaGlsZE5vZGUpLnJlbW92ZSgpO1xyXG59O1xyXG5cclxucHJvdG8ubWVyZ2VDb250ZW50QXRFbmRPZiA9IGZ1bmN0aW9uIChjaGlsZE5vZGUsIHByZXZpb3VzU2libGluZykge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHBvc2l0aW9uRWw7XHJcblxyXG4gIHBvc2l0aW9uRWwgPSAkKGNoaWxkTm9kZS5jaGlsZE5vZGVzWzBdKTtcclxuICBwb3NpdGlvbkVsLmFwcGVuZFRvKHByZXZpb3VzU2libGluZyk7XHJcblxyXG4gIG1lLm1vdmVDb250ZW50cyhjaGlsZE5vZGUsIHBvc2l0aW9uRWwpO1xyXG5cclxuICAkKGNoaWxkTm9kZSkucmVtb3ZlKCk7XHJcbn07XHJcblxyXG5wcm90by5tb3ZlQ29udGVudHMgPSBmdW5jdGlvbiAoZnJvbU5vZGUsIGFmdGVyUG9zaXRpb25FbCkge1xyXG4gIHZhciBwb3NpdGlvbkVsID0gYWZ0ZXJQb3NpdGlvbkVsLFxyXG4gICAgICBjaGlsZE5vZGUgPSBmcm9tTm9kZSxcclxuICAgICAgY3VycmVudE5vZGU7XHJcblxyXG4gIHdoaWxlIChjaGlsZE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICBjdXJyZW50Tm9kZSA9IGNoaWxkTm9kZS5jaGlsZE5vZGVzWzBdO1xyXG4gICAgcG9zaXRpb25FbC5hZnRlcihjdXJyZW50Tm9kZSk7XHJcbiAgICBwb3NpdGlvbkVsID0gJChjdXJyZW50Tm9kZSk7XHJcbiAgfVxyXG59O1xyXG5cclxucHJvdG8ucHJldmVudFRhZ3NSZW1vdmFsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCksXHJcbiAgICAgIHRleHROb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcclxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcclxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQsXHJcbiAgICAgIGZvY3VzTm9kZUxlbmd0aCxcclxuICAgICAgaXNLZXlCYWNrc3BhY2UgPSBldi5rZXlDb2RlID09PSBtZS5rZXlCYWNrc3BhY2UsXHJcbiAgICAgIGlzS2V5RGVsZXRlID0gZXYua2V5Q29kZSA9PT0gbWUua2V5RGVsZXRlLFxyXG4gICAgICBzaW5nbGVDaGFyYWN0ZXIgPSAxO1xyXG5cclxuICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGZvY3VzTm9kZSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFpc0tleURlbGV0ZSAmJiAhaXNLZXlCYWNrc3BhY2UpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmIChmb2N1c05vZGUubm9kZVR5cGUgPT09IG1lLnRleHROb2RlVHlwZSkge1xyXG4gICAgLy8gRmlyZWZveCBwb3NpdGlvbiBmaXhcclxuICAgIGlmIChmb2N1c09mZnNldCA9PT0gMCAmJiBpc0tleUJhY2tzcGFjZSkge1xyXG4gICAgICBtZS5maXhGaXJlZm94UG9zaXRpb25aZXJvKCk7XHJcbiAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XHJcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGZvY3VzTm9kZUxlbmd0aCA9IGZvY3VzTm9kZS5sZW5ndGg7XHJcbiAgICBmb2N1c05vZGUgPSBmb2N1c05vZGUucGFyZW50Tm9kZTtcclxuICB9XHJcblxyXG4gIHZhciBpc0F0RW5kID0gZm9jdXNPZmZzZXQgPT09IGZvY3VzTm9kZUxlbmd0aDtcclxuICB2YXIgaXNBdFN0YXJ0ID0gZm9jdXNPZmZzZXQgPT09IHNpbmdsZUNoYXJhY3RlcjtcclxuICB2YXIgaXNBdExhc3RDaGFyYWN0ZXIgPSAoIWlzQXRFbmQgJiYgKGZvY3VzT2Zmc2V0ICsgc2luZ2xlQ2hhcmFjdGVyKSkgPT09IGZvY3VzTm9kZUxlbmd0aDtcclxuXHJcbiAgdmFyIGlzRm9jdXNPblRleHQsXHJcbiAgICAgIGlzTmV4dFNpYmxpbmdUYWcsXHJcbiAgICAgIGlzUHJldmlvdXNTaWJpbGluZ1RhZyxcclxuICAgICAgaXNDdXJyZW50Q29udGFpbmVyVGFnUGFpckNvbnRlbnQsXHJcbiAgICAgIGlzUGFyZW50VGFnQ29udGFpbmVyLFxyXG4gICAgICB1ZVRhZ1dyYXBwZXIsXHJcbiAgICAgIHJhbmdlO1xyXG5cclxuICBpc0ZvY3VzT25UZXh0ID0gJChmb2N1c05vZGUpLmhhc0NsYXNzKCd1ZS10ZXh0Jyk7XHJcbiAgLy8gaXNQYXJlbnRUYWdDb250YWluZXIgc2hvdWxkIGJlIHRydWUgaW4gZmlyZWZveFxyXG4gIGlzUGFyZW50VGFnQ29udGFpbmVyID0gJChmb2N1c05vZGUucGFyZW50Tm9kZSkuaGFzQ2xhc3MoJ3VlLXRhZ3BhaXItY29udGVudCcpO1xyXG5cclxuICB2YXIgbmV4dFNpYmxpbmcgPSBmb2N1c05vZGUubmV4dFNpYmxpbmc7XHJcbiAgdmFyIHByZXZpb3VzU2libGluZyA9IGZvY3VzTm9kZS5wcmV2aW91c1NpYmxpbmc7XHJcbiAgdmFyIGZvY3VzTm9kZVBhcmVudCA9IGZvY3VzTm9kZS5wYXJlbnROb2RlO1xyXG5cclxuICBpc05leHRTaWJsaW5nVGFnID0gJChuZXh0U2libGluZykuaGFzQ2xhc3MoJ3VlLXRhZy13cmFwcGVyJyk7XHJcbiAgaXNQcmV2aW91c1NpYmlsaW5nVGFnID0gJChwcmV2aW91c1NpYmxpbmcpLmhhc0NsYXNzKCd1ZS10YWctd3JhcHBlcicpO1xyXG4gIGlzQ3VycmVudENvbnRhaW5lclRhZ1BhaXJDb250ZW50ID0gJChmb2N1c05vZGVQYXJlbnQpLmhhc0NsYXNzKCd1ZS10YWdwYWlyLWNvbnRlbnQnKTtcclxuXHJcbiAgaWYgKCFpc0F0U3RhcnQgJiYgIWlzQXRFbmQgJiYgIWlzQXRMYXN0Q2hhcmFjdGVyIHx8ICFpc0ZvY3VzT25UZXh0KSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoaXNQcmV2aW91c1NpYmlsaW5nVGFnIHx8IGlzTmV4dFNpYmxpbmdUYWcgfHwgaXNDdXJyZW50Q29udGFpbmVyVGFnUGFpckNvbnRlbnQpIHtcclxuICAgIGlmIChpc0tleUJhY2tzcGFjZSkge1xyXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2RlLCAoZm9jdXNPZmZzZXQgLSBzaW5nbGVDaGFyYWN0ZXIpKTtcclxuICAgICAgcmFuZ2Uuc2V0RW5kKHRleHROb2RlLCBmb2N1c09mZnNldCk7XHJcblxyXG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG4gICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xyXG5cclxuICAgICAgLy8gcG9zaXRpb25cclxuICAgICAgaWYgKGlzQXRTdGFydCkge1xyXG4gICAgICAgIHZhciBtb3ZlRGlyZWN0aW9uID0gaXNLZXlCYWNrc3BhY2UgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xyXG4gICAgICAgIHNlbGVjdGlvbi5tb2RpZnkoJ21vdmUnLCBtb3ZlRGlyZWN0aW9uLCAnY2hhcmFjdGVyJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNLZXlEZWxldGUgJiYgaXNOZXh0U2libGluZ1RhZykge1xyXG4gICAgICB2YXIgdGFnUGFpckNvbnRlbnQgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcclxuICAgICAgdmFyIGlzVGFnUGFpckNvbnRhaW5lciA9ICQodGFnUGFpckNvbnRlbnQpLmhhc0NsYXNzKCd1ZS10YWdwYWlyLWNvbnRlbnQnKTtcclxuXHJcbiAgICAgIGlmIChpc0F0TGFzdENoYXJhY3Rlcikge1xyXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHRoZSBuZXh0IHRleHQgbm9kZVxyXG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIGZvY3VzT2Zmc2V0KTtcclxuICAgICAgICByYW5nZS5zZXRFbmQodGV4dE5vZGUsIGZvY3VzT2Zmc2V0ICsgc2luZ2xlQ2hhcmFjdGVyKTtcclxuICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XHJcblxyXG4gICAgICAgIC8vIHNldCBzZWxlY3Rpb24gcG9zaXRpb24gdG8gc3RhcnQgb2YgdGV4dCBub2RlXHJcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZSwgZm9jdXNPZmZzZXQpO1xyXG4gICAgICAgIHJhbmdlLnNldEVuZCh0ZXh0Tm9kZSwgZm9jdXNPZmZzZXQpO1xyXG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc0F0RW5kKSB7XHJcbiAgICAgICAgaWYgKGlzVGFnUGFpckNvbnRhaW5lcikge1xyXG4gICAgICAgICAgdmFyIHVlVGV4dCA9IHRhZ1BhaXJDb250ZW50LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICB0ZXh0Tm9kZSA9IHVlVGV4dC5maXJzdENoaWxkO1xyXG5cclxuICAgICAgICAgIGlmICh0ZXh0Tm9kZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gbW92ZSB0byBuZXh0IHNpYmxpbmdcclxuICAgICAgICAgICAgdWVUYWdXcmFwcGVyID0gdGFnUGFpckNvbnRlbnQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgIHVlVGV4dCA9IHVlVGFnV3JhcHBlci5uZXh0U2libGluZztcclxuXHJcbiAgICAgICAgICAgIGlmICh1ZVRleHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRleHROb2RlID0gdWVUZXh0LmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgbmV4dCB0ZXh0IG5vZGVcclxuICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2RlLCAwKTtcclxuICAgICAgICAgIHJhbmdlLnNldEVuZCh0ZXh0Tm9kZSwgMSk7XHJcbiAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG4gICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcclxuXHJcbiAgICAgICAgICAvLyBzZXQgc2VsZWN0aW9uIHBvc2l0aW9uIHRvIHN0YXJ0IG9mIHRleHQgbm9kZVxyXG4gICAgICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG4gICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIDApO1xyXG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKHRleHROb2RlLCAwKTtcclxuICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoaXNLZXlEZWxldGUgJiYgaXNQYXJlbnRUYWdDb250YWluZXIpIHtcclxuICAgIC8vIHRoaXMgaXMgZmlyZWZveCwgaGUgcHV0cyB0aGUgc2VsZWN0aW9uIHdpdGhpbiB0aGUgdGV4dCBub2RlXHJcbiAgICAvLyB1bmxpa2UgdGhlIGN1cnJlbnQgY2hyb21lIGltcGxlbWVudGF0aW9uXHJcblxyXG4gICAgLy8gcmVtb3ZlIHRleHROb2RlIGNvbnRlbnRcclxuICAgIHZhciBpc1JlbW92aW5nRnJvbUN1cnJlbnRUYWdDb250YWluZXIgPSBmb2N1c09mZnNldCArIHNpbmdsZUNoYXJhY3RlciA9PT0gZm9jdXNOb2RlTGVuZ3RoO1xyXG4gICAgaWYgKGlzUmVtb3ZpbmdGcm9tQ3VycmVudFRhZ0NvbnRhaW5lcikge1xyXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG4gICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZSwgZm9jdXNPZmZzZXQpO1xyXG4gICAgICByYW5nZS5zZXRFbmQodGV4dE5vZGUsIChmb2N1c09mZnNldCArIHNpbmdsZUNoYXJhY3RlcikpO1xyXG4gICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XHJcbiAgICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XHJcbiAgICB9XHJcbiAgICAvLyBtb3ZlIHNlbGVjdGlvbiB0byBuZXh0IHNpYmxpbmdcclxuICAgIG5leHRTaWJsaW5nID0gZm9jdXNOb2RlUGFyZW50O1xyXG4gICAgZG8ge1xyXG4gICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLm5leHRTaWJsaW5nO1xyXG4gICAgfSB3aGlsZSAobmV4dFNpYmxpbmcgIT09IG51bGwgJiYgJChuZXh0U2libGluZykuaGFzQ2xhc3MoJ3VlLXRhZy13cmFwcGVyJykpO1xyXG5cclxuICAgIHRleHROb2RlID0gbmV4dFNpYmxpbmc7XHJcbiAgICBkbyB7XHJcbiAgICAgIHRleHROb2RlID0gdGV4dE5vZGUuZmlyc3RDaGlsZDtcclxuICAgIH0gd2hpbGUgKHRleHROb2RlICE9PSBudWxsICYmIHRleHROb2RlLm5vZGVUeXBlICE9PSBtZS50ZXh0Tm9kZVR5cGUpO1xyXG5cclxuICAgIGlmICghaXNSZW1vdmluZ0Zyb21DdXJyZW50VGFnQ29udGFpbmVyKSB7XHJcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuICAgICAgcmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGUsIDApO1xyXG4gICAgICByYW5nZS5zZXRFbmQodGV4dE5vZGUsIHNpbmdsZUNoYXJhY3Rlcik7XHJcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcclxuICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XHJcbiAgICByYW5nZS5zZXRFbmQodGV4dE5vZGUsIDApO1xyXG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcclxuICB9XHJcbn07XHJcblxyXG5wcm90by5maXhGaXJlZm94UG9zaXRpb25aZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSxcclxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcclxuICAgICAgdWVUZXh0LCB1ZVRhZywgdWVUYWdDb250YWluZXIsXHJcbiAgICAgIHJhbmdlO1xyXG5cclxuICB1ZVRleHQgPSBmb2N1c05vZGUucGFyZW50Tm9kZTtcclxuICB1ZVRhZyA9IHVlVGV4dC5wcmV2aW91c1NpYmxpbmc7XHJcblxyXG4gIGlmICgkKHVlVGFnKS5oYXNDbGFzcygndWUtdGFnLXdyYXBwZXInKSkge1xyXG4gICAgdWVUYWdDb250YWluZXIgPSB1ZVRhZy5wcmV2aW91c1NpYmxpbmc7XHJcblxyXG4gICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZSh1ZVRhZ0NvbnRhaW5lci5sYXN0Q2hpbGQpO1xyXG4gICAgcmFuZ2UuY29sbGFwc2UoKTtcclxuXHJcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG4gIH1cclxufTtcclxuXHJcbnByb3RvLmhhbmRsZUNsZWFyVGFnc1Nob3J0Y3V0UHJldmVudHNEZWZhdWx0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgIHNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCgpLFxyXG4gICAgaXNDdHJsUHJlc3NlZCA9IGV2LmN0cmxLZXksXHJcbiAgICBpc1NwYWNlS2V5UHJlc3NlZCA9IGV2LmtleUNvZGUgPT09IG1lLmtleVNwYWNlLFxyXG4gICAgaXNDbGVhclRhZ3NDb21tYW5kUHJlc3NlZCA9IGlzQ3RybFByZXNzZWQgJiYgaXNTcGFjZUtleVByZXNzZWQ7XHJcblxyXG4gIGlmIChtZS5pc0Nyb3NzU2VnbWVudFNlbGVjdGlvbigpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmICghaXNDbGVhclRhZ3NDb21tYW5kUHJlc3NlZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZXYucHJldmVudERlZmF1bHQoKTtcclxufTtcclxuXHJcbnByb3RvLmhhbmRsZUNsZWFyVGFncyA9IGZ1bmN0aW9uIChldikge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCgpLFxyXG4gICAgICBpc0N0cmxQcmVzc2VkID0gZXYuY3RybEtleSxcclxuICAgICAgaXNTcGFjZUtleVByZXNzZWQgPSBldi5rZXlDb2RlID09PSBtZS5rZXlTcGFjZSxcclxuICAgICAgaXNDbGVhclRhZ3NDb21tYW5kUHJlc3NlZCA9IGlzQ3RybFByZXNzZWQgJiYgaXNTcGFjZUtleVByZXNzZWQ7XHJcblxyXG4gIGlmIChtZS5pc0Nyb3NzU2VnbWVudFNlbGVjdGlvbigpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGlmICghaXNDbGVhclRhZ3NDb21tYW5kUHJlc3NlZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgbWUudGFncyA9IHt9O1xyXG4gIG1lLnN0b3JlZEV2ZW50ID0gZXY7XHJcblxyXG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHNlbGVjdGlvbi5jb21tb25BbmNlc3RvckNvbnRhaW5lcixcclxuICAgICAgc3RhcnRDb250YWluZXIgPSBzZWxlY3Rpb24uc3RhcnRDb250YWluZXIsXHJcbiAgICAgIGVuZENvbnRhaW5lciA9IHNlbGVjdGlvbi5lbmRDb250YWluZXI7XHJcbiAgaWYgKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID09PSBzdGFydENvbnRhaW5lciAmJiBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9PT0gZW5kQ29udGFpbmVyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIFRPRE8gc2VlIGFib3V0IGVkZ2UgY2FzZXMgd2hlcmUgdGhlIHN0YXJ0Q29udGFpbmVyIGFuZCBlbmRDb250YWluZXIgYXJlIGxlZnQgd2l0aCBubyBjb250ZW50XHJcbiAgLy8gaWYgc2VsZWN0aW9uIGF0IHN0YXJ0IGlzIDAgbWF5YmUgdGhlIHRhZ3BhaXIgc3RhcnQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgYmUgaW5jbHVkZWQgd2l0aCB0aGUgc2VsZWN0aW9uXHJcbiAgLy8gaWYgc2VsZWN0aW9uIGF0IGVuZCBpcyBmdWxsIGNvbnRhaW5lciBsZW5ndGggbWF5YmUgdGhlIHRhZ3BhaXIgZW5kIHNob3VsZCBhdXRvbWF0aWNhbGx5IGJlIGluY2x1ZGVkIHdpdGggdGhlIHNlbGVjdGlvblxyXG5cclxuICB2YXIgbm9kZVdhbGtlciA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihzdGFydENvbnRhaW5lcik7XHJcbiAgdmFyIGVuZCA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihlbmRDb250YWluZXIpO1xyXG5cclxuICBpZiAoZW5kLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgZW5kID0gZW5kLnBhcmVudCgpO1xyXG4gIH1cclxuXHJcbiAgd2hpbGUgKCFub2RlV2Fsa2VyLmlzTnVsbCgpICYmICFub2RlV2Fsa2VyLmlzV3JhcHBlckZvcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcclxuICAgIG1lLmlkZW50aWZ5VGFnc0luQ29udGFpbmVyKG5vZGVXYWxrZXIsIGVuZCk7XHJcbiAgICBub2RlV2Fsa2VyID0gbm9kZVdhbGtlci5wYXJlbnQoKTtcclxuICB9XHJcblxyXG4gIHZhciBkb2N1bWVudEZyYWdtZW50Q29udGFpbmVyID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKHNlbGVjdGlvbi5jbG9uZUNvbnRlbnRzKCkpO1xyXG5cclxuICBtZS5tb3ZlVGFnc1RvRnJvbnQgPSBbXTtcclxuICBtZS5tb3ZlVGFnc1RvRW5kID0gW107XHJcblxyXG4gIG1lLnRyYW5zZm9ybVRhZ3MoZG9jdW1lbnRGcmFnbWVudENvbnRhaW5lcik7XHJcblxyXG4gIG1lLm1vdmVUYWdzVG9Gcm9udC5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcclxuICAgIHRhZy5yZW1vdmUoKTtcclxuICB9KTtcclxuICBtZS5tb3ZlVGFnc1RvRW5kLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xyXG4gICAgdGFnLnJlbW92ZSgpO1xyXG4gIH0pO1xyXG5cclxuICB2YXIgbmVlZHNUb01vdmVUYWdzID0gIG1lLm1vdmVUYWdzVG9Gcm9udC5sZW5ndGggPiAwIHx8IG1lLm1vdmVUYWdzVG9FbmQubGVuZ3RoID4gMDtcclxuICBpZiAoIW5lZWRzVG9Nb3ZlVGFncykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgc2VsZWN0aW9uLmRlbGV0ZUNvbnRlbnRzKCk7XHJcblxyXG4gIHZhciBwYXRjaCA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihzdGFydENvbnRhaW5lcik7XHJcbiAgaWYgKHBhdGNoLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgcGF0Y2ggPSBwYXRjaC5wYXJlbnQoKTtcclxuICB9XHJcblxyXG4gIHZhciBsYXN0RW5kVGFnID0gcGF0Y2g7XHJcbiAgd2hpbGUgKHBhdGNoLnBhcmVudCgpLmlzVGFnUGFpckNvbnRhaW5lcigpKSB7XHJcbiAgICBwYXRjaCA9IHBhdGNoLnBhcmVudCgpO1xyXG4gICAgaWYgKG1lLm1vdmVUYWdzVG9Gcm9udC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGxhc3RFbmRUYWcgPSBtZS5tb3ZlVGFnc1RvRnJvbnQuc2hpZnQoKTtcclxuICAgICAgcGF0Y2guaW5zZXJ0QWZ0ZXIobGFzdEVuZFRhZyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGxhc3RFbmRUYWcuaW5zZXJ0QWZ0ZXIoZG9jdW1lbnRGcmFnbWVudENvbnRhaW5lcik7XHJcblxyXG4gIHBhdGNoID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKGVuZENvbnRhaW5lcik7XHJcbiAgaWYgKHBhdGNoLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgcGF0Y2ggPSBwYXRjaC5wYXJlbnQoKTtcclxuICB9XHJcblxyXG4gIHdoaWxlICghcGF0Y2guaXNOdWxsKCkgJiYgcGF0Y2gucGFyZW50KCkuaXNUYWdQYWlyQ29udGFpbmVyKCkpIHtcclxuICAgIHBhdGNoID0gcGF0Y2gucGFyZW50KCk7XHJcblxyXG4gICAgaWYgKG1lLm1vdmVUYWdzVG9FbmQubGVuZ3RoID4gMCkge1xyXG4gICAgICBwYXRjaC5pbnNlcnRCZWZvcmUobWUubW92ZVRhZ3NUb0VuZC5wb3AoKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBtZS5tb3ZlVGFnc1RvRnJvbnQgPSBudWxsO1xyXG4gIG1lLm1vdmVUYWdzVG9FbmQgPSBudWxsO1xyXG4gIG1lLnRhZ3MgPSBudWxsO1xyXG4gIG1lLnN0b3JlZEV2ZW50ID0gbnVsbDtcclxufTtcclxuXHJcbnByb3RvLmlkZW50aWZ5VGFnc0luQ29udGFpbmVyID0gZnVuY3Rpb24gKG5vZGVXYWxrZXIsIGVuZCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHRhZ0lkO1xyXG5cclxuICBtZS5lbmRDb250YWluZXJSZWFjaGVkID0gZmFsc2U7XHJcblxyXG4gIGRvIHtcclxuICAgIGlmIChub2RlV2Fsa2VyLmVxdWFscyhlbmQpKSB7XHJcbiAgICAgIG1lLmVuZENvbnRhaW5lclJlYWNoZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub2RlV2Fsa2VyLmlzVGFnUGFpckNvbnRhaW5lcigpKSB7XHJcbiAgICAgIG5vZGVXYWxrZXIgPSBub2RlV2Fsa2VyLmZpcnN0Q2hpbGQoKTtcclxuICAgICAgbWUuaWRlbnRpZnlUYWdzSW5Db250YWluZXIobm9kZVdhbGtlciwgZW5kKTtcclxuICAgICAgbm9kZVdhbGtlciA9IG5vZGVXYWxrZXIucGFyZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vZGVXYWxrZXIuaXNTdGFydFRhZygpICYmIG5vZGVXYWxrZXIuY2FuSGlkZSgpKSB7XHJcbiAgICAgIHRhZ0lkID0gbm9kZVdhbGtlci50YWdJZCgpO1xyXG4gICAgICBtZS50YWdzW3RhZ0lkXSA9IHtzdGFydFRhZzogbm9kZVdhbGtlcixcclxuICAgICAgICBlbmRUYWc6IG51bGxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZVdhbGtlci5pc0VuZFRhZygpICYmIG5vZGVXYWxrZXIuY2FuSGlkZSgpKSB7XHJcbiAgICAgIHRhZ0lkID0gbm9kZVdhbGtlci50YWdJZCgpO1xyXG4gICAgICBtZS50YWdzW3RhZ0lkXSA9IG1lLnRhZ3NbdGFnSWRdIHx8IHtzdGFydFRhZzogbnVsbCwgZW5kVGFnOiBudWxsIH07XHJcbiAgICAgIG1lLnRhZ3NbdGFnSWRdLmVuZFRhZyA9IG5vZGVXYWxrZXI7XHJcblxyXG4gICAgICBpZiAobWUudGFnc1t0YWdJZF0uc3RhcnRUYWcgIT09IG51bGwpIHtcclxuICAgICAgICBtZS5fcmVtb3ZlSW5saW5lKG5vZGVXYWxrZXIuZWwsIG1lLnN0b3JlZEV2ZW50KTtcclxuXHJcbiAgICAgICAgZGVsZXRlIG1lLnRhZ3NbdGFnSWRdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbm9kZVdhbGtlciA9IG5vZGVXYWxrZXIubmV4dCgpO1xyXG5cclxuICB9IHdoaWxlICghbm9kZVdhbGtlci5pc051bGwoKSAmJiAhbWUuZW5kQ29udGFpbmVyUmVhY2hlZCk7XHJcblxyXG4gIG5vZGVXYWxrZXIucmV0dXJuVG9QcmV2aW91cygpO1xyXG59O1xyXG5cclxucHJvdG8udHJhbnNmb3JtVGFncyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBpc0luVGFncyxcclxuICAgICAgbm9kZVdhbGtlcjtcclxuXHJcbiAgaWYgKCFjb250YWluZXIuaGFzQ2hpbGRyZW4oKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgbm9kZVdhbGtlciA9IGNvbnRhaW5lci5maXJzdENoaWxkKCk7XHJcbiAgZG8ge1xyXG4gICAgaXNJblRhZ3MgPSBub2RlV2Fsa2VyLnRhZ0lkKCkgaW4gbWUudGFncztcclxuICAgIGlmIChub2RlV2Fsa2VyLmlzVGFnUGFpckNvbnRhaW5lcigpICYmIGlzSW5UYWdzKSB7XHJcbiAgICAgIHZhciB0YWdwYWlyID0gbm9kZVdhbGtlcjtcclxuXHJcbiAgICAgIG1lLnRyYW5zZm9ybVRhZ3ModGFncGFpcik7XHJcbiAgICAgIG5vZGVXYWxrZXIgPSBub2RlV2Fsa2VyLm5leHQoKTtcclxuICAgICAgdGFncGFpci5yZXBsYWNlV2l0aElubmVyQ29udGVudCgpO1xyXG5cclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vZGVXYWxrZXIuaXNTdGFydFRhZygpICYmIGlzSW5UYWdzKSB7XHJcbiAgICAgIG1lLm1vdmVUYWdzVG9FbmQucHVzaChub2RlV2Fsa2VyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZVdhbGtlci5pc0VuZFRhZygpICYmIGlzSW5UYWdzKSB7XHJcbiAgICAgIG1lLm1vdmVUYWdzVG9Gcm9udC5wdXNoKG5vZGVXYWxrZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIG5vZGVXYWxrZXIgPSBub2RlV2Fsa2VyLm5leHQoKTtcclxuICB9IHdoaWxlICghbm9kZVdhbGtlci5pc051bGwoKSk7XHJcbn07XHJcblxyXG5cclxucHJvdG8uaGFuZGxlTWlzc2luZ1RleHRDb250YWluZXIgPSBmdW5jdGlvbiAoZXYpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBzZWxlY3Rpb24sXHJcbiAgICAgIGZvY3VzTm9kZSxcclxuICAgICAgdGV4dENvbnRlbnQsXHJcbiAgICAgIHplcm9XaWR0aENoYXJJbmRleCxcclxuICAgICAgdGV4dEJlZm9yZSxcclxuICAgICAgdGV4dEFmdGVyLFxyXG4gICAgICB0ZXh0RWwsXHJcbiAgICAgIGlzSW5TZWdtZW50LFxyXG4gICAgICBjb250YWluZXJFbCxcclxuICAgICAgY3VycmVudFRleHQsXHJcbiAgICAgIHVlVGFnV3JhcHBlcixcclxuICAgICAgcmFuZ2U7XHJcblxyXG4gIGlmIChtZS5pZ25vcmVkS2V5cy5pbmRleE9mKGV2LmtleUNvZGUpICE9PSAtMSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGV2LmtleUNvZGUgPT09IG1lLmtleURlbGV0ZSB8fCBldi5rZXlDb2RlID09PSBtZS5rZXlCYWNrc3BhY2UpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpIHx8IHt9O1xyXG4gIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XHJcblxyXG4gIGlmIChmb2N1c05vZGUgPT09IHVuZGVmaW5lZCB8fCBmb2N1c05vZGUgPT09IG51bGwpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHRleHRDb250ZW50ID0gZm9jdXNOb2RlLnRleHRDb250ZW50O1xyXG4gIHplcm9XaWR0aENoYXJJbmRleCA9IHRleHRDb250ZW50LmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZSh0bXBsLnplcm9XaWR0aE5vbkpvaW5lckNoYXJDb2RlKSk7XHJcblxyXG4gIGlmICh6ZXJvV2lkdGhDaGFySW5kZXggPiAtMSkge1xyXG4gICAgdGV4dEJlZm9yZSA9IHRleHRDb250ZW50LnN1YnN0cmluZygwLCB6ZXJvV2lkdGhDaGFySW5kZXgpO1xyXG4gICAgdGV4dEFmdGVyID0gdGV4dENvbnRlbnQuc3Vic3RyaW5nKHplcm9XaWR0aENoYXJJbmRleCArIDEpO1xyXG5cclxuICAgIHRleHRFbCA9ICQodG1wbC50ZXh0KS5hcHBlbmQodGV4dEJlZm9yZSkuYXBwZW5kKHRleHRBZnRlcik7XHJcbiAgICB0ZXh0RWxbMF0uZGF0YXNldC50eXBlID0gJ3RleHQnO1xyXG5cclxuICAgIGlzSW5TZWdtZW50ID0gJChmb2N1c05vZGUucGFyZW50Tm9kZSkuaGFzQ2xhc3MoJ3VlLXNlZ21lbnQnKTtcclxuXHJcbiAgICBpZiAoaXNJblNlZ21lbnQpIHtcclxuICAgICAgJChmb2N1c05vZGUubmV4dFNpYmxpbmcpLnByZXBlbmQodGV4dEVsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnRhaW5lckVsID0gJChmb2N1c05vZGUucGFyZW50Tm9kZSk7XHJcblxyXG4gICAgICBpZiAoY29udGFpbmVyRWwuaGFzQ2xhc3MoJ3VlLXRleHQnKSkge1xyXG4gICAgICAgIGN1cnJlbnRUZXh0ID0gY29udGFpbmVyRWwudGV4dCgpO1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmh0bWwodGV4dEVsLnRleHQoKSArIGN1cnJlbnRUZXh0KTtcclxuICAgICAgfSBlbHNlIGlmIChjb250YWluZXJFbC5oYXNDbGFzcygndWUtaW5saW5lLWNvbnRlbnQnKSkge1xyXG4gICAgICAgIGNvbnRhaW5lckVsLmFwcGVuZCh0ZXh0RWwpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVlVGFnV3JhcHBlciA9ICQoZm9jdXNOb2RlKS5wYXJlbnQoKTtcclxuICAgICAgICB1ZVRhZ1dyYXBwZXIuYWZ0ZXIodGV4dEVsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICQoZm9jdXNOb2RlKS5yZXBsYWNlV2l0aCh0bXBsLnp3bmopO1xyXG5cclxuICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuICAgIHJhbmdlLnNlbGVjdE5vZGUodGV4dEVsWzBdKTtcclxuICAgIHJhbmdlLmNvbGxhcHNlKCk7XHJcblxyXG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcclxuICB9XHJcbn07XHJcblxyXG5wcm90by5faGFzSW5saW5lQ29udGVudFBhcmVudCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgdmFyIGhhc0lubGluZUNvbnRlbnRQYXJlbnQgPSAkKG5vZGUucGFyZW50Tm9kZSkuaGFzQ2xhc3MoJ3VlLWlubGluZS1jb250ZW50Jyk7XHJcblxyXG4gIHJldHVybiBoYXNJbmxpbmVDb250ZW50UGFyZW50O1xyXG59O1xyXG5cclxucHJvdG8uX3Bvc2l0aW9uSW5QYXJlbnQgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUsXHJcbiAgICAgIHBvc2l0aW9uID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XHJcblxyXG4gIHJldHVybiBwb3NpdGlvbjtcclxufTtcclxuXHJcbnByb3RvLnJlc2l6ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChldikge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcbiAgdmFyIGVudGVySXNQcmVzc2VkID0gKGV2LmtleUNvZGUgPT09IG1lLmtleUVudGVyKTtcclxuXHJcbiAgaWYgKCEoZXYuc2hpZnRLZXkgJiYgZW50ZXJJc1ByZXNzZWQpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBzZWdtZW50V2F0Y2hlci5yZXNpemUobWUuY3VycmVudFNlZ21lbnROdW1iZXIpO1xyXG59O1xyXG5cclxucHJvdG8ubWFya0N1cnJlbnRTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIHZhciBwcmV2aW91c1NlZ21lbnROdW1iZXIgPSBtZS5jdXJyZW50U2VnbWVudE51bWJlcjtcclxuICB2YXIgcHJldmlvdXNTZWdtZW50RWwgPSBtZS5jdXJyZW50U2VnbWVudEVsO1xyXG5cclxuICB2YXIgY3VycmVudFNlZ21lbnRTZWxlY3Rpb24gPSBtZS5fc2VnbWVudFVuZGVyQ3VycmVudFNlbGVjdGlvbigpO1xyXG5cclxuICBtZS5jdXJyZW50U2VnbWVudE51bWJlciA9IGN1cnJlbnRTZWdtZW50U2VsZWN0aW9uLnNlZ21lbnROdW1iZXI7XHJcbiAgbWUuY3VycmVudFNlZ21lbnRFbCA9IGN1cnJlbnRTZWdtZW50U2VsZWN0aW9uLnNlZ21lbnRFbDtcclxuXHJcbiAgc2VnbWVudFdhdGNoZXIubWFya0NvbnRhaW5lckFzSW5hY3RpdmUocHJldmlvdXNTZWdtZW50TnVtYmVyKTtcclxuICBzZWdtZW50V2F0Y2hlci5tYXJrQ29udGFpbmVyQXNBY3RpdmUobWUuY3VycmVudFNlZ21lbnROdW1iZXIpO1xyXG5cclxuICBpZiAobWUuY3VycmVudFNlZ21lbnROdW1iZXIgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgbWUuY3VycmVudFNlZ21lbnRFbCAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICBtZS5jdXJyZW50U2VnbWVudE51bWJlciAhPT0gcHJldmlvdXNTZWdtZW50TnVtYmVyKSB7XHJcblxyXG4gICAgdmFyIGN1cnJlbnREYXRhc2V0ID0gbWUuY3VycmVudFNlZ21lbnRFbC5kYXRhc2V0O1xyXG5cclxuICAgIE1lZGlhdG9yLnB1Ymxpc2goJ3NlZ21lbnQ6c3RhcnQtZWRpdCcsIHtcclxuICAgICAgZWw6IG1lLmN1cnJlbnRTZWdtZW50RWwsXHJcbiAgICAgIHNlZ21lbnROdW1iZXI6IGN1cnJlbnREYXRhc2V0LnNlZ21lbnROdW1iZXIsXHJcbiAgICAgIG90aGVyU2VnbWVudERhdGE6IGRhdGFQcm92aWRlci5nZXRTZWdtZW50QnlTZWdtZW50TnVtYmVyKG1lLmN1cnJlbnRTZWdtZW50TnVtYmVyKVxyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgaWYgKHByZXZpb3VzU2VnbWVudE51bWJlciAhPT0gbWUuY3VycmVudFNlZ21lbnROdW1iZXIgJiZcclxuICAgICAgcHJldmlvdXNTZWdtZW50RWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgdmFyIHByZXZpb3VzRGF0YXNldCA9IHByZXZpb3VzU2VnbWVudEVsLmRhdGFzZXQ7XHJcblxyXG4gICAgTWVkaWF0b3IucHVibGlzaCgnc2VnbWVudDplbmQtZWRpdCcsIHtcclxuICAgICAgZWw6IHByZXZpb3VzU2VnbWVudEVsLFxyXG4gICAgICBzZWdtZW50TnVtYmVyOiBwcmV2aW91c0RhdGFzZXQuc2VnbWVudE51bWJlcixcclxuICAgICAgb3RoZXJTZWdtZW50RGF0YTogZGF0YVByb3ZpZGVyLmdldFNlZ21lbnRCeVNlZ21lbnROdW1iZXIocHJldmlvdXNTZWdtZW50TnVtYmVyKVxyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxucHJvdG8uY2hhbmdlU3RhdHVzVG9EcmFmdCA9IGZ1bmN0aW9uIChldikge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGlzU2hpZnRFbnRlclByZXNzZWQsXHJcbiAgICAgIHNlZ21lbnQsXHJcbiAgICAgIHNlZ21lbnREYXRhO1xyXG5cclxuICBpc1NoaWZ0RW50ZXJQcmVzc2VkID0gKGV2LnNoaWZ0S2V5ICYmIGV2LmtleUNvZGUgPT09IG1lLmtleUVudGVyKTtcclxuXHJcbiAgaWYgKCFpc1NoaWZ0RW50ZXJQcmVzc2VkICYmIG1lLmlnbm9yZWRLZXlzLmluZGV4T2YoZXYua2V5Q29kZSkgIT09IC0xKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBzZWdtZW50RGF0YSA9IGRhdGFQcm92aWRlci5nZXRTZWdtZW50QnlTZWdtZW50TnVtYmVyKG1lLmN1cnJlbnRTZWdtZW50TnVtYmVyKTtcclxuICBzZWdtZW50ID0gbmV3IFNlZ21lbnQoc2VnbWVudERhdGEpO1xyXG5cclxuICBpZiAoKCFldi5jdHJsS2V5IHx8ICFldi5tZXRhS2V5KSAmJiBoZWxwZXJzLmtleUNvZGVUb1N0cmluZyhldi53aGljaCkgIT09ICdsJykge1xyXG4gICAgc2VnbWVudC5jaGFuZ2VUb0RyYWZ0KCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgTWVkaWF0b3IucHVibGlzaCgnc2VnbWVudDpjb25maXJtYXRpb25MZXZlbENoYW5nZWQnLCBzZWdtZW50RGF0YSk7XHJcbn07XHJcblxyXG5cclxucHJvdG8uY2hhbmdlU3RhdHVzVG9Db25maXJtZWQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG4gIHZhciBpc0N0cmxFbnRlclByZXNzZWQgPSBldi5jdHJsS2V5ICYmIChldi5rZXlDb2RlID09PSBtZS5rZXlFbnRlcik7XHJcblxyXG4gIGlmICghaXNDdHJsRW50ZXJQcmVzc2VkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgc2VnbWVudCA9IGRhdGFQcm92aWRlci5nZXRTZWdtZW50QnlTZWdtZW50TnVtYmVyKG1lLmN1cnJlbnRTZWdtZW50TnVtYmVyKTtcclxuXHJcbiAgaWYgKHNlZ21lbnQuY29uZmlybWF0aW9ubGV2ZWwgIT09ICd0cmFuc2xhdGVkJykge1xyXG4gICAgc2VnbWVudC5jb25maXJtYXRpb25sZXZlbCA9ICd0cmFuc2xhdGVkJztcclxuICAgIE1lZGlhdG9yLnB1Ymxpc2goJ3NlZ21lbnQ6Y29uZmlybWF0aW9uTGV2ZWxDaGFuZ2VkJywgc2VnbWVudCk7XHJcbiAgICBNZWRpYXRvci5wdWJsaXNoKCdzZWdtZW50Omp1bXBUb05leHRVbkNvbmZpcm1lZCcsIHNlZ21lbnQpO1xyXG4gIH1cclxufTtcclxuXHJcbnByb3RvLmhhbmRsZUNhcmV0UG9zaXRpb24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBhcnJvd0tleVByZXNzZWQgPSBtZS5pc0Fycm93S2V5KGV2LmtleUNvZGUpLFxyXG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKSxcclxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcclxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQsXHJcbiAgICAgIG1vdmVtZW50S2V5cyA9IFttZS5rZXlMZWZ0QXJyb3csIG1lLmtleVJpZ2h0QXJyb3ddLFxyXG4gICAgICBpbmRleE9mTW92ZW1lbnRLZXlzID0gbW92ZW1lbnRLZXlzLmluZGV4T2YoZXYua2V5Q29kZSk7XHJcblxyXG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwgfHwgZm9jdXNOb2RlID09PSBudWxsKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoaW5kZXhPZk1vdmVtZW50S2V5cyA9PT0gLTEpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBpc1RleHROb2RlID0gZm9jdXNOb2RlLm5vZGVUeXBlID09PSBtZS50ZXh0Tm9kZVR5cGU7XHJcblxyXG4gIHZhciBpc01vdmluZ0ZvcndhcmQgPSBldi5rZXlDb2RlID09PSBtZS5rZXlSaWdodEFycm93O1xyXG4gIHZhciBtb3ZlRGlyZWN0aW9uID0gaXNNb3ZpbmdGb3J3YXJkID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJztcclxuXHJcbiAgaWYgKGlzVGV4dE5vZGUgJiYgKG1lLl9pc0ludmlzaWJsZUNoYXIoZm9jdXNOb2RlKSkpIHtcclxuICAgIGlmIChldi5rZXlDb2RlID09PSBtZS5rZXlMZWZ0QXJyb3cpIHtcclxuICAgICAgc2VsZWN0aW9uLm1vZGlmeSgnbW92ZScsICdiYWNrd2FyZCcsICdjaGFyYWN0ZXInKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gbWUua2V5UmlnaHRBcnJvdykge1xyXG4gICAgICBzZWxlY3Rpb24ubW9kaWZ5KCdtb3ZlJywgJ2ZvcndhcmQnLCAnY2hhcmFjdGVyJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoZm9jdXNOb2RlLm5vZGVUeXBlID09PSBtZS5lbGVtZW50Tm9kZVR5cGUpIHtcclxuICAgIHNlbGVjdGlvbi5tb2RpZnkoJ21vdmUnLCAnZm9yd2FyZCcsICdjaGFyYWN0ZXInKTtcclxuICB9XHJcblxyXG4gIHdoaWxlIChtZS5faXNJbnNpZGVUYWcoc2VsZWN0aW9uLmZvY3VzTm9kZSkpIHtcclxuICAgIHNlbGVjdGlvbi5tb2RpZnkoJ21vdmUnLCBtb3ZlRGlyZWN0aW9uLCAnY2hhcmFjdGVyJyk7XHJcbiAgfVxyXG59O1xyXG5cclxucHJvdG8uX2lzSW52aXNpYmxlQ2hhciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudCxcclxuICAgICAgaXNJbnZpc2libGVDaGFyID0gdGV4dENvbnRlbnQubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IHRtcGwuemVyb1dpZHRoTm9uSm9pbmVyQ2hhckNvZGU7XHJcblxyXG4gIHJldHVybiBpc0ludmlzaWJsZUNoYXI7XHJcbn07XHJcblxyXG5wcm90by5faXNJbnNpZGVUYWcgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gIHZhciBpc1RhZztcclxuXHJcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgaXNUYWcgPSAkKG5vZGUucGFyZW50Tm9kZSkuaGFzQ2xhc3MoJ3VlLXRhZycpO1xyXG5cclxuICByZXR1cm4gaXNUYWc7XHJcbn07XHJcblxyXG5wcm90by5pc0Fycm93S2V5ID0gZnVuY3Rpb24gKGtleUNvZGUpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICByZXR1cm4ga2V5Q29kZSA9PT0gbWUua2V5VXBBcnJvdyB8fFxyXG4gICAgICAgICBrZXlDb2RlID09PSBtZS5rZXlEb3duQXJyb3cgfHxcclxuICAgICAgICAga2V5Q29kZSA9PT0gbWUua2V5TGVmdEFycm93IHx8XHJcbiAgICAgICAgIGtleUNvZGUgPT09IG1lLmtleVJpZ2h0QXJyb3c7XHJcbn07XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBMb2NrIGN1cnJlbnQgc2VnbWVudCBvbiBDVFJMK2xcclxuICogQHBhcmFtICB7RXZlbnRPYmplY3R9IGV2XHJcbiAqL1xyXG5wcm90by50b2dnbGVTZWdtZW50TG9ja1N0YXRlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgY2hhcktleSA9IGhlbHBlcnMua2V5Q29kZVRvU3RyaW5nKGV2LndoaWNoKSxcclxuICAgICAgc2VnbWVudCA9IG1lLl9zZWdtZW50VW5kZXJDdXJyZW50U2VsZWN0aW9uKCksXHJcbiAgICAgIHNlZ21lbnREYXRhID0gZGF0YVByb3ZpZGVyLmdldFNlZ21lbnRCeVNlZ21lbnROdW1iZXIobWUuY3VycmVudFNlZ21lbnROdW1iZXIpLFxyXG4gICAgICBzZWdtZW50RWwgPSBzZWdtZW50LnNlZ21lbnRFbCxcclxuICAgICAgaXNMb2NrZWRTZWdtZW50LFxyXG4gICAgICBzb3VyY2VSZWw7XHJcblxyXG4gIGlmICgoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSAmJiBjaGFyS2V5ID09PSAnbCcpIHtcclxuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgaXNMb2NrZWRTZWdtZW50ID0gc2VnbWVudERhdGEuaXNMb2NrZWQgfHwgZmFsc2U7IC8vaGVscGVycy5oYXNDbGFzcyhzZWdtZW50RWwsICd1ZS1zZWdtZW50LWxvY2tlZCcpO1xyXG4gICAgc291cmNlUmVsID0gJCgnW2RhdGEtc291cmNlLXNlZ21lbnQtbnVtYmVyPVwiJyArIHNlZ21lbnQuc2VnbWVudE51bWJlciArICdcIl0nKVswXTtcclxuXHJcbiAgICBpZiAoaXNMb2NrZWRTZWdtZW50KSB7XHJcbiAgICAgIC8vIFVuLWxvY2sgc2VnbWVudCBhbmQgcHVibGlzaCB1bmxvY2sgZXZlbnRcclxuICAgICAgW3NlZ21lbnRFbCwgc291cmNlUmVsXS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKCd1ZS1zZWdtZW50LWxvY2tlZCcpO1xyXG4gICAgICAgIGVsZW0uZGF0YXNldC5pc0xvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHNlZ21lbnREYXRhLmlzTG9ja2VkID0gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgTWVkaWF0b3IucHVibGlzaCgnc2VnbWVudDp1bmxvY2snLCBzZWdtZW50RGF0YSk7XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFyayBzZWdtZW50IGFzIGxvY2tlZCBhbmQgcHVibGlzaCBsb2NrIGV2ZW50XHJcbiAgICBbc2VnbWVudEVsLCBzb3VyY2VSZWxdLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKCd1ZS1zZWdtZW50LWxvY2tlZCcpO1xyXG4gICAgICBlbGVtLmRhdGFzZXQuaXNMb2NrZWQgPSB0cnVlO1xyXG4gICAgICBzZWdtZW50RGF0YS5pc0xvY2tlZCA9IHRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBNZWRpYXRvci5wdWJsaXNoKCdzZWdtZW50OmxvY2snLCBzZWdtZW50RGF0YSk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbnNlcnQgdGFiIG9uIFRBQiBrZXlwcmVzc1xyXG4gKiBAcGFyYW0gIHtFdmVudH0gZXZcclxuICovXHJcbnByb3RvLmluc2VydFRhYiA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcclxuICB2YXIgdGFiID0gdG1wbC5rZXlUYWIudW5pY29kZSxcclxuICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0YWIpLFxyXG4gICAgICByYW5nZTtcclxuXHJcbiAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcclxuXHJcblxyXG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcclxuICAgIHJhbmdlLmluc2VydE5vZGUodGV4dE5vZGUpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcclxuICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XHJcbiAgICByYW5nZS5pbnNlcnROb2RlKHRleHROb2RlKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBNb3ZlIGN1cnNvciBhZnRlciBpbnNlcnRlZCB0YWJcclxuICByYW5nZS5zZXRTdGFydEFmdGVyKHRleHROb2RlKTtcclxuICByYW5nZS5zZXRFbmRBZnRlcih0ZXh0Tm9kZSk7XHJcblxyXG4gIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBIYW5kZWwgVEFCIGtleXMgcHJlc3NcclxuICogQHBhcmFtICB7T2JqZWN0fSBldiBbZGVzY3JpcHRpb25dXHJcbiAqL1xyXG5wcm90by5oYW5kbGVUYWJLZXkgPSBmdW5jdGlvbiAoZXYpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcclxuXHJcbiAgaWYgKGV2LmtleUNvZGUgPT09IG1lLmtleVRhYikge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAvLyBJZiBsb2NrZWQgc2VnbWVudCBvciBsb2NrZWQgY29udGVudFxyXG4gICAgLy8gc3RvcCBpbnNlcnRpbmcgdGFic1xyXG4gICAgaWYgKG1lLmN1cnJlbnRFbGVtZW50SXNMb2NrZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIG1lLmluc2VydFRhYihzZWxlY3Rpb24pO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGlzYWJsZXMgZWRpdHRpbmcgaW4gYSBsb2NrZWQgc2VnbWVudCBvciBhIGxvY2tlZCBjb250ZW50XHJcbiAqIEBwYXJhbSAge09iamVjdH0gZXZcclxuICovXHJcbnByb3RvLmRpc2FibGVFZGl0aW5nID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgY3VycmVudFNlZ21lbnQgPSBtZS5fc2VnbWVudFVuZGVyQ3VycmVudFNlbGVjdGlvbigpLFxyXG4gICAgICBzZWxlY3Rpb25Db250ZXh0ID0gbmV3IFNlbGVjdGlvbi5TZWxlY3Rpb25Db250ZXh0KCksXHJcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbkNvbnRleHQuc2VsZWN0aW9uLFxyXG4gICAgICBub2RlV2Fsa2VyID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKGV2LnRhcmdldCksXHJcbiAgICAgIGlzSW52aXNpYmxlQ2hhciA9IG5vZGVXYWxrZXIuaXNJbnZpc2libGVDaGFyKCksXHJcbiAgICAgIGlzU2VnbWVudCA9IG5vZGVXYWxrZXIuaXNTZWdtZW50KCksXHJcbiAgICAgIHNlZ21lbnREYXRhLCBlbGVtLCByYW5nZTtcclxuXHJcbiAgLy8gTWFrZSBzdXJlIHRoaXMgaXMgZmFsc2UgYnkgZGVmYXVsdFxyXG4gIG1lLmN1cnJlbnRFbGVtZW50SXNMb2NrZWQgPSBmYWxzZTtcclxuXHJcbiAgLy8gSXMgbG9ja2VkIGNvbnRlbnRcclxuICBpZiAoc2VsZWN0aW9uLmFuY2hvck5vZGUpIHtcclxuICAgIGVsZW0gPSBzZWxlY3Rpb25Db250ZXh0LmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzU2VnbWVudCAmJiBzZWxlY3Rpb25Db250ZXh0LmlzQ29sbGFwc2VkKCkpIHtcclxuICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuICAgIHJhbmdlLnNlbGVjdE5vZGUobm9kZVdhbGtlci5maXJzdENoaWxkKCkuZWwubmV4dFNpYmxpbmcpO1xyXG5cclxuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XHJcbiAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcclxuICB9XHJcblxyXG4gIC8vIElzIGN1cnNvciBpbiBhIGxvY2tlZCBzZWdtZW50IG9yIGNvbnRlbnQ/XHJcbiAgaWYgKGN1cnJlbnRTZWdtZW50LnNlZ21lbnRFbC5kYXRhc2V0LmlzTG9ja2VkIHx8IGhlbHBlcnMuaGFzUGFyZW50KGVsZW0ucGFyZW50Tm9kZSwgJ3VlLWxvY2tlZC1jb250ZW50JykpIHtcclxuICAgIG1lLmN1cnJlbnRFbGVtZW50SXNMb2NrZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKG1lLmN1cnJlbnRFbGVtZW50SXNMb2NrZWQpIHtcclxuICAgIC8vIFByZXZlbnQgdXNlciB0byBlZGl0IGxvY2tlZCBzZWdtZW50IG9yIGNvbnRlbnRcclxuICAgIGlmICghKGV2LmtleUNvZGUgaW4gbWUuYWxsb3dlZEtleXNJbkxvY2tlZENvbnRlbnQpKSB7XHJcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICBzZWdtZW50RGF0YSA9IGRhdGFQcm92aWRlci5nZXRTZWdtZW50QnlTZWdtZW50TnVtYmVyKGN1cnJlbnRTZWdtZW50LnNlZ21lbnROdW1iZXIpO1xyXG5cclxuICAgICAgLy8gUHJldmVudCBzZWdtZW50IHN0YXR1cyBjaGFuZ2VcclxuICAgICAgc2VnbWVudERhdGEuc3RvcEVkaXRpbmcgPSBtZS5jdXJyZW50RWxlbWVudElzTG9ja2VkO1xyXG4gICAgICBNZWRpYXRvci5wdWJsaXNoKCdzZWdtZW50OnN0b3BFZGl0aW5nSW5Mb2NrZWRDb250ZW50Jywgc2VnbWVudERhdGEpO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogSGFuZGxlcyBjcm9zcyBzZWdtZW50cyBzZWxlY3Rpb25cclxuICogVE9ETzogZXh0ZW5kIGl0IGZvciBtb3VzZSBkcmFnIHNlbGVjdGlvbiBvciBrZXlib2FyZCBzZWxlY3Rpb24/XHJcbiAqL1xyXG5wcm90by5oYW5kbGVDcm9zc1NlZ21lbnRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICB2YXIgdGV4dENvbnRlbnQgPSBldi50YXJnZXQudGV4dENvbnRlbnQsXHJcbiAgICAgIHNlbGVjdGlvbkNvbnRleHQgPSBuZXcgU2VsZWN0aW9uLlNlbGVjdGlvbkNvbnRleHQoKSxcclxuICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uQ29udGV4dC5zZWxlY3Rpb24sXHJcbiAgICAgIGlzSW52aXNpYmxlQ2hhciA9IChuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoZXYudGFyZ2V0KSkuaXNJbnZpc2libGVDaGFyKCksXHJcbiAgICAgIHJhbmdlO1xyXG5cclxuICAvLyBJZiBkYmxjbGljayBvciB0cmlwbGVjbGljayBhbmQgc2VnbWVudCBpcyBlbXB0eVxyXG4gIC8vIChyZWxpZXMgb24gWmVybyBXaWR0aCBOb24tSm9pbmVyLCB0byBiZSBjaGFuZ2VkIGlmIGl0IHdpbGwgYmUgcmVtb3ZlZClcclxuICBpZiAoZXYub3JpZ2luYWxFdmVudC5kZXRhaWwgPj0gMiAmJiBpc0ludmlzaWJsZUNoYXIpIHtcclxuICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuICAgIHJhbmdlLnNlbGVjdE5vZGUoZXYudGFyZ2V0LmNoaWxkcmVuWzBdKTtcclxuXHJcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xyXG4gICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBLZXlib2FyZEJpbmRpbmdzOyIsIi8qIEZpbGU6IExheW91dC5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzIF8sIHJlcXVpcmUsIG1vZHVsZSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEhlbHBlcnMgPSByZXF1aXJlKCcuL0hlbHBlcnMnKTtcclxudmFyIFRtcGwgPSByZXF1aXJlKCcuL1RtcGwnKTtcclxudmFyIE1lZGlhdG9yID0gcmVxdWlyZSgnLi9NZWRpYXRvcicpO1xyXG52YXIgUmliYm9uTWVudUNvbW1hbmRzID0gcmVxdWlyZSgnLi9sYXlvdXQvUmliYm9uTWVudUNvbW1hbmRzJyk7XHJcblxyXG52YXIgZGlzcGxheVNhdmluZ0luZm9ybWF0aW9uID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICB2YXIgZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3VlLXN0YXR1cy1pbmZvcm1hdGlvbicpLml0ZW0oMCksXHJcbiAgICAgIGNoaWxkcmVuID0gZWxlbSA/IGVsZW0uY2hpbGROb2RlcyA6IG51bGwsXHJcbiAgICAgIHRtcGwgPSBUbXBsLmZpbGVTdGF0dXMsXHJcbiAgICAgIHN0cmluZ1RvSFRNTEVsZW1lbnQgPSBIZWxwZXJzLnN0cmluZ1RvSFRNTEVsZW1lbnQsXHJcbiAgICAgIGkgPSAwLCBsZW4sIHByZXBhcmVNZXNzYWdlO1xyXG5cclxuICAvLyBFeGl0IGlmIGVsZW1lbnQgaXMgbm8gcHJlc2VudFxyXG4gIGlmIChlbGVtID09PSB1bmRlZmluZWQgfHwgZWxlbSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGV4aXN0aW5nIG1lc3NhZ2VzXHJcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG5cclxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgZWxlbS5yZW1vdmVDaGlsZChjaGlsZHJlbltpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEaXNwbGF5IG1lc3NhZ2VzIHV0aWxpdHkgZnVuY3Rpb25cclxuICBwcmVwYXJlTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gZWxlbS5hcHBlbmRDaGlsZChzdHJpbmdUb0hUTUxFbGVtZW50KF8udGVtcGxhdGUodG1wbCwge3N0YXR1czogbWVzc2FnZX0pKSk7XHJcbiAgfVxyXG5cclxuICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgIGNhc2UgJ2JlZm9yZSc6XHJcbiAgICAgIHByZXBhcmVNZXNzYWdlKCdTYXZpbmcgY2hhbmdlcy4uLicpO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlICdhZnRlcic6XHJcbiAgICAgIHByZXBhcmVNZXNzYWdlKCdBbGwgY2hhbmdlcyBzYXZlZCcpO1xyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlICdmYWlsZWQnOlxyXG4gICAgICBwcmVwYXJlTWVzc2FnZSgnU2F2aW5nIGZhaWxlZCcpO1xyXG4gICAgICBicmVhaztcclxuICB9XHJcbn07XHJcblxyXG52YXIgYmVmb3JlU2F2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZGlzcGxheVNhdmluZ0luZm9ybWF0aW9uKCdiZWZvcmUnKTtcclxufTtcclxuXHJcbnZhciBhZnRlclNhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGRpc3BsYXlTYXZpbmdJbmZvcm1hdGlvbignYWZ0ZXInKTtcclxufTtcclxuXHJcbnZhciBmYWlsZWRTYXZlID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBkaXNwbGF5U2F2aW5nSW5mb3JtYXRpb24oJ2ZhaWxlZCcpO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyBUTyBETzogUmUtZmFjdG9yIHRoaXMgcGFydCB3aGljaCBkZWFscyB3aXRoXHJcbiAgICAgIC8vICAgICAgICBlZGl0b3IgY29sdW1ucyByZXNpemVcclxuICAgICAgJCh3aW5kb3cpLm9uKCdsb2FkIHJlc2l6ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd3JhcHBlciA9ICQoJy53cmFwcGVyJyksXHJcbiAgICAgICAgICAgIHdlc3QgPSAkKCcud3JhcHBlci13ZXN0JyksXHJcbiAgICAgICAgICAgIGVhc3QgPSAkKCcud3JhcHBlci1lYXN0JyksXHJcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzID0gJCgnLnVlLWd1dHRlcicpLFxyXG4gICAgICAgICAgICBzdGF0dXMgPSAkKCcudWUtc3RhdHVzJyksXHJcbiAgICAgICAgICAgIHRvcEhlaWdodCA9ICQoJy5uYXZiYXInKS5vdXRlckhlaWdodCgpLFxyXG4gICAgICAgICAgICByaWJib25IZWlnaHQgPSAkKCcubmF2LXJpYmJvbicpLm91dGVySGVpZ2h0KCksXHJcbiAgICAgICAgICAgIHdpbmRvd0hlaWdodCA9ICQod2luZG93KS5oZWlnaHQoKSxcclxuICAgICAgICAgICAgc3RhdHVzQmFySGVpZ2h0ID0gJCgnLnN0YXR1cy1iYXInKS5vdXRlckhlaWdodCgpLFxyXG4gICAgICAgICAgICBjb2xIZWlnaHQ7XHJcblxyXG4gICAgICAgIGlmICh3ZXN0Lmxlbmd0aCB8fCBlYXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgY29sSGVpZ2h0ID0gd2luZG93SGVpZ2h0IC0gKHRvcEhlaWdodCArIHJpYmJvbkhlaWdodCArIHN0YXR1c0JhckhlaWdodCk7XHJcblxyXG4gICAgICAgICAgd3JhcHBlci5oZWlnaHQoY29sSGVpZ2h0KTtcclxuICAgICAgICAgIHdlc3QuY3NzKCdtaW4taGVpZ2h0JywgY29sSGVpZ2h0ICsgJ3B4Jyk7XHJcbiAgICAgICAgICBlYXN0LmNzcygnbWluLWhlaWdodCcsIGNvbEhlaWdodCArICdweCcpO1xyXG4gICAgICAgICAgbGluZU51bWJlcnMuY3NzKCdtaW4taGVpZ2h0JywgY29sSGVpZ2h0ICsgJ3B4Jyk7XHJcbiAgICAgICAgICBzdGF0dXMuY3NzKCdtaW4taGVpZ2h0JywgY29sSGVpZ2h0ICsgJ3B4Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFNpZGViYXIgc2hvdy9oaWRlXHJcbiAgICAgICQoJy5idG4tbWVudScpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2lkZWJhckVsID0gJCgnLnNpZGViYXInKTtcclxuXHJcbiAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgaWYgKHNpZGViYXJFbC5sZW5ndGgpIHtcclxuICAgICAgICAgIHNpZGViYXJFbC50b2dnbGVDbGFzcygnb3BlbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgTWVkaWF0b3Iuc3Vic2NyaWJlKCdzYXZlOmJlZm9yZScsIGJlZm9yZVNhdmUpO1xyXG4gICAgTWVkaWF0b3Iuc3Vic2NyaWJlKCdzYXZlOmRvbmUnLCBhZnRlclNhdmUpO1xyXG4gICAgTWVkaWF0b3Iuc3Vic2NyaWJlKCdzYXZlOmZhaWwnLCBmYWlsZWRTYXZlKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSByaWJib24gbWVudSBjb21tYW5kc1xyXG4gICAgUmliYm9uTWVudUNvbW1hbmRzLmluaXQoKTtcclxuICB9XHJcbn07IiwiLyogRmlsZTogTWFya3VwRGF0YUZhY3RvcnkuanMgKi9cbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXG4vKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTWFya3VwRGF0YUZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtZSA9IHRoaXM7XG4gIHZhciBkYXRhUHJvdmlkZXIgPSBudWxsO1xuXG4gIHZhciBNYXJrdXBEYXRhU2NoZW1hID0ge1xuICAgIGlkOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHR5cGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgbWV0YWRhdGE6IHsgdHlwZTogT2JqZWN0IH1cbiAgfTtcblxuICB2YXIgTWtDb250YWluZXJTY2hlbWEgPSB7XG4gICAgY2hpbGRyZW46IHsgdHlwZTogQXJyYXksIHJlcXVpcmVkOiB0cnVlLCBkZWZhdWx0czogW10gfVxuICB9O1xuXG4gIHZhciBNa1NlZ21lbnRTY2hlbWEgPSB7XG4gICAgc2VnbWVudE51bWJlcjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBpc0xvY2tlZDogeyB0eXBlOiBCb29sZWFuIH0sXG4gICAgY29uZmlybWF0aW9uTGV2ZWw6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdHJhbnNsYXRpb25PcmlnaW46IHsgdHlwZTogT2JqZWN0IH1cbiAgfTtcblxuICB2YXIgTWtUYWdwYWlyU2NoZW1hID0ge1xuICAgIHRhZ1BhaXJEZWZpbml0aW9uSWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY2FuSGlkZTogeyB0eXBlOiBCb29sZWFuIH1cbiAgfTtcblxuICB2YXIgTWtQbGFjZWhvbGRlclNjaGVtYSA9IHtcbiAgICBwbGFjZWhvbGRlclRhZ0RlZmluaXRpb25JZDogeyB0eXBlOiBTdHJpbmcgfVxuICB9O1xuXG4gIHZhciBNa0xvY2tlZENvbnRlbnRTY2hlbWEgPSB7XG4gICAgY2hpbGRyZW46IHsgdHlwZTogQXJyYXkgfVxuICB9O1xuXG4gIHZhciBNa1RleHRTY2hlbWEgPSB7XG4gICAgdGV4dDogeyB0eXBlOiBTdHJpbmcgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIE1hcmt1cERhdGEob3B0aW9ucykge1xuICAgIGRhdGFQcm92aWRlciA9IGRhdGFQcm92aWRlciB8fCByZXF1aXJlKCcuL0RhdGFQcm92aWRlcicpO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIE1hcmt1cERhdGFTY2hlbWEpIHtcbiAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IG9wdGlvbnNbcHJvcGVydHldO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmIE1hcmt1cERhdGFTY2hlbWFbcHJvcGVydHldWydyZXF1aXJlZCddKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gTWFya3VwRGF0YVNjaGVtYVtwcm9wZXJ0eV1bJ2RlZmF1bHRzJ107XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm1ldGFkYXRhICYmIHR5cGVvZiBvcHRpb25zLm1ldGFkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zLm1ldGFkYXRhID0gZGF0YVByb3ZpZGVyLm1ldGFkYXRhTWFwW29wdGlvbnMubWV0YWRhdGFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIE1rQ29udGFpbmVyKG9wdGlvbnMpIHtcbiAgICAvLyBJbnZva2UgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3Igb24gdGhlIG5ldyBvYmplY3RcbiAgICBNYXJrdXBEYXRhLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBNa0NvbnRhaW5lclNjaGVtYSkge1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gb3B0aW9uc1twcm9wZXJ0eV07XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYgTWtDb250YWluZXJTY2hlbWFbcHJvcGVydHldWydyZXF1aXJlZCddKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gTWtDb250YWluZXJTY2hlbWFbcHJvcGVydHldWydkZWZhdWx0cyddO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIE1rU2VnbWVudChvcHRpb25zKSB7XG4gICAgLy8gSW52b2tlIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yIG9uIHRoZSBuZXcgb2JqZWN0XG4gICAgTWtDb250YWluZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIE1rU2VnbWVudFNjaGVtYSkge1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gb3B0aW9uc1twcm9wZXJ0eV07XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYgTWtTZWdtZW50U2NoZW1hW3Byb3BlcnR5XVsncmVxdWlyZWQnXSkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IE1rU2VnbWVudFNjaGVtYVtwcm9wZXJ0eV1bJ2RlZmF1bHRzJ107XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gTWtUYWdwYWlyKG9wdGlvbnMpIHtcbiAgICAvLyBJbnZva2UgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3Igb24gdGhlIG5ldyBvYmplY3RcbiAgICBNa0NvbnRhaW5lci5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gTWtUYWdwYWlyU2NoZW1hKSB7XG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBvcHRpb25zW3Byb3BlcnR5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiBNa1RhZ3BhaXJTY2hlbWFbcHJvcGVydHldWydyZXF1aXJlZCddKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gTWtUYWdwYWlyU2NoZW1hW3Byb3BlcnR5XVsnZGVmYXVsdHMnXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBNa1BsYWNlaG9sZGVyKG9wdGlvbnMpIHtcbiAgICAvLyBJbnZva2UgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3Igb24gdGhlIG5ldyBvYmplY3RcbiAgICBNYXJrdXBEYXRhLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBNa1BsYWNlaG9sZGVyU2NoZW1hKSB7XG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBvcHRpb25zW3Byb3BlcnR5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiBNa1BsYWNlaG9sZGVyU2NoZW1hW3Byb3BlcnR5XVsncmVxdWlyZWQnXSkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IE1rUGxhY2Vob2xkZXJTY2hlbWFbcHJvcGVydHldWydkZWZhdWx0cyddO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIE1rTG9ja2VkQ29udGVudChvcHRpb25zKSB7XG4gICAgLy8gSW52b2tlIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yIG9uIHRoZSBuZXcgb2JqZWN0XG4gICAgTWtDb250YWluZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gTWtMb2NrZWRDb250ZW50U2NoZW1hKSB7XG4gICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBvcHRpb25zW3Byb3BlcnR5XTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiBNa0xvY2tlZENvbnRlbnRTY2hlbWFbcHJvcGVydHldWydyZXF1aXJlZCddKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gTWtMb2NrZWRDb250ZW50U2NoZW1hW3Byb3BlcnR5XVsnZGVmYXVsdHMnXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBNa1RleHQob3B0aW9ucykge1xuICAgIC8vIEludm9rZSB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvciBvbiB0aGUgbmV3IG9iamVjdFxuICAgIE1hcmt1cERhdGEuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIE1rVGV4dFNjaGVtYSkge1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gb3B0aW9uc1twcm9wZXJ0eV07XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiYgTWtUZXh0U2NoZW1hW3Byb3BlcnR5XVsncmVxdWlyZWQnXSkge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IE1rVGV4dFNjaGVtYVtwcm9wZXJ0eV1bJ2RlZmF1bHRzJ107XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAvL2RlbGV0ZSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGV4aXN0XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgIGlmIChkYXRhW3Byb3BlcnR5XSA9PT0gbnVsbCB8fCBkYXRhW3Byb3BlcnR5XSA9PT0gJycgfHwgZGF0YVtwcm9wZXJ0eV0gPT09ICd1bmRlZmluZWQnIHx8ICh0eXBlb2YgZGF0YVtwcm9wZXJ0eV0gPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGFbcHJvcGVydHldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2RldGVybWluZSBjbGFzcyB0eXBlXG4gICAgICBpZiAoZGF0YS50eXBlID09PSAnc2VnbWVudCcpIHtcbiAgICAgICAgbWUubWFya3VwZGF0YUNsYXNzID0gTWtTZWdtZW50O1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICd0YWdQYWlyJykge1xuICAgICAgICBtZS5tYXJrdXBkYXRhQ2xhc3MgPSBNa1RhZ3BhaXI7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3BsYWNlaG9sZGVyVGFnJykge1xuICAgICAgICBtZS5tYXJrdXBkYXRhQ2xhc3MgPSBNa1BsYWNlaG9sZGVyO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBtZS5tYXJrdXBkYXRhQ2xhc3MgPSBNa1RleHQ7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2xvY2tlZCcpIHtcbiAgICAgICAgbWUubWFya3VwZGF0YUNsYXNzID0gTWtMb2NrZWRDb250ZW50O1xuICAgICAgfVxuXG4gICAgICAvL2NyZWF0ZSBuZXcgbWFya3VwZGF0YVxuICAgICAgcmV0dXJuIG5ldyBtZS5tYXJrdXBkYXRhQ2xhc3MoZGF0YSk7XG4gICAgfVxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgTWFya3VwRGF0YUZhY3RvcnkoKTsiLCIvKiBGaWxlOiBNZWRpYXRvci5qcyAqL1xuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbi8qIGdsb2JhbHMgbW9kdWxlLCBwdWJzdWIgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gdmFyIE1lZGlhdG9yID0ge30sXG4vLyAgICAgbWVkaWF0b3IgPSBuZXcgcHVic3ViKCk7XG5cbi8vIC8vIE1ldGhvZCBhbGlhc2VzXG4vLyBNZWRpYXRvci5wdWJsaXNoID0gbWVkaWF0b3IucHViO1xuLy8gTWVkaWF0b3Iuc3Vic2NyaWJlID0gbWVkaWF0b3Iuc3ViO1xuLy8gTWVkaWF0b3IudW5zdWJzY3JpYmUgPSBtZWRpYXRvci51bnN1Yjtcbi8vIE1lZGlhdG9yLnN1YnNjcmliZV9vbmNlID0gbWVkaWF0b3Iub25jZTtcbi8vIE1lZGlhdG9yLnN1YnNjcmliZV9yZWNvdXAgPSBtZWRpYXRvci5yZWNvdXA7XG5cblxuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLFxuICAgIE1lZGlhdG9yID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4vLyBNZXRob2QgYWxpYXNlc1xuTWVkaWF0b3IucHVibGlzaCA9IE1lZGlhdG9yLmVtaXQ7XG5NZWRpYXRvci5zdWJzY3JpYmUgPSBNZWRpYXRvci5vbjtcbk1lZGlhdG9yLnVuc3Vic2NyaWJlID0gTWVkaWF0b3IucmVtb3ZlTGlzdGVuZXI7XG5NZWRpYXRvci5zdWJzY3JpYmVfb25jZSA9IE1lZGlhdG9yLm9uY2U7XG4vLyBNZWRpYXRvci5zdWJzY3JpYmVfcmVjb3VwID0gZXZlbnRzLnJlY291cDtcblxubW9kdWxlLmV4cG9ydHMgPSBNZWRpYXRvcjsiLCIvKiBGaWxlOiBNb3VzZS5qcyAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBDdHJsSG92ZXJIYW5kbGVyID0gcmVxdWlyZSgnLi9tb3VzZS9DdHJsSG92ZXJIYW5kbGVyJyk7XHJcbnZhciBDdHJsQ2xpY2tIYW5kbGVyID0gcmVxdWlyZSgnLi9tb3VzZS9DdHJsQ2xpY2tIYW5kbGVyJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBDdHJsSG92ZXJIYW5kbGVyOiBDdHJsSG92ZXJIYW5kbGVyLFxyXG4gIEN0cmxDbGlja0hhbmRsZXI6IEN0cmxDbGlja0hhbmRsZXJcclxufTsiLCIvKiBGaWxlOiBOb2RlV3JhcHBlci5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgSGVscGVycyA9IHJlcXVpcmUoJy4vSGVscGVycycpO1xyXG52YXIgRGF0YVByb3ZpZGVyID0gcmVxdWlyZSgnLi9EYXRhUHJvdmlkZXInKTtcclxudmFyIFRyYW5zbGF0aW9uT3JpZ2luID0gcmVxdWlyZSgnLi9UcmFuc2xhdGlvbk9yaWdpbicpO1xyXG5cclxudmFyIGRlZjtcclxuXHJcbnZhciBzdGF0dXNJY29uQ2xhc3MgPSB7XHJcbiAgICAnTm90VHJhbnNsYXRlZCc6ICdub3QtdHJhbnNsYXRlZCcsXHJcbiAgICAnQXBwcm92ZWRTaWduT2ZmJzogJ2FwcHJvdmVkLXNpZ24tb2ZmJyxcclxuICAgICdBcHByb3ZlZFRyYW5zbGF0aW9uJzogJ2FwcHJvdmVkLXRyYW5zbGF0aW9uJyxcclxuICAgICdEcmFmdCc6ICdkcmFmdCcsXHJcbiAgICAnUmVqZWN0ZWRTaWduT2ZmJzogJ3JlamVjdGVkLXNpZ24tb2ZmJyxcclxuICAgICdSZWplY3RlZFRyYW5zbGF0aW9uJzogJ3JlamVjdGVkLXRyYW5zbGF0aW9uJyxcclxuICAgICdUcmFuc2xhdGVkJzogJ3RyYW5zbGF0ZWQnXHJcbiAgfTtcclxuXHJcbnZhciB0cmFuc2xhdGlvbk9yaWdpbkNsYXNzID0ge1xyXG4gICAgJ2l0JzogJ3RyYW5zcGFyZW50JyxcclxuICAgICdhdCc6ICdibHVlJyxcclxuICAgICdwbSc6ICdncmF5JyxcclxuICAgICdhcCc6ICd5ZWxsb3cnLFxyXG4gICAgJ2NtJzogJ2dyZWVuJ1xyXG4gIH07XHJcblxyXG5cclxudmFyIE5vZGVXcmFwcGVyID0gSGVscGVycy5jb25zdHJ1Y3Rvcih7XHJcbiAgX2V4dGVuZDogSGVscGVycy5fZXh0ZW5kLFxyXG5cclxuICBpbml0OiBmdW5jdGlvbiAoYXR0cnMsIHBhcmVudCkge1xyXG4gICAgdGhpcy5fYXR0cnMgPSBhdHRycztcclxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICAgIHRoaXMuX2V4dGVuZCh0aGlzLCBhdHRycyk7XHJcblxyXG4gICAgaWYgKCF0aGlzLnR5cGUpIHtcclxuICAgICAgdGhpcy50eXBlID0gJ3BhcmFncmFwaC11bml0JztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5tZXRhZGF0YSkge1xyXG4gICAgICB0aGlzLm1ldGFkYXRhID0gRGF0YVByb3ZpZGVyLmNhY2hlTWV0YWRhdGEodGhpcy5tZXRhZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuXHJcbiAgICAgIGNhc2UgJ3RhZ1BhaXInOlxyXG4gICAgICAgIGRlZiA9IHRoaXMuX2V4dGVuZCh7fSwgRGF0YVByb3ZpZGVyLnRhZ1BhaXJNYXBbdGhpcy50YWdQYWlyRGVmaW5pdGlvbklkXSk7XHJcbiAgICAgICAgZGVmLnBtZXRhZGF0YSA9IGRlZi5tZXRhZGF0YTtcclxuICAgICAgICBkZWxldGUgZGVmLm1ldGFkYXRhOyAvLyBtYWtlIHN1cmUgd2UgZG9udCcgb3ZlcndyaXRlIG91ciBtZXRhZGF0YVxyXG4gICAgICAgIGRlbGV0ZSBkZWYuaWQ7IC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBvdmVyd3JpdGUgb3VyIGlkXHJcbiAgICAgICAgdGhpcy5fZXh0ZW5kKHRoaXMsIGRlZik7XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAncGxhY2Vob2xkZXJUYWcnOlxyXG4gICAgICAgIGRlZiA9IHRoaXMuX2V4dGVuZCh7fSwgRGF0YVByb3ZpZGVyLnBsYWNlaG9sZGVyTWFwW3RoaXMucGxhY2Vob2xkZXJUYWdEZWZpbml0aW9uSWRdKTtcclxuICAgICAgICBkZWYucG1ldGFkYXRhID0gZGVmLm1ldGFkYXRhO1xyXG4gICAgICAgIGRlbGV0ZSBkZWYubWV0YWRhdGE7IC8vIG1ha2Ugc3VyZSB3ZSBkb250JyBvdmVyd3JpdGUgb3VyIG1ldGFkYXRhXHJcbiAgICAgICAgZGVsZXRlIGRlZi5pZDsgLy8gbWFrZSBzdXJlIHdlIGRvbid0IG92ZXJ3cml0ZSBvdXIgaWRcclxuICAgICAgICB0aGlzLl9leHRlbmQodGhpcywgZGVmKTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICdzZWdtZW50JzpcclxuICAgICAgICBpZiAoIXRoaXMudHJhbnNsYXRpb25PcmlnaW4pIHtcclxuICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25PcmlnaW4gPSBUcmFuc2xhdGlvbk9yaWdpbi5jcmVhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIERhdGFQcm92aWRlci5zZWdtZW50c01hcFt0aGlzLnNlZ21lbnROdW1iZXJdID0ge1xyXG4gICAgICAgICAgJ29yZGVybnVtYmVyJyA6IHRoaXMuc2VnbWVudE51bWJlcixcclxuICAgICAgICAgICdpc0xvY2tlZCcgOiB0aGlzLmlzTG9ja2VkIHx8IGZhbHNlLFxyXG4gICAgICAgICAgJ2NvbmZpcm1hdGlvbmxldmVsJzogc3RhdHVzSWNvbkNsYXNzW3RoaXMuY29uZmlybWF0aW9uTGV2ZWxdIHx8ICdub3QtdHJhbnNsYXRlZCcsXHJcbiAgICAgICAgICAndHJhbnNsYXRpb25vcmlnaW4nOiB0aGlzLnRyYW5zbGF0aW9uT3JpZ2luXHJcbiAgICAgICAgfTtcclxuICAgICAgICBEYXRhUHJvdmlkZXIuc2VnbWVudHNNYXBMZW5ndGgrKztcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2xvY2tlZCc6XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuc291cmNlKSB7XHJcbiAgICAgIHRoaXMuc291cmNlID0gbmV3IE5vZGVXcmFwcGVyKHRoaXMuc291cmNlLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy50YXJnZXQpIHtcclxuICAgICAgdGhpcy50YXJnZXQgPSBuZXcgTm9kZVdyYXBwZXIodGhpcy50YXJnZXQsIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudCB8fCBudWxsO1xyXG5cclxuXHJcbiAgICBpZiAodGhpcy5jaGlsZHJlbikge1xyXG4gICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlV3JhcHBlcihjaGlsZCwgdGhpcyk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQcmVwYXJlIGZvcm1hdHRpbmdcclxuICAgIGlmICh0aGlzLmZvcm1hdHRpbmdHcm91cElkKSB7XHJcbiAgICAgIHRoaXMuZm9ybWF0dGluZ0dyb3VwID0gdGhpcy5fZXh0ZW5kKHRoaXMuZm9ybWF0dGluZ0dyb3VwIHx8IHt9LCBEYXRhUHJvdmlkZXIuZm9ybWF0aW5nR3JvdXBNYXBbdGhpcy5mb3JtYXR0aW5nR3JvdXBJZF0pO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGNvbnRhaW5zU2VnbWVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNTZWdtZW50KCkgfHwgKHRoaXMuY2hpbGRyZW4gJiYgdGhpcy5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgIHJldHVybiBjaGlsZC5jb250YWluc1NlZ21lbnQoKTtcclxuICAgIH0pLmxlbmd0aCk7XHJcbiAgfSxcclxuXHJcbiAgaXNTZWdtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAnc2VnbWVudCcgfHwgKHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuaXNTZWdtZW50KCkpO1xyXG4gIH0sXHJcblxyXG4gIG1ldGFkYXRhVGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGEgPyBKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGFkYXRhKSA6ICcnO1xyXG4gIH0sXHJcblxyXG4gIHN1YmNvbnRlbnRUZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGl6YWJsZVN1YkNvbnRlbnRMaXN0ID8gSlNPTi5zdHJpbmdpZnkodGhpcy5sb2NhbGl6YWJsZVN1YkNvbnRlbnRMaXN0KSA6ICcnO1xyXG4gIH0sXHJcblxyXG4gIHRyYW5zbGF0aW9uT3JpZ2luVGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRpb25PcmlnaW4gPyBKU09OLnN0cmluZ2lmeSh0aGlzLnRyYW5zbGF0aW9uT3JpZ2luKSA6ICcnO1xyXG4gIH0sXHJcblxyXG4gIHN0YXR1c0ljb246IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBEYXRhUHJvdmlkZXIuc2VnbWVudHNNYXBbdGhpcy5zZWdtZW50TnVtYmVyXS5jb25maXJtYXRpb25sZXZlbCB8fCAnbm90LXRyYW5zbGF0ZWQnO1xyXG4gIH0sXHJcblxyXG4gIGRpc3BsYXlPcmlnaW5JY29uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdHJhbnNsYXRpb25PcmlnaW4gPSBEYXRhUHJvdmlkZXIuc2VnbWVudHNNYXBbdGhpcy5zZWdtZW50TnVtYmVyXS50cmFuc2xhdGlvbm9yaWdpbjtcclxuXHJcbiAgICBpZiAoIXRyYW5zbGF0aW9uT3JpZ2luIHx8ICF0cmFuc2xhdGlvbk9yaWdpbi5vcmlnaW5UeXBlKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGFzdFR5cGUgPSAodHJhbnNsYXRpb25PcmlnaW4ub3JpZ2luQmVmb3JlQWRhcHRhdGlvbikgPyB0cmFuc2xhdGlvbk9yaWdpbi5vcmlnaW5CZWZvcmVBZGFwdGF0aW9uLm9yaWdpblR5cGUgOiBudWxsO1xyXG4gICAgdmFyIG9yaWdpblR5cGVzID0geydpbnRlcmFjdGl2ZSc6IHRydWUsICdzb3VyY2UnOiB0cnVlfTtcclxuXHJcbiAgICBpZiAob3JpZ2luVHlwZXNbdHJhbnNsYXRpb25PcmlnaW4ub3JpZ2luVHlwZV0gJiZcclxuICAgICAgICB0cmFuc2xhdGlvbk9yaWdpbi5tYXRjaFBlcmNlbnQgPT09IDAgJiZcclxuICAgICAgICAodHJhbnNsYXRpb25PcmlnaW4ub3JpZ2luQmVmb3JlQWRhcHRhdGlvbiA9PT0gbnVsbCB8fFxyXG4gICAgICAgICBsYXN0VHlwZSA9PT0gbnVsbCB8fCBvcmlnaW5UeXBlc1tsYXN0VHlwZV0pKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9LFxyXG5cclxuICBvcmlnaW5DbGFzczogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHRyYW5zbGF0aW9uT3JpZ2luID0gRGF0YVByb3ZpZGVyLnNlZ21lbnRzTWFwW3RoaXMuc2VnbWVudE51bWJlcl0udHJhbnNsYXRpb25vcmlnaW4sXHJcbiAgICAgICAgdHlwZSA9IFRyYW5zbGF0aW9uT3JpZ2luLm9yaWdpblR5cGUodHJhbnNsYXRpb25PcmlnaW4pLFxyXG4gICAgICAgIGNsYXNzTmFtZSA9IHRyYW5zbGF0aW9uT3JpZ2luQ2xhc3NbdHlwZV07XHJcblxyXG4gICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICByZXR1cm4gY2xhc3NOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cmFuc2xhdGlvbk9yaWdpbi5tYXRjaFBlcmNlbnQgPCAxMDAgPyAneWVsbG93JyA6ICdncmVlbic7XHJcbiAgfSxcclxuXHJcbiAgb3JpZ2luVGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHQgPSBEYXRhUHJvdmlkZXIuc2VnbWVudHNNYXBbdGhpcy5zZWdtZW50TnVtYmVyXS50cmFuc2xhdGlvbm9yaWdpbjtcclxuICAgIHZhciB0eXBlID0gVHJhbnNsYXRpb25PcmlnaW4ub3JpZ2luVHlwZSh0KTtcclxuICAgIHZhciBwZXJjZW50ID0gdC5tYXRjaFBlcmNlbnQ7XHJcblxyXG4gICAgLy9sb29rIGZvciB0aGUgZmlyc3Qgb3JpZ2luIFR5cGVcclxuICAgIGlmICh0Lm9yaWdpbkJlZm9yZUFkYXB0YXRpb24gIT09IG51bGwgJiYgdHlwZSA9PT0gJ2l0Jykge1xyXG4gICAgICB2YXIgbGFzdCA9IHQub3JpZ2luQmVmb3JlQWRhcHRhdGlvbjtcclxuICAgICAgdHlwZSA9IFRyYW5zbGF0aW9uT3JpZ2luLm9yaWdpblR5cGUobGFzdCk7XHJcbiAgICAgIHBlcmNlbnQgPSBsYXN0Lm1hdGNoUGVyY2VudDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc0ljb24gPSAnJztcclxuICAgIHZhciBwZXJjZW50VHlwZXMgPSB7J2ZtJzogdHJ1ZSwgJ2VtJzogdHJ1ZSwgJ3RtJzogdHJ1ZSwgJ2l0JzogdHJ1ZSwgJ2FwJzogdHJ1ZSB9O1xyXG5cclxuICAgIGlmIChwZXJjZW50VHlwZXNbdHlwZV0pIHtcclxuICAgICAgc0ljb24gPSBwZXJjZW50ICsgJyUnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc0ljb24gPSB0eXBlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc0ljb247XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHNlZ21lbnQgbG9ja2VkIHN0YXRlXHJcbiAgICovXHJcbiAgaXNMb2NrZWRTZWdtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gRGF0YVByb3ZpZGVyLnNlZ21lbnRzTWFwW3RoaXMuc2VnbWVudE51bWJlcl0uaXNMb2NrZWQgfHwgZmFsc2U7XHJcbiAgfSxcclxuXHJcbiAgc2VnbWVudEluZm86IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWdtID0gRGF0YVByb3ZpZGVyLnNlZ21lbnRzTWFwW3RoaXMuc2VnbWVudE51bWJlcl07XHJcblxyXG4gICAgaWYgKHNlZ20gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFRyYW5zbGF0aW9uT3JpZ2luLnRyYW5zbGF0aW9uSW5mbyhzZWdtKTtcclxuICB9LFxyXG5cclxuICBwdWlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy50eXBlID09PSAncGFyYWdyYXBoLXVuaXQnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5wdWlkKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfSxcclxuXHJcbiAgY2hpbGRTZWdtZW50czogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4gPyB0aGlzLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICByZXR1cm4gaXRlbS5jb250YWluc1NlZ21lbnQoKTtcclxuICAgIH0pIDogW107XHJcbiAgfSxcclxuXHJcbiAgc2VnbWVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWdtZW50cyA9IFtdLFxyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3BhcmFncmFwaC11bml0Jykge1xyXG4gICAgICB2YXIgc291cmNlU2VnbWVudHMgPSB0aGlzLnNvdXJjZS5zZWdtZW50cygpO1xyXG4gICAgICB2YXIgdGFyZ2V0U2VnbWVudHMgPSB0aGlzLnRhcmdldC5zZWdtZW50cygpO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIHB1aWQ6IHRoaXMuaWQsXHJcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZVNlZ21lbnRzW2ldLFxyXG4gICAgICAgICAgdGFyZ2V0OiB0YXJnZXRTZWdtZW50c1tpXVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkU2VnbWVudHMoKTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gJ3NlZ21lbnQnKSB7XHJcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKGNoaWxkcmVuW2ldKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIHZhciBzID0gY2hpbGRyZW5baV0uc2VnbWVudHMoKS5tYXAoZnVuY3Rpb24gKHNlZ21lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGZsYXQgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGZsYXQuY2hpbGRyZW4gPSBbc2VnbWVudF07XHJcbiAgICAgICAgICAgIHJldHVybiBmbGF0O1xyXG4gICAgICAgICAgfSwgY2hpbGRyZW5baV0pO1xyXG5cclxuICAgICAgICAgIHNlZ21lbnRzID0gc2VnbWVudHMuY29uY2F0KHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlZ21lbnRzO1xyXG4gIH0sXHJcblxyXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbmV3IE5vZGVXcmFwcGVyKHRoaXMuX2F0dHJzLCB0aGlzLl9wYXJlbnQpO1xyXG4gIH0sXHJcblxyXG4gIHNob3dUYWdzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAndGFnUGFpcicgJiYgdGhpcy5jYW5IaWRlID09PSBmYWxzZSAmJiB0aGlzLmlzU2VnbWVudCgpO1xyXG4gIH0sXHJcblxyXG4gIHF1ZXJ5OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgIHZhciByZXMgPSBbXTtcclxuICAgIGlmIChjYWxsYmFjayh0aGlzKSkge1xyXG4gICAgICByZXMucHVzaCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5jaGlsZHJlbiAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICB2YXIgY2hpbGRfcmVzID0gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkLnF1ZXJ5KGNhbGxiYWNrKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJlcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkocmVzLCBjaGlsZF9yZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXM7XHJcbiAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZVdyYXBwZXI7IiwiLyogRmlsZTogUGFyYWdyYXBocy5qcyAqL1xuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbi8qIGdsb2JhbHMgJCwgcmVxdWlyZSwgbW9kdWxlLCBFdmVudCAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqICBQYXJhZ3JhcGhzIG1vZHVsZVxuICovXG5cbnZhciBEYXRhUHJvdmlkZXIgPSByZXF1aXJlKCcuL0RhdGFQcm92aWRlcicpO1xudmFyIFNlZ21lbnRzV2F0Y2hlciA9IHJlcXVpcmUoJy4vU2VnbWVudHNXYXRjaGVyJyk7XG52YXIgU2lkZUJ5U2lkZVBhcmFncmFwaFVuaXRzUmVuZGVyZXIgPSByZXF1aXJlKCcuL1NpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyJyk7XG52YXIgS2V5Ym9hcmRCaW5kaW5ncyA9IHJlcXVpcmUoJy4vS2V5Ym9hcmRCaW5kaW5ncycpO1xuXG4vKipcbiAqIFBhcmFncmFwaHMgbW9kdWxlXG4gKiBEaXNwbGF5cyBhbGwgUGFyYWdyYXBocyBmcm9tIHRoZSBzdG9yYWdlLCBhdHRhY2hlcyBldmVudCBoYW5kbGVyc1xuICovXG52YXIgUGFyYWdyYXBocyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhUHJvdmlkZXIgPSBEYXRhUHJvdmlkZXIsXG4gICAgICBzZWdtZW50c1dhdGNoZXIgPSBTZWdtZW50c1dhdGNoZXIsXG4gICAgICBmb3JtYXR0aW5nTWFwLFxuICAgICAgc3RhdHVzSWNvbkNsYXNzLFxuICAgICAgdHJhbnNsYXRpb25PcmlnaW5DbGFzcztcblxuICBmb3JtYXR0aW5nTWFwID0ge1xuICAgICdCb2xkJyA6ICdmb250LXdlaWdodDogYm9sZCcsXG4gICAgJ0l0YWxpYycgOiAnZm9udC1zdHlsZTogaXRhbGljJyxcbiAgICAnVW5kZXJsaW5lJyA6ICd0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZScsXG4gICAgJ1RleHRDb2xvcicgOiAnY29sb3I6IHJnYih7e3N9fSknLFxuICAgICdGb250TmFtZScgOiAnZm9udC1mYW1pbHk6IHt7c319JyxcbiAgICAnRm9udFNpemUnIDogJ2ZvbnQtc2l6ZToge3tzfX1weCdcbiAgfTtcblxuICBzdGF0dXNJY29uQ2xhc3MgPSB7XG4gICAgJ05vdFRyYW5zbGF0ZWQnOiAnbm90LXRyYW5zbGF0ZWQnLFxuICAgICdBcHByb3ZlZFNpZ25PZmYnOiAnYXBwcm92ZWQtc2lnbi1vZmYnLFxuICAgICdBcHByb3ZlZFRyYW5zbGF0aW9uJzogJ2FwcHJvdmVkLXRyYW5zbGF0aW9uJyxcbiAgICAnRHJhZnQnOiAnZHJhZnQnLFxuICAgICdSZWplY3RlZFNpZ25PZmYnOiAncmVqZWN0ZWQtc2lnbi1vZmYnLFxuICAgICdSZWplY3RlZFRyYW5zbGF0aW9uJzogJ3JlamVjdGVkLXRyYW5zbGF0aW9uJyxcbiAgICAnVHJhbnNsYXRlZCc6ICd0cmFuc2xhdGVkJ1xuICB9O1xuXG4gIHRyYW5zbGF0aW9uT3JpZ2luQ2xhc3MgPSB7XG4gICAgJ2l0JzogJ3RyYW5zcGFyZW50JyxcbiAgICAnYXQnOiAnYmx1ZScsXG4gICAgJ3BtJzogJ2dyYXknLFxuICAgICdhcCc6ICd5ZWxsb3cnLFxuICAgICdjbSc6ICdncmVlbidcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHNlZ21lbnQgZGF0YSBmcm9tIERPTVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsIC0gYW4gZWxlbWVudCByZXByZXNlbnRpbmcgYSBzZWdtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzZWdtZW50RGF0YShlbCkge1xuICAgIHZhciBkYXRhID0gZWwuZGF0YXNldCxcbiAgICAgICAgb3RoZXJTZWdtZW50RGF0YSA9IGRhdGFQcm92aWRlci5zZWdtZW50c01hcFtkYXRhLm9yZGVybnVtYmVyXTtcblxuICAgIHJldHVybiB7XG4gICAgICBpZDogICAgICAgICAgICAgICBkYXRhLmlkLFxuICAgICAgcHVpZDogICAgICAgICAgICAgZGF0YS5wdWlkLFxuICAgICAgZWw6ICAgICAgICAgICAgICAgZWwsXG4gICAgICBvdGhlclNlZ21lbnREYXRhOiBvdGhlclNlZ21lbnREYXRhXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgZmlyc3Qgc2V0IG9mIHBhcmFncmFwaCB1bml0c1xuICAgICAqL1xuICAgIHJlbmRlckZpcnN0UGFyYWdyYXBoczogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIHZhciBjRG9jID0gZGF0YVByb3ZpZGVyLmdldEN1cnJlbnREb2N1bWVudCgpO1xuICAgICAgdmFyIHBPZmZzZXQgPSAwO1xuICAgICAgdmFyIHBMaW1pdCA9IGNEb2MucGFyYWdyYXBoQ291bnQ7XG5cbiAgICAgIGRhdGFQcm92aWRlci5nZXRQYXJhZ3JhcGhzKGNEb2MuaWQsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcblxuICAgICAgICB2YXIgZWRpdG9yQm9keSA9ICQoJyNlZGl0b3ItYm9keScpO1xuICAgICAgICBlZGl0b3JCb2R5Lmh0bWwoJycpO1xuXG4gICAgICAgIG1lLl9yZW5kZXJQYXJhZ3JhcGhzKGRhdGEsIGNEb2MpO1xuICAgICAgfSwgcExpbWl0LCBwT2Zmc2V0KTtcbiAgICB9LFxuXG4gICAgX3JlbmRlclBhcmFncmFwaHM6IGZ1bmN0aW9uIChwYXJhZ3JhcGhzLCBjdXJyZW50RG9jdW1lbnQpIHtcbiAgICAgIHZhciBzaWRlQnlTaWRlUmVuZGVyZXIgPSBuZXcgU2lkZUJ5U2lkZVBhcmFncmFwaFVuaXRzUmVuZGVyZXIocGFyYWdyYXBocywgY3VycmVudERvY3VtZW50KSxcbiAgICAgICAgICBlZGl0b3JCb2R5RWwsIGtleWJvYXJkQmluZGluZ3MsIHNvdXJjZUtleXNCaW5kO1xuXG4gICAgICBzaWRlQnlTaWRlUmVuZGVyZXIucmVuZGVyKCk7XG5cbiAgICAgIGVkaXRvckJvZHlFbCA9ICQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRvci1ib2R5JykpO1xuICAgICAgZWRpdG9yQm9keUVsLmFwcGVuZChzaWRlQnlTaWRlUmVuZGVyZXIuc291cmNlU2VjdGlvbkVsKTtcbiAgICAgIGVkaXRvckJvZHlFbC5hcHBlbmQoc2lkZUJ5U2lkZVJlbmRlcmVyLnRhcmdldFNlY3Rpb25FbCk7XG5cbiAgICAgIGtleWJvYXJkQmluZGluZ3MgPSBuZXcgS2V5Ym9hcmRCaW5kaW5ncyhzaWRlQnlTaWRlUmVuZGVyZXIudGFyZ2V0RWRpdGFibGVDb2x1bW4pO1xuICAgICAga2V5Ym9hcmRCaW5kaW5ncy5iaW5kKCk7XG5cbiAgICAgIHNvdXJjZUtleXNCaW5kID0gbmV3IEtleWJvYXJkQmluZGluZ3Moc2lkZUJ5U2lkZVJlbmRlcmVyLnNvdXJjZUNvbHVtbnMpO1xuICAgICAgc291cmNlS2V5c0JpbmQuYmluZCgpO1xuXG4gICAgICAvLyBUcmlnZ2VyIHdpbmRvdyByZXNpemUgdG8gbWFrZSBzdXJlXG4gICAgICAvLyB0aGUgbGF5b3V0IHJlc2l6ZXMgdG8gZnVsbCBwYWdlIGhlaWdodFxuICAgICAgLy8gVVNFIE1FRElBVE9SIFRPIFRSSUdHRVIgVEhJUyBFVkVOVFxuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdyZXNpemUnKSk7XG5cbiAgICAgIHNlZ21lbnRzV2F0Y2hlci5yZXNpemVDb250YWluZXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvYWQgbW9yZSBwYXJhZ3JhcGggdW5pdHMgaW50byB0aGUgdmlld1xuICAgICAqXG4gICAgICovXG4gICAgbG9hZE1vcmVQYXJhZ3JhcGhzOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICBkYXRhUHJvdmlkZXIuZ2V0TmV4dFBhcmFncmFwaHMoZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBtZS5yZW5kZXJQYXJhZ3JhcGhzKGRhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhZ3JhcGhzOyIsIi8qIEZpbGU6IFNlZ21lbnQuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyByZXF1aXJlLCBtb2R1bGUgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBEYXRhUHJvdmlkZXIgPSByZXF1aXJlKCcuL0RhdGFQcm92aWRlcicpO1xyXG52YXIgVHJhbnNsYXRpb25PcmlnaW4gPSByZXF1aXJlKCcuL1RyYW5zbGF0aW9uT3JpZ2luJyk7XHJcblxyXG52YXIgdHJhbnNsYXRpb25PcmlnaW5DbGFzcyA9IHtcclxuICAnaXQnOiAndHJhbnNwYXJlbnQnLFxyXG4gICdhdCc6ICdibHVlJyxcclxuICAncG0nOiAnZ3JheScsXHJcbiAgJ2FwJzogJ3llbGxvdycsXHJcbiAgJ2NtJzogJ2dyZWVuJ1xyXG59O1xyXG5cclxudmFyIGRhdGFQcm92aWRlciA9IERhdGFQcm92aWRlcjtcclxudmFyIHRyYW5zbGF0aW9uT3JpZ2luUHJvdmlkZXIgPSBUcmFuc2xhdGlvbk9yaWdpbjtcclxuXHJcbnZhciBTZWdtZW50ID0gZnVuY3Rpb24gKGluaXRpYWxpemVyKSB7XHJcbiAgaWYgKGluaXRpYWxpemVyKSB7XHJcbiAgICB0aGlzLnNlZ21lbnROdW1iZXIgPSBpbml0aWFsaXplci5vcmRlcm51bWJlcjtcclxuICB9XHJcblxyXG4gIHRoaXMuc2VnbWVudERhdGEgPSBkYXRhUHJvdmlkZXIuZ2V0U2VnbWVudEJ5U2VnbWVudE51bWJlcih0aGlzLnNlZ21lbnROdW1iZXIpO1xyXG59O1xyXG5cclxudmFyIHByb3RvID0gU2VnbWVudC5wcm90b3R5cGU7XHJcblxyXG5wcm90by5kaXNwbGF5T3JpZ2luSWNvbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBsYXN0VHlwZSxcclxuICAgICAgb3JpZ2luVHlwZXMsXHJcbiAgICAgIHRyYW5zbGF0aW9uT3JpZ2luID0gbWUuc2VnbWVudERhdGEudHJhbnNsYXRpb25vcmlnaW47XHJcblxyXG4gIGlmICghdHJhbnNsYXRpb25PcmlnaW4gfHwgIXRyYW5zbGF0aW9uT3JpZ2luLm9yaWdpblR5cGUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGxhc3RUeXBlID0gKHRyYW5zbGF0aW9uT3JpZ2luLm9yaWdpbkJlZm9yZUFkYXB0YXRpb24pID8gdHJhbnNsYXRpb25PcmlnaW4ub3JpZ2luQmVmb3JlQWRhcHRhdGlvbi5vcmlnaW5UeXBlIDogbnVsbDtcclxuICBvcmlnaW5UeXBlcyA9IHsnaW50ZXJhY3RpdmUnOiB0cnVlLCAnc291cmNlJzogdHJ1ZX07XHJcblxyXG4gIGlmIChvcmlnaW5UeXBlc1t0cmFuc2xhdGlvbk9yaWdpbi5vcmlnaW5UeXBlXSAmJlxyXG4gICAgICB0cmFuc2xhdGlvbk9yaWdpbi5tYXRjaFBlcmNlbnQgPT09IDAgJiZcclxuICAgICAgKHRyYW5zbGF0aW9uT3JpZ2luLm9yaWdpbkJlZm9yZUFkYXB0YXRpb24gPT09IG51bGwgfHxcclxuICAgICAgbGFzdFR5cGUgPT09IG51bGwgfHwgb3JpZ2luVHlwZXNbbGFzdFR5cGVdKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5wcm90by5vcmlnaW5DbGFzcyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICB0cmFuc2xhdGlvbk9yaWdpbiA9IG1lLnNlZ21lbnREYXRhLnRyYW5zbGF0aW9ub3JpZ2luLFxyXG4gICAgICB0eXBlID0gVHJhbnNsYXRpb25PcmlnaW4ub3JpZ2luVHlwZSh0cmFuc2xhdGlvbk9yaWdpbiksXHJcbiAgICAgIGNsYXNzTmFtZSA9IHRyYW5zbGF0aW9uT3JpZ2luQ2xhc3NbdHlwZV07XHJcblxyXG4gIGlmIChjbGFzc05hbWUpIHtcclxuICAgIHJldHVybiBjbGFzc05hbWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJhbnNsYXRpb25PcmlnaW4ubWF0Y2hQZXJjZW50IDwgMTAwID8gJ3llbGxvdycgOiAnZ3JlZW4nO1xyXG59O1xyXG5cclxucHJvdG8ub3JpZ2luVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICB2YXIgdCA9IG1lLnNlZ21lbnREYXRhLnRyYW5zbGF0aW9ub3JpZ2luO1xyXG4gIHZhciB0eXBlID0gdHJhbnNsYXRpb25PcmlnaW5Qcm92aWRlci5vcmlnaW5UeXBlKHQpO1xyXG4gIHZhciBwZXJjZW50ID0gdC5tYXRjaFBlcmNlbnQ7XHJcblxyXG4gIC8vbG9vayBmb3IgdGhlIGZpcnN0IG9yaWdpbiBUeXBlXHJcbiAgaWYgKHQub3JpZ2luQmVmb3JlQWRhcHRhdGlvbiAhPT0gbnVsbCAmJiB0eXBlID09PSAnaXQnKSB7XHJcbiAgICB2YXIgbGFzdCA9IHQub3JpZ2luQmVmb3JlQWRhcHRhdGlvbjtcclxuICAgIHR5cGUgPSBUcmFuc2xhdGlvbk9yaWdpbi5vcmlnaW5UeXBlKGxhc3QpO1xyXG4gICAgcGVyY2VudCA9IGxhc3QubWF0Y2hQZXJjZW50O1xyXG4gIH1cclxuXHJcbiAgdmFyIHNJY29uID0gJyc7XHJcbiAgdmFyIHBlcmNlbnRUeXBlcyA9IHsnZm0nOiB0cnVlLCAnZW0nOiB0cnVlLCAndG0nOiB0cnVlLCAnaXQnOiB0cnVlLCAnYXAnOiB0cnVlIH07XHJcblxyXG4gIGlmIChwZXJjZW50VHlwZXNbdHlwZV0pIHtcclxuICAgIHNJY29uID0gcGVyY2VudCArICclJztcclxuICB9IGVsc2Uge1xyXG4gICAgc0ljb24gPSB0eXBlLnRvVXBwZXJDYXNlKCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc0ljb247XHJcbn07XHJcblxyXG5wcm90by5zZWdtZW50SW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBpZiAobWUuc2VnbWVudERhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRyYW5zbGF0aW9uT3JpZ2luUHJvdmlkZXIudHJhbnNsYXRpb25JbmZvKG1lLnNlZ21lbnREYXRhKTtcclxufTtcclxuXHJcbnByb3RvLnN0YXR1c0ljb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuc2VnbWVudERhdGEuY29uZmlybWF0aW9ubGV2ZWwgfHwgJ25vdC10cmFuc2xhdGVkJztcclxufTtcclxuXHJcbnByb3RvLmlzTG9ja2VkU2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5zZWdtZW50RGF0YS5pc0xvY2tlZDtcclxufTtcclxuXHJcbnByb3RvLmlzQ29uZmlybWVkID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBjb25maXJtZWRMZXZlbHMgPSBbXHJcbiAgICAndHJhbnNsYXRlZCcsXHJcbiAgICAnYXBwcm92ZWQtdHJhbnNsYXRpb24nLFxyXG4gICAgJ2FwcHJvdmVkLXNpZ24tb2ZmJ1xyXG4gIF07XHJcblxyXG4gIHZhciBpc0NvbmZpcm1lZCA9IGNvbmZpcm1lZExldmVscy5pbmRleE9mKHRoaXMuc2VnbWVudERhdGEuY29uZmlybWF0aW9ubGV2ZWwpICE9PSAtMTtcclxuXHJcbiAgcmV0dXJuIGlzQ29uZmlybWVkO1xyXG59O1xyXG5cclxucHJvdG8uY2hhbmdlVG9EcmFmdCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICB0cmFuc2xhdGlvbk9yaWdpbjtcclxuXHJcbiAgbWUuc2VnbWVudERhdGEuY29uZmlybWF0aW9ubGV2ZWwgPSAnZHJhZnQnO1xyXG4gIHRyYW5zbGF0aW9uT3JpZ2luID0gbWUuc2VnbWVudERhdGEudHJhbnNsYXRpb25vcmlnaW47XHJcblxyXG4gIGlmICh0cmFuc2xhdGlvbk9yaWdpbi5vcmlnaW5UeXBlICE9PSAnaW50ZXJhY3RpdmUnKSB7XHJcbiAgICB0cmFuc2xhdGlvbk9yaWdpbi5vcmlnaW5CZWZvcmVBZGFwdGF0aW9uID0gdHJhbnNsYXRpb25PcmlnaW5Qcm92aWRlci5jbG9uZSh0cmFuc2xhdGlvbk9yaWdpbik7XHJcbiAgICB0cmFuc2xhdGlvbk9yaWdpbi5vcmlnaW5UeXBlID0gJ2ludGVyYWN0aXZlJztcclxuICB9XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNlZ21lbnQ7IiwiLyogRmlsZTogU2VnbWVudENsZWFudXAuanMgKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgU2VnbWVudFdhdGNoZXIgPSByZXF1aXJlKCcuL1NlZ21lbnRzV2F0Y2hlcicpO1xyXG52YXIgTm9kZVdhbGtlciA9IHJlcXVpcmUoJy4vc2VsZWN0aW9uL05vZGVXYWxrZXInKTtcclxudmFyIFRtcGwgPSByZXF1aXJlKCcuL1RtcGwnKTtcclxuXHJcbnZhciBwcm90bztcclxuXHJcbmZ1bmN0aW9uIFNlZ21lbnRDbGVhbnVwKHNlZ21lbnRObykge1xyXG4gIHRoaXMuc2VnbWVudCA9IFNlZ21lbnRXYXRjaGVyLmdldFRhcmdldEVsKHNlZ21lbnRObyk7XHJcbiAgdGhpcy53YWxrZXIgPSBuZXcgTm9kZVdhbGtlcih0aGlzLnNlZ21lbnQpO1xyXG59XHJcblxyXG5wcm90byA9IFNlZ21lbnRDbGVhbnVwLnByb3RvdHlwZTtcclxuXHJcbnByb3RvLmNsZWFuU3RydWN0dXJlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICB3YWxrZXIgPSBtZS53YWxrZXI7XHJcblxyXG4gIGlmICghd2Fsa2VyLmlzU2VnbWVudCgpKSB7XHJcbiAgICB0aHJvdyAnVGhlIHN0cnVjdHVyZSBtdXN0IGJlZ2luIHByb2Nlc3NpbmcgYXQgc2VnbWVudCBsZXZlbC4nO1xyXG4gIH1cclxuXHJcbiAgbWUuZW5zdXJlSW5saW5lQ29udGVudEV4aXN0cygpO1xyXG4gIG1lLnByb2Nlc3NTdGFydE9mU2VnbWVudCgpO1xyXG4gIG1lLnByb2Nlc3NFbmRPZlNlZ21lbnQoKTtcclxuXHJcbiAgbWUucHJvY2Vzc1RleHRFbGVtZW50cygpO1xyXG5cclxufTtcclxuXHJcbnByb3RvLmVuc3VyZUlubGluZUNvbnRlbnRFeGlzdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgIHdhbGtlciA9IG1lLndhbGtlcjtcclxuXHJcbiAgd2Fsa2VyID0gd2Fsa2VyLmZpcnN0Q2hpbGQoKTtcclxuICB3aGlsZSAoIXdhbGtlci5pc051bGwoKSAmJiAhd2Fsa2VyLmlzSW5saW5lQ29udGVudCgpKSB7XHJcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHdhbGtlci5pc0lubGluZUNvbnRlbnQoKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgd2Fsa2VyID0gbWUud2Fsa2VyO1xyXG5cclxuICB3YWxrZXIuYXBwZW5kKFRtcGwuYnVpbGRTZWdtZW50SW5saW5lQ29udGVudCgpKTtcclxufTtcclxuXHJcbnByb3RvLnByb2Nlc3NTdGFydE9mU2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgd2Fsa2VyID0gbWUud2Fsa2VyLFxyXG4gICAgY29sbGVjdEVsZW1lbnRzVG9CZU1vdmVkID0gW107XHJcblxyXG4gIHdhbGtlciA9IHdhbGtlci5maXJzdENoaWxkKCk7XHJcbiAgaWYgKHdhbGtlci5pc0lubGluZUNvbnRlbnQoKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgd2hpbGUgKCF3YWxrZXIuaXNOdWxsKCkgJiYgIXdhbGtlci5pc0lubGluZUNvbnRlbnQoKSkge1xyXG4gICAgY29sbGVjdEVsZW1lbnRzVG9CZU1vdmVkLnB1c2god2Fsa2VyLmVsKTtcclxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0KCk7XHJcbiAgfVxyXG5cclxuICBjb2xsZWN0RWxlbWVudHNUb0JlTW92ZWQuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XHJcbiAgICB3YWxrZXIucHJlcGVuZCh2YWwpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxucHJvdG8ucHJvY2Vzc0VuZE9mU2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgd2Fsa2VyID0gbWUud2Fsa2VyLFxyXG4gICAgY29sbGVjdEVsZW1lbnRzVG9CZU1vdmVkID0gW107XHJcblxyXG4gIHdhbGtlciA9IHdhbGtlci5sYXN0Q2hpbGQoKTtcclxuXHJcbiAgd2hpbGUgKCF3YWxrZXIuaXNOdWxsKCkgJiYgIXdhbGtlci5pc0lubGluZUNvbnRlbnQoKSkge1xyXG4gICAgY29sbGVjdEVsZW1lbnRzVG9CZU1vdmVkLnB1c2god2Fsa2VyLmVsKTtcclxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2KCk7XHJcbiAgfVxyXG5cclxuICBjb2xsZWN0RWxlbWVudHNUb0JlTW92ZWQuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XHJcbiAgICB3YWxrZXIuYXBwZW5kKHZhbCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5wcm90by5wcm9jZXNzVGV4dEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICB3YWxrZXIgPSBtZS53YWxrZXIsXHJcbiAgICBwcm9jZXNzUXVldWUgPSBbXSxcclxuICAgIHRyYW5zZm9ybWF0aW9uUmVxdWlyZWQgPSB7fSxcclxuICAgIHRyYWNraW5nSWQgPSAwLFxyXG4gICAgdGFnSWRlbnRpZmllZDtcclxuXHJcbiAgcHJvY2Vzc1F1ZXVlLnB1c2god2Fsa2VyLmZpcnN0Q2hpbGQoKSk7XHJcblxyXG4gIGZ1bmN0aW9uIHB1c2hUb1F1ZXVlKGNoaWxkKSB7XHJcbiAgICBwcm9jZXNzUXVldWUucHVzaChjaGlsZCk7XHJcbiAgfVxyXG5cclxuICB3aGlsZSAocHJvY2Vzc1F1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgIHdhbGtlciA9IHByb2Nlc3NRdWV1ZS5wb3AoKTtcclxuICAgIGlmICghd2Fsa2VyLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgICB3YWxrZXIuZm9yRWFjaENoaWxkKHB1c2hUb1F1ZXVlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod2Fsa2VyLmlzVGFnKCkgJiYgd2Fsa2VyLnBhcmVudCgpLmlzVGV4dCgpKSB7XHJcbiAgICAgIHRhZ0lkZW50aWZpZWQgPSB3YWxrZXI7XHJcbiAgICAgIHdhbGtlciA9IHdhbGtlci5wYXJlbnQoKTtcclxuICAgICAgaWYgKCF3YWxrZXIuZWwuZGF0YXNldC50cmFja2luZ0lkKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtYXRpb25SZXF1aXJlZFt0cmFja2luZ0lkXSA9IHRhZ0lkZW50aWZpZWQ7XHJcbiAgICAgICAgd2Fsa2VyLmVsLmRhdGFzZXQudHJhY2tpbmdJZCA9IHRyYWNraW5nSWQ7XHJcbiAgICAgICAgdHJhY2tpbmdJZCsrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3IgKHRyYWNraW5nSWQgaW4gdHJhbnNmb3JtYXRpb25SZXF1aXJlZCkge1xyXG4gICAgdmFyIHByZXYsIG5leHQsIHBhcmVudDtcclxuXHJcbiAgICB3YWxrZXIgPSB0cmFuc2Zvcm1hdGlvblJlcXVpcmVkW3RyYWNraW5nSWRdO1xyXG4gICAgcHJldiA9IHdhbGtlci5wcmV2KCk7XHJcbiAgICBuZXh0ID0gd2Fsa2VyLm5leHQoKTtcclxuICAgIHBhcmVudCA9IHdhbGtlci5wYXJlbnQoKTtcclxuXHJcbiAgICBpZiAoIXByZXYuaXNOdWxsKCkgJiYgcHJldi5pc1RleHROb2RlKCkpIHtcclxuICAgICAgbWUubW92ZVRleHROb2RlT3V0c2lkZShwcmV2KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod2Fsa2VyLmlzUGxhY2Vob2xkZXIoKSkge1xyXG4gICAgICBtZS5tb3ZlUGxhY2Vob2xkZXJPdXRzaWRlKHdhbGtlcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFuZXh0LmlzTnVsbCgpICYmIG5leHQuaXNUZXh0Tm9kZSgpKSB7XHJcbiAgICAgIG1lLm1vdmVUZXh0Tm9kZU91dHNpZGUobmV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgcGFyZW50LnJlbW92ZSgpO1xyXG4gIH1cclxufTtcclxuXHJcbnByb3RvLm1vdmVUZXh0Tm9kZU91dHNpZGUgPSBmdW5jdGlvbiAobm9kZVdhbGtlcikge1xyXG4gIHZhciBwYXJlbnQsXHJcbiAgICBwYXJlbnRFbCxcclxuICAgIHBhcmVudENsb25lO1xyXG5cclxuICBwYXJlbnQgPSBub2RlV2Fsa2VyLnBhcmVudCgpO1xyXG4gIHBhcmVudEVsID0gcGFyZW50LmVsO1xyXG4gIHBhcmVudENsb25lID0gcGFyZW50RWwuY2xvbmVOb2RlKGZhbHNlKTtcclxuICBwYXJlbnRDbG9uZS5hcHBlbmRDaGlsZChub2RlV2Fsa2VyLmVsKTtcclxuICBwYXJlbnQuaW5zZXJ0QWZ0ZXIocGFyZW50Q2xvbmUpO1xyXG59O1xyXG5cclxucHJvdG8ubW92ZVBsYWNlaG9sZGVyT3V0c2lkZSA9IGZ1bmN0aW9uIChwbGFjZWhvbGRlcikge1xyXG4gIHZhciBwYXJlbnQgPSBwbGFjZWhvbGRlci5wYXJlbnQoKTtcclxuXHJcbiAgcGFyZW50ID0gcGxhY2Vob2xkZXIucGFyZW50KCk7XHJcbiAgcGFyZW50Lmluc2VydEFmdGVyKHBsYWNlaG9sZGVyKTtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBTZWdtZW50Q2xlYW51cDsiLCIvKiBGaWxlOiBTZWdtZW50U3RhdHVzVXBkYXRlci5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE1lZGlhdG9yID0gcmVxdWlyZSgnLi9NZWRpYXRvcicpO1xyXG52YXIgRGF0YVByb3ZpZGVyID0gcmVxdWlyZSgnLi9EYXRhUHJvdmlkZXInKTtcclxudmFyIFNlZ21lbnQgPSByZXF1aXJlKCcuL1NlZ21lbnQnKTtcclxudmFyIFNlZ21lbnRzV2F0Y2hlciA9IHJlcXVpcmUoJy4vU2VnbWVudHNXYXRjaGVyJyk7XHJcbnZhciBTaWRlQnlTaWRlUGFyYWdyYXBoVW5pdHNSZW5kZXJlciA9IHJlcXVpcmUoJy4vU2lkZUJ5U2lkZVBhcmFncmFwaFVuaXRzUmVuZGVyZXInKTtcclxuXHJcbnZhciByZW5kZXJlciA9IG5ldyBTaWRlQnlTaWRlUGFyYWdyYXBoVW5pdHNSZW5kZXJlcigpO1xyXG5cclxuZnVuY3Rpb24gc2VnbWVudFN0YXR1c1VwZGF0ZSAoc2VnbWVudERhdGEpIHtcclxuICB2YXIgc2VnbWVudCxcclxuICAgICAgc3RhdHVzLFxyXG4gICAgICBzZWdtZW50Q29udGFpbmVyO1xyXG5cclxuICAvLyBTdG9wIGNoYW5naW5nIHRoZSBzdGF0dXMgd2hlbiBjdXJzb3IgaXNcclxuICAvLyBpbiBsb2NrZWQgc2VnbWVudCBvciBsb2NrZWQgY29udGVudFxyXG4gIGlmIChzZWdtZW50RGF0YS5zdG9wRWRpdGluZykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgc2VnbWVudCA9IG5ldyBTZWdtZW50KHNlZ21lbnREYXRhKTtcclxuICBzdGF0dXMgPSByZW5kZXJlci5yZW5kZXJTdGF0dXMoc2VnbWVudCk7XHJcbiAgc2VnbWVudENvbnRhaW5lciA9IFNlZ21lbnRzV2F0Y2hlci5nZXRDb250YWluZXJCeVNlZ21lbnROdW1iZXIoc2VnbWVudC5zZWdtZW50TnVtYmVyKTtcclxuXHJcbiAgc2VnbWVudENvbnRhaW5lci5yZXBsYWNlU3RhdHVzRWwoc3RhdHVzKTtcclxuICBTZWdtZW50c1dhdGNoZXIucmVzaXplKHNlZ21lbnQuc2VnbWVudE51bWJlcik7XHJcbiAgU2VnbWVudHNXYXRjaGVyLm1hcmtDb250YWluZXJBc0FjdGl2ZShzZWdtZW50LnNlZ21lbnROdW1iZXIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24ganVtcFRvTmV4dFVuQ29uZmlybWVkU2VnbWVudCAoc2VnbWVudERhdGEpIHtcclxuICB2YXIgaW5pdGlhbFNlZ21lbnQsXHJcbiAgICAgIHNlZ21lbnQ7XHJcblxyXG4gIGluaXRpYWxTZWdtZW50ID0gc2VnbWVudCA9IG5ldyBTZWdtZW50KHNlZ21lbnREYXRhKTtcclxuXHJcbiAgZG8ge1xyXG4gICAgdmFyIG5leHRTZWdtZW50RGF0YSA9IERhdGFQcm92aWRlci5nZXRTZWdtZW50QnlTZWdtZW50TnVtYmVyKCtzZWdtZW50LnNlZ21lbnROdW1iZXIgKyAxKTtcclxuICAgIHNlZ21lbnQgPSBudWxsO1xyXG5cclxuICAgIGlmIChuZXh0U2VnbWVudERhdGEpIHtcclxuICAgICAgc2VnbWVudCA9IG5ldyBTZWdtZW50KG5leHRTZWdtZW50RGF0YSk7XHJcbiAgICB9XHJcblxyXG4gIH0gd2hpbGUgKHNlZ21lbnQgIT09IG51bGwgJiYgc2VnbWVudC5pc0NvbmZpcm1lZCgpKTtcclxuXHJcbiAgaWYgKHNlZ21lbnQgPT09IG51bGwpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIFNlZ21lbnRzV2F0Y2hlci5tYXJrQ29udGFpbmVyQXNJbmFjdGl2ZShpbml0aWFsU2VnbWVudC5zZWdtZW50TnVtYmVyKTtcclxuICBTZWdtZW50c1dhdGNoZXIubWFya0NvbnRhaW5lckFzQWN0aXZlKHNlZ21lbnQuc2VnbWVudE51bWJlcik7XHJcbiAgU2VnbWVudHNXYXRjaGVyLmZvY3VzVGFyZ2V0KHNlZ21lbnQuc2VnbWVudE51bWJlcik7XHJcbn07XHJcblxyXG52YXIgU2VnbWVudFN0YXR1c1VwZGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgTWVkaWF0b3Iuc3Vic2NyaWJlKCdzZWdtZW50OmNvbmZpcm1hdGlvbkxldmVsQ2hhbmdlZCcsIHNlZ21lbnRTdGF0dXNVcGRhdGUpO1xyXG4gIE1lZGlhdG9yLnN1YnNjcmliZSgnc2VnbWVudDpqdW1wVG9OZXh0VW5Db25maXJtZWQnLCBqdW1wVG9OZXh0VW5Db25maXJtZWRTZWdtZW50KTtcclxuXHJcbiAgTWVkaWF0b3Iuc3Vic2NyaWJlKCdzZWdtZW50OmxvY2snLCBzZWdtZW50U3RhdHVzVXBkYXRlKTtcclxuICBNZWRpYXRvci5zdWJzY3JpYmUoJ3NlZ21lbnQ6dW5sb2NrJywgc2VnbWVudFN0YXR1c1VwZGF0ZSk7XHJcblxyXG4gIE1lZGlhdG9yLnN1YnNjcmliZSgnc2VnbWVudDpzdG9wRWRpdGluZ0luTG9ja2VkQ29udGVudCcsIHNlZ21lbnRTdGF0dXNVcGRhdGUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTZWdtZW50U3RhdHVzVXBkYXRlcigpOyIsIi8qIEZpbGU6IFNlZ21lbnRXYXRjaGVyLmpzICovXHJcbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcbi8qIGdsb2JhbHMgJCwgXywgbW9kdWxlICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBTZWdtZW50c1dhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciByZXNpemVDYWxscyxcclxuICAgICAgZ3JvdXBzID0ge30sXHJcbiAgICAgIHRhZ1BhaXJzID0ge30sXHJcbiAgICAgIGN1cnJlbnRDb250YWluZXIgPSB7fTtcclxuXHJcbiAgZnVuY3Rpb24gc2VnbWVudENvbnRhaW5lcigpIHtcclxuICAgIHRoaXMuc291cmNlRWwgPSBudWxsO1xyXG4gICAgdGhpcy50YXJnZXRFbCA9IG51bGw7XHJcbiAgICB0aGlzLnN0YXR1c0VsID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLnNvdXJjZUlubGluZUNvbnRlbnRFbCA9IG51bGw7XHJcbiAgICB0aGlzLnRhcmdldElubGluZUNvbnRlbnRFbCA9IG51bGw7XHJcbiAgICB0aGlzLmxpbmtlZEVsZW1lbnRzID0gW107XHJcblxyXG4gICAgdGhpcy5pc0hlaWdodENvbXB1dGVkID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzZWdtZW50Q29udGFpbmVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgIHRoaXMubGlua2VkRWxlbWVudHMucHVzaChpdGVtKTtcclxuICB9O1xyXG5cclxuICBzZWdtZW50Q29udGFpbmVyLnByb3RvdHlwZS5yZXBsYWNlU3RhdHVzRWwgPSBmdW5jdGlvbiAoc3RhdHVzRWwpIHtcclxuICAgIHZhciBtZSA9IHRoaXM7XHJcbiAgICB2YXIgc3RhdHVzUG9zaXRpb24gPSBtZS5saW5rZWRFbGVtZW50cy5pbmRleE9mKG1lLnN0YXR1c0VsKTtcclxuICAgIGlmIChzdGF0dXNQb3NpdGlvbiA9PT0gLTEpIHtcclxuICAgICAgdGhyb3cgJ0ludmFsaWQgc3RhdGUsIGxpbmtlZEVsZW1lbnQgZG9lcyBub3QgZXhpc3QnO1xyXG4gICAgfVxyXG5cclxuICAgIG1lLnN0YXR1c0VsLnJlcGxhY2VXaXRoKHN0YXR1c0VsKTtcclxuICAgIG1lLnN0YXR1c0VsID0gc3RhdHVzRWw7XHJcblxyXG4gICAgbWUubGlua2VkRWxlbWVudHNbc3RhdHVzUG9zaXRpb25dID0gbWUuc3RhdHVzRWw7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gX3Jlc2l6ZUNvbnRhaW5lcihjb250YWluZXIpIHtcclxuICAgIHZhciBNSU5fSEVJR0hUID0gMjcsXHJcbiAgICAgICAgc291cmNlSW5saW5lQ29udGVudCA9IGNvbnRhaW5lci5zb3VyY2VJbmxpbmVDb250ZW50RWwgfHwgJChjb250YWluZXIuc291cmNlRWxbMF0uZmlyc3RDaGlsZCksIC8vJCgnOmZpcnN0LWNoaWxkJywgY29udGFpbmVyLnNvdXJjZUVsKSxcclxuICAgICAgICB0YXJnZXRJbmxpbmVDb250ZW50ID0gY29udGFpbmVyLnRhcmdldElubGluZUNvbnRlbnRFbCB8fCAkKGNvbnRhaW5lci50YXJnZXRFbFswXS5maXJzdENoaWxkKSwgLy8kKCc6Zmlyc3QtY2hpbGQnLCBjb250YWluZXIudGFyZ2V0RWwpLFxyXG4gICAgICAgIHNvdXJjZUhlaWdodCA9IHBhcnNlSW50KHNvdXJjZUlubGluZUNvbnRlbnQuY3NzKCdoZWlnaHQnKSwgMTApLFxyXG4gICAgICAgIHRhcmdldEhlaWdodCA9IHBhcnNlSW50KHRhcmdldElubGluZUNvbnRlbnQuY3NzKCdoZWlnaHQnKSwgMTApLFxyXG4gICAgICAgIG1heEhlaWdodCA9IE1hdGgubWF4KHNvdXJjZUhlaWdodCwgdGFyZ2V0SGVpZ2h0KSxcclxuICAgICAgICB0YXJnZXRlZEhlaWdodCA9IE1hdGgubWF4KE1JTl9IRUlHSFQsIG1heEhlaWdodCk7XHJcblxyXG4gICAgY29udGFpbmVyLmxpbmtlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgaXRlbS5jc3MoJ2hlaWdodCcsIHRhcmdldGVkSGVpZ2h0ICsgJ3B4Jyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJlc2l6ZUNhbGxzID0gMDtcclxuXHJcbiAgd2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgU2VnbWVudHNXYXRjaGVyLnJlc2l6ZUNvbnRhaW5lcnMoKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcmVzaXplQ2FsbHM6IDAsXHJcbiAgICAvKlxyXG4gICAgKiBAZWxlbWVudEdyb3VwIC0gbGlzdCBvZiBlbGVtZW50cyB0aGF0IG11c3QgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcclxuICAgICovXHJcbiAgICB3YXRjaFNlZ21lbnQ6IGZ1bmN0aW9uIChzZWdtZW50TnVtYmVyKSB7XHJcbiAgICAgIGlmIChncm91cHNbc2VnbWVudE51bWJlcl0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGdyb3Vwc1tzZWdtZW50TnVtYmVyXSA9IG5ldyBzZWdtZW50Q29udGFpbmVyKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN1cnJlbnRDb250YWluZXIgPSBncm91cHNbc2VnbWVudE51bWJlcl07XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgZ3JvdXBBZGQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgIGN1cnJlbnRDb250YWluZXIucHVzaChlbGVtZW50KTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2VFbCkge1xyXG4gICAgICBjdXJyZW50Q29udGFpbmVyLnNvdXJjZUVsID0gc291cmNlRWw7XHJcbiAgICAgIHRoaXMuZ3JvdXBBZGQoc291cmNlRWwpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0YXR1czogZnVuY3Rpb24gKHN0YXR1c0VsKSB7XHJcbiAgICAgIGN1cnJlbnRDb250YWluZXIuc3RhdHVzRWwgPSBzdGF0dXNFbDtcclxuICAgICAgdGhpcy5ncm91cEFkZChzdGF0dXNFbCk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0VGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0RWwpIHtcclxuICAgICAgY3VycmVudENvbnRhaW5lci50YXJnZXRFbCA9IHRhcmdldEVsO1xyXG4gICAgICB0aGlzLmdyb3VwQWRkKHRhcmdldEVsKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICBhZGRUYWdQYWlyOiBmdW5jdGlvbiAodGFnUGFpcklkLCB0YWdQYWlyRWxlbWVudHMpIHtcclxuICAgICAgdGFnUGFpcnNbdGFnUGFpcklkXSA9IHRhZ1BhaXJFbGVtZW50cztcclxuICAgIH0sXHJcblxyXG4gICAgcmVtb3ZlVGFnUGFpcjogZnVuY3Rpb24gKHRhZ1BhaXJJZCkge1xyXG4gICAgICB2YXIgZXhpc3RzID0gdGFnUGFpcklkIGluIHRhZ1BhaXJzLFxyXG4gICAgICAgICAgZWxlbWVudDtcclxuXHJcbiAgICAgIGlmICghZXhpc3RzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0YWdQYWlyc1t0YWdQYWlySWRdLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgcmVzaXplQ29udGFpbmVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgICBfKGdyb3VwcykuZm9yT3duKF9yZXNpemVDb250YWluZXIpO1xyXG5cclxuICAgICAgaWYgKHRoaXMucmVzaXplQ2FsbHMgPCAzKSB7XHJcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgU2VnbWVudHNXYXRjaGVyLnJlc2l6ZUNvbnRhaW5lcnMoKTtcclxuICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIHRoaXMucmVzaXplQ2FsbHMrKztcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICByZXNpemU6IGZ1bmN0aW9uIChjb250YWluZXJJZCkge1xyXG4gICAgICBfcmVzaXplQ29udGFpbmVyKGdyb3Vwc1tjb250YWluZXJJZF0pO1xyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDb250YWluZXJCeVNlZ21lbnROdW1iZXI6IGZ1bmN0aW9uIChzZWdtZW50TnVtYmVyKSB7XHJcbiAgICAgIHJldHVybiBncm91cHNbc2VnbWVudE51bWJlcl07XHJcbiAgICB9LFxyXG5cclxuICAgIG1hcmtDb250YWluZXJBc0FjdGl2ZTogZnVuY3Rpb24gKHNlZ21lbnROdW1iZXIpIHtcclxuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyQnlTZWdtZW50TnVtYmVyKHNlZ21lbnROdW1iZXIpO1xyXG5cclxuICAgICAgaWYgKGNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb250YWluZXIubGlua2VkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobGlua2VkRWwpIHtcclxuICAgICAgICBsaW5rZWRFbC5hZGRDbGFzcygndWUtcm93LWFjdGl2ZScpO1xyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgbWFya0NvbnRhaW5lckFzSW5hY3RpdmU6IGZ1bmN0aW9uIChzZWdtZW50TnVtYmVyKSB7XHJcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lckJ5U2VnbWVudE51bWJlcihzZWdtZW50TnVtYmVyKTtcclxuXHJcbiAgICAgIGlmIChjb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29udGFpbmVyLmxpbmtlZEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGxpbmtlZEVsKSB7XHJcbiAgICAgICAgbGlua2VkRWwucmVtb3ZlQ2xhc3MoJ3VlLXJvdy1hY3RpdmUnKTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGZvY3VzVGFyZ2V0OiBmdW5jdGlvbiAoc2VnbWVudE51bWJlcikge1xyXG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXJCeVNlZ21lbnROdW1iZXIoc2VnbWVudE51bWJlcik7XHJcbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKGNvbnRhaW5lci50YXJnZXRFbFswXSk7XHJcblxyXG4gICAgICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcclxuICAgICAgcmFuZ2UuY29sbGFwc2UoKTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0VGFyZ2V0RWw6IGZ1bmN0aW9uIChzZWdtZW50TnVtYmVyKSB7XHJcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lckJ5U2VnbWVudE51bWJlcihzZWdtZW50TnVtYmVyKSxcclxuICAgICAgICB0YXJnZXRFbDtcclxuXHJcbiAgICAgIGlmIChjb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0YXJnZXRFbCA9IGNvbnRhaW5lci50YXJnZXRFbDtcclxuXHJcbiAgICAgIHJldHVybiB0YXJnZXRFbDtcclxuICAgIH0sXHJcblxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbn0pKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNlZ21lbnRzV2F0Y2hlcjsiLCIvKiBGaWxlOiBTZWxlY3Rpb24uanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyByZXF1aXJlLCBtb2R1bGUgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBub2RlV2Fsa2VyID0gcmVxdWlyZSgnLi9zZWxlY3Rpb24vTm9kZVdhbGtlcicpO1xyXG52YXIgdGFnUGFpciA9IHJlcXVpcmUoJy4vc2VsZWN0aW9uL1RhZ1BhaXInKTtcclxudmFyIHNlbGVjdGlvbkNvbnRleHQgPSByZXF1aXJlKCcuL3NlbGVjdGlvbi9TZWxlY3Rpb25Db250ZXh0Jyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgTm9kZVdhbGtlcjogbm9kZVdhbGtlcixcclxuICBTZWxlY3Rpb25Db250ZXh0OiBzZWxlY3Rpb25Db250ZXh0LFxyXG4gIFRhZ1BhaXI6IHRhZ1BhaXJcclxufTsiLCIvKiBGaWxlOiBTaWRlQnlTaWRlUGFyYWdyYXBoVW5pdHNSZW5kZXJlci5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzIF8sIGNvbnNvbGUsIHJlcXVpcmUsIG1vZHVsZSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcclxudmFyIEhlbHBlcnMgPSByZXF1aXJlKCcuL0hlbHBlcnMnKTtcclxudmFyIFRtcGwgPSByZXF1aXJlKCcuL1RtcGwnKTtcclxudmFyIFNlZ21lbnRzV2F0Y2hlciA9IHJlcXVpcmUoJy4vU2VnbWVudHNXYXRjaGVyJyk7XHJcbnZhciBOb2RlV3JhcHBlciA9IHJlcXVpcmUoJy4vTm9kZVdyYXBwZXInKTtcclxudmFyIFRhZ0NvbnRlbnRCdWlsZGVyID0gcmVxdWlyZSgnLi9yZW5kZXJlci9UYWdDb250ZW50QnVpbGRlcicpO1xyXG52YXIgU3R5bGVzTWFwID0gcmVxdWlyZSgnLi9yZW5kZXJlci9TdHlsZXNNYXAnKTtcclxuXHJcbnZhciBTaWRlQnlTaWRlUGFyYWdyYXBoVW5pdHNSZW5kZXJlciA9IGZ1bmN0aW9uIChwYXJhZ3JhcGhzLCB1ZURvY3VtZW50KSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgbWUucGFyYWdyYXBocyA9IHBhcmFncmFwaHM7XHJcbiAgbWUudWVEb2N1bWVudCA9IHVlRG9jdW1lbnQ7XHJcblxyXG4gIG1lLnRtcGwgPSBUbXBsO1xyXG4gIG1lLnNlZ21lbnRzV2F0Y2hlciA9IFNlZ21lbnRzV2F0Y2hlcjtcclxuXHJcbiAgbWUuc291cmNlU2VjdGlvbkVsID0gJChtZS50bXBsLnNvdXJjZVNlY3Rpb24pO1xyXG4gIG1lLnRhcmdldFNlY3Rpb25FbCA9ICQobWUudG1wbC50YXJnZXRTZWN0aW9uKTtcclxuXHJcbiAgbWUuc2VnbWVudE51bWJlcnMgPSAkKG1lLnRtcGwuZ3V0dGVyQ29sdW1uKTtcclxuICBtZS5zb3VyY2VDb2x1bW5zID0gJChtZS50bXBsLnNvdXJjZUNvbHVtbik7XHJcbiAgbWUuc2VnbWVudFN0YXR1cyA9ICQobWUudG1wbC5zdGF0dXNDb2x1bW4pO1xyXG4gIG1lLnRhcmdldENvbHVtbnMgPSAkKG1lLnRtcGwudGFyZ2V0Q29sdW1uKTtcclxuXHJcbiAgbWUuc291cmNlRWRpdGFibGVDb2x1bW4gPSAkKG1lLnRtcGwuZWRpdGFibGVGYWxzZSk7XHJcbiAgbWUudGFyZ2V0RWRpdGFibGVDb2x1bW4gPSAkKG1lLnRtcGwuZWRpdGFibGVUcnVlKTtcclxuXHJcbiAgbWUuZmlsZVN0YXJ0ID0gJChtZS50bXBsLmZpbGVUYWdTdGFydCk7XHJcbiAgbWUuZmlsZUVuZCA9ICQobWUudG1wbC5maWxlVGFnRW5kKTtcclxuXHJcbiAgbWUuaXNUYWdDb3B5QWxsb3dlZCA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcbnZhciByZW5kZXJlciA9IFNpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyO1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBtZS5hc3NpZ25FZGl0YWJsZUNvbHVtbnNMYW5nKCk7XHJcbiAgbWUuYXNzaWduRG9jdW1lbnROYW1lKCk7XHJcbiAgbWUuYXBwZW5kU3RydWN0dXJlKCk7XHJcbiAgbWUuYXBwZW5kRmlsZVN0YXJ0KCk7XHJcbiAgbWUuYXBwZW5kRWRpdGFibGVDb2x1bW5zKCk7XHJcbiAgbWUucHJvY2Vzc1BhcmFncmFwaHMoKTtcclxuICBtZS5hcHBlbmRGaWxlRW5kKCk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFkZCBsYW5nIGF0dHJpYnV0ZSB0byBjb250ZW50IGVkaXRhYmxlIGVsZW1lbnRzXHJcbiAqL1xyXG5yZW5kZXJlci5wcm90b3R5cGUuYXNzaWduRWRpdGFibGVDb2x1bW5zTGFuZyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBkb2NEYXRhID0gbWUudWVEb2N1bWVudC5kYXRhLFxyXG4gIGNvbHVtbnMgPSB7XHJcbiAgICBzb3VyY2U6IG1lLnNvdXJjZUNvbHVtbnMsXHJcbiAgICB0YXJnZXQ6IG1lLnRhcmdldENvbHVtbnNcclxuICB9O1xyXG5cclxuICBfLmZvckVhY2goY29sdW1ucywgZnVuY3Rpb24gKGNvbHVtbiwgY29sdW1uTmFtZSkge1xyXG4gICAgY29sdW1uLnByb3AoJ2xhbmcnLFxyXG4gICAgICBkb2NEYXRhW2NvbHVtbk5hbWUgKyAnTGFuZ3VhZ2VDb2RlJ10pO1xyXG4gIH0pO1xyXG59O1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLmFzc2lnbkRvY3VtZW50TmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG4gIFttZS5maWxlU3RhcnQsIG1lLmZpbGVFbmRdLmZvckVhY2goZnVuY3Rpb24gKGZpbGVUYWcpIHtcclxuICAgIGZpbGVUYWdbMF0uZmlyc3RDaGlsZC5kYXRhc2V0LmRpc3BsYXlDb250ZW50ID0gbWUudWVEb2N1bWVudC5kYXRhLm5hbWU7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5yZW5kZXJlci5wcm90b3R5cGUuYXBwZW5kU3RydWN0dXJlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIG1lLnNvdXJjZVNlY3Rpb25FbC5hcHBlbmQobWUuc2VnbWVudE51bWJlcnMpO1xyXG4gIG1lLnNvdXJjZVNlY3Rpb25FbC5hcHBlbmQobWUuc291cmNlQ29sdW1ucyk7XHJcbiAgbWUudGFyZ2V0U2VjdGlvbkVsLmFwcGVuZChtZS5zZWdtZW50U3RhdHVzKTtcclxuICBtZS50YXJnZXRTZWN0aW9uRWwuYXBwZW5kKG1lLnRhcmdldENvbHVtbnMpO1xyXG59O1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLmFwcGVuZEZpbGVTdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBtZS5zZWdtZW50TnVtYmVycy5hcHBlbmQoJChtZS50bXBsLmNlbGwpLmh0bWwobWUudG1wbC56d25qKSk7XHJcbiAgbWUuc291cmNlRWRpdGFibGVDb2x1bW4uYXBwZW5kKG1lLmZpbGVTdGFydCk7XHJcbiAgbWUuc2VnbWVudFN0YXR1cy5hcHBlbmQoJChtZS50bXBsLmNlbGwpLmh0bWwobWUudG1wbC56d25qKSk7XHJcbiAgbWUudGFyZ2V0RWRpdGFibGVDb2x1bW4uYXBwZW5kKG1lLmZpbGVTdGFydC5jbG9uZSgpKTtcclxufTtcclxuXHJcbnJlbmRlcmVyLnByb3RvdHlwZS5hcHBlbmRFZGl0YWJsZUNvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgbWUuc291cmNlQ29sdW1ucy5hcHBlbmQobWUuc291cmNlRWRpdGFibGVDb2x1bW4pO1xyXG4gIG1lLnRhcmdldENvbHVtbnMuYXBwZW5kKG1lLnRhcmdldEVkaXRhYmxlQ29sdW1uKTtcclxufTtcclxuXHJcbnJlbmRlcmVyLnByb3RvdHlwZS5wcm9jZXNzUGFyYWdyYXBocyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBwYXJhZ3JhcGhTZWdtZW50cztcclxuXHJcbiAgbWUucGFyYWdyYXBocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhZ3JhcGhJdGVtKSB7XHJcbiAgICBwYXJhZ3JhcGhTZWdtZW50cyA9IG5ldyBOb2RlV3JhcHBlcihwYXJhZ3JhcGhJdGVtKS5zZWdtZW50cygpO1xyXG4gICAgbWUucmVuZGVyU2VnbWVudHMocGFyYWdyYXBoU2VnbWVudHMpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ21lbnRzID0gZnVuY3Rpb24gKHBhcmFncmFwaFNlZ21lbnRzKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgcGFyYWdyYXBoU2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYWdyYXBoKSB7XHJcbiAgICBtZS5yZW5kZXJTb3VyY2UocGFyYWdyYXBoLnNvdXJjZSk7XHJcbiAgICBtZS5yZW5kZXJUYXJnZXQocGFyYWdyYXBoLnRhcmdldCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG5yZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlZ21lbnQgPSBzb3VyY2UsXHJcbiAgICAgIHNlZ21lbnREYXRhLCBmb3JtYXR0aW5nLCBzZWdtZW50TnVtYmVyRWwsXHJcbiAgICAgIHNlZ21lbnRTb3VyY2VFbCwgc2VnbWVudFN0YXR1c0VsO1xyXG5cclxuICBtZS5pc1RhZ0NvcHlBbGxvd2VkID0gdHJ1ZTtcclxuXHJcbiAgaWYgKHNvdXJjZS50eXBlID09PSAndGFnUGFpcicpIHtcclxuICAgIHNlZ21lbnREYXRhID0gbWUuX2ZpbmRTZWdtZW50KHNvdXJjZSk7XHJcbiAgICBzZWdtZW50ID0gc2VnbWVudERhdGEuc2VnbWVudDtcclxuICAgIGZvcm1hdHRpbmcgPSBzZWdtZW50RGF0YS5mb3JtYXR0aW5nIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgbWUuc2VnbWVudHNXYXRjaGVyLndhdGNoU2VnbWVudChzZWdtZW50LnNlZ21lbnROdW1iZXIpO1xyXG5cclxuICBzZWdtZW50TnVtYmVyRWwgPSBtZS5yZW5kZXJTZWdtZW50TnVtYmVyKHNlZ21lbnQpO1xyXG4gIHNlZ21lbnRTb3VyY2VFbCA9IG1lLnJlbmRlclNvdXJjZVNlZ21lbnQoc2VnbWVudCwgZm9ybWF0dGluZyk7XHJcbiAgc2VnbWVudFN0YXR1c0VsID0gbWUucmVuZGVyU3RhdHVzKHNlZ21lbnQpO1xyXG5cclxuICBtZS5zZWdtZW50TnVtYmVycy5hcHBlbmQoc2VnbWVudE51bWJlckVsKTtcclxuICBtZS5zb3VyY2VFZGl0YWJsZUNvbHVtbi5hcHBlbmQoc2VnbWVudFNvdXJjZUVsKTtcclxuICBtZS5zZWdtZW50U3RhdHVzLmFwcGVuZChzZWdtZW50U3RhdHVzRWwpO1xyXG4gIG1lLnNlZ21lbnRzV2F0Y2hlci5zZXRTb3VyY2Uoc2VnbWVudFNvdXJjZUVsKTtcclxuICBtZS5zZWdtZW50c1dhdGNoZXIuZ3JvdXBBZGQoc2VnbWVudE51bWJlckVsKTtcclxuICBtZS5zZWdtZW50c1dhdGNoZXIuc2V0U3RhdHVzKHNlZ21lbnRTdGF0dXNFbCk7XHJcbn07XHJcblxyXG5yZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlZ21lbnQgPSB0YXJnZXQsXHJcbiAgICAgIHNlZ21lbnREYXRhLCBmb3JtYXR0aW5nLCBzZWdtZW50VGFyZ2V0RWw7XHJcblxyXG4gIG1lLmlzVGFnQ29weUFsbG93ZWQgPSBmYWxzZTtcclxuXHJcbiAgaWYgKHRhcmdldC50eXBlID09PSAndGFnUGFpcicpIHtcclxuICAgIHNlZ21lbnREYXRhID0gbWUuX2ZpbmRTZWdtZW50KHRhcmdldCk7XHJcbiAgICBzZWdtZW50ID0gc2VnbWVudERhdGEuc2VnbWVudDtcclxuICAgIGZvcm1hdHRpbmcgPSBzZWdtZW50RGF0YS5mb3JtYXR0aW5nIHx8IHt9O1xyXG4gIH1cclxuXHJcbiAgbWUuc2VnbWVudHNXYXRjaGVyLndhdGNoU2VnbWVudChzZWdtZW50LnNlZ21lbnROdW1iZXIpO1xyXG4gIHNlZ21lbnRUYXJnZXRFbCA9IG1lLnJlbmRlclRhcmdldFNlZ21lbnQoc2VnbWVudCwgZm9ybWF0dGluZyk7XHJcbiAgbWUudGFyZ2V0RWRpdGFibGVDb2x1bW4uYXBwZW5kKHNlZ21lbnRUYXJnZXRFbCk7XHJcbiAgbWUuc2VnbWVudHNXYXRjaGVyLnNldFRhcmdldChzZWdtZW50VGFyZ2V0RWwpO1xyXG59O1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLl9maW5kU2VnbWVudCA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcclxuICB2YXIgc2VnbWVudCA9IGNvbnRhaW5lcixcclxuICAgICAgZm9ybWF0dGluZyA9IHNlZ21lbnQuZm9ybWF0dGluZ0dyb3VwIHx8IHt9OyAvLyBjYWNoZSB0YWdwYWlyIGZvcm1hdHRpbmdcclxuXHJcbiAgd2hpbGUgKHNlZ21lbnQgIT09IG51bGwgJiYgc2VnbWVudC50eXBlID09PSAndGFnUGFpcicpIHtcclxuICAgIGlmIChzZWdtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBzZWdtZW50ID0gc2VnbWVudC5jaGlsZHJlblswXTtcclxuICB9XHJcblxyXG4gIC8vIHJldHVybiBzZWdtZW50IGFuZCB0YWdwYWlyIGZvcm1hdHRpbmdcclxuICByZXR1cm4ge1xyXG4gICAgc2VnbWVudDogc2VnbWVudCxcclxuICAgIGZvcm1hdHRpbmc6IGZvcm1hdHRpbmdcclxuICB9O1xyXG59O1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ21lbnROdW1iZXIgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlZ21lbnROdW1iZXJFbCA9ICQobWUudG1wbC5jZWxsKTtcclxuXHJcbiAgc2VnbWVudE51bWJlckVsLmh0bWwoc2VnbWVudC5zZWdtZW50TnVtYmVyKTtcclxuXHJcbiAgcmV0dXJuIHNlZ21lbnROdW1iZXJFbDtcclxufTtcclxuXHJcbnJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTb3VyY2VTZWdtZW50ID0gZnVuY3Rpb24gKHNlZ21lbnQsIGZvcm1hdHRpbmcpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBzZWdtZW50U291cmNlRWwgPSAkKG1lLnRtcGwuc2VnbWVudCksXHJcbiAgICAgIGlubGluZUNvbnRlbnQgPSBtZS5fcmVuZGVySW5saW5lQ29udGVudChzZWdtZW50LmNoaWxkcmVuKSxcclxuICAgICAgc291cmNlRGF0YXNldDtcclxuXHJcbiAgLy8gSWYgc2VnbWVudCBpcyBsb2NrZWQsIGFkZCAndWUtbG9ja2VkJyBjbGFzcyB0byBzZWdtZW50IGVsZW1lbnRcclxuICBpZiAoc2VnbWVudC5pc0xvY2tlZCkge1xyXG4gICAgc2VnbWVudFNvdXJjZUVsWzBdLmNsYXNzTGlzdC5hZGQoJ3VlLXNlZ21lbnQtbG9ja2VkJyk7XHJcbiAgICBzZWdtZW50U291cmNlRWxbMF0uZGF0YXNldC5pc0xvY2tlZCA9IHNlZ21lbnQuaXNMb2NrZWQ7XHJcbiAgfVxyXG5cclxuICBpZiAoZm9ybWF0dGluZykge1xyXG4gICAgaW5saW5lQ29udGVudFswXS5kYXRhc2V0LnN0eWxlID0gSlNPTi5zdHJpbmdpZnkoZm9ybWF0dGluZy5pdGVtcyk7XHJcbiAgICBpbmxpbmVDb250ZW50WzBdLnN0eWxlLmNzc1RleHQgPSBtZS5fcHJlcGFyZUZvcm1hdHRpbmcoZm9ybWF0dGluZyk7XHJcbiAgfVxyXG5cclxuICBzZWdtZW50U291cmNlRWwuYXBwZW5kKGlubGluZUNvbnRlbnQpO1xyXG5cclxuICBzb3VyY2VEYXRhc2V0ID0gc2VnbWVudFNvdXJjZUVsWzBdLmRhdGFzZXQ7XHJcbiAgc291cmNlRGF0YXNldC5zb3VyY2VTZWdtZW50TnVtYmVyID0gc2VnbWVudC5zZWdtZW50TnVtYmVyO1xyXG4gIHNvdXJjZURhdGFzZXQuc291cmNlUHVpZCA9IHNlZ21lbnQucHVpZCgpO1xyXG5cclxuICByZXR1cm4gc2VnbWVudFNvdXJjZUVsO1xyXG59O1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclN0YXR1cyA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgc2VnbWVudFN0YXR1c0VsID0gJChtZS50bXBsLmNlbGwpLFxyXG4gICAgICBzZWdtZW50U3RhdHVzQ29udGVudCA9IG1lLl9yZW5kZXJTZWdtZW50U3RhdHVzKHNlZ21lbnQpO1xyXG5cclxuICBzZWdtZW50U3RhdHVzRWwuYXBwZW5kKHNlZ21lbnRTdGF0dXNDb250ZW50KTtcclxuICBzZWdtZW50U3RhdHVzRWwuYXR0cigndGl0bGUnLCBzZWdtZW50LnNlZ21lbnRJbmZvKCkpO1xyXG5cclxuICByZXR1cm4gc2VnbWVudFN0YXR1c0VsO1xyXG59O1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRhcmdldFNlZ21lbnQgPSBmdW5jdGlvbiAoc2VnbWVudCwgZm9ybWF0dGluZykge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlZ21lbnRUYXJnZXRFbCA9IG1lLnRtcGwudGFyZ2V0U2VnbWVudEJ1aWxkZXIoKSxcclxuICAgICAgaW5saW5lQ29udGVudCA9IG1lLl9yZW5kZXJJbmxpbmVDb250ZW50KHNlZ21lbnQuY2hpbGRyZW4pLFxyXG4gICAgICB0YXJnZXREYXRhc2V0O1xyXG5cclxuICAvLyBJZiBzZWdtZW50IGlzIGxvY2tlZCwgYWRkICd1ZS1zZWdtZW50LWxvY2tlZCcgY2xhc3MgdG8gc2VnbWVudCBlbGVtZW50XHJcbiAgaWYgKHNlZ21lbnQuaXNMb2NrZWQpIHtcclxuICAgIHNlZ21lbnRUYXJnZXRFbFswXS5jbGFzc0xpc3QuYWRkKCd1ZS1zZWdtZW50LWxvY2tlZCcpO1xyXG4gICAgc2VnbWVudFRhcmdldEVsWzBdLmRhdGFzZXQuaXNMb2NrZWQgPSBzZWdtZW50LmlzTG9ja2VkO1xyXG4gICAgc2VnbWVudFRhcmdldEVsWzBdLmRhdGFzZXQuc2VnbWVudE51bWJlciA9IHNlZ21lbnQuc2VnbWVudE51bWJlcjtcclxuICB9XHJcblxyXG4gIC8vIElmIHdlIGhhdmUgZm9ybWF0aW5nIGFkZCBpdCB0byB0aGUgaW5saW5lIGNvbnRlbnRcclxuICBpZiAoZm9ybWF0dGluZykge1xyXG4gICAgaW5saW5lQ29udGVudFswXS5kYXRhc2V0LnN0eWxlID0gSlNPTi5zdHJpbmdpZnkoZm9ybWF0dGluZy5pdGVtcyk7XHJcbiAgICBpbmxpbmVDb250ZW50WzBdLnN0eWxlLmNzc1RleHQgPSBtZS5fcHJlcGFyZUZvcm1hdHRpbmcoZm9ybWF0dGluZyk7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgWmVybyBXaWR0aCBOb24tSm9pbmVyIGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcclxuICAvLyBpbnNpZGUgZmlyc3QgXCJ1ZS1pbmxpbmUtY29udGVudFwiIGNvbnRhaW5lclxyXG4gIGlubGluZUNvbnRlbnQucHJlcGVuZChtZS50bXBsLnp3bmopO1xyXG4gIHNlZ21lbnRUYXJnZXRFbC5hcHBlbmQoaW5saW5lQ29udGVudCk7XHJcblxyXG4gIHRhcmdldERhdGFzZXQgPSBzZWdtZW50VGFyZ2V0RWxbMF0uZGF0YXNldDtcclxuICB0YXJnZXREYXRhc2V0LnNlZ21lbnROdW1iZXIgPSBzZWdtZW50LnNlZ21lbnROdW1iZXI7XHJcbiAgdGFyZ2V0RGF0YXNldC5wdWlkID0gc2VnbWVudC5wdWlkKCk7XHJcblxyXG4gIHJldHVybiBzZWdtZW50VGFyZ2V0RWw7XHJcbn07XHJcblxyXG5yZW5kZXJlci5wcm90b3R5cGUuYXBwZW5kRmlsZUVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBtZS5zZWdtZW50TnVtYmVycy5hcHBlbmQoJChtZS50bXBsLmNlbGwpLmh0bWwobWUudG1wbC56d25qKSk7XHJcbiAgbWUuc291cmNlRWRpdGFibGVDb2x1bW4uYXBwZW5kKCQobWUuZmlsZUVuZCkpO1xyXG4gIG1lLnNlZ21lbnRTdGF0dXMuYXBwZW5kKCQobWUudG1wbC5jZWxsKS5odG1sKG1lLnRtcGwuenduaikpO1xyXG4gIG1lLnRhcmdldEVkaXRhYmxlQ29sdW1uLmFwcGVuZChtZS5maWxlRW5kLmNsb25lKCkpO1xyXG59O1xyXG5cclxucmVuZGVyZXIucHJvdG90eXBlLl9yZW5kZXJTZWdtZW50U3RhdHVzID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBpbmZvID0gbWUuX3JlbmRlclNlZ21lbnRTdGF0dXNJY29uKHNlZ21lbnQpLFxyXG4gICAgICBvcmlnaW4gPSBtZS5fcmVuZGVyU2VnbWVudE9yaWdpbihzZWdtZW50KSxcclxuICAgICAgc3RhdHVzID0gbWUuX3JlbmRlclNlZ21lbnRTdGF0ZUljb24oc2VnbWVudCk7XHJcblxyXG4gIHJldHVybiBbIGluZm8sIG9yaWdpbiwgc3RhdHVzIF07XHJcbn07XHJcblxyXG5yZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlclNlZ21lbnRTdGF0dXNJY29uID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBzdGF0dXNJY29uRWwgPSAkKCc8aS8+JykuYWRkQ2xhc3MoJ3N0YXR1cy1pY29uLScgKyBzZWdtZW50LnN0YXR1c0ljb24oKSk7XHJcblxyXG4gIHJldHVybiAkKG1lLnRtcGwuc3RhdHVzQ29sdW1uV3JhcHBlcignZmlyc3QnKSkuYXBwZW5kKHN0YXR1c0ljb25FbCk7XHJcbn07XHJcblxyXG5yZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlclNlZ21lbnRPcmlnaW4gPSBmdW5jdGlvbiAoc2VnbWVudCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlZ21lbnRPcmlnaW5FbCA9ICQoJzxkaXYvPicpO1xyXG5cclxuICBpZiAoc2VnbWVudC5kaXNwbGF5T3JpZ2luSWNvbigpKSB7XHJcbiAgICBzZWdtZW50T3JpZ2luRWwgPSAkKCc8ZGl2IGNsYXNzPVwidWUtdHJhbnNsYXRpb24tb3JpZ2luLScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQub3JpZ2luQ2xhc3MoKSArICdcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50Lm9yaWdpblRleHQoKSArICc8L2Rpdj4nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiAkKG1lLnRtcGwuc3RhdHVzQ29sdW1uV3JhcHBlcignc2Vjb25kJykpLmFwcGVuZChzZWdtZW50T3JpZ2luRWwpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbmRlciBzdGF0dXMgdGhpcmQgY29sdW1uIGljb25cclxuICogQHBhcmFtICB7T2JqZWN0fSBzZWdtZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fSAgalF1ZXJ5IHdyYXBwZWQgc2V0XHJcbiAqL1xyXG5yZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlclNlZ21lbnRTdGF0ZUljb24gPSBmdW5jdGlvbiAoc2VnbWVudCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHNlZ21lbnRTdGF0ZUVsLFxyXG4gICAgICBpc0xvY2tlZCA9IHNlZ21lbnQuaXNMb2NrZWRTZWdtZW50KCk7XHJcblxyXG4gIGlmIChpc0xvY2tlZCkge1xyXG4gICAgc2VnbWVudFN0YXRlRWwgPSAkKG1lLnRtcGwuc3RhdHVzSWNvblNlZ21lbnRMb2NrZWQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuICQobWUudG1wbC5zdGF0dXNDb2x1bW5XcmFwcGVyKCd0aGlyZCcpKS5odG1sKHNlZ21lbnRTdGF0ZUVsKTtcclxufTtcclxuXHJcbnJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVySW5saW5lQ29udGVudCA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGNvbnRlbnQgPSBbXSxcclxuICAgICAgaW5saW5lSXRlbXM7XHJcblxyXG4gIGlmICghY2hpbGRyZW4pIHtcclxuICAgIHJldHVybiBjb250ZW50O1xyXG4gIH1cclxuXHJcbiAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoaW5saW5lKSB7XHJcbiAgICBpbmxpbmVJdGVtcyA9IG1lLl9yZW5kZXJJbmxpbmUoaW5saW5lKTtcclxuICAgIGNvbnRlbnQgPSBjb250ZW50LmNvbmNhdChpbmxpbmVJdGVtcyk7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiAkKG1lLnRtcGwuaW5saW5lQ29udGVudFdyYXBwZXIpLmFwcGVuZChjb250ZW50KTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVuZGVyIHRleHRcclxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKi9cclxucmVuZGVyZXIucHJvdG90eXBlLl9yZW5kZXJUZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICB0bXBsID0gbWUudG1wbCxcclxuICAgICAgaHRtbCA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCh0bXBsLnRleHQpLFxyXG4gICAgICBodG1sRWwgPSAkKGh0bWwpO1xyXG5cclxuICBodG1sLmRhdGFzZXQudHlwZSA9ICd0ZXh0JztcclxuICBodG1sRWwuaHRtbChkYXRhLnRleHQpO1xyXG5cclxuICByZXR1cm4gWyBodG1sRWwgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW5kZXIgdGFnc1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5yZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlclRhZ1BhaXIgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHRhZ1BhaXJTdGFydCxcclxuICAgICAgdGFnUGFpckVuZCxcclxuICAgICAgdGFnUGFpciA9IFtdLFxyXG4gICAgICBpbmxpbmVDb250ZW50LFxyXG4gICAgICBpbmxpbmVDb250ZW50RWwsXHJcbiAgICAgIHRhZ1BhaXJTdGFydENvbnRlbnQsXHJcbiAgICAgIHRhZ1BhaXJFbmRDb250ZW50LFxyXG4gICAgICB0YWdQYWlyQ29udGVudCA9IChuZXcgVGFnQ29udGVudEJ1aWxkZXIoY29uZmlnLnRhZ0Rpc3BsYXlDb250ZXh0LnRhZ0Rpc3BsYXlNb2RlKSkuYnVpbGQoZGF0YSksXHJcbiAgICAgIGVzY2FwZUhUTUwgPSBIZWxwZXJzLmVzY2FwZUhUTUwsXHJcbiAgICAgIHRhZ0Rpc3BsYXlDb250ZXh0ID0gKGNvbmZpZy50YWdEaXNwbGF5Q29udGV4dC5zaG93Rm9ybWF0dGluZyA9PT0gZmFsc2UpO1xyXG5cclxuICBpZiAodHlwZW9mIHRhZ1BhaXJDb250ZW50ID09PSAnb2JqZWN0Jykge1xyXG4gICAgdGFnUGFpclN0YXJ0Q29udGVudCA9IHRhZ1BhaXJDb250ZW50LnRhZ1N0YXJ0O1xyXG4gICAgdGFnUGFpckVuZENvbnRlbnQgPSB0YWdQYWlyQ29udGVudC50YWdFbmQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRhZ1BhaXJTdGFydENvbnRlbnQgPSB0YWdQYWlyRW5kQ29udGVudCA9IHRhZ1BhaXJDb250ZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gQnVpbGQgc3RhcnQgJiBlbmQgdGFnXHJcbiAgdGFnUGFpclN0YXJ0ID0gbWUudG1wbC50YWdQYWlyU3RhcnRCdWlsZGVyKCk7XHJcbiAgdGFnUGFpckVuZCA9IG1lLnRtcGwudGFnUGFpckVuZEJ1aWxkZXIoKTtcclxuXHJcbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBjaGFuZ2VkXHJcbiAgdGFnUGFpclN0YXJ0WzBdLmNoaWxkTm9kZXNbMF0uZGF0YXNldC5kaXNwbGF5Q29udGVudCA9IHRhZ1BhaXJTdGFydENvbnRlbnQ7XHJcbiAgdGFnUGFpckVuZFswXS5jaGlsZE5vZGVzWzBdLmRhdGFzZXQuZGlzcGxheUNvbnRlbnQgPSB0YWdQYWlyRW5kQ29udGVudDtcclxuXHJcbiAgLy8gQWRkIGRhdGEtKiBhdHRyaWJ1dGVzIHRvIHRhZ3BhaXJcclxuICB0YWdQYWlyU3RhcnRbMF0uZGF0YXNldC50YWdDb3B5ID0gbWUuaXNUYWdDb3B5QWxsb3dlZDtcclxuICB0YWdQYWlyRW5kWzBdLmRhdGFzZXQudGFnQ29weSA9IG1lLmlzVGFnQ29weUFsbG93ZWQ7XHJcblxyXG4gIHRhZ1BhaXJTdGFydFswXS5kYXRhc2V0LmlkID0gZGF0YS5pZDtcclxuICB0YWdQYWlyRW5kWzBdLmRhdGFzZXQuaWQgPSBkYXRhLmlkO1xyXG5cclxuICB0YWdQYWlyU3RhcnRbMF0uZGF0YXNldC5tZXRhZGF0YSA9IGRhdGEubWV0YWRhdGE7XHJcbiAgdGFnUGFpckVuZFswXS5kYXRhc2V0Lm1ldGFkYXRhID0gZGF0YS5tZXRhZGF0YTtcclxuXHJcbiAgLy8gSWYgd2UgaGF2ZSBjYW5IaWRlIHByb3BlcnR5LCBhZGQgaXQgdG8gdGhlIHRhZ3NcclxuICBpZiAoZGF0YS5jYW5IaWRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHRhZ1BhaXJTdGFydFswXS5kYXRhc2V0LmNhbkhpZGUgPSBkYXRhLmNhbkhpZGU7XHJcbiAgICB0YWdQYWlyRW5kWzBdLmRhdGFzZXQuY2FuSGlkZSA9IGRhdGEuY2FuSGlkZTtcclxuXHJcbiAgICBpZiAodGFnRGlzcGxheUNvbnRleHQgJiYgZGF0YS5jYW5IaWRlKSB7XHJcbiAgICAgIHRhZ1BhaXJTdGFydFswXS5jbGFzc0xpc3QuYWRkKCdoaWRlJyk7XHJcbiAgICAgIHRhZ1BhaXJFbmRbMF0uY2xhc3NMaXN0LmFkZCgnaGlkZScpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGFnUGFpci5wdXNoKHRhZ1BhaXJTdGFydCk7XHJcblxyXG4gIGlubGluZUNvbnRlbnQgPSBtZS5fcmVuZGVySW5saW5lQ29udGVudChkYXRhLmNoaWxkcmVuKTtcclxuICBpbmxpbmVDb250ZW50LmFkZENsYXNzKCd1ZS10YWdwYWlyLWNvbnRlbnQnKTtcclxuXHJcbiAgaW5saW5lQ29udGVudEVsID0gaW5saW5lQ29udGVudFswXTtcclxuICBpbmxpbmVDb250ZW50RWwuZGF0YXNldC50eXBlID0gJ3RhZ3BhaXInO1xyXG4gIGlubGluZUNvbnRlbnRFbC5kYXRhc2V0LmlkID0gZGF0YS5pZDtcclxuICBpbmxpbmVDb250ZW50RWwuZGF0YXNldC5kZWZpbml0aW9uaWQgPSBkYXRhLnRhZ1BhaXJEZWZpbml0aW9uSWQ7XHJcbiAgaW5saW5lQ29udGVudEVsLmRhdGFzZXQubWV0YWRhdGEgPSBkYXRhLm1ldGFkYXRhO1xyXG5cclxuICB0YWdQYWlyU3RhcnRbMF0uZGF0YXNldC5pZCA9IGRhdGEuaWQ7XHJcbiAgdGFnUGFpckVuZFswXS5kYXRhc2V0LmlkID0gZGF0YS5pZDtcclxuXHJcbiAgLy8gUmVkZXIgc3R5bGVzIGlmIHdlIGhhdmUgYSBmb3JtYXR0aW5nR3JvdXBcclxuICBpZiAoZGF0YS5mb3JtYXR0aW5nR3JvdXApIHtcclxuICAgIGlubGluZUNvbnRlbnRbMF0uZGF0YXNldC5zdHlsZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEuZm9ybWF0dGluZ0dyb3VwLml0ZW1zKTtcclxuICAgIGlubGluZUNvbnRlbnRbMF0uc3R5bGUuY3NzVGV4dCA9IG1lLl9wcmVwYXJlRm9ybWF0dGluZyhkYXRhLmZvcm1hdHRpbmdHcm91cCk7XHJcbiAgfVxyXG5cclxuICB0YWdQYWlyLnB1c2goaW5saW5lQ29udGVudCk7XHJcbiAgdGFnUGFpci5wdXNoKHRhZ1BhaXJFbmQpO1xyXG5cclxuICBtZS5zZWdtZW50c1dhdGNoZXIuYWRkVGFnUGFpcihkYXRhLmlkLCBbdGFnUGFpclN0YXJ0LCB0YWdQYWlyRW5kXSk7XHJcblxyXG4gIHJldHVybiB0YWdQYWlyO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXIgcGxhY2Vob2xkZXJzXHJcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICovXHJcbnJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHRtcGwgPSBtZS50bXBsLFxyXG4gICAgICBwbGFjZWhvbGRlcixcclxuICAgICAgcGxhY2Vob2xkZXJFbCxcclxuICAgICAgcGxhY2Vob2xkZXJDb250ZW50ID0gKG5ldyBUYWdDb250ZW50QnVpbGRlcihjb25maWcudGFnRGlzcGxheUNvbnRleHQudGFnRGlzcGxheU1vZGUpKS5idWlsZChkYXRhKSxcclxuICAgICAgZXNjYXBlSFRNTCA9IEhlbHBlcnMuZXNjYXBlSFRNTDtcclxuXHJcbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBjaGFuZ2VkXHJcbiAgcGxhY2Vob2xkZXIgPSBtZS50bXBsLnBsYWNlaG9sZGVyVGFnQnVpbGRlcigpO1xyXG4gIHBsYWNlaG9sZGVyWzBdLmNoaWxkTm9kZXNbMF0uZGF0YXNldC5kaXNwbGF5Q29udGVudCA9IHBsYWNlaG9sZGVyQ29udGVudDtcclxuXHJcbiAgcGxhY2Vob2xkZXJFbCA9IHBsYWNlaG9sZGVyWzBdO1xyXG4gIHBsYWNlaG9sZGVyRWwuZGF0YXNldC50eXBlID0gJ3BsYWNlaG9sZGVyJztcclxuICBwbGFjZWhvbGRlckVsLmRhdGFzZXQuaWQgPSBkYXRhLmlkO1xyXG4gIHBsYWNlaG9sZGVyRWwuZGF0YXNldC5kZWZpbml0aW9uaWQgPSBkYXRhLnBsYWNlaG9sZGVyVGFnRGVmaW5pdGlvbklkO1xyXG4gIHBsYWNlaG9sZGVyRWwuZGF0YXNldC5tZXRhZGF0YSA9IGRhdGEubWV0YWRhdGE7XHJcbiAgcGxhY2Vob2xkZXJFbC5kYXRhc2V0LnRhZ0NvcHkgPSBtZS5pc1RhZ0NvcHlBbGxvd2VkO1xyXG5cclxuICByZXR1cm4gWyBwbGFjZWhvbGRlciBdO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXIgbG9ja2VkIGNvbnRlbnQgaW5zaWRlIGEgc2VnbWVudFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5yZW5kZXJlci5wcm90b3R5cGUuX3JlbmRlckxvY2tlZENvbnRlbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHRtcGwgPSBtZS50bXBsLFxyXG4gICAgICBsb2NrZWRDb250ZW50U3RhcnQsXHJcbiAgICAgIGxvY2tlZENvbnRlbnRFbmQsXHJcbiAgICAgIGxvY2tlZElubGluZUNvbnRlbnQ7XHJcblxyXG4gIGlmICghZGF0YSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgbG9ja2VkQ29udGVudFN0YXJ0ID0gdG1wbC5sb2NrZWRDb250ZW50U3RhcnRUYWdCdWlsZGVyKCk7XHJcbiAgbG9ja2VkQ29udGVudEVuZCA9IHRtcGwubG9ja2VkQ29udGVudEVuZFRhZ0J1aWxkZXIoKTtcclxuICBsb2NrZWRJbmxpbmVDb250ZW50ID0gbWUuX3JlbmRlcklubGluZUNvbnRlbnQoZGF0YSk7XHJcblxyXG4gIGxvY2tlZElubGluZUNvbnRlbnRbMF0uZGF0YXNldC5pc0xvY2tlZCA9IHRydWU7XHJcbiAgbG9ja2VkSW5saW5lQ29udGVudFswXS5jbGFzc0xpc3QuYWRkKCd1ZS1sb2NrZWQtY29udGVudCcpO1xyXG5cclxuICByZXR1cm4gW1xyXG4gICAgbG9ja2VkQ29udGVudFN0YXJ0LFxyXG4gICAgbG9ja2VkSW5saW5lQ29udGVudCxcclxuICAgIGxvY2tlZENvbnRlbnRFbmRcclxuICBdO1xyXG59O1xyXG5cclxuXHJcbnJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVySW5saW5lID0gZnVuY3Rpb24gKGlubGluZSkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIC8vIFJlbmRlciB0ZXh0XHJcbiAgaWYgKGlubGluZS50eXBlID09PSAndGV4dCcpIHtcclxuICAgIHJldHVybiBtZS5fcmVuZGVyVGV4dChpbmxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVuZGVyIHRhZ3MgYW5kIGlubGluZSBjb250ZW50XHJcbiAgaWYgKGlubGluZS50eXBlID09PSAndGFnUGFpcicpIHtcclxuICAgIHJldHVybiBtZS5fcmVuZGVyVGFnUGFpcihpbmxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVuZGVyIHBsYWNlaG9sZGVyc1xyXG4gIGlmIChpbmxpbmUudHlwZSA9PT0gJ3BsYWNlaG9sZGVyVGFnJykge1xyXG4gICAgcmV0dXJuIG1lLl9yZW5kZXJQbGFjZWhvbGRlcihpbmxpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVuZGVyIGxvY2tlZCBjb250ZW50IGluc2lkZSBzZWdtZW50c1xyXG4gIGlmIChpbmxpbmUudHlwZSA9PT0gJ2xvY2tlZCcpIHtcclxuICAgIHJldHVybiBtZS5fcmVuZGVyTG9ja2VkQ29udGVudChpbmxpbmUuY2hpbGRyZW4pO1xyXG4gIH1cclxuXHJcbiAgLy8gT3IgcmV0dXJuIGVtcHR5IGFycmF5XHJcbiAgcmV0dXJuIFtdO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBQcmVwYXJlcyBzdHlsZXMgZm9yIHRhZ3BhaXIgZm9ybWF0dGluZ1xyXG4gKiBAcGFyYW0gIHtvYmplY3R9IGZvcm1hdHRpbmdHcm91cFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqL1xyXG5yZW5kZXJlci5wcm90b3R5cGUuX3ByZXBhcmVGb3JtYXR0aW5nID0gZnVuY3Rpb24gKGZvcm1hdHRpbmdHcm91cCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGl0ZW1zID0ge30sXHJcbiAgICAgIHN0eWxlc0xpc3QgPSBbXTtcclxuXHJcbiAgaWYgKGZvcm1hdHRpbmdHcm91cCkge1xyXG4gICAgaXRlbXMgPSBmb3JtYXR0aW5nR3JvdXAuaXRlbXM7XHJcblxyXG4gICAgLy8gSW50ZXJhdGUgb3ZlciBmb3JtYXR0aW5nIGl0ZW1zXHJcbiAgICBfLmZvckVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtLCBrZXkpIHtcclxuXHJcbiAgICAgIC8vIEdldCBhbGwgc3R5bGVzIGZyb20gU3R5bGVzTWFwIGFuZCBidWlsZFxyXG4gICAgICAvLyB0aGUgc3RyaW5nIGZvciBpbmxpbmUgc3R5bGUgYXR0cmlidXRlXHJcbiAgICAgIGlmIChrZXkgJiYgKGtleS50b0xvd2VyQ2FzZSgpIGluIFN0eWxlc01hcCkpIHtcclxuICAgICAgICBfLmZvckVhY2goU3R5bGVzTWFwW2tleS50b0xvd2VyQ2FzZSgpXShpdGVtc1trZXldKSwgZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgc3R5bGVzTGlzdC5wdXNoKFtwcm9wZXJ0eSwgc3R5bGVdLmpvaW4oJzonKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIHN0eWxlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIFN0eWxlc01hcCwgbG9nIGFuIGVycm9yXHJcbiAgICAgICAgY29uc29sZS5lcnJvcignXCInICsga2V5ICsgJ1wiIGRvZXMgbm90IGV4aXN0IGluIHRoZSBzdHlsZXMgbWFwJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdHlsZXNMaXN0LmpvaW4oJzsnKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2lkZUJ5U2lkZVBhcmFncmFwaFVuaXRzUmVuZGVyZXI7IiwiLyogRmlsZTogU3RvcmFnZS5qcyAqL1xuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbi8qIGdsb2JhbHMgcmVxdWlyZSwgbW9kdWxlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIE1lZGlhdG9yID0gcmVxdWlyZSgnLi9NZWRpYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3RvcmFnZUltcGxlbWVudGF0aW9uOiAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0YW5jZSA9IG51bGwsXG4gICAgICAgIGJhc2VfdXJsID0gY29uZmlnLmJhc2VVcmw7XG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBsaW1pdDogY29uZmlnLmRlZmF1bHRMaW1pdCB8fCA1LFxuICAgICAgb2Zmc2V0OiBjb25maWcuZGVmYXVsdE9mZnNldCB8fCAwXG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBzZWFyY2ggZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvbiBjaGVjayBjb25zdHJhaW50c1xuICAgICAqIEByZXR1cm4ge051bWJlcnxJdGVtfSBpbmRleHxpdGVtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VhcmNoKGxpc3QsIGZuYykge1xuICAgICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gICAgICBpZiAoIWZuYyB8fCB0eXBlb2YoZm5jKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGlzdCB8fCAhbGVuIHx8IGxlbiA8IDEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChmbmMobGlzdFtpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2luZ2xlIGVudHJ5IHBvaW50IHRvIGdldCBkYXRhXG4gICAgICpcbiAgICAgKiBAZGVwZW5kZW5jeSBqUXVlcnlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICB1cmxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgY2FsbGJhY2sgc3VjY2VzcyBjYWxsYmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldERhdGEodXJsLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGFjdGlvbiA9ICQuYWpheCh7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHVybDogYmFzZV91cmwgKyB1cmwsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgIH0pO1xuXG4gICAgICBhY3Rpb24uZG9uZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZURhdGEodXJsLCBkYXRhKSB7XG4gICAgICB2YXIgcHJvbWlzZSA9ICQuRGVmZXJyZWQoKTtcblxuICAgICAgdmFyIGFjdGlvbiA9ICQuYWpheCh7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIHVybDogYmFzZV91cmwgKyB1cmwsXG4gICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICBkYXRhVHlwZTogJ3RleHQnXG4gICAgICB9KTtcblxuICAgICAgTWVkaWF0b3IucHVibGlzaCgnc2F2ZTpiZWZvcmUnKTtcblxuICAgICAgYWN0aW9uLmRvbmUoZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICBwcm9taXNlLnJlc29sdmVXaXRoKG51bGwsIFtkYXRhXSk7XG4gICAgICAgIE1lZGlhdG9yLnB1Ymxpc2goJ3NhdmU6ZG9uZScpO1xuXG4gICAgICB9KS5mYWlsKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBwcm9taXNlLnJlamVjdFdpdGgobnVsbCwgW3tcbiAgICAgICAgICAvLyBlcnJvciBvYmplY3QgZ29lcyBoZXJlXG4gICAgICAgIH1dKTtcblxuICAgICAgICBNZWRpYXRvci5wdWJsaXNoKCdzYXZlOmZhaWwnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdCgpIHtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudFBhcmFncmFwaEluZGV4OiAwLFxuICAgICAgICBkb2N1bWVudHM6IFtdLFxuICAgICAgICBwYXJhZ3JhcGhzOiBbXSxcbiAgICAgICAgY3VycmVudERvY3VtZW50OiB7XG4gICAgICAgICAgaWQ6IG51bGwsXG4gICAgICAgICAgcGFyYWdyYXBoQ291bnQ6IDAsXG4gICAgICAgICAgbG9hZGVkUGFyYWdyYXBoczogMCxcbiAgICAgICAgICBza2VsZXRvbnM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBwYXJhZ3JhcGhcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYXJhZ3JhcGg6IGZ1bmN0aW9uIChpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh0cnVlLCBudWxsKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXJhZ3JhcGhVbml0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmFncmFwaFVuaXRzLmxlbmd0aCA9PT0gMSAmJiBwYXJhZ3JhcGhVbml0c1swXS5pZCAhPT0gaWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGl0ZW0gPSBzZWFyY2gocGFyYWdyYXBoVW5pdHMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gaWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvL2lmIHNlYXJjaCByZXR1cm4gLTFcbiAgICAgICAgICBpZiAoIX5pdGVtKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL3JldHVybiBmb3VuZCBpdGVtXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgaXRlbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFBhcmFncmFwaHM6IGZ1bmN0aW9uIChkb2N1bWVudElkLCBjYWxsYmFjaywgbGltaXQsIG9mZnNldCkge1xuICAgICAgICAgIC8vaWYgdGhlcmUgaXMgbm8gbG9jYWwgZGF0YSwgdHJ5IHRvIGdldCBkYXRhIGZyb20gdGhlIHNlcnZpY2VcbiAgICAgICAgICBpZiAocGFyYWdyYXBoVW5pdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXREYXRhKCcvYXBpL3BhcmFncmFwaHVuaXRzJywgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9pZiBsaW1pdCBvZiBvZmZzZXQgZXhpc3RzIGNyZWF0ZSB0aGUgcXVlcnkgc3RyaW5nIGFuZFxuICAgICAgICAgIC8vYXNrIHRoZSBzZXJ2aWNlIGZvciBkYXRhXG4gICAgICAgICAgaWYgKCh0eXBlb2YgbGltaXQpICE9PSAndW5kZWZpbmVkJyB8fCAodHlwZW9mIG9mZnNldCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGxpbWl0IG9yIG9mZnNldCBhcmUgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgICAgIGlmIChpc05hTigrbGltaXQpIHx8IGlzTmFOKCtvZmZzZXQpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9jcmVhdGUgdGhlIGxpbWl0IGFuZCBvZmZzZXQgcXVlcnkgc3RyaW5nc1xuICAgICAgICAgICAgdmFyIGwgPSAobGltaXQpID8gJz9saW1pdD0nICsgbGltaXQgOiAnP2xpbWl0PTInO1xuICAgICAgICAgICAgdmFyIG8gPSAob2Zmc2V0KSA/ICcmb2Zmc2V0PScgKyBvZmZzZXQgOiAnJm9mZnNldD0wJztcblxuICAgICAgICAgICAgZ2V0RGF0YSgnL2FwaS9wYXJhZ3JhcGh1bml0cy8nICsgbCArIG8sIGNhbGxiYWNrKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBhcmFncmFwaFVuaXRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYWxsIHBhcmFncmFwaCB1bml0cyBmb3IgYSBzcGVjaWZpZWQgZG9jdW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9ICAgIGRvY3VtZW50SWRcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gIGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSAgICBsaW1pdFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gICAgb2Zmc2V0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYXJhZ3JhcGhzOiBmdW5jdGlvbiAoZG9jdW1lbnRJZCwgY2FsbGJhY2ssIGxpbWl0LCBvZmZzZXQpIHtcbiAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgbWUuY3VycmVudERvY3VtZW50LmlkID0gZG9jdW1lbnRJZDtcblxuICAgICAgICAgIGlmICgodHlwZW9mIGxpbWl0KSAhPT0gJ3VuZGVmaW5lZCcgfHwgKHR5cGVvZiBvZmZzZXQpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy9zYW5pdHkgY2hlY2tcbiAgICAgICAgICAgIGlmIChpc05hTigrbGltaXQpIHx8IGlzTmFOKCtvZmZzZXQpIHx8IGxpbWl0ID09PSBudWxsIHx8IG9mZnNldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldERhdGEoJy9kb2N1bWVudC8nICsgZG9jdW1lbnRJZCArICcvcGFyYWdyYXBocy8nICsgb2Zmc2V0ICsgJy8nICsgbGltaXQsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgbWUuY3VycmVudERvY3VtZW50LmxvYWRlZFBhcmFncmFwaHMgPSBtZS5jdXJyZW50RG9jdW1lbnQubG9hZGVkUGFyYWdyYXBocyArIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICBtZS5wYXJhZ3JhcGhzID0gbWUucGFyYWdyYXBocy5jb25jYXQoZGF0YSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXREYXRhKCcvZG9jdW1lbnQvJyArIGRvY3VtZW50SWQgKyAnL3BhcmFncmFwaHMvJyArIGRlZmF1bHRzLm9mZnNldCArICcvJyArIGRlZmF1bHRzLmxpbWl0LCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBtZS5jdXJyZW50RG9jdW1lbnQubG9hZGVkUGFyYWdyYXBocyA9IG1lLmN1cnJlbnREb2N1bWVudC5sb2FkZWRQYXJhZ3JhcGhzICsgZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgIG1lLnBhcmFncmFwaHMgPSBtZS5wYXJhZ3JhcGhzLmNvbmNhdChkYXRhKTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE5leHRQYXJhZ3JhcGg6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZ2V0RGF0YSgnL2FwaS9wYXJhZ3JhcGh1bml0cy8/YWN0aW9uPW5leHQnLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRQcmV2UGFyYWdyYXBoOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGdldERhdGEoJy9hcGkvcGFyYWdyYXBodW5pdHMvP2FjdGlvbj1wcmV2JywgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIG5leHQgc2V0IG9mIHBhcmFncmFwaCB1bml0cyBmcm9tIHRoZSBzdG9yYWdlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICBnZXROZXh0UGFyYWdyYXBoczogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIG1lID0gdGhpcyxcbiAgICAgICAgICAgICAgZG9jdW1lbnRJZCA9IG1lLmN1cnJlbnREb2N1bWVudC5pZDtcblxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZ2V0RGF0YSgnL2RvY3VtZW50LycgKyBkb2N1bWVudElkICsgJy9wYXJhZ3JhcGhzLycgKyB0aGlzLmN1cnJlbnREb2N1bWVudC5sb2FkZWRQYXJhZ3JhcGhzICsgJy8nICsgZGVmYXVsdHMubGltaXQsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgbWUuY3VycmVudERvY3VtZW50LmxvYWRlZFBhcmFncmFwaHMgPSBtZS5jdXJyZW50RG9jdW1lbnQubG9hZGVkUGFyYWdyYXBocyArIGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIG1lLnBhcmFncmFwaHMgPSBtZS5wYXJhZ3JhcGhzLmNvbmNhdChkYXRhKTtcblxuICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBsaXN0IG9mIGRvY3VtZW50c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RG9jdW1lbnRzOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBnZXREYXRhKCcvZG9jdW1lbnRzJywgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAvL2NhY2hlIHRoZSBkb2N1bWVudHNcbiAgICAgICAgICAgICAgbWUuZG9jdW1lbnRzID0gbWUuZG9jdW1lbnRzLmNvbmNhdChkYXRhKTtcblxuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgZG9jdW1lbnQgYnkgaWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICBnZXREb2N1bWVudDogZnVuY3Rpb24gKGlkLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGdldERhdGEoJy9kb2N1bWVudC8nICsgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgLy9jYWNoZSBkYXRhIHJlbGF0ZWQgdG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgIG1lLmN1cnJlbnREb2N1bWVudC5kYXRhID0gZGF0YTtcblxuICAgICAgICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHBhcmFncmFwaHNcbiAgICAgICAgICAgICAgdmFyIG5yUGFyYWdyYXBocyA9IDA7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZGF0YS5maWxlcykge1xuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSByZWd1bGFyIHBhcmFncmFwaCB1bml0IGNvdW50XG4gICAgICAgICAgICAgICAgbnJQYXJhZ3JhcGhzICs9IGRhdGEuZmlsZXNbaV0ucGFyYWdyYXBoVW5pdENvdW50IC0gZGF0YS5maWxlc1tpXS5zdHJ1Y3R1cmVQYXJhZ3JhcGhVbml0Q291bnQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBtZS5jdXJyZW50RG9jdW1lbnQucGFyYWdyYXBoQ291bnQgPSBuclBhcmFncmFwaHM7XG5cbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzYXZlT3BlcmF0aW9uOiBmdW5jdGlvbiAob3BlcmF0aW9ucykgeyAvLyBhcmcgJ2NhbGxiYWNrJyBuZXZlciB1c2VkXG4gICAgICAgICAgcmV0dXJuIHNhdmVEYXRhKCcvb3BlcmF0aW9uJywge1xuICAgICAgICAgICAgJ2FjdGlvbnMnIDogb3BlcmF0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNrZWxldG9uOiBmdW5jdGlvbiAoZmlsZUlkLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGdldERhdGEoJy9za2VsZXRvbi8nICsgZmlsZUlkLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBtZS5jdXJyZW50RG9jdW1lbnQuc2tlbGV0b25zLnB1c2goZGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEluc3RhbmNlKCkge1xuICAgICAgaWYgKCFpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZSA9IGluaXQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRJbnN0YW5jZTogZ2V0SW5zdGFuY2UsXG4gICAgICBnOiBnZXRJbnN0YW5jZVxuICAgIH07XG4gIH0pKClcbn07IiwiLyogRmlsZTogVG1wbC5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzICQsIG1vZHVsZSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBoID0gcmVxdWlyZSAoJy4vSGVscGVycycpLnN0cmluZ1RvSFRNTEVsZW1lbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBmaWxlU3RhdHVzOiAnPHNwYW4gZGF0YS10eXBlPVwic3RhdHVzLW1lc3NhZ2VcIj48JT0gc3RhdHVzICU+PC9zcGFuPicsXHJcblxyXG4gIHNlZ21lbnQ6ICc8ZGl2IGNsYXNzPVwidWUtc2VnbWVudFwiLz4nLFxyXG4gIGNlbGw6ICc8ZGl2IGNsYXNzPVwidWUtY2VsbFwiLz4nLFxyXG4gIHNvdXJjZVNlY3Rpb246ICc8c2VjdGlvbiBjbGFzcz1cImNvbC14cy02IHdyYXBwZXItd2VzdFwiLz4nLFxyXG4gIHRhcmdldFNlY3Rpb246ICc8c2VjdGlvbiBjbGFzcz1cImNvbC14cy02IHdyYXBwZXItZWFzdFwiLz4nLFxyXG5cclxuICBndXR0ZXJDb2x1bW46ICc8ZGl2IGNsYXNzPVwidWUtZ3V0dGVyXCIvPicsXHJcbiAgc291cmNlQ29sdW1uOiAnPGRpdiBjbGFzcz1cInVlLXNvdXJjZVwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiLz4nLFxyXG4gIHN0YXR1c0NvbHVtbjogJzxkaXYgY2xhc3M9XCJ1ZS1zdGF0dXNcIi8+JyxcclxuICB0YXJnZXRDb2x1bW46ICc8ZGl2IGNsYXNzPVwidWUtdGFyZ2V0XCIgc3BlbGxjaGVjaz1cInRydWVcIi8+JyxcclxuXHJcbiAgZWRpdGFibGVUcnVlOiAnPGRpdiBjbGFzcz1cInVlLWVkaXRhYmxlXCIgY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiLz4nLFxyXG4gIGVkaXRhYmxlRmFsc2U6ICc8ZGl2IGNsYXNzPVwidWUtZWRpdGFibGVcIiBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiLz4nLFxyXG5cclxuICBmaWxlVGFnU3RhcnQ6ICc8ZGl2IGNsYXNzPVwidWUtZmlsZVwiPjxzcGFuIGNsYXNzPVwidWUtdGFnIHVlLXRhZy1zdGFydCB1ZS10YWctZmlsZVwiPjwvc3Bhbj48L2Rpdj4nLFxyXG4gIGZpbGVUYWdFbmQ6ICc8ZGl2IGNsYXNzPVwidWUtZmlsZVwiPjxzcGFuIGNsYXNzPVwidWUtdGFnIHVlLXRhZy1lbmQgdWUtdGFnLWZpbGVcIj48L3NwYW4+PC9kaXY+JyxcclxuXHJcbiAgZmlsZTogJzxkaXYgY2xhc3M9XCJ1ZS1lZGl0YWJsZVwiIGNvbnRlbnRlZGl0YWJsZT1cInRydWVcIi8+JyxcclxuXHJcbiAgdGFnUGFpclN0YXJ0OiAnPHNwYW4gY2xhc3M9XCJ1ZS10YWcgdWUtdGFnLXN0YXJ0XCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIi8+JyxcclxuICB0YWdQYWlyRW5kOiAnPHNwYW4gY2xhc3M9XCJ1ZS10YWcgdWUtdGFnLWVuZFwiIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIvPicsXHJcblxyXG4gIHBsYWNlaG9sZGVyVGFnOiAnPHNwYW4gY2xhc3M9XCJ1ZS10YWdcIiBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiLz4nLFxyXG4gIHRleHQ6ICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIi8+JyxcclxuXHJcbiAgdGFnTG9ja2VkU3RhcnQ6ICc8c3BhbiBjbGFzcz1cInVlLXRhZyB1ZS10YWctbG9ja2VkLXN0YXJ0XCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIi8+JyxcclxuICB0YWdMb2NrZWRFbmQ6ICc8c3BhbiBjbGFzcz1cInVlLXRhZyB1ZS10YWctbG9ja2VkLWVuZFwiIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIvPicsXHJcblxyXG4gIGlubGluZUNvbnRlbnRXcmFwcGVyOiAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+PC9kaXY+JyxcclxuICBsb2NrZWRDb250ZW50V3JhcHBlcjogJzxkaXYgY2xhc3M9XCJ1ZS1sb2NrZWQtY29udGVudFwiPjwvZGl2PicsXHJcblxyXG4gIHRhZ1dyYXBwZXI6ICc8c3BhbiBjbGFzcz1cInVlLXRhZy13cmFwcGVyXCIvPicsXHJcblxyXG4gIC8vIFN0YXR1cyBpY29uc1xyXG4gIHN0YXR1c0ljb25TZWdtZW50TG9ja2VkOiAnPGkgY2xhc3M9XCJzdGF0dXMtaWNvbi1zZWdtZW50LXN0YXRlLWxva2VkXCIvPicsXHJcblxyXG4gIC8vIEFjdGl2aXR5IGluZGljYXRvclxyXG4gIC8vIFRoZSBtZXNzYWdlIGNhbiBiZSBjaGFuZ2VkIGJ5IG92ZXJyaWRpbmdcclxuICAvLyBkYXRhLWFjdGl2aXR5LW1lc3NhZ2UgYXR0cmlidXRlXHJcbiAgYWN0aXZpdHlJbmRpY2F0b3I6XHJcbiAgICAnPGRpdiBjbGFzcz1cInVlLWFjdGl2aXR5LWluZGljYXRvci13cmFwcGVyXCI+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwidWUtYWN0aXZpdHktaW5kaWNhdG9yXCIgZGF0YS1hY3Rpdml0eS1tZXNzYWdlPVwiTG9hZGluZyAuLi5cIj4nICtcclxuICAgICAgICAnPGRpdiBjbGFzcz1cInNwaW5uZXJcIj48L2Rpdj4nICtcclxuICAgICAgJzwvZGl2PicgK1xyXG4gICAgJzwvZGl2PicsXHJcblxyXG4gIC8vIHplcm9XaWR0aE5vbkpvaW5lciAtIGludmlzaWJsZSBjaGFyYWN0ZXJcclxuICB6d25qOiAnJnp3bmo7JyxcclxuICB6ZXJvV2lkdGhOb25Kb2luZXJDaGFyQ29kZTogODIwNCxcclxuXHJcblxyXG4gIGtleVRhYjoge1xyXG4gICAgY2hhckNvZGU6IDksXHJcbiAgICB1bmljb2RlOiAnXFx1MDAwOScsXHJcbiAgICBlbnRpdHk6ICcmIzA5OydcclxuICB9LFxyXG5cclxuICBzdGF0dXNDb2x1bW5XcmFwcGVyOiBmdW5jdGlvbiAob3JkZXIpIHtcclxuICAgIHJldHVybiAnPGRpdiBjbGFzcz1cImNvbC0nICsgb3JkZXIgKyAnXCIvPic7XHJcbiAgfSxcclxuXHJcbiAgdGFyZ2V0U2VnbWVudEJ1aWxkZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgICAgdGFyZ2V0U2VnbWVudDtcclxuXHJcbiAgICB0YXJnZXRTZWdtZW50ID0gJChtZS5zZWdtZW50KTsvLy5hcHBlbmQobWUuenduaik7XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldFNlZ21lbnQ7XHJcbiAgfSxcclxuXHJcbiAgdGFnUGFpclN0YXJ0QnVpbGRlcjogZnVuY3Rpb24gKGRpc3BsYXlUZXh0KSB7XHJcbiAgICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICAgIHN0YXJ0VGFnLFxyXG4gICAgICAgIHdyYXBwZXI7XHJcblxyXG4gICAgc3RhcnRUYWcgPSAkKG1lLnRhZ1BhaXJTdGFydCk7XHJcbiAgICBzdGFydFRhZy5odG1sKGRpc3BsYXlUZXh0KTtcclxuXHJcbiAgICB3cmFwcGVyID0gJChtZS50YWdXcmFwcGVyKS5hcHBlbmQoc3RhcnRUYWcpLmFwcGVuZChtZS56d25qKTtcclxuICAgIHdyYXBwZXJbMF0uZGF0YXNldC50eXBlID0gJ3N0YXJ0LXRhZyc7XHJcblxyXG4gICAgcmV0dXJuIHdyYXBwZXI7XHJcbiAgfSxcclxuXHJcbiAgdGFnUGFpckVuZEJ1aWxkZXI6IGZ1bmN0aW9uIChkaXNwbGF5VGV4dCkge1xyXG4gICAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgICBlbmRUYWcsXHJcbiAgICAgICAgd3JhcHBlcjtcclxuXHJcbiAgICBlbmRUYWcgPSAkKG1lLnRhZ1BhaXJFbmQpO1xyXG4gICAgZW5kVGFnLmh0bWwoZGlzcGxheVRleHQpO1xyXG5cclxuICAgIHdyYXBwZXIgPSAkKG1lLnRhZ1dyYXBwZXIpLmFwcGVuZChlbmRUYWcpLmFwcGVuZChtZS56d25qKTtcclxuICAgIHdyYXBwZXJbMF0uZGF0YXNldC50eXBlID0gJ2VuZC10YWcnO1xyXG5cclxuICAgIHJldHVybiB3cmFwcGVyO1xyXG4gIH0sXHJcblxyXG4gIHBsYWNlaG9sZGVyVGFnQnVpbGRlcjogZnVuY3Rpb24gKGRpc3BsYXlUZXh0KSB7XHJcbiAgICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICAgIHBsYWNlaG9sZGVyLFxyXG4gICAgICAgIHdyYXBwZXI7XHJcblxyXG4gICAgcGxhY2Vob2xkZXIgPSAkKG1lLnBsYWNlaG9sZGVyVGFnKTtcclxuICAgIHBsYWNlaG9sZGVyLmh0bWwoZGlzcGxheVRleHQpO1xyXG5cclxuICAgIHdyYXBwZXIgPSAkKG1lLnRhZ1dyYXBwZXIpLmFwcGVuZChwbGFjZWhvbGRlcikuYXBwZW5kKG1lLnp3bmopO1xyXG4gICAgd3JhcHBlclswXS5kYXRhc2V0LnR5cGUgPSAncGxhY2Vob2xkZXInO1xyXG5cclxuICAgIHJldHVybiB3cmFwcGVyO1xyXG4gIH0sXHJcblxyXG4gIGxvY2tlZENvbnRlbnRTdGFydFRhZ0J1aWxkZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgICAgc3RhcnRUYWcsXHJcbiAgICAgICAgd3JhcHBlcjtcclxuXHJcbiAgICBzdGFydFRhZyA9ICQobWUudGFnTG9ja2VkU3RhcnQpO1xyXG4gICAgc3RhcnRUYWcuaHRtbChtZS56d25qKTtcclxuXHJcbiAgICB3cmFwcGVyID0gJChtZS50YWdXcmFwcGVyKS5hcHBlbmQoc3RhcnRUYWcpLmFwcGVuZChtZS56d25qKTtcclxuICAgIHdyYXBwZXJbMF0uZGF0YXNldC50eXBlID0gJ3N0YXJ0LXRhZyc7XHJcblxyXG4gICAgcmV0dXJuIHdyYXBwZXI7XHJcbiAgfSxcclxuXHJcbiAgbG9ja2VkQ29udGVudEVuZFRhZ0J1aWxkZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgICAgZW5kVGFnLFxyXG4gICAgICAgIHdyYXBwZXI7XHJcblxyXG4gICAgZW5kVGFnID0gJChtZS50YWdMb2NrZWRFbmQpO1xyXG4gICAgZW5kVGFnLmh0bWwobWUuenduaik7XHJcblxyXG4gICAgd3JhcHBlciA9ICQobWUudGFnV3JhcHBlcikuYXBwZW5kKGVuZFRhZykuYXBwZW5kKG1lLnp3bmopO1xyXG4gICAgd3JhcHBlclswXS5kYXRhc2V0LnR5cGUgPSAnZW5kLXRhZyc7XHJcblxyXG4gICAgcmV0dXJuIHdyYXBwZXI7XHJcbiAgfSxcclxuXHJcbiAgYnVpbGRTZWdtZW50SW5saW5lQ29udGVudDogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgICBpbmxpbmVDb250ZW50ID0gaChtZS5pbmxpbmVDb250ZW50V3JhcHBlcik7XHJcblxyXG4gICAgaW5saW5lQ29udGVudC5hcHBlbmRDaGlsZChoKG1lLnp3bmopKTtcclxuXHJcbiAgICByZXR1cm4gaW5saW5lQ29udGVudDtcclxuICB9XHJcbn07IiwiLyogRmlsZTogVHJhbnNsYXRpb25PcmlnaW4uanMgKi9cbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXG4vKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSGVscGVycyA9IHJlcXVpcmUoJy4vSGVscGVycycpO1xuXG52YXIgVHJhbnNsYXRpb25PcmlnaW4gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgX19leHRlbmQgPSBIZWxwZXJzLl9leHRlbmQ7XG5cbiAgdmFyIHRyYW5zbGF0aW9uT3JpZ2luID0ge1xuICAgIG1ldGFkYXRhIDogICAgICAgICAgICAgICAgbnVsbCwgLy8gYXJyYXkgb2YgT2JqZWN0cyA9IHtuYW1lIDogU3RyaW5nLCB2YWx1ZSA6IFN0cmluZ31cbiAgICBvcmlnaW5UeXBlIDogICAgICAgICAgICAgIG51bGwsIC8vIFN0cmluZ1xuICAgIG9yaWdpblN5c3RlbTogICAgICAgICAgICAgbnVsbCxcbiAgICBtYXRjaFBlcmNlbnQ6ICAgICAgICAgICAgIDAsICAgIC8vIEludFxuICAgIHRleHRDb250ZXh0TWF0Y2hMZXZlbDogICAgbnVsbCxcbiAgICBvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaDogIG51bGwsXG4gICAgb3JpZ2luQmVmb3JlQWRhcHRhdGlvbjogICBudWxsLCAvLyB7b2JqZWN0IC0gdHJhbnNsYXRpb25PcmlnaW4gdHlwZSBvZiBvYmplY3R9XG4gICAgaXNTdHJ1Y3R1cmVDb250ZXh0TWF0Y2g6ICBmYWxzZSAvLyBib29sZWFuXG4gIH07XG5cbiAgLy8gTm90IHVzZWQ/XG4gIC8vIHZhciBmb3JtYXRPcmlnaW5UeXBlID0ge1xuICAvLyAgICdhbCc6ICAnYXV0by1hbGlnbmVkJyxcbiAgLy8gICAnYXAnOiAgJ2F1dG8tcHJvcGFnYXRlZCcsXG4gIC8vICAgJ2F0JzogICdtdCcsXG4gIC8vICAgJ250JzogICdub3QtdHJhbnNsYXRlZCcsXG4gIC8vICAgJ3NyYyc6ICdzb3VyY2UnLFxuICAvLyAgICd1bic6ICAndW5rbm93bidcbiAgLy8gfTtcblxuICB2YXIgY29uZmlybWF0aW9uTGV2ZWxUZXh0ID0ge1xuICAgICdub3QtdHJhbnNsYXRlZCc6ICAgICAgICdOb3QgVHJhbnNsYXRlZCcsXG4gICAgJ05vdFRyYW5zbGF0ZWQnOiAgICAgICAgJ05vdCBUcmFuc2xhdGVkJyxcbiAgICAnYXBwcm92ZWQtc2lnbi1vZmYnOiAgICAnU2lnbiBPZmYnLFxuICAgICdBcHByb3ZlZFNpZ25PZmYnOiAgICAgICdTaWduIE9mZicsXG4gICAgJ2FwcHJvdmVkLXRyYW5zbGF0aW9uJzogJ1RyYW5zbGF0aW9uIEFwcHJvdmVkJyxcbiAgICAnQXBwcm92ZWRUcmFuc2xhdGlvbic6ICAnVHJhbnNsYXRpb24gQXBwcm92ZWQnLFxuICAgICdkcmFmdCc6ICAgICAgICAgICAgICAgICdEcmFmdCcsXG4gICAgJ0RyYWZ0JzogICAgICAgICAgICAgICAgJ0RyYWZ0JyxcbiAgICAncmVqZWN0ZWQtc2lnbi1vZmYnOiAgICAnU2lnbiBPZmYgUmVqZWN0ZWQnLFxuICAgICdSZWplY3RlZFNpZ25PZmYnOiAgICAgICdTaWduIE9mZiBSZWplY3RlZCcsXG4gICAgJ3JlamVjdGVkLXRyYW5zbGF0aW9uJzogJ1RyYW5zbGF0aW9uIFJlamVjdGVkJyxcbiAgICAnUmVqZWN0ZWRUcmFuc2xhdGlvbic6ICAnVHJhbnNsYXRpb24gUmVqZWN0ZWQnLFxuICAgICd0cmFuc2xhdGVkJzogICAgICAgICAgICdUcmFuc2xhdGVkJyxcbiAgICAnVHJhbnNsYXRlZCc6ICAgICAgICAgICAnVHJhbnNsYXRlZCdcbiAgfTtcblxuICB2YXIgb3JpZ2luVGV4dCA9IHtcbiAgICAnYWwnOiAgJ0F1dG8tYWxpZ25lZCcsXG4gICAgJ2FwJzogICdBdXRvLXByb3BhZ2F0ZWQnLFxuICAgICdhdCc6ICAnQXV0b21hdGVkIFRyYW5zbGF0aW9uJyxcbiAgICAnY20nOiAgJ0NvbnRleHQgTWF0Y2gnLFxuICAgICdlbSc6ICAnRXhhY3QgTWF0Y2gnLFxuICAgICdmbSc6ICAnRnV6enkgTWF0Y2gnLFxuICAgICdpdCc6ICAnSW50ZXJhY3RpdmUnLFxuICAgICdudCc6ICAnTm90IFRyYW5zbGF0ZWQnLFxuICAgICdwbSc6ICAnUGVyZmVjdCBNYXRjaCcsXG4gICAgJ3NyYyc6ICdDb3BpZWQgRnJvbSBTb3VyY2UnLFxuICAgICd0bSc6ICAnVHJhbnNsYXRpb24gTWVtb3J5JyxcbiAgICAndW4nOiAgJ1Vua25vd24nXG4gIH07XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRpb25EZXRhaWxzKHNlZ21lbnREYXRhKSB7XG4gICAgdmFyIGluZm8gPSAnVHJhbnNsYXRpb24gRGV0YWlsczogJyArICdcXHJcXG4nLFxuICAgICAgICBzdGF0dXMgPSBjb25maXJtYXRpb25MZXZlbFRleHRbc2VnbWVudERhdGEuY29uZmlybWF0aW9ubGV2ZWxdIHx8ICdOb3QgVHJhbnNsYXRlZCcsXG4gICAgICAgIHR5cGUgPSBUcmFuc2xhdGlvbk9yaWdpbi5vcmlnaW5UeXBlKHNlZ21lbnREYXRhLnRyYW5zbGF0aW9ub3JpZ2luKTtcblxuICAgIC8vYWRkIGNvbmZpcm1hdGlvbiBsZXZlbCBpbmZvXG4gICAgaW5mbyArPSAnU3RhdHVzOiAnICsgc3RhdHVzICsgJ1xcclxcbic7XG5cbiAgICAvL2FkZCBvcmlnaW4gaW5mb1xuICAgIGluZm8gKz0gJ09yaWdpbjogJyArIG9yaWdpblRleHRbdHlwZV0gKyAnXFxyXFxuJztcblxuICAgIC8vYWRkIG9yaWdpbiBzeXN0ZW1cbiAgICBpZiAodHlwZSAhPT0gJ2l0Jykge1xuICAgICAgaW5mbyArPSAnU3lzdGVtOiAnICsgc2VnbWVudERhdGEudHJhbnNsYXRpb25vcmlnaW4ub3JpZ2luU3lzdGVtICsgJ1xcclxcbic7XG4gICAgfVxuXG4gICAgLy9hZGQgcGVyY2VudCBpbmZvXG4gICAgaW5mbyArPSAnU2NvcmU6ICcgKyBzZWdtZW50RGF0YS50cmFuc2xhdGlvbm9yaWdpbi5tYXRjaFBlcmNlbnQgKyAnJScgKyAnXFxyXFxuJztcblxuICAgIHJldHVybiBpbmZvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmVmb3JlSW50ZXJhY3RpdmVFZGl0aW5nKHRPYmopIHtcbiAgICB2YXIgdE8gPSB0T2JqLm9yaWdpbkJlZm9yZUFkYXB0YXRpb24sXG4gICAgICAgIGluZm8sIHR5cGU7XG5cbiAgICBpZiAoIWlzRGlmZmVyZW50KHRPYmosIHRPKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGluZm8gPSAnQmVmb3JlIEludGVyYWN0aXZlIEVkaXRpbmc6ICcgKyAnXFxyXFxuJztcbiAgICB0eXBlID0gVHJhbnNsYXRpb25PcmlnaW4ub3JpZ2luVHlwZSh0Tyk7XG5cbiAgICAvL2FkZCBvcmlnaW4gaW5mb1xuICAgIGluZm8gKz0gJ09yaWdpbjogJyArIG9yaWdpblRleHRbdHlwZV0gKyAnXFxyXFxuJztcblxuICAgIC8vYWRkIG9yaWdpbiBzeXN0ZW1cbiAgICBpZiAodE8ub3JpZ2luU3lzdGVtKSB7XG4gICAgICBpbmZvICs9ICdTeXN0ZW06ICcgKyB0Ty5vcmlnaW5TeXN0ZW0gKyAnXFxyXFxuJztcbiAgICB9XG5cbiAgICAvL2FkZCBwZXJjZW50IGluZm9cbiAgICBpbmZvICs9ICdTY29yZTogJyArIHRPLm1hdGNoUGVyY2VudCArICclJyArICdcXHJcXG4nO1xuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBmdW5jdGlvbiBpc0RpZmZlcmVudCh0Tywgb3JpZ2luYWxUTykge1xuICAgIGlmICghdE8ub3JpZ2luVHlwZSB8fCAhb3JpZ2luYWxUTyB8fCAhb3JpZ2luYWxUTy5vcmlnaW5UeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRPLm9yaWdpblR5cGUgIT09IG9yaWdpbmFsVE8ub3JpZ2luVHlwZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRPLm1hdGNoUGVyY2VudCAhPT0gb3JpZ2luYWxUTy5tYXRjaFBlcmNlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRPIERPIC0gbm90IGZpbmlzaGVkXG4gICAgLy90ZXh0Q29udGV4dE1hdGNoTGV2ZWwgY29ucGFyZVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGlvbk9yaWdpbjtcbiAgICB9LFxuXG4gICAgb3JpZ2luYWxGb3JtYXQ6IGZ1bmN0aW9uICh0ck9yaWdpbikge1xuICAgICAgdmFyIGNsb25lVHJPcmlnaW4gPSBfX2V4dGVuZCh7fSwgdHJPcmlnaW4pO1xuICAgICAgZGVsZXRlIGNsb25lVHJPcmlnaW4ud2FzQ2hhbmdlZDtcblxuICAgICAgcmV0dXJuIGNsb25lVHJPcmlnaW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsb25lIHwgRHVwbGljYXRlIHRyYW5zbGF0aW9uIE9yaWdpbiBPYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24gKHRyT3JpZ2luKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRhZGF0YSA6ICAgICAgICAgICAgICAgdHJPcmlnaW4ubWV0YWRhdGEsXG4gICAgICAgIG9yaWdpblR5cGU6ICAgICAgICAgICAgICB0ck9yaWdpbi5vcmlnaW5UeXBlLFxuICAgICAgICBvcmlnaW5TeXN0ZW06ICAgICAgICAgICAgdHJPcmlnaW4ub3JpZ2luU3lzdGVtLFxuICAgICAgICBtYXRjaFBlcmNlbnQ6ICAgICAgICAgICAgdHJPcmlnaW4ubWF0Y2hQZXJjZW50LFxuICAgICAgICB0ZXh0Q29udGV4dE1hdGNoTGV2ZWw6ICAgdHJPcmlnaW4udGV4dENvbnRleHRNYXRjaExldmVsLFxuICAgICAgICBvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaDogdHJPcmlnaW4ub3JpZ2luYWxUcmFuc2xhdGlvbkhhc2gsXG4gICAgICAgIG9yaWdpbkJlZm9yZUFkYXB0YXRpb246ICB0ck9yaWdpbi5vcmlnaW5CZWZvcmVBZGFwdGF0aW9uLFxuICAgICAgICBpc1N0cnVjdHVyZUNvbnRleHRNYXRjaDogdHJPcmlnaW4uaXNTdHJ1Y3R1cmVDb250ZXh0TWF0Y2gsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGlvbkluZm86IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAvL3RyYW5zbGF0aW9uIGRldGFpbHNcbiAgICAgIHZhciBkZXRhaWxzID0gdHJhbnNsYXRpb25EZXRhaWxzKGRhdGEpLFxuICAgICAgICAgIG1vcmVEZXRhaWxzO1xuXG4gICAgICAvL2JlZm9yZSBpbnRlcmFjdGl2ZSBlZGl0aW5nIGRldGFpbHNcbiAgICAgIGlmIChkYXRhLnRyYW5zbGF0aW9ub3JpZ2luLm9yaWdpbkJlZm9yZUFkYXB0YXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgbW9yZURldGFpbHMgPSBiZWZvcmVJbnRlcmFjdGl2ZUVkaXRpbmcoZGF0YS50cmFuc2xhdGlvbm9yaWdpbiwgZGF0YS5jb25maXJtYXRpb25sZXZlbCk7XG4gICAgICAgIGRldGFpbHMgKz0gKG1vcmVEZXRhaWxzICE9PSAnJykgPyAnXFxyXFxuJyArIG1vcmVEZXRhaWxzIDogJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH0sXG5cbiAgICBvcmlnaW5UeXBlIDogZnVuY3Rpb24gKHRyYW5zbGF0aW9uT2JqKSB7XG4gICAgICB2YXIgc2hvcnRPcmlnaW5UeXBlID0gJ2l0JztcblxuICAgICAgaWYgKHRyYW5zbGF0aW9uT2JqID09PSB1bmRlZmluZWQgfHwgdHJhbnNsYXRpb25PYmogPT09IFtdIHx8IHRyYW5zbGF0aW9uT2JqID09PSB7fSkge1xuICAgICAgICByZXR1cm4gc2hvcnRPcmlnaW5UeXBlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNsYXRpb25PYmoub3JpZ2luVHlwZSA9PT0gdW5kZWZpbmVkIHx8IHRyYW5zbGF0aW9uT2JqLm9yaWdpblR5cGUgPT09IG51bGwgfHwgdHJhbnNsYXRpb25PYmoub3JpZ2luVHlwZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgICAgICByZXR1cm4gc2hvcnRPcmlnaW5UeXBlO1xuICAgICAgfVxuXG4gICAgICAvLyEhISEhIERvIG5vdCBjaGFuZ2UgaWYgb3JkZXIgISEhISFcbiAgICAgIGlmICh0cmFuc2xhdGlvbk9iai5tYXRjaFBlcmNlbnQgIT09IG51bGwgJiYgdHJhbnNsYXRpb25PYmoubWF0Y2hQZXJjZW50ID09PSAxMDApIHsgICAgICAvL0V4YWN0IE1hdGNoIGNhc2VcbiAgICAgICAgc2hvcnRPcmlnaW5UeXBlID0gJ2VtJztcbiAgICAgIH0gZWxzZSBpZiAodHJhbnNsYXRpb25PYmoubWF0Y2hQZXJjZW50ICE9PSBudWxsICYmIHRyYW5zbGF0aW9uT2JqLm1hdGNoUGVyY2VudCA8IDEwMCkgeyAvL0Z1enp5IE1hdGNoIGNhc2VcbiAgICAgICAgc2hvcnRPcmlnaW5UeXBlID0gJ2ZtJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0cmFuc2xhdGlvbk9iai5vcmlnaW5UeXBlKSB7XG4gICAgICAgIGNhc2UgJ3RtJzogLy9UcmFuc2xhdGlvbiBNZW1vcnkgY2FzZVxuICAgICAgICAgIHNob3J0T3JpZ2luVHlwZSA9ICd0bSc7XG5cbiAgICAgICAgICBpZiAodHJhbnNsYXRpb25PYmoudGV4dENvbnRleHRNYXRjaExldmVsICE9PSBudWxsICYmIHRyYW5zbGF0aW9uT2JqLnRleHRDb250ZXh0TWF0Y2hMZXZlbC50b0xvd2VyQ2FzZSgpID09PSAnc291cmNlYW5kdGFyZ2V0Jykge1xuICAgICAgICAgICAgc2hvcnRPcmlnaW5UeXBlID0gJ2NtJztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZG9jdW1lbnQtbWF0Y2gnOiAvL1BlcmZlY3QgTWF0Y2ggY2FzZVxuICAgICAgICAgIGlmICh0cmFuc2xhdGlvbk9iai50ZXh0Q29udGV4dE1hdGNoTGV2ZWwgIT09IG51bGwgJiYgdHJhbnNsYXRpb25PYmoudGV4dENvbnRleHRNYXRjaExldmVsLnRvTG93ZXJDYXNlKCkgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzaG9ydE9yaWdpblR5cGUgPSAncG0nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtdCc6IC8vQXV0b21hdGVkIFRyYW5zbGF0aW9uIGNhc2VcbiAgICAgICAgICBzaG9ydE9yaWdpblR5cGUgPSAnYXQnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NvdXJjZSc6IC8vU291cmNlIGNhc2VcbiAgICAgICAgICBzaG9ydE9yaWdpblR5cGUgPSAnc3JjJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhdXRvLXByb3BhZ2F0ZWQnOiAvL1NvdXJjZSBjYXNlXG4gICAgICAgICAgc2hvcnRPcmlnaW5UeXBlID0gJ2FwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdub3QtdHJhbnNsYXRlZCc6IC8vTm90IFRyYW5zbGF0ZWQgY2FzZSAhISEhISBOT1QgVFJFQVRFRFxuICAgICAgICAgIHNob3J0T3JpZ2luVHlwZSA9ICdudCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYXV0by1hbGlnbmVkJzogLy9BdXRvLWFsaWduZWQgY2FzZSAhISEhISBOT1QgVFJFQVRFRFxuICAgICAgICAgIHNob3J0T3JpZ2luVHlwZSA9ICdhbCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndW5rbm93bic6IC8vVW5rbm93biBjYXNlICEhISEhIE5PVCBUUkVBVEVEXG4gICAgICAgICAgc2hvcnRPcmlnaW5UeXBlID0gJ3VuJztcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNob3J0T3JpZ2luVHlwZTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zbGF0aW9uT3JpZ2luOyIsIi8qIEZpbGU6IHVlLmpzICovXHJcbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcbi8qIGdsb2JhbHMgJCwgcmVxdWlyZSwgbW9kdWxlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcclxudmFyIERhdGFQcm92aWRlciA9IHJlcXVpcmUoJy4vRGF0YVByb3ZpZGVyJyk7XHJcbnZhciBEb2N1bWVudHMgPSByZXF1aXJlKCcuL0RvY3VtZW50cycpO1xyXG52YXIgTGF5b3V0ID0gcmVxdWlyZSgnLi9MYXlvdXQnKTtcclxudmFyIENvbW1hbmRNYW5hZ2VyID0gcmVxdWlyZSgnLi9Db21tYW5kTWFuYWdlcicpO1xyXG52YXIgU2VnbWVudFN0YXR1c1VwZGF0ZXIgPSByZXF1aXJlKCcuL1NlZ21lbnRTdGF0dXNVcGRhdGVyJyk7XHJcblxyXG5cclxudmFyIEFwcCA9IG1vZHVsZS5leHBvcnRzID0ge307XHJcblxyXG4vLyBSZW5kZXJpbmcgbW9kdWxlXHJcbnZhciBWaWV3UmVuZGVyZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMuJGJvZHkgPSAkKCdib2R5Jyk7XHJcblxyXG4gICAgICBMYXlvdXQuaW5pdCgpO1xyXG4gICAgICBEb2N1bWVudHMuaW5pdCgpO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pKCk7XHJcblxyXG4vLyBEZWZhdWx0IGNvbmZpZ1xyXG5BcHAuY29uZmlnID0gY29uZmlnO1xyXG5cclxuLy8gRGVmYXVsdCBlbnZpcm9ubWVudFxyXG5BcHAuY29uZmlnLmVudmlyb25tZW50ID0gJ2RldmVsb3BtZW50JztcclxuXHJcbi8vIEFwcCBpbml0aWFsaXphdGlvblxyXG5BcHAuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gIC8vIE1lcmdlIGNvbmZpZyBpZiB0aGUgY2FzZVxyXG4gIGlmIChvcHRpb25zLmNvbmZpZyAmJiAodHlwZW9mIG9wdGlvbnMuY29uZmlnID09PSAnb2JqZWN0JykpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbmZpZykge1xyXG4gICAgICBpZiAob3B0aW9ucy5jb25maWcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgIEFwcC5jb25maWdba2V5XSA9IG9wdGlvbnMuY29uZmlnW2tleV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIERhdGFQcm92aWRlci5pbml0KCk7XHJcbiAgVmlld1JlbmRlcmVyLmluaXQoKTtcclxuICBEb2N1bWVudHMub3BlbkRvY3VtZW50KG9wdGlvbnMuZG9jKTtcclxufTtcclxuXHJcbi8vIEV4cG9zZSBjb21tYW5kIG1hbm5hZ2VyIGFzIGFuIGV4dGVybmFsIEFQSVxyXG5BcHAuQ29tbWFuZE1hbmFnZXIgPSBDb21tYW5kTWFuYWdlcjsiLCIvKiBGaWxlOiBFZGl0b3JDb21tYW5kcy5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzIHJlcXVpcmUsIG1vZHVsZSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xyXG5cclxudmFyIGNtZHMgPSB7XHJcbiAgJ3Bhc3RlJzoge1xyXG4gICAgaGFuZGxlOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgdmFyIHRleHQsXHJcbiAgICAgICAgICBySW52YWxpZENoYXJzID0gL1xccj9cXG4vZyxcclxuICAgICAgICAgIGh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksXHJcbiAgICAgICAgICBjbGlwYm9hcmQgPSAoZXYub3JpZ2luYWxFdmVudCB8fCBldikuY2xpcGJvYXJkRGF0YTtcclxuXHJcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICBpZiAoY2xpcGJvYXJkID09PSB1bmRlZmluZWQgfHwgY2xpcGJvYXJkID09PSBudWxsKSB7XHJcbiAgICAgICAgdGV4dCA9IHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQnKSB8fCAnJztcclxuXHJcbiAgICAgICAgaWYgKHRleHQgIT09ICcnKSB7XHJcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJJbnZhbGlkQ2hhcnMsICcgJyk7XHJcbiAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VBdCgwKS5pbnNlcnROb2RlKGh0bWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGV4dCA9IGNsaXBib2FyZC5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgJyc7XHJcblxyXG4gICAgICAgIGlmICh0ZXh0ICE9PSAnJykge1xyXG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShySW52YWxpZENoYXJzLCAnICcpO1xyXG4gICAgICAgICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2luc2VydFRleHQnLCBmYWxzZSwgdGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjbWRzOyIsIi8qIEZpbGU6IGNvbmZpZy5qcyAqL1xuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cbi8qIGdsb2JhbHMgbW9kdWxlICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb25maWcgPSB7XG4gIGZ1bGxNb2RlOiB0cnVlLFxuXG4gIC8vc2V0IHRoZSBzdG9yYWdlIGltcGxlbWVudGF0aW9uIG1vZHVsZVxuICBzdG9yYWdlOiAnU3RvcmFnZUltcGxlbWVudGF0aW9uJyxcblxuICAvL3NldCBkaXNwbGF5IGxpbWl0IG9mIHBhcmFncmFwaCB1bml0c1xuICAvL2RlZmF1bHRMaW1pdDogNTAsXG4gIGRlZmF1bHRMaW1pdDogMTAwMCwgLy90cnlpbmcgdG8gZ2V0IGxvYWQgYWxsIHBhcmFncmFwaHMgaW4gZmlsZVxuXG4gIC8vc2V0IHRoZSBkZWZhdWx0IG9mZnNldCBmcm9tIHdoZXJlIHRvIGdldCBwYXJhZ3JhcGggdW5pdHNcbiAgZGVmYXVsdE9mZnNldDogMCxcblxuICBiYXNlVXJsOiAnaHR0cDovL2NsdWplZGl0b3IwMTo4MDgwL3dzZS9sdWUnLC8vJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9jZScsXG4gIC8vYXBpVXJsOiBVRS5jb25maWcuYmFzZVVybCArICcnLFxuICBhcGlVcmw6ICdodHRwOi8vY2x1amVkaXRvcjAxOjgwODAvd3NlL2x1ZScsXG5cbiAgdGFnRGlzcGxheUNvbnRleHQ6IHtcbiAgICAvLyBEZXRlcm1pbmVzIGhvdyB0aGUgdGFnIHBhaXJzIHdpbGwgYmUgZGlzcGxheWVkXG4gICAgLy9cbiAgICAvLyBPcHRpb25zOlxuICAgIC8vICAgIG5vbmUgICAgLSBObyBUYWcgVGV4dFxuICAgIC8vICAgIHBhcnRpYWwgLSBQYXJ0aWFsIFRhZyBUZXh0XG4gICAgLy8gICAgZnVsbCAgICAtIEZ1bGwgVGFnIFRleHRcbiAgICAvLyAgICBpZCAgICAgIC0gVGFnIElkXG4gICAgLy9cbiAgICAvLyBUaGUgZGVmYXVsdCBkaXNwbGF5IG1vZGUgaXMgUGFydGlhbCBUYWcgVGV4dFxuICAgIHRhZ0Rpc3BsYXlNb2RlOiAncGFydGlhbCcsXG4gICAgc2hvd0Zvcm1hdHRpbmc6IGZhbHNlXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnOyIsIi8qIEZpbGU6IEtleXMuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyBtb2R1bGUgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBGVU5DVElPTl9LRVlTID0ge1xyXG4gIC8vIEtleWJvYXJkIGtleXNcclxuICBrZXlUYWI6IDksXHJcbiAga2V5QmFja3NwYWNlOiA4LFxyXG4gIGtleUVudGVyOiAxMyxcclxuICBrZXlTcGFjZTogMzIsXHJcblxyXG4gIGtleVBhZ2VVcDogMzMsXHJcbiAga2V5UGFnZURvd246IDM0LFxyXG4gIGtleUVuZDogMzUsXHJcbiAga2V5SG9tZTogMzYsXHJcbiAga2V5SW5zZXJ0OiA0NSxcclxuICBrZXlEZWxldGU6IDQ2LFxyXG5cclxuICBrZXlMZWZ0QXJyb3c6IDM3LFxyXG4gIGtleVVwQXJyb3c6IDM4LFxyXG4gIGtleVJpZ2h0QXJyb3c6IDM5LFxyXG4gIGtleURvd25BcnJvdzogNDAsXHJcblxyXG4gIGtleVNoaWZ0OiAxNixcclxuICBrZXlDdHJsOiAxNyxcclxuICBrZXlBbHQ6IDE4LFxyXG4gIGtleUVzYzogMjcsXHJcblxyXG4gIGtleUNhcHNMb2NrOiAyMCxcclxuICBrZXlOdW1Mb2NrOiAxNDQsXHJcbiAga2V5U2Nyb2xsTG9jazogMTQ1LFxyXG5cclxuICBrZXlGMTogMTEyLFxyXG4gIGtleUYyOiAxMTMsXHJcbiAga2V5RjM6IDExNCxcclxuICBrZXlGNDogMTE1LFxyXG4gIGtleUY1OiAxMTYsXHJcbiAga2V5RjY6IDExNyxcclxuICBrZXlGNzogMTE4LFxyXG4gIGtleUY4OiAxMTksXHJcbiAga2V5Rjk6IDEyMCxcclxuICBrZXlGMTA6IDEyMSxcclxuICBrZXlGMTE6IDEyMixcclxuICBrZXlGMTI6IDEyM1xyXG59O1xyXG5cclxudmFyIElHTk9SRURfS0VZUyA9IFtcclxuICBGVU5DVElPTl9LRVlTLmtleUxlZnRBcnJvdyxcclxuICBGVU5DVElPTl9LRVlTLmtleVVwQXJyb3csXHJcbiAgRlVOQ1RJT05fS0VZUy5rZXlSaWdodEFycm93LFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5RG93bkFycm93LFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5Q2Fwc0xvY2ssXHJcbiAgRlVOQ1RJT05fS0VZUy5rZXlTY3JvbGxMb2NrLFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5TnVtTG9jayxcclxuICBGVU5DVElPTl9LRVlTLmtleUFsdCxcclxuICBGVU5DVElPTl9LRVlTLmtleUN0cmwsXHJcbiAgRlVOQ1RJT05fS0VZUy5rZXlTaGlmdCxcclxuICBGVU5DVElPTl9LRVlTLmtleVBhZ2VVcCxcclxuICBGVU5DVElPTl9LRVlTLmtleVBhZ2VEb3duLFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5SG9tZSxcclxuICBGVU5DVElPTl9LRVlTLmtleUVuZCxcclxuICBGVU5DVElPTl9LRVlTLmtleUVudGVyLFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5RXNjLFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5SW5zZXJ0LFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5RjEsXHJcbiAgRlVOQ1RJT05fS0VZUy5rZXlGMixcclxuICBGVU5DVElPTl9LRVlTLmtleUYzLFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5RjQsXHJcbiAgRlVOQ1RJT05fS0VZUy5rZXlGNSxcclxuICBGVU5DVElPTl9LRVlTLmtleUY2LFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5RjcsXHJcbiAgRlVOQ1RJT05fS0VZUy5rZXlGOCxcclxuICBGVU5DVElPTl9LRVlTLmtleUY5LFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5RjEwLFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5RjExLFxyXG4gIEZVTkNUSU9OX0tFWVMua2V5RjEyXHJcbl07XHJcblxyXG52YXIgQUxMT1dFRF9JTl9MT0NLRURfQ09OVEVOVCA9IHtcclxuICAzMzogJ1BhZ2VVcCcsXHJcbiAgMzQ6ICdQYWdlRG93bicsXHJcbiAgMzU6ICdFbmQnLFxyXG4gIDM2OiAnSG9tZScsXHJcbiAgMzc6ICdMZWZ0JyxcclxuICAzODogJ1VwJyxcclxuICAzOTogJ1JpZ2h0JyxcclxuICA0MDogJ0Rvd24nLFxyXG5cclxuICAxMTI6ICdGMScsXHJcbiAgMTEzOiAnRjInLFxyXG4gIDExNDogJ0YzJyxcclxuICAxMTU6ICdGNCcsXHJcbiAgMTE2OiAnRjUnLFxyXG4gIDExNzogJ0Y2JyxcclxuICAxMTg6ICdGNycsXHJcbiAgMTE5OiAnRjgnLFxyXG4gIDEyMDogJ0Y5JyxcclxuICAxMjE6ICdGMTAnLFxyXG4gIDEyMjogJ0YxMScsXHJcbiAgMTIzOiAnRjEyJ1xyXG59O1xyXG5cclxudmFyIEtleXMgPSB7XHJcbiAgZnVuY3Rpb25LZXlzOiBGVU5DVElPTl9LRVlTLFxyXG4gIGlnbm9yZWRLZXlzOiBJR05PUkVEX0tFWVMsXHJcbiAgYWxsb3dlZEtleXNJbkxvY2tlZENvbnRlbnQ6IEFMTE9XRURfSU5fTE9DS0VEX0NPTlRFTlRcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gS2V5czsiLCIvKiBGaWxlOiBTZWdtZW50VW5kZXJDdXJyZW50U2VsZWN0aW9uLmpzICovXHJcbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcbi8qIGdsb2JhbHMgXyAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbmZ1bmN0aW9uIFNlZ21lbnRVbmRlckN1cnJlbnRTZWxlY3Rpb24oKSB7XHJcbiAgdmFyIHNlZ21lbnROdW1iZXIsXHJcbiAgICAgIHNlZ21lbnRFbDtcclxuXHJcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xyXG4gIHZhciBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xyXG5cclxuXHJcbiAgaWYgKGZvY3VzTm9kZSA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2VnbWVudE51bWJlcjogdW5kZWZpbmVkLFxyXG4gICAgICBzZWdtZW50RWw6IHVuZGVmaW5lZFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGlmIChmb2N1c05vZGUuZGF0YXNldCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBzZWdtZW50TnVtYmVyID0gZm9jdXNOb2RlLmRhdGFzZXQuc2VnbWVudE51bWJlcjtcclxuICAgIHNlZ21lbnRFbCA9IGZvY3VzTm9kZTtcclxuICB9XHJcblxyXG4gIGlmIChzZWdtZW50TnVtYmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgIHZhciBwYXJlbnRTZWdtZW50ID0gJChzZWxlY3Rpb24uZm9jdXNOb2RlKS5wYXJlbnRzKCcudWUtc2VnbWVudCcpO1xyXG4gICAgdmFyIHBhcmVudFNlZ21lbnRFbCA9IF8ocGFyZW50U2VnbWVudCkuZmlyc3QoKTtcclxuXHJcbiAgICBzZWdtZW50TnVtYmVyID0gcGFyZW50U2VnbWVudEVsLmRhdGFzZXQuc2VnbWVudE51bWJlcjtcclxuICAgIHNlZ21lbnRFbCA9IHBhcmVudFNlZ21lbnRFbDtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzZWdtZW50TnVtYmVyOiBzZWdtZW50TnVtYmVyLFxyXG4gICAgc2VnbWVudEVsOiBzZWdtZW50RWxcclxuICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNlZ21lbnRVbmRlckN1cnJlbnRTZWxlY3Rpb247IiwiLyogRmlsZTogU2hpZnRFbnRlckhhbmRsZXIuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyByZXF1aXJlLCBtb2R1bGUgKi9cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgSGVscGVycyA9IHJlcXVpcmUoJy4uL0hlbHBlcnMnKTtcclxudmFyIFNlZ21lbnRzV2F0Y2hlciA9IHJlcXVpcmUoJy4uL1NlZ21lbnRzV2F0Y2hlcicpO1xyXG52YXIgS2V5Ym9hcmRCaW5kaW5ncyA9IHJlcXVpcmUoJy4uL0tleWJvYXJkQmluZGluZ3MnKTtcclxudmFyIEtleXMgPSByZXF1aXJlKCcuL0tleXMnKTtcclxudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NlbGVjdGlvbicpO1xyXG5cclxudmFyIFNoaWZ0RW50ZXJIYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgaXNTaGlmdEtleVByZXNzZWQgPSBldi5zaGlmdEtleSxcclxuICAgICAgaXNFbnRlclByZXNzZWQgPSBldi5rZXlDb2RlID09PSBLZXlzLmZ1bmN0aW9uS2V5cy5rZXlFbnRlcixcclxuICAgICAgaXNIYW5kbGluZ1JlcXVpcmVkID0gaXNTaGlmdEtleVByZXNzZWQgJiYgaXNFbnRlclByZXNzZWQsXHJcbiAgICAgIHNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCgpLFxyXG4gICAgICBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xyXG5cclxuICBpZiAoIWlzSGFuZGxpbmdSZXF1aXJlZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgbWUuZm9jdXMgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoZm9jdXNOb2RlKTtcclxuICBtZS5icmVha0xpbmVzT3V0c2lkZU9mVGV4dCA9IFtdO1xyXG5cclxuICBtZS5tb3ZlRm9jdXNUb1RhcmdldFNlZ21lbnQoKTtcclxuICBtZS5tb3ZlQnJlYWtMaW5lc1RvVGV4dENvbnRhaW5lcnMoKTtcclxuXHJcbiAgU2VnbWVudHNXYXRjaGVyLnJlc2l6ZShtZS5zZWdtZW50TnVtYmVyKTtcclxufTtcclxuXHJcbnZhciBwcm90byA9IFNoaWZ0RW50ZXJIYW5kbGVyLnByb3RvdHlwZTtcclxuXHJcbnByb3RvLm1vdmVGb2N1c1RvVGFyZ2V0U2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBmb2N1cyA9IG1lLmZvY3VzO1xyXG5cclxuICB3aGlsZSAoIWZvY3VzLmlzTnVsbCgpICYmICFmb2N1cy5pc1NlZ21lbnQoKSkge1xyXG4gICAgZm9jdXMgPSBmb2N1cy5wYXJlbnQoKTtcclxuICB9XHJcblxyXG4gIG1lLnNlZ21lbnROdW1iZXIgPSBmb2N1cy5zZWdtZW50TnVtYmVyKCk7XHJcbiAgbWUuZm9jdXMgPSBmb2N1cztcclxufTtcclxuXHJcbnByb3RvLm1vdmVCcmVha0xpbmVzVG9UZXh0Q29udGFpbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBub2RlV2Fsa2VyID0gbWUuZm9jdXM7XHJcblxyXG4gIG1lLm1vdmVUaHJvdWdoKG5vZGVXYWxrZXIpO1xyXG59O1xyXG5cclxucHJvdG8ubW92ZVRocm91Z2ggPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgbm9kZVdhbGtlciA9IGNvbnRhaW5lcjtcclxuXHJcbiAgbm9kZVdhbGtlciA9IG5vZGVXYWxrZXIuZmlyc3RDaGlsZCgpO1xyXG4gIHdoaWxlICghbm9kZVdhbGtlci5pc051bGwoKSkge1xyXG5cclxuICAgIGlmIChub2RlV2Fsa2VyLmlzSW5saW5lQ29udGVudCgpKSB7XHJcbiAgICAgIG1lLmluc2VydEJyZWFrTGluZXNBdFN0YXJ0T2Yobm9kZVdhbGtlcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vZGVXYWxrZXIuaXNFbGVtZW50KCdicicpICYmIG5vZGVXYWxrZXIucGFyZW50KCkuaXNTZWdtZW50KCkpIHtcclxuICAgICAgbWUuYnJlYWtMaW5lc091dHNpZGVPZlRleHQucHVzaChub2RlV2Fsa2VyKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobm9kZVdhbGtlci5pc0VsZW1lbnQoJ2JyJykgJiYgbm9kZVdhbGtlci5wYXJlbnQoKS5pc1RhZygpKSB7XHJcbiAgICAgIG1lLm1vdmVOb2RlQWZ0ZXJUaGVUYWcobm9kZVdhbGtlcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vZGVXYWxrZXIuaXNFbGVtZW50KCkpIHtcclxuICAgICAgbWUubW92ZVRocm91Z2gobm9kZVdhbGtlcik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5vZGVXYWxrZXIuaXNUYWcoKSkge1xyXG4gICAgICBtZS5leHBvcnROZXdMaW5lcyhub2RlV2Fsa2VyKTtcclxuICAgICAgbWUuaW5zZXJ0QnJlYWtMaW5lc0FmdGVyKG5vZGVXYWxrZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub2RlV2Fsa2VyLmlzVGV4dCgpKSB7XHJcbiAgICAgIG1lLmNvbnZlcnRDYXJyaWFnZVJldHVyblRvQnJlYWsobm9kZVdhbGtlcik7XHJcbiAgICB9XHJcblxyXG4gICAgbm9kZVdhbGtlciA9IG5vZGVXYWxrZXIubmV4dCgpO1xyXG4gIH1cclxufTtcclxuXHJcbnByb3RvLmluc2VydEJyZWFrTGluZXNBdFN0YXJ0T2YgPSBmdW5jdGlvbiAobm9kZVdhbGtlcikge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGJyZWFrTGluZUVsZW1lbnQsXHJcbiAgICAgIGZpcnN0Q2hpbGQgPSBub2RlV2Fsa2VyLmZpcnN0Q2hpbGQoKTtcclxuXHJcbiAgd2hpbGUgKG1lLmJyZWFrTGluZXNPdXRzaWRlT2ZUZXh0Lmxlbmd0aCA+IDApIHtcclxuICAgIGJyZWFrTGluZUVsZW1lbnQgPSBtZS5icmVha0xpbmVzT3V0c2lkZU9mVGV4dC5wb3AoKTtcclxuXHJcbiAgICBpZiAoIWZpcnN0Q2hpbGQuaXNOdWxsKCkpIHtcclxuICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUoYnJlYWtMaW5lRWxlbWVudCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBub2RlV2Fsa2VyLmFwcGVuZChicmVha0xpbmVFbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5wcm90by5pbnNlcnRCcmVha0xpbmVzQWZ0ZXIgPSBmdW5jdGlvbiAobm9kZVdhbGtlcikge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGJyZWFrTGluZUVsZW1lbnQ7XHJcblxyXG4gIHdoaWxlIChtZS5icmVha0xpbmVzT3V0c2lkZU9mVGV4dC5sZW5ndGggPiAwKSB7XHJcbiAgICBicmVha0xpbmVFbGVtZW50ID0gbWUuYnJlYWtMaW5lc091dHNpZGVPZlRleHQucG9wKCk7XHJcblxyXG4gICAgbm9kZVdhbGtlci5pbnNlcnRBZnRlcihicmVha0xpbmVFbGVtZW50KTtcclxuICB9XHJcbn07XHJcblxyXG5wcm90by5leHBvcnROZXdMaW5lcyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICB0ZXh0Q29udGVudCxcclxuICAgICAgbmV3TGluZXNDb3VudCxcclxuICAgICAgaSxcclxuICAgICAgYnI7XHJcblxyXG4gIGlmIChjb250YWluZXIuaXNOdWxsKCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHRleHRDb250ZW50ID0gY29udGFpbmVyLnRleHRDb250ZW50KCk7XHJcbiAgbmV3TGluZXNDb3VudCA9IHRleHRDb250ZW50LnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgbmV3TGluZXNDb3VudDsgaSsrKSB7XHJcbiAgICBiciA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGJyPicpO1xyXG4gICAgbWUuYnJlYWtMaW5lc091dHNpZGVPZlRleHQucHVzaChicik7XHJcbiAgfVxyXG5cclxuICBpZiAobmV3TGluZXNDb3VudCA+IDApIHtcclxuICAgIG1lLmNsZWFuQ2FycmlhZ2VSZXR1cm5Gcm9tKGNvbnRhaW5lcik7XHJcbiAgfVxyXG59O1xyXG5cclxucHJvdG8uY2xlYW5DYXJyaWFnZVJldHVybkZyb20gPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcbiAgdmFyIHByb2Nlc3NpbmdRdWV1ZSA9IFtjb250YWluZXJdLFxyXG4gICAgICBub2RlVmFsdWU7XHJcblxyXG4gIHdoaWxlIChwcm9jZXNzaW5nUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgdmFyIGl0ZW0gPSBwcm9jZXNzaW5nUXVldWUucG9wKCk7XHJcblxyXG4gICAgaWYgKGl0ZW0uaXNUZXh0Tm9kZSgpKSB7XHJcbiAgICAgIG5vZGVWYWx1ZSA9IGl0ZW0uZWwubm9kZVZhbHVlO1xyXG4gICAgICBub2RlVmFsdWUgPSBub2RlVmFsdWUucmVwbGFjZSgnXFxuJywgJycpO1xyXG4gICAgICBpdGVtLmVsLm5vZGVWYWx1ZSA9IG5vZGVWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWl0ZW0ubmV4dCgpLmlzTnVsbCgpKSB7XHJcbiAgICAgIHByb2Nlc3NpbmdRdWV1ZS5wdXNoKGl0ZW0ubmV4dCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWl0ZW0uZmlyc3RDaGlsZCgpLmlzTnVsbCgpKSB7XHJcbiAgICAgIHByb2Nlc3NpbmdRdWV1ZS5wdXNoKGl0ZW0uZmlyc3RDaGlsZCgpKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG5wcm90by5jb252ZXJ0Q2FycmlhZ2VSZXR1cm5Ub0JyZWFrID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xyXG4gIHZhciBub2RlV2Fsa2VyID0gY29udGFpbmVyLmZpcnN0Q2hpbGQoKTtcclxuICB2YXIgbm9kZVZhbHVlO1xyXG4gIHZhciBicmVha05vZGU7XHJcbiAgdmFyIGNhcnJpYWdlUmV0dXJuTm9kZTtcclxuICB2YXIgcGFyZW50Tm9kZTtcclxuXHJcbiAgd2hpbGUgKCFub2RlV2Fsa2VyLmlzTnVsbCgpKSB7XHJcbiAgICBpZiAobm9kZVdhbGtlci5pc1RleHROb2RlKCkpIHtcclxuICAgICAgbm9kZVZhbHVlID0gbm9kZVdhbGtlci5lbC5ub2RlVmFsdWU7XHJcbiAgICAgIGNhcnJpYWdlUmV0dXJuTm9kZSA9IG5vZGVXYWxrZXIuZWw7XHJcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlV2Fsa2VyLmVsLnBhcmVudE5vZGU7XHJcblxyXG4gICAgICBpZiAobm9kZVZhbHVlID09PSAnXFxuJykge1xyXG4gICAgICAgIGJyZWFrTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XHJcbiAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYnJlYWtOb2RlLCBjYXJyaWFnZVJldHVybk5vZGUpO1xyXG4gICAgICAgIG5vZGVXYWxrZXIuZWwgPSBicmVha05vZGU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBub2RlV2Fsa2VyID0gbm9kZVdhbGtlci5uZXh0KCk7XHJcbiAgfVxyXG5cclxufTtcclxuXHJcbnByb3RvLm1vdmVOb2RlQWZ0ZXJUaGVUYWcgPSBmdW5jdGlvbiAoYnJOb2RlKSB7XHJcbiAgdmFyIHRhZyA9IGJyTm9kZS5wYXJlbnQoKTtcclxuXHJcbiAgdGFnLmluc2VydEFmdGVyKGJyTm9kZSk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFNoaWZ0RW50ZXJIYW5kbGVyOyIsIi8qIEZpbGU6IFJpYmJvbk1lbnVDb21tYW5kcy5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzICQsIHJlcXVpcmUsIG1vZHVsZSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xyXG52YXIgTWVkaWF0b3IgPSByZXF1aXJlKCcuLi9NZWRpYXRvcicpO1xyXG52YXIgQ29tbWFuZE1hbmFnZXIgPSByZXF1aXJlKCcuLi9Db21tYW5kTWFuYWdlcicpO1xyXG5cclxudmFyIFN0b3JhZ2UgPSByZXF1aXJlKCcuLi9TdG9yYWdlJyk7XHJcbnZhciBEYXRhUHJvdmlkZXIgPSByZXF1aXJlKCcuLi9EYXRhUHJvdmlkZXInKTtcclxudmFyIFBhcmFncmFwaHMgPSByZXF1aXJlKCcuLi9QYXJhZ3JhcGhzJyk7XHJcblxyXG52YXIgY21kciA9IG5ldyBDb21tYW5kTWFuYWdlcigpO1xyXG5cclxudmFyIFJpYmJvbk1lbnVDb21tYW5kcyA9IHtcclxuICBzZXR1cExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgICB2YXIgY29tbWFuZHMgPSB7XHJcbiAgICAgICd0b2dnbGVfZm9ybWF0dGluZ190YWdzJzoge1xyXG4gICAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgIHZhciB0YXJnZXQgPSAkKGVsZW0pLFxyXG4gICAgICAgICAgICAgIGhpZGRlbiA9IHRhcmdldC5kYXRhKCdoaWRkZW4nKSxcclxuICAgICAgICAgICAgICBzaG93Rm9ybWF0dGluZyA9IGNvbmZpZy50YWdEaXNwbGF5Q29udGV4dC5zaG93Rm9ybWF0dGluZztcclxuXHJcbiAgICAgICAgICBpZiAoc2hvd0Zvcm1hdHRpbmcpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmRhdGEoJ2hpZGRlbicsIGZhbHNlKS5hZGRDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBoaWRkZW4gPT09ICd1bmRlZmluZWQnIHx8IGhpZGRlbikge1xyXG4gICAgICAgICAgICB0YXJnZXQuZGF0YSgnaGlkZGVuJywgZmFsc2UpLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAgICAgbWUuc2hvd1RhZ3MoKTtcclxuICAgICAgICAgICAgY29uZmlnLnRhZ0Rpc3BsYXlDb250ZXh0LnNob3dGb3JtYXR0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5kYXRhKCdoaWRkZW4nLCB0cnVlKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgIG1lLmhpZGVUYWdzKCk7XHJcbiAgICAgICAgICAgIGNvbmZpZy50YWdEaXNwbGF5Q29udGV4dC5zaG93Rm9ybWF0dGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgICdkaXNwbGF5X3RhZ19ub25lJzoge1xyXG4gICAgICAgIGhhbmRsZTogZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgIG1lLnRvZ2dsZUdyb3VwZWRCdXR0b25zKGVsZW0pO1xyXG4gICAgICAgICAgbWUuc3dpdGNoRGlzcGxheU1vZGUoJ25vbmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAnZGlzcGxheV90YWdfcGFydGlhbCc6IHtcclxuICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICBtZS50b2dnbGVHcm91cGVkQnV0dG9ucyhlbGVtKTtcclxuICAgICAgICAgIG1lLnN3aXRjaERpc3BsYXlNb2RlKCdwYXJ0aWFsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG5cclxuICAgICAgJ2Rpc3BsYXlfdGFnX2Z1bGwnOiB7XHJcbiAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICAgICAgbWUudG9nZ2xlR3JvdXBlZEJ1dHRvbnMoZWxlbSk7XHJcbiAgICAgICAgICBtZS5zd2l0Y2hEaXNwbGF5TW9kZSgnZnVsbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuXHJcbiAgICAgICdkaXNwbGF5X3RhZ19pZCc6IHtcclxuICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uIChlbGVtKSB7XHJcbiAgICAgICAgICBtZS50b2dnbGVHcm91cGVkQnV0dG9ucyhlbGVtKTtcclxuICAgICAgICAgIG1lLnN3aXRjaERpc3BsYXlNb2RlKCdpZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBtZS4kcmliYm9uLm9uKCdjbGljaycsICdbZGF0YS1hY3Rpb25dJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgIHZhciBlbGVtID0gZXYuY3VycmVudFRhcmdldDtcclxuXHJcbiAgICAgIE1lZGlhdG9yLnB1Ymxpc2goJ3JpYmJvbjpjb21tYW5kJywge1xyXG4gICAgICAgIGVsZW06IGVsZW0sXHJcbiAgICAgICAgYWN0aW9uOiBlbGVtLmRhdGFzZXQuYWN0aW9uIHx8IG51bGxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTZXQgdXAgY29tbWFuZHMgZm9yIHRoZSByaWJib24gbWVudVxyXG4gICAgY21kci5hZGRDb21tYW5kcyhjb21tYW5kcyk7XHJcblxyXG4gIH0sXHJcblxyXG4gIGhpZGVUYWdzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICAgIGVsZW1zID0gbWUuJGVkaXRvci5maW5kKCdbZGF0YS1jYW4taGlkZT1cInRydWVcIl0nKTtcclxuXHJcbiAgICBlbGVtcy5hZGRDbGFzcygnaGlkZScpLmRhdGEoJ2Nhbi1kZWxldGUnLCBmYWxzZSk7XHJcbiAgfSxcclxuXHJcbiAgc2hvd1RhZ3M6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgICAgZWxlbXMgPSBtZS4kZWRpdG9yLmZpbmQoJ1tkYXRhLWNhbi1oaWRlPVwidHJ1ZVwiXScpO1xyXG5cclxuICAgIGVsZW1zLnJlbW92ZUNsYXNzKCdoaWRlJykuZGF0YSgnY2FuLWRlbGV0ZScsIHRydWUpO1xyXG4gIH0sXHJcblxyXG5cclxuICAvKipcclxuICAgKiBUb2dnbGUgZ3JvdXBlZCBidXR0b25zIHN0YXRlXHJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IHRhcmdldCAtIENsaWNrZWQgZWxlbWVudFxyXG4gICAqXHJcbiAgICogVE9ETzogaXQgZGVwZW5kcyBoZWF2aWx5IG9uIGpRdWVyeSwgdGhpcyBzaG91bGQgYmUgY2hhbmdlZFxyXG4gICAqL1xyXG4gIHRvZ2dsZUdyb3VwZWRCdXR0b25zOiBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICB2YXIgdGFyZ2V0RWwgPSAkKHRhcmdldCk7XHJcblxyXG4gICAgaWYgKCF0YXJnZXQuZGF0YXNldC5hY3Rpb25Hcm91cCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0RWwucGFyZW50cygnLm5hdi1yaWJib24tcGFuZWwnKVxyXG4gICAgICAgICAgICAuZmluZCgnW2RhdGEtYWN0aW9uLWdyb3VwXScpXHJcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcblxyXG4gICAgdGFyZ2V0RWwuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gIH0sXHJcblxyXG5cclxuICAvKipcclxuICAgKiBTd2l0Y2ggdGhlIGRpc3BsYXkgbW9kZSBmb3IgZm9ybWF0dGluZyB0YWdzXHJcbiAgICogQHBhcmFtICB7U3RyaW5nfSBtb2RlXHJcbiAgICovXHJcbiAgc3dpdGNoRGlzcGxheU1vZGU6IGZ1bmN0aW9uIChtb2RlKSB7XHJcbiAgICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICAgIHN0b3JhZ2UgPSBTdG9yYWdlW2NvbmZpZy5zdG9yYWdlXS5nZXRJbnN0YW5jZSgpLFxyXG4gICAgICAgIGN1cnJlbnREb2MgPSBEYXRhUHJvdmlkZXIuZ2V0Q3VycmVudERvY3VtZW50KCk7XHJcblxyXG4gICAgY29uZmlnLnRhZ0Rpc3BsYXlDb250ZXh0LnRhZ0Rpc3BsYXlNb2RlID0gbW9kZTtcclxuXHJcbiAgICBtZS4kZWRpdG9yLmh0bWwoJycpO1xyXG4gICAgUGFyYWdyYXBocy5fcmVuZGVyUGFyYWdyYXBocyhzdG9yYWdlLnBhcmFncmFwaHMsIGN1cnJlbnREb2MpO1xyXG4gIH0sXHJcblxyXG5cclxuICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICAgIG1lLiRlZGl0b3IgPSAkKCcjZWRpdG9yLWJvZHknKTtcclxuICAgIG1lLiRyaWJib24gPSAkKCcubmF2LXJpYmJvbicpO1xyXG5cclxuICAgIG1lLnNldHVwTGlzdGVuZXJzKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gU3Vic2NyaWJlIHRvIHJpYmJvbiBjb21tYW5kcyBhbmQgZXhlY3V0ZSB0aGVtXHJcbk1lZGlhdG9yLnN1YnNjcmliZSgncmliYm9uOmNvbW1hbmQnLCBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIGNtZHIuZXhlY3V0ZShkYXRhLmFjdGlvbiwgZGF0YS5lbGVtKTtcclxufSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFJpYmJvbk1lbnVDb21tYW5kczsiLCIvKiBGaWxlOiBDdHJsQ2xpY2tIYW5kbGVyLmpzICovXHJcbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcbi8qIGdsb2JhbHMgXyAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi4vSGVscGVycycpO1xyXG52YXIgZGF0YVByb3ZpZGVyID0gcmVxdWlyZSgnLi4vRGF0YVByb3ZpZGVyJyk7XHJcblxyXG52YXIgTWVkaWF0b3IgPSByZXF1aXJlKCcuLi9NZWRpYXRvcicpO1xyXG52YXIgU2VnbWVudCA9IHJlcXVpcmUoJy4uL1NlZ21lbnQnKTtcclxudmFyIEtleWJvYXJkID0gcmVxdWlyZSgnLi4vS2V5Ym9hcmQnKTtcclxudmFyIE5vZGVXYWxrZXIgPSByZXF1aXJlKCcuLi9zZWxlY3Rpb24nKS5Ob2RlV2Fsa2VyO1xyXG52YXIgVGFnUGFpciA9IHJlcXVpcmUoJy4uL3NlbGVjdGlvbicpLlRhZ1BhaXI7XHJcbnZhciBTZWxlY3Rpb25Db250ZXh0ID0gcmVxdWlyZSgnLi4vc2VsZWN0aW9uJykuU2VsZWN0aW9uQ29udGV4dDtcclxuXHJcbmZ1bmN0aW9uIE1vdXNlQ3RybENsaWNrSGFuZGxlcigpIHtcclxufVxyXG52YXIgcHJvdG8gPSBNb3VzZUN0cmxDbGlja0hhbmRsZXIucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIEluc2VydHMgdGFncyBvciB3cmFwcyBzZWxlY3Rpb25zIHdpdGggdGFnc1xyXG4gKiBAcGFyYW0gIHtPYmplY3R9IGV2IGpRdWVyeSBldmVudCBvYmplY3RcclxuICovXHJcbnByb3RvLmhhbmRsZSA9IGZ1bmN0aW9uIChldikge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHRhZywgdGFncyxcclxuICAgICAgcGxhY2Vob2xkZXJDbG9uZSxcclxuICAgICAgY3VycmVudFNlZ21lbnQgPSBLZXlib2FyZC5TZWdtZW50VW5kZXJDdXJyZW50U2VsZWN0aW9uKCksXHJcbiAgICAgIGN1cnJlbnRTZWdtZW50TnVtYmVyID0gY3VycmVudFNlZ21lbnQuc2VnbWVudE51bWJlcixcclxuICAgICAgaXNTZWxlY3Rpb25JblNvdXJjZSwgaXNDb2xsYXBzZWQsXHJcbiAgICAgIHNlZ21lbnQsIHNlZ21lbnREYXRhLFxyXG4gICAgICBzdGFydENvbnRhaW5lcjtcclxuXHJcbiAgdGFnID0gbmV3IE5vZGVXYWxrZXIoZXYuY3VycmVudFRhcmdldCk7XHJcbiAgdGFncyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuXHJcbiAgaWYgKCF0YWcuaXNUYWcoKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRhZy5pc1BsYWNlaG9sZGVyKCkpIHtcclxuICAgIHBsYWNlaG9sZGVyQ2xvbmUgPSB0YWcuZWwuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgbWUuY2xlYXJBY3RpdmVDbGFzcyhwbGFjZWhvbGRlckNsb25lKTtcclxuICAgIG1lLmRpc2FibGVUYWdDb3B5KHBsYWNlaG9sZGVyQ2xvbmUpO1xyXG4gICAgdGFncy5hcHBlbmRDaGlsZChwbGFjZWhvbGRlckNsb25lKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGFnID0gbmV3IFRhZ1BhaXIodGFnKTtcclxuICAgIHRhZ3MgPSB0YWcuY2xvbmVTdHJ1Y3R1cmUoKTtcclxuICAgIG1lLmNsZWFyQWN0aXZlQ2xhc3ModGFncy5jaGlsZE5vZGVzWzBdKTtcclxuICAgIG1lLmNsZWFyQWN0aXZlQ2xhc3ModGFncy5jaGlsZE5vZGVzWzJdKTtcclxuXHJcbiAgICBtZS5kaXNhYmxlVGFnQ29weSh0YWdzLmNoaWxkTm9kZXNbMF0pO1xyXG4gICAgbWUuZGlzYWJsZVRhZ0NvcHkodGFncy5jaGlsZE5vZGVzWzJdKTtcclxuICB9XHJcblxyXG4gIG1lLnJhbmdlID0gbmV3IFNlbGVjdGlvbkNvbnRleHQoKTtcclxuICBzdGFydENvbnRhaW5lciA9IG1lLnJhbmdlLnN0YXJ0Q29udGFpbmVyO1xyXG5cclxuICBpZiAoIXN0YXJ0Q29udGFpbmVyKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpc0NvbGxhcHNlZCA9IG1lLnJhbmdlLmlzQ29sbGFwc2VkKCk7XHJcblxyXG4gIGlzU2VsZWN0aW9uSW5Tb3VyY2UgPSBoZWxwZXJzLmhhc1BhcmVudChzdGFydENvbnRhaW5lciwgJ3VlLXNvdXJjZScpO1xyXG5cclxuICAvLyBDaGVjayBpZiBzZWxlY3Rpb24gaXMgaW4gc291cmNlXHJcbiAgaWYgKGlzU2VsZWN0aW9uSW5Tb3VyY2UpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIElmIENUUkwga2V5IGlzIHByZXNzZWQgYW5kIGNsaWNrZWRcclxuICAvLyBtb3VzZSBidXR0b24gaXMgbGVmdCBidXR0b24sIGluc2VydCB0YWdcclxuICBpZiAoZXYuY3RybEtleSAmJiBldi53aGljaCA9PT0gMSkge1xyXG4gICAgaWYgKGlzQ29sbGFwc2VkKSB7XHJcbiAgICAgIG1lLmluc2VydFRhZ0F0Q3Vyc29yKHRhZ3MpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWUuaW5zZXJ0VGFnT3ZlclNlbGVjdGlvbih0YWdzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGFuZ2Ugc2VnbWVudCBzdGF0dXMgdG8gZHJhZnQgYWZ0ZXIgdGFnIGluc2VydGlvblxyXG4gICAgc2VnbWVudERhdGEgPSBkYXRhUHJvdmlkZXIuZ2V0U2VnbWVudEJ5U2VnbWVudE51bWJlcihjdXJyZW50U2VnbWVudE51bWJlcik7XHJcbiAgICBzZWdtZW50ID0gbmV3IFNlZ21lbnQoc2VnbWVudERhdGEpO1xyXG4gICAgc2VnbWVudC5jaGFuZ2VUb0RyYWZ0KCk7XHJcblxyXG4gICAgLy8gUHVibGlzaCBzZWdtZW50IHN0YXR1cyBoYXMgY2hhbmdlZFxyXG4gICAgTWVkaWF0b3IucHVibGlzaCgnc2VnbWVudDpjb25maXJtYXRpb25MZXZlbENoYW5nZWQnLCBzZWdtZW50RGF0YSk7XHJcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH1cclxufTtcclxuXHJcbnByb3RvLmNsZWFyQWN0aXZlQ2xhc3MgPSBmdW5jdGlvbiAodGFnV3JhcHBlcikge1xyXG4gIHZhciB0YWcgPSB0YWdXcmFwcGVyLmZpcnN0Q2hpbGQ7XHJcbiAgdGFnLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xyXG59O1xyXG5cclxucHJvdG8uZGlzYWJsZVRhZ0NvcHkgPSBmdW5jdGlvbiAodGFnV3JhcHBlcikge1xyXG4gIHRhZ1dyYXBwZXIuZGF0YXNldC50YWdDb3B5ID0gZmFsc2U7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5zZXJ0cyB0aGUgY2xpY2tlZCB0YWcgYXQgdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXHJcbiAqIEBwYXJhbSAge0RvY3VtZW50RnJhZ21lbnR9ICB0YWdzXHJcbiAqL1xyXG5wcm90by5pbnNlcnRUYWdBdEN1cnNvciA9IGZ1bmN0aW9uICh0YWdzKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgaHRtbCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcclxuICAgICAgcmFuZ2UgPSBtZS5yYW5nZSxcclxuICAgICAgaW5zZXJ0ZWROb2RlID0gdGFncy5maXJzdENoaWxkLFxyXG4gICAgICBmb2N1c05vZGUgPSBpbnNlcnRlZE5vZGUubGFzdENoaWxkOy8vIEkgZXhwZWN0IHRoZSBpbnZpc2libGUgY2hhciB0byBiZSBoZXJlLlxyXG5cclxuICBodG1sLmFwcGVuZENoaWxkKHRhZ3MpO1xyXG5cclxuICByYW5nZS5pbnNlcnROb2RlKGh0bWwpO1xyXG4gIG1lLnNldEN1cnNvckF0KGZvY3VzTm9kZSk7XHJcbn07XHJcblxyXG5wcm90by5zZXRDdXJzb3JBdCA9IGZ1bmN0aW9uIChmb2N1c05vZGUpe1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHJhbmdlID0gbWUucmFuZ2U7XHJcblxyXG4gIGlmKGZvY3VzTm9kZSA9PT0gbnVsbCB8fCBmb2N1c05vZGUgPT09IHVuZGVmaW5lZCl7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBfLmRlbGF5KGZ1bmN0aW9uICgpIHtcclxuICAgIHJhbmdlLmNoYW5nZVJhbmdlKGZ1bmN0aW9uKG5ld1JhbmdlKXtcclxuICAgICAgdmFyIHNlbGVjdGlvbk9mZnNldCA9IDE7XHJcbiAgICAgIG5ld1JhbmdlLnNldFN0YXJ0KGZvY3VzTm9kZSwgc2VsZWN0aW9uT2Zmc2V0KTtcclxuICAgICAgbmV3UmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgc2VsZWN0aW9uT2Zmc2V0KTtcclxuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JhcHMgc2VsZWN0aW9uIGFuZCBpbnNlcnRzIGl0IGF0IHRoZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxyXG4gKiBAcGFyYW0gIHtEb2N1bWVudEZyYWdtZW50fSAgdGFnc1xyXG4gKi9cclxucHJvdG8uaW5zZXJ0VGFnT3ZlclNlbGVjdGlvbiA9IGZ1bmN0aW9uICh0YWdzKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgaHRtbCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcclxuICAgICAgcmFuZ2UgPSBtZS5yYW5nZSxcclxuICAgICAgZG9jdW1lbnRGcmFnbWVudCxcclxuICAgICAgaW5saW5lQ29udGVudDtcclxuXHJcbiAgZG9jdW1lbnRGcmFnbWVudCA9IHJhbmdlLmNsb25lQ29udGVudHMoKTtcclxuXHJcbiAgaHRtbC5hcHBlbmRDaGlsZCh0YWdzKTtcclxuXHJcbiAgaW5saW5lQ29udGVudCA9IGh0bWwucXVlcnlTZWxlY3RvcignLnVlLWlubGluZS1jb250ZW50Jyk7XHJcbiAgaWYgKGlubGluZUNvbnRlbnQgIT09IG51bGwpIHtcclxuICAgIGlubGluZUNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnRGcmFnbWVudCk7XHJcbiAgfVxyXG5cclxuICByYW5nZS5kZWxldGVDb250ZW50cygpO1xyXG4gIHJhbmdlLmluc2VydE5vZGUoaHRtbCk7XHJcbiAgbWUuc2VsZWN0Q29udGVudChpbmxpbmVDb250ZW50KTtcclxufTtcclxuXHJcbnByb3RvLnNlbGVjdENvbnRlbnQgPSBmdW5jdGlvbiAoaW5saW5lQ29udGVudCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHJhbmdlID0gbWUucmFuZ2U7XHJcblxyXG4gIGlmKGlubGluZUNvbnRlbnQgPT09IHVuZGVmaW5lZCB8fCBpbmxpbmVDb250ZW50ID09PSBudWxsKXtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHJhbmdlLmNoYW5nZVJhbmdlKGZ1bmN0aW9uIChyYW5nZSkge1xyXG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGlubGluZUNvbnRlbnQpO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0pO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBNb3VzZUN0cmxDbGlja0hhbmRsZXI7IiwiLyogRmlsZTogQ3RybEhvdmVySGFuZGxlci5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBNb3VzZUN0cmxIb3ZlckhhbmRsZXIoKSB7XHJcbn1cclxuXHJcbnZhciBwcm90byA9IE1vdXNlQ3RybEhvdmVySGFuZGxlci5wcm90b3R5cGU7XHJcblxyXG5wcm90by5tb3VzZU92ZXIgPSBmdW5jdGlvbiAoZXYpIHtcclxuICBpZiAoIWV2LmN0cmxLZXkgfHwgZXYudHlwZSAhPT0gJ21vdXNlb3ZlcicpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgJChldi5jdXJyZW50VGFyZ2V0KS5jaGlsZHJlbigpLmFkZENsYXNzKCdhY3RpdmUnKTtcclxufTtcclxuXHJcbnByb3RvLm1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICBpZiAoZXYudHlwZSAhPT0gJ21vdXNlbGVhdmUnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gICQoZXYuY3VycmVudFRhcmdldCkuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VDdHJsSG92ZXJIYW5kbGVyOyIsIi8qIEZpbGU6IFN0eWxlc01hcC5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzIG1vZHVsZSAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVXNlZCB0byBtYXAgZGlmZmVyZW50IHJlcHJlc2V0YXRpb25zXHJcbi8vIG9mIGEgdHJ1ZS9mYWxzZSBzdHJpbmdzXHJcbnZhciBib29sZWFuTWFwID0ge1xyXG4gICdGQUxTRSc6IGZhbHNlLFxyXG4gICdGYWxzZSc6IGZhbHNlLFxyXG4gICdmYWxzZSc6IGZhbHNlLFxyXG4gICdUUlVFJzogdHJ1ZSxcclxuICAnVHJ1ZSc6IHRydWUsXHJcbiAgJ3RydWUnOiB0cnVlXHJcbn07XHJcblxyXG4vLyBNYXAgdGV4dCBwb3NpdGlvbiBuYW1lcyB0byBtdWx0aXBsZSBDU1MgcHJvcGVydGllcyxcclxuLy8gYmVjYXVzZSAnc3VwZXInIGFuZCAnc3ViJyB2YWx1ZXMgb2YgJ3ZlcnRpY2FsLWFsaWduJyBwcm9wZXJ0eSBhcmUgbm90IGVub3VnaFxyXG52YXIgdGV4dFBvc2l0aW9uTWFwID0ge1xyXG4gICdTdXBlcnNjcmlwdCc6IHtcclxuICAgICdmb250LXNpemUnOiAnMC44ZW0nLFxyXG4gICAgJ3ZlcnRpY2FsLWFsaWduJzogJzAuNmVtJ1xyXG4gIH0sXHJcbiAgJ1N1YnNjcmlwdCc6IHtcclxuICAgICdmb250LXNpemUnOiAnMC44ZW0nLFxyXG4gICAgJ3ZlcnRpY2FsLWFsaWduJzogJy0wLjNlbSdcclxuICB9LFxyXG4gICdOb3JtYWwnOiB7XHJcbiAgICAnZm9udC1zaXplJzogJ2luaGVyaXQnLFxyXG4gICAgJ3ZlcnRpY2FsLWFsaWduJzogJ2luaGVyaXQnXHJcbiAgfVxyXG59O1xyXG5cclxudmFyIFN0eWxlc01hcCA9IHtcclxuICAndGV4dGNvbG9yJzogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgdmFsdWVzID0gdmFsdWUuc3BsaXQoJywnKSxcclxuICAgICAgICByZ2JSZWdleHAgPSAvKF5cXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKikkL2ksXHJcbiAgICAgICAgcmdiVGVzdCwgcmdiVGV4dDtcclxuXHJcbiAgICAvLyBJbiBjYXNlIFRleHRDb2xvciBmb3JtYXQgaXMgJ1wiVGV4dENvbG9yXCI6IFwiMCwgMTEyLCA0OCwgMTYwXCInXHJcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgdmFsdWVzLnNoaWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgXCJUZXh0Q29sb3JcIjpcIlRyYW5zcGFyZW50XCJcclxuICAgIC8vIGl0IGhhcHBlbnMgd2hlbiB3aGl0ZSB0ZXh0IGhhcyBiYWNrZ3JvdW5kIGNvbG9yIGluIGEgTVMgV29yZCBkb2N1bWVudFxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyYW5zcGFyZW50Jykge1xyXG4gICAgICB2YWx1ZSA9ICdyZ2IoMjU1LCAyNTUsIDI1NSknO1xyXG4gICAgfVxyXG5cclxuICAgIHJnYlRleHQgPSB2YWx1ZXMudG9TdHJpbmcoKTtcclxuICAgIHJnYlRlc3QgPSByZ2JUZXh0Lm1hdGNoKHJnYlJlZ2V4cCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ2NvbG9yJzogcmdiVGVzdCA/ICdyZ2IoJyArIHJnYlRleHQgKyAnKScgOiB2YWx1ZS50b0xvd2VyQ2FzZSgpXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gICdmb250c2l6ZSc6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIHN0ciA9IHZhbHVlLm1hdGNoKC9cXHMqKFxcZHsxLDN9KXB4Lyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgJ2ZvbnQtc2l6ZSc6IHN0ciA/IHZhbHVlIDogdmFsdWUgKyAncHgnXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gICdib2xkJzogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnZm9udC13ZWlnaHQnOiB2YWx1ZSA/ICdib2xkJyA6ICdub3JtYWwnXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gICdpdGFsaWMnOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICdmb250LXN0eWxlJzogdmFsdWUgPyAnaXRhbGljJyA6ICdub25lJ1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAnZm9udG5hbWUnOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICdmb250LWZhbWlseSc6IHZhbHVlXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gICd1bmRlcmxpbmUnOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICd0ZXh0LWRlY29yYXRpb24nOiBib29sZWFuTWFwW3ZhbHVlXSA/ICd1bmRlcmxpbmUnIDogJ25vbmUnXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gICdzdHJpa2V0aHJvdWdoJzogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAndGV4dC1kZWNvcmF0aW9uJzogYm9vbGVhbk1hcFt2YWx1ZV0gPyAnbGluZS10aHJvdWdoJyA6ICdub25lJ1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAndGV4dHBvc2l0aW9uJzogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGV4dFBvc2l0aW9uTWFwW3ZhbHVlXTtcclxuICB9LFxyXG5cclxuICAnYmFja2dyb3VuZGNvbG9yJzogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB2YXIgdmFsdWVzID0gdmFsdWUuc3BsaXQoJywnKSxcclxuICAgICAgICByZ2JSZWdleHAgPSAvKF5cXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKikkL2ksXHJcbiAgICAgICAgcmdiVGVzdCwgcmdiVGV4dDtcclxuXHJcbiAgICAvLyBJbiBjYXNlIFRleHRDb2xvciBmb3JtYXQgaXMgJ1wiVGV4dENvbG9yXCI6IFwiMCwgMTEyLCA0OCwgMTYwXCInXHJcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgdmFsdWVzLnNoaWZ0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmdiVGV4dCA9IHZhbHVlcy50b1N0cmluZygpO1xyXG4gICAgcmdiVGVzdCA9IHJnYlRleHQubWF0Y2gocmdiUmVnZXhwKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHJnYlRlc3QgPyAncmdiKCcgKyByZ2JUZXh0ICsgJyknIDogdmFsdWUudG9Mb3dlckNhc2UoKVxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAnc2hhZG93JzogZnVuY3Rpb24gKCkge30sXHJcbiAgJ3JzdHlsZSc6IGZ1bmN0aW9uICgpIHt9LFxyXG4gICd3MTQ6cHJzdGRhc2gnOiBmdW5jdGlvbiAoKSB7fSxcclxuICAndzE0OnJlZmxlY3Rpb24nOiBmdW5jdGlvbiAoKSB7fSxcclxuICAndzE0Omdsb3cnOiBmdW5jdGlvbiAoKSB7fSxcclxuICAnZm9udHRoZW1lJzogZnVuY3Rpb24gKCkge30sXHJcbiAgJ3cxNDpwcm9wczNkJzogZnVuY3Rpb24gKCkge31cclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU3R5bGVzTWFwOyIsIi8qIEZpbGU6IFRhZ0NvbnRlbnRCdWlsZGVyLmpzICovXHJcbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcbi8qIGdsb2JhbHMgcmVxdWlyZSwgbW9kdWxlICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgc3RyYXRlZ2llcyA9IHtcclxuICBub25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg4MjA0KTtcclxuICB9LFxyXG5cclxuICBpZDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiBkYXRhLnRhZ1BhaXJEZWZpbml0aW9uSWQgfHwgZGF0YS5wbGFjZWhvbGRlclRhZ0RlZmluaXRpb25JZDtcclxuICB9LFxyXG5cclxuICBwYXJ0aWFsOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RhZ1BhaXInKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGFnU3RhcnQ6IGRhdGEuc3RhcnRUYWdEaXNwbGF5VGV4dCxcclxuICAgICAgICB0YWdFbmQ6IGRhdGEuZW5kVGFnRGlzcGxheVRleHRcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF0YS5kaXNwbGF5VGV4dDtcclxuICB9LFxyXG5cclxuICBmdWxsOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEudHlwZSA9PT0gJ3RhZ1BhaXInKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdGFnU3RhcnQ6IGRhdGEuc3RhcnRUYWdDb250ZW50LFxyXG4gICAgICAgIHRhZ0VuZDogZGF0YS5lbmRUYWdDb250ZW50XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRhdGEudGFnQ29udGVudDtcclxuICB9XHJcbn07XHJcblxyXG52YXIgVGFnQ29udGVudEJ1aWxkZXIgPSBmdW5jdGlvbiAoc3RyYXRlZ3kpIHtcclxuICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ2llc1tzdHJhdGVneV07XHJcbn07XHJcblxyXG5UYWdDb250ZW50QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gIHJldHVybiB0aGlzLnN0cmF0ZWd5KGRhdGEpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUYWdDb250ZW50QnVpbGRlcjsiLCIvKiBGaWxlOiBOb2RlV2Fsa2VyLmpzICovXHJcbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcbi8qIGdsb2JhbHMgJCwgbW9kdWxlLCByZXF1aXJlICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBUbXBsID0gcmVxdWlyZSgnLi4vVG1wbCcpO1xyXG5cclxudmFyIE5vZGVXYWxrZXIgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIG1lLmVsID0gbm9kZTtcclxuICBtZS5yZXR1cm5Ob2RlID0gbnVsbDtcclxufTtcclxuXHJcbnZhciBwcm90byA9IE5vZGVXYWxrZXIucHJvdG90eXBlO1xyXG5cclxucHJvdG8udGFnSWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgZWwgPSBtZS5lbDtcclxuXHJcbiAgaWYgKG1lLmlzTnVsbCgpIHx8IG1lLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWwuZGF0YXNldC5pZDtcclxufTtcclxuXHJcbnByb3RvLmlzU2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBpZiAobWUuaXNOdWxsKCkgfHwgbWUuaXNUZXh0Tm9kZSgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWUuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd1ZS1zZWdtZW50Jyk7XHJcbn07XHJcblxyXG5wcm90by5pc0lubGluZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgaWYgKG1lLmlzTnVsbCgpIHx8IG1lLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lLmVsLmNsYXNzTGlzdC5jb250YWlucygndWUtaW5saW5lLWNvbnRlbnQnKTtcclxufTtcclxuXHJcbnByb3RvLmlzVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBpZiAobWUuaXNOdWxsKCkgfHwgbWUuaXNUZXh0Tm9kZSgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWUuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd1ZS10ZXh0Jyk7XHJcbn07XHJcblxyXG5wcm90by5pc1RleHROb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIGlmIChtZS5pc051bGwoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lLmVsLm5vZGVUeXBlID09PSAzO1xyXG59O1xyXG5cclxucHJvdG8uaXNUYWdQYWlyQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIGlmIChtZS5pc051bGwoKSB8fCBtZS5pc1RleHROb2RlKCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHJldHVybiBtZS5lbC5jbGFzc0xpc3QuY29udGFpbnMoJ3VlLXRhZ3BhaXItY29udGVudCcpO1xyXG59O1xyXG5cclxucHJvdG8uaXNUYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgaWYgKG1lLmlzTnVsbCgpIHx8IG1lLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lLmVsLmNsYXNzTGlzdC5jb250YWlucygndWUtdGFnLXdyYXBwZXInKTtcclxufTtcclxuXHJcbnByb3RvLmlzU3RhcnRUYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgaWYgKG1lLmlzTnVsbCgpIHx8IG1lLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lLmVsLmRhdGFzZXQudHlwZSA9PT0gJ3N0YXJ0LXRhZyc7XHJcbn07XHJcblxyXG5wcm90by5pc0VuZFRhZyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBpZiAobWUuaXNOdWxsKCkgfHwgbWUuaXNUZXh0Tm9kZSgpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWUuZWwuZGF0YXNldC50eXBlID09PSAnZW5kLXRhZyc7XHJcbn07XHJcblxyXG5wcm90by5pc1BsYWNlaG9sZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIGlmIChtZS5pc051bGwoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lLmVsLmRhdGFzZXQudHlwZSA9PT0gJ3BsYWNlaG9sZGVyJztcclxufTtcclxuXHJcbnByb3RvLmNhbkhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgaWYgKG1lLmlzTnVsbCgpIHx8IG1lLmlzVGV4dE5vZGUoKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lLmVsLmRhdGFzZXQuY2FuSGlkZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb29wIG92ZXIgcGFyZW50cyBhbmQgcmV0dXJuIHRydWUgaWYgaXNMb2tlZCBwcm9wZXJ0eSBpcyBzZXRcclxuICogQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgb3IgcGFyZW50IGlzIGxvY2tlZFxyXG4gKi9cclxucHJvdG8uaXNMb2NrZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgbm9kZSA9IG1lLmVsLFxyXG4gICAgICBpc0xvY2tlZCA9IChub2RlLmhhc093blByb3BlcnR5KCdkYXRhc2V0JykgJiYgbm9kZS5kYXRhc2V0LmlzTG9ja2VkKSA/IG5vZGUuZGF0YXNldC5pc0xvY2tlZCA6IGZhbHNlO1xyXG5cclxuICB3aGlsZSAoIWlzTG9ja2VkICYmIG5vZGUubm9kZVR5cGUgIT09IDkpIHtcclxuICAgIGlzTG9ja2VkID0gKG5vZGUuaGFzT3duUHJvcGVydHkoJ2RhdGFzZXQnKSAmJiBub2RlLmRhdGFzZXQuaXNMb2NrZWQpID8gbm9kZS5kYXRhc2V0LmlzTG9ja2VkIDogZmFsc2U7XHJcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlzTG9ja2VkO1xyXG59O1xyXG5cclxucHJvdG8uaXNXcmFwcGVyRm9yID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsO1xyXG5cclxuICByZXR1cm4gZWwgPT09IG5vZGU7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBjdXJzb3IgaXMgaW4gYW4gZW1wdHkgc2VnbWVudFxyXG4gKiB0aGF0IGNvbnRhaW5zIG9ubHkgWmVybyBXaWR0aCBOb24tSm9pbmVyIGNoYXJcclxuICpcclxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBpdCdzIGFuIGVtcHR5IHNlZ21lbnRcclxuICovXHJcbnByb3RvLmlzSW52aXNpYmxlQ2hhciA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsLFxyXG4gICAgICB0bXBsID0gVG1wbCxcclxuICAgICAgdGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudCxcclxuICAgICAgaXNJbnZpc2libGVDaGFyO1xyXG5cclxuICBpc0ludmlzaWJsZUNoYXIgPSB0ZXh0Q29udGVudC5sZW5ndGggPT09IDEgJiZcclxuICAgIHRleHRDb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IHRtcGwuemVyb1dpZHRoTm9uSm9pbmVyQ2hhckNvZGU7XHJcblxyXG4gIHJldHVybiBpc0ludmlzaWJsZUNoYXI7XHJcbn07XHJcblxyXG5cclxucHJvdG8uaXNFbGVtZW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsLFxyXG4gICAgICBpc0VsZW1lbnRUeXBlID0gbWUuZWwubm9kZVR5cGUgPT09IDEsXHJcbiAgICAgIGNoZWNrTmFtZSA9IG5hbWUgIT09IHVuZGVmaW5lZCAmJiBuYW1lICE9PSBudWxsLFxyXG4gICAgICByZXN1bHQ7XHJcblxyXG4gIHJlc3VsdCA9IGlzRWxlbWVudFR5cGU7XHJcbiAgaWYgKGNoZWNrTmFtZSkge1xyXG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmIGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWU7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxucHJvdG8uaXNOdWxsID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIHJldHVybiBtZS5lbCA9PT0gbnVsbCB8fCBtZS5lbCA9PT0gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxucHJvdG8uaGFzQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgY2hpbGROb2RlcyA9IG1lLmVsLmNoaWxkTm9kZXM7XHJcblxyXG4gIHJldHVybiBjaGlsZE5vZGVzLmxlbmd0aCAhPT0gMDtcclxufTtcclxuXHJcbnByb3RvLmVxdWFscyA9IGZ1bmN0aW9uIChub2RlV2Fsa2VyKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgaWYgKG1lLmlzTnVsbCgpICYmIG5vZGVXYWxrZXIuaXNOdWxsKCkpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1lLmVsID09PSBub2RlV2Fsa2VyLmVsO1xyXG59O1xyXG5cclxucHJvdG8udGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgZWwgPSBtZS5lbDtcclxuXHJcbiAgcmV0dXJuIGVsLnRleHRDb250ZW50O1xyXG59O1xyXG5cclxucHJvdG8ucGFyZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHJldHVybk5vZGUgPSBtZS5lbCxcclxuICAgICAgd2Fsa2VyO1xyXG5cclxuICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcihtZS5lbC5wYXJlbnROb2RlKTtcclxuICB3YWxrZXIucmV0dXJuTm9kZSA9IHJldHVybk5vZGU7XHJcblxyXG4gIHJldHVybiB3YWxrZXI7XHJcbn07XHJcblxyXG5wcm90by5yZXR1cm5Ub1ByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHJldHVybk5vZGUgPSBtZS5lbCxcclxuICAgICAgd2Fsa2VyO1xyXG5cclxuICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcihtZS5yZXR1cm5Ob2RlKTtcclxuICB3YWxrZXIucmV0dXJuTm9kZSA9IHJldHVybk5vZGU7XHJcblxyXG4gIHJldHVybiB3YWxrZXI7XHJcbn07XHJcblxyXG5wcm90by5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIHJldHVybk5vZGUgPSBtZS5lbCxcclxuICAgICAgd2Fsa2VyO1xyXG5cclxuICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcihtZS5lbC5uZXh0U2libGluZyk7XHJcbiAgd2Fsa2VyLnJldHVybk5vZGUgPSByZXR1cm5Ob2RlO1xyXG5cclxuICByZXR1cm4gd2Fsa2VyO1xyXG59O1xyXG5cclxucHJvdG8ucHJldiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICByZXR1cm5Ob2RlID0gbWUuZWwsXHJcbiAgICAgIHdhbGtlcjtcclxuXHJcbiAgd2Fsa2VyID0gbmV3IE5vZGVXYWxrZXIobWUuZWwucHJldmlvdXNTaWJsaW5nKTtcclxuICB3YWxrZXIucmV0dXJuTm9kZSA9IHJldHVybk5vZGU7XHJcblxyXG4gIHJldHVybiB3YWxrZXI7XHJcbn07XHJcblxyXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgcGFyZW50ID0gbWUuZWwucGFyZW50Tm9kZTtcclxuICBwYXJlbnQucmVtb3ZlQ2hpbGQobWUuZWwpO1xyXG59O1xyXG5cclxucHJvdG8uZmlyc3RDaGlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsLFxyXG4gICAgICBmaXJzdENoaWxkID0gbWUuZWwuZmlyc3RDaGlsZCxcclxuICAgICAgd2Fsa2VyO1xyXG5cclxuICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcihmaXJzdENoaWxkKTtcclxuICB3YWxrZXIucmV0dXJuTm9kZSA9IGVsO1xyXG5cclxuICByZXR1cm4gd2Fsa2VyO1xyXG59O1xyXG5cclxucHJvdG8ubGFzdENoaWxkID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGVsID0gbWUuZWwsXHJcbiAgICAgIGxhc3RDaGlsZCA9IG1lLmVsLmxhc3RDaGlsZCxcclxuICAgICAgd2Fsa2VyO1xyXG5cclxuICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcihsYXN0Q2hpbGQpO1xyXG4gIHdhbGtlci5yZXR1cm5Ob2RlID0gZWw7XHJcblxyXG4gIHJldHVybiB3YWxrZXI7XHJcbn07XHJcblxyXG5wcm90by5yZXBsYWNlV2l0aElubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICAkZWwgPSAkKG1lLmVsKTtcclxuXHJcbiAgJGVsLnJlcGxhY2VXaXRoKCRlbC5jaGlsZHJlbigpKTtcclxuXHJcbiAgbWUuZWwgPSBudWxsO1xyXG59O1xyXG5cclxucHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsLFxyXG4gICAgICBwYXJlbnQgPSBlbC5wYXJlbnROb2RlLFxyXG4gICAgICBub2RlRWw7XHJcblxyXG4gIGlmIChub2RlIGluc3RhbmNlb2YgTm9kZVdhbGtlcikge1xyXG4gICAgbm9kZUVsID0gbm9kZS5lbDtcclxuICB9IGVsc2Uge1xyXG4gICAgbm9kZUVsID0gbm9kZTtcclxuICB9XHJcblxyXG4gIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZUVsLCBlbCk7XHJcbn07XHJcblxyXG5wcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgZWwgPSBtZS5lbCxcclxuICAgICAgcGFyZW50ID0gZWwucGFyZW50Tm9kZSxcclxuICAgICAgbmV4dFNpYmxpbmcgPSBlbC5uZXh0U2libGluZyxcclxuICAgICAgbm9kZUVsO1xyXG5cclxuICBpZiAobm9kZSBpbnN0YW5jZW9mIE5vZGVXYWxrZXIpIHtcclxuICAgIG5vZGVFbCA9IG5vZGUuZWw7XHJcbiAgfSBlbHNlIHtcclxuICAgIG5vZGVFbCA9IG5vZGU7XHJcbiAgfVxyXG5cclxuICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGVFbCwgbmV4dFNpYmxpbmcpO1xyXG59O1xyXG5cclxucHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsLFxyXG4gICAgICBub2RlRWw7XHJcblxyXG4gIGlmIChub2RlIGluc3RhbmNlb2YgTm9kZVdhbGtlcikge1xyXG4gICAgbm9kZUVsID0gbm9kZS5lbDtcclxuICB9IGVsc2Uge1xyXG4gICAgbm9kZUVsID0gbm9kZTtcclxuICB9XHJcblxyXG4gIGVsLmFwcGVuZENoaWxkKG5vZGVFbCk7XHJcbn07XHJcblxyXG5wcm90by5wcmVwZW5kID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsLFxyXG4gICAgICBub2RlRWw7XHJcblxyXG4gIGlmIChub2RlIGluc3RhbmNlb2YgTm9kZVdhbGtlcikge1xyXG4gICAgbm9kZUVsID0gbm9kZS5lbDtcclxuICB9IGVsc2Uge1xyXG4gICAgbm9kZUVsID0gbm9kZTtcclxuICB9XHJcblxyXG4gIGVsLmluc2VydEJlZm9yZShub2RlRWwsIGVsLmZpcnN0Q2hpbGQpO1xyXG59O1xyXG5cclxucHJvdG8uc2VnbWVudE51bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsO1xyXG5cclxuICByZXR1cm4gZWwuZGF0YXNldC5zZWdtZW50TnVtYmVyO1xyXG59O1xyXG5cclxucHJvdG8uc2V0Q2FuQ29weSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGVsID0gbWUuZWw7XHJcbiAgZWwuZGF0YXNldC5jYW5Db3B5ID0gdmFsdWU7XHJcbn07XHJcblxyXG5wcm90by5jYW5Db3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGVsID0gbWUuZWw7XHJcbiAgcmV0dXJuIGVsLmRhdGFzZXQuY2FuQ29weTtcclxufTtcclxuXHJcbnByb3RvLmhhc0NsYXNzID0gZnVuY3Rpb24gKGNzc0NsYXNzKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgZWwgPSBtZS5lbDtcclxuXHJcbiAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhjc3NDbGFzcyk7XHJcbn07XHJcblxyXG5wcm90by5hZGRDbGFzcyA9IGZ1bmN0aW9uIChjc3NDbGFzcykge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGVsID0gbWUuZWw7XHJcblxyXG4gIGVsLmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3MpO1xyXG59O1xyXG5cclxucHJvdG8ucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoY3NzQ2xhc3MpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBlbCA9IG1lLmVsO1xyXG4gIGVsLmNsYXNzTGlzdC5yZW1vdmUoY3NzQ2xhc3MpO1xyXG59O1xyXG5cclxucHJvdG8uZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgd2Fsa2VyID0gbWUuZmlyc3RDaGlsZCgpO1xyXG5cclxuICB3aGlsZSAoIXdhbGtlci5pc051bGwoKSkge1xyXG4gICAgY2FsbGJhY2sod2Fsa2VyKTtcclxuXHJcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dCgpO1xyXG4gIH1cclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlV2Fsa2VyOyIsIi8qIEZpbGU6IFNlbGVjdGlvbkNvbnRleHQuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyByZXF1aXJlLCBtb2R1bGUgKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIFRleHROb2RlVHlwZSA9IDM7XHJcbnZhciBFbGVtZW50Tm9kZVR5cGUgPSAxO1xyXG5cclxudmFyIFNlbGVjdGlvbkNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgbWUuc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgbWUucmFuZ2UgPSBtZS5zZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcclxuXHJcbiAgbWUuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSBtZS5yYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcclxuICBtZS5zdGFydENvbnRhaW5lciA9IG1lLnJhbmdlLnN0YXJ0Q29udGFpbmVyO1xyXG4gIG1lLnN0YXJ0T2Zmc2V0ID0gbWUucmFuZ2Uuc3RhcnRPZmZzZXQ7XHJcbiAgbWUuZW5kQ29udGFpbmVyID0gbWUucmFuZ2UuZW5kQ29udGFpbmVyO1xyXG4gIG1lLmVuZE9mZnNldCA9IG1lLnJhbmdlLmVuZE9mZnNldDtcclxuXHJcbiAgbWUuZm9jdXNOb2RlID0gbWUuc2VsZWN0aW9uLmZvY3VzTm9kZTtcclxuICBtZS5mb2N1c09mZnNldCA9IG1lLnNlbGVjdGlvbi5mb2N1c09mZnNldDtcclxuICBtZS5mb2N1c05vZGVQYXJlbnRzID0gW107XHJcblxyXG4gIG1lLmhhc0ZvY3VzTm9kZVBhcmVudCA9IG1lLmZvY3VzTm9kZSAhPT0gbnVsbCAmJiBtZS5mb2N1c05vZGUucGFyZW50Tm9kZSAhPT0gbnVsbDtcclxuICBpZiAobWUuaGFzRm9jdXNOb2RlUGFyZW50KSB7XHJcbiAgICBtZS5mb2N1c05vZGVQYXJlbnQgPSBtZS5mb2N1c05vZGUucGFyZW50Tm9kZTtcclxuICB9XHJcblxyXG4gIG1lLmlzRm9jdXNUZXh0Tm9kZSA9IG1lLmZvY3VzTm9kZS5ub2RlVHlwZSA9PT0gVGV4dE5vZGVUeXBlO1xyXG4gIG1lLmlzU3RhcnRDb250YWluZXJUZXh0Tm9kZSA9IG1lLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSBUZXh0Tm9kZVR5cGU7XHJcbiAgbWUuaXNFbmRDb250YWluZXJUZXh0Tm9kZSA9IG1lLmVuZENvbnRhaW5lci5ub2RlVHlwZSA9PT0gVGV4dE5vZGVUeXBlO1xyXG59O1xyXG5cclxudmFyIHByb3RvID0gU2VsZWN0aW9uQ29udGV4dC5wcm90b3R5cGU7XHJcblxyXG5wcm90by5pc0NvbGxhcHNlZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG4gIHJldHVybiBtZS5yYW5nZS5jb2xsYXBzZWQ7XHJcbn07XHJcblxyXG5wcm90by5jbG9uZUNvbnRlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcbiAgcmV0dXJuIG1lLnJhbmdlLmNsb25lQ29udGVudHMoKTtcclxufTtcclxuXHJcbnByb3RvLmRlbGV0ZUNvbnRlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIG1lLnJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XHJcbn07XHJcblxyXG5wcm90by5pbnNlcnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBtZS5yYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xyXG59O1xyXG5cclxucHJvdG8uaGFzQ29tbW9uQW5jZXN0b3JDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IG1lLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLFxyXG4gICAgICByZXN1bHQ7XHJcblxyXG4gIGlmIChjb21tb25BbmNlc3RvckNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMyB8fCBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgcmVzdWx0ID0gY29tbW9uQW5jZXN0b3JDb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnByb3RvLmNoYW5nZVJhbmdlID0gZnVuY3Rpb24gKGNoYW5nZUNhbGxiYWNrKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgIHNlbGVjdGlvbiA9IG1lLnNlbGVjdGlvbixcclxuICAgIG5ld1JhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcclxuXHJcbiAgaWYgKCFjaGFuZ2VDYWxsYmFjaykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYoIWNoYW5nZUNhbGxiYWNrKG5ld1JhbmdlKSl7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgc2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0aW9uQ29udGV4dDsiLCIvKiBGaWxlOiBNb3VzZUN0cmxDbGlja0hhbmRsZXJfdGVzdC5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBOb2RlV2Fsa2VyID0gcmVxdWlyZSgnLi9Ob2RlV2Fsa2VyJyk7XHJcblxyXG52YXIgcHJvdG87XHJcbi8qXHJcbiAqIENyZWF0ZXMgYSB0YWcgcGFpciBmb3JtZWQgb2Ygc3RhcnQtdGFnLFxyXG4gKiBlbmQtdGFnLCBpbm5lci1jb250ZW50LlxyXG4gKiBAcGFyYW0ge0hUTUxOb2RlfSBlbCAtIGNhbiBiZSBhbnkgc3RhcnQtdGFnLCBpbmxpbmUtY29udGVudCxcclxuICogb3IgZW5kLXRhZ1xyXG4gKi9cclxuZnVuY3Rpb24gVGFnUGFpcihlbCkge1xyXG4gIGlmIChlbCBpbnN0YW5jZW9mIE5vZGVXYWxrZXIpIHtcclxuICAgIGVsID0gZWwuZWw7XHJcbiAgfVxyXG4gIHRoaXMuZWwgPSBlbDtcclxuICB0aGlzLndhbGtlciA9IG5ldyBOb2RlV2Fsa2VyKGVsKTtcclxuXHJcbiAgdGhpcy52YWxpZCA9ICghdGhpcy53YWxrZXIuaXNQbGFjZWhvbGRlcigpKSAmJiAodGhpcy53YWxrZXIuaXNUYWcoKSB8fCB0aGlzLndhbGtlci5pc1RhZ1BhaXJDb250YWluZXIoKSk7XHJcblxyXG4gIGlmICh0aGlzLndhbGtlci5pc1N0YXJ0VGFnKCkpIHtcclxuICAgIHRoaXMucHJvY2Vzc0Zyb21TdGFydFRhZygpO1xyXG4gIH0gZWxzZSBpZiAodGhpcy53YWxrZXIuaXNUYWdQYWlyQ29udGFpbmVyKCkpIHtcclxuICAgIHRoaXMucHJvY2Vzc0Zyb21UYWdQYWlyQ29udGFpbmVyKCk7XHJcbiAgfSBlbHNlIGlmICh0aGlzLndhbGtlci5pc0VuZFRhZygpKSB7XHJcbiAgICB0aGlzLnByb2Nlc3NGcm9tRW5kVGFnKCk7XHJcbiAgfVxyXG59XHJcbnByb3RvID0gVGFnUGFpci5wcm90b3R5cGU7XHJcbi8qXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxucHJvdG8uaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy52YWxpZDtcclxufTtcclxuXHJcbnByb3RvLnByb2Nlc3NGcm9tU3RhcnRUYWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5zdGFydFRhZ0VsID0gdGhpcy53YWxrZXIuZWw7XHJcbiAgdGhpcy53YWxrZXIgPSB0aGlzLndhbGtlci5uZXh0KCk7XHJcbiAgdGhpcy5pbmxpbmVDb250ZW50RWwgPSB0aGlzLndhbGtlci5lbDtcclxuICB0aGlzLndhbGtlciA9IHRoaXMud2Fsa2VyLm5leHQoKTtcclxuICB0aGlzLmVuZFRhZ0VsID0gdGhpcy53YWxrZXIuZWw7XHJcbn07XHJcblxyXG5wcm90by5wcm9jZXNzRnJvbVRhZ1BhaXJDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy53YWxrZXIgPSB0aGlzLndhbGtlci5wcmV2KCk7XHJcbiAgdGhpcy5wcm9jZXNzRnJvbVN0YXJ0VGFnKCk7XHJcbn07XHJcblxyXG5wcm90by5wcm9jZXNzRnJvbUVuZFRhZyA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLndhbGtlciA9IHRoaXMud2Fsa2VyLnByZXYoKTtcclxuICB0aGlzLnByb2Nlc3NGcm9tVGFnUGFpckNvbnRhaW5lcigpO1xyXG59O1xyXG4vKlxyXG4gKiBjbG9uZXMgdGhlIFRhZyBQYWlyIHN0cnVjdHVyZVxyXG4gKiBAcmV0dXJucyB7RG9jdW1lbnRGcmFnbWVudH0gZG9jdW1lbnRGcmFnbWVudFxyXG4gKi9cclxucHJvdG8uY2xvbmVTdHJ1Y3R1cmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgc3RhcnRUYWdDbG9uZSxcclxuICAgICAgaW5saW5lQ29udGVudENsb25lLFxyXG4gICAgICBlbmRUYWdDbG9uZSxcclxuICAgICAgZG9jdW1lbnRGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuXHJcbiAgc3RhcnRUYWdDbG9uZSA9IG1lLnN0YXJ0VGFnRWwuY2xvbmVOb2RlKHRydWUpO1xyXG4gIGlubGluZUNvbnRlbnRDbG9uZSA9IG1lLmlubGluZUNvbnRlbnRFbC5jbG9uZU5vZGUoZmFsc2UpO1xyXG4gIGVuZFRhZ0Nsb25lID0gbWUuZW5kVGFnRWwuY2xvbmVOb2RlKHRydWUpO1xyXG5cclxuICBkb2N1bWVudEZyYWdtZW50LmFwcGVuZENoaWxkKHN0YXJ0VGFnQ2xvbmUpO1xyXG4gIGRvY3VtZW50RnJhZ21lbnQuYXBwZW5kQ2hpbGQoaW5saW5lQ29udGVudENsb25lKTtcclxuICBkb2N1bWVudEZyYWdtZW50LmFwcGVuZENoaWxkKGVuZFRhZ0Nsb25lKTtcclxuXHJcbiAgcmV0dXJuIGRvY3VtZW50RnJhZ21lbnQ7XHJcbn07XHJcblxyXG5wcm90by50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBbXHJcbiAgICB0aGlzLnN0YXJ0VGFnRWwsXHJcbiAgICB0aGlzLmlubGluZUNvbnRlbnRFbCxcclxuICAgIHRoaXMuZW5kVGFnRWxcclxuICBdO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUYWdQYWlyO1xyXG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCBpZiBicm93c2VyIHN1cHBvcnRzIFR5cGVkIEFycmF5cy4gU3VwcG9ydGVkIGJyb3dzZXJzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssXG4gIC8vIENocm9tZSA3KywgU2FmYXJpIDUuMSssIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhZGRpbmdcbiAgLy8gcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLCB0aGVuIHRoYXQncyB0aGUgc2FtZSBhcyBubyBgVWludDhBcnJheWAgc3VwcG9ydFxuICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy4gVGhpcyBpcyBhbiBpc3N1ZVxuICAvLyBpbiBGaXJlZm94IDQtMjkuIE5vdyBmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJlxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nIC8vIENocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrYXJvdW5kOiBub2RlJ3MgYmFzZTY0IGltcGxlbWVudGF0aW9uIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBzdHJpbmdzXG4gIC8vIHdoaWxlIGJhc2U2NC1qcyBkb2VzIG5vdC5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHN1YmplY3QgPSBzdHJpbmd0cmltKHN1YmplY3QpXG4gICAgd2hpbGUgKHN1YmplY3QubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3QgKyAnPSdcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpIC8vIGFzc3VtZSB0aGF0IG9iamVjdCBpcyBhcnJheS1saWtlXG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSlcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdFtpXVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbicgK1xuICAgICAgJ2xpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHRvdGFsTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBfaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyXG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIF91dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gX2FzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kICE9PSB1bmRlZmluZWQpXG4gICAgPyBOdW1iZXIoZW5kKVxuICAgIDogZW5kID0gc2VsZi5sZW5ndGhcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIF91dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gX2FzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBfYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gX2FzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBfaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpKzFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSksICd2YWx1ZSBpcyBub3QgYSBudW1iZXInKVxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXg7ICAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvZXJjZSAobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aClcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKVxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3NcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBaRVJPICAgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0oKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImQ6XFxcXHhhbXBwXFxcXGh0ZG9jc1xcXFx1bml2ZXJzYWwtZWRpdG9yLXdlYlxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcaW5zZXJ0LW1vZHVsZS1nbG9iYWxzXFxcXG5vZGVfbW9kdWxlc1xcXFxwcm9jZXNzXFxcXGJyb3dzZXIuanNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvY2hhaScpO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxudmFyIHVzZWQgPSBbXVxuICAsIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKiFcbiAqIENoYWkgdmVyc2lvblxuICovXG5cbmV4cG9ydHMudmVyc2lvbiA9ICcxLjkuMSc7XG5cbi8qIVxuICogQXNzZXJ0aW9uIEVycm9yXG4gKi9cblxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IHJlcXVpcmUoJ2Fzc2VydGlvbi1lcnJvcicpO1xuXG4vKiFcbiAqIFV0aWxzIGZvciBwbHVnaW5zIChub3QgZXhwb3J0ZWQpXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL2NoYWkvdXRpbHMnKTtcblxuLyoqXG4gKiAjIC51c2UoZnVuY3Rpb24pXG4gKlxuICogUHJvdmlkZXMgYSB3YXkgdG8gZXh0ZW5kIHRoZSBpbnRlcm5hbHMgb2YgQ2hhaVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAcmV0dXJucyB7dGhpc30gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKGZuKSB7XG4gIGlmICghfnVzZWQuaW5kZXhPZihmbikpIHtcbiAgICBmbih0aGlzLCB1dGlsKTtcbiAgICB1c2VkLnB1c2goZm4pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIENvbmZpZ3VyYXRpb25cbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jaGFpL2NvbmZpZycpO1xuZXhwb3J0cy5jb25maWcgPSBjb25maWc7XG5cbi8qIVxuICogUHJpbWFyeSBgQXNzZXJ0aW9uYCBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXNzZXJ0aW9uID0gcmVxdWlyZSgnLi9jaGFpL2Fzc2VydGlvbicpO1xuZXhwb3J0cy51c2UoYXNzZXJ0aW9uKTtcblxuLyohXG4gKiBDb3JlIEFzc2VydGlvbnNcbiAqL1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJy4vY2hhaS9jb3JlL2Fzc2VydGlvbnMnKTtcbmV4cG9ydHMudXNlKGNvcmUpO1xuXG4vKiFcbiAqIEV4cGVjdCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgZXhwZWN0ID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9leHBlY3QnKTtcbmV4cG9ydHMudXNlKGV4cGVjdCk7XG5cbi8qIVxuICogU2hvdWxkIGludGVyZmFjZVxuICovXG5cbnZhciBzaG91bGQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL3Nob3VsZCcpO1xuZXhwb3J0cy51c2Uoc2hvdWxkKTtcblxuLyohXG4gKiBBc3NlcnQgaW50ZXJmYWNlXG4gKi9cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvYXNzZXJ0Jyk7XG5leHBvcnRzLnVzZShhc3NlcnQpO1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfY2hhaSwgdXRpbCkge1xuICAvKiFcbiAgICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbkVycm9yID0gX2NoYWkuQXNzZXJ0aW9uRXJyb3JcbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIF9jaGFpLkFzc2VydGlvbiA9IEFzc2VydGlvbjtcblxuICAvKiFcbiAgICogQXNzZXJ0aW9uIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIENyZWF0ZXMgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIGZ1bmN0aW9uIEFzc2VydGlvbiAob2JqLCBtc2csIHN0YWNrKSB7XG4gICAgZmxhZyh0aGlzLCAnc3NmaScsIHN0YWNrIHx8IGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIG9iaik7XG4gICAgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXNzZXJ0aW9uLCAnaW5jbHVkZVN0YWNrJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgcmV0dXJuIGNvbmZpZy5pbmNsdWRlU3RhY2s7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5pbmNsdWRlU3RhY2sgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayBpbnN0ZWFkLicpO1xuICAgICAgY29uZmlnLmluY2x1ZGVTdGFjayA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ3Nob3dEaWZmJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuc2hvd0RpZmY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0Fzc2VydGlvbi5zaG93RGlmZiBpcyBkZXByZWNhdGVkLCB1c2UgY2hhaS5jb25maWcuc2hvd0RpZmYgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5zaG93RGlmZiA9IHZhbHVlO1xuICAgIH1cbiAgfSk7XG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLmFkZE1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4pO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QgPSBmdW5jdGlvbiAobmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgICB1dGlsLmFkZENoYWluYWJsZU1ldGhvZCh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5hc3NlcnQoZXhwcmVzc2lvbiwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSwgZXhwZWN0ZWQsIGFjdHVhbClcbiAgICpcbiAgICogRXhlY3V0ZXMgYW4gZXhwcmVzc2lvbiBhbmQgY2hlY2sgZXhwZWN0YXRpb25zLiBUaHJvd3MgQXNzZXJ0aW9uRXJyb3IgZm9yIHJlcG9ydGluZyBpZiB0ZXN0IGRvZXNuJ3QgcGFzcy5cbiAgICpcbiAgICogQG5hbWUgYXNzZXJ0XG4gICAqIEBwYXJhbSB7UGhpbG9zb3BoaWNhbH0gZXhwcmVzc2lvbiB0byBiZSB0ZXN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdG8gZGlzcGxheSBpZiBmYWlsc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmVnYXRlZE1lc3NhZ2UgdG8gZGlzcGxheSBpZiBuZWdhdGVkIGV4cHJlc3Npb24gZmFpbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWQgdmFsdWUgKHJlbWVtYmVyIHRvIGNoZWNrIGZvciBuZWdhdGlvbilcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsIChvcHRpb25hbCkgd2lsbCBkZWZhdWx0IHRvIGB0aGlzLm9iamBcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIEFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHIsIG1zZywgbmVnYXRlTXNnLCBleHBlY3RlZCwgX2FjdHVhbCwgc2hvd0RpZmYpIHtcbiAgICB2YXIgb2sgPSB1dGlsLnRlc3QodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodHJ1ZSAhPT0gc2hvd0RpZmYpIHNob3dEaWZmID0gZmFsc2U7XG4gICAgaWYgKHRydWUgIT09IGNvbmZpZy5zaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcblxuICAgIGlmICghb2spIHtcbiAgICAgIHZhciBtc2cgPSB1dGlsLmdldE1lc3NhZ2UodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAsIGFjdHVhbCA9IHV0aWwuZ2V0QWN0dWFsKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnLCB7XG4gICAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICAgLCBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgLCBzaG93RGlmZjogc2hvd0RpZmZcbiAgICAgIH0sIChjb25maWcuaW5jbHVkZVN0YWNrKSA/IHRoaXMuYXNzZXJ0IDogZmxhZyh0aGlzLCAnc3NmaScpKTtcbiAgICB9XG4gIH07XG5cbiAgLyohXG4gICAqICMjIyAuX29ialxuICAgKlxuICAgKiBRdWljayByZWZlcmVuY2UgdG8gc3RvcmVkIGBhY3R1YWxgIHZhbHVlIGZvciBwbHVnaW4gZGV2ZWxvcGVycy5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24ucHJvdG90eXBlLCAnX29iaicsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgICAgfVxuICAgICwgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbCk7XG4gICAgICB9XG4gIH0pO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qKlxuICAgKiAjIyMgY29uZmlnLmluY2x1ZGVTdGFja1xuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIHN0YWNrIHRyYWNlXG4gICAqIGlzIGluY2x1ZGVkIGluIEFzc2VydGlvbiBlcnJvciBtZXNzYWdlLiBEZWZhdWx0IG9mIGZhbHNlXG4gICAqIHN1cHByZXNzZXMgc3RhY2sgdHJhY2UgaW4gdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgPSB0cnVlOyAgLy8gZW5hYmxlIHN0YWNrIG9uIGVycm9yXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgIGluY2x1ZGVTdGFjazogZmFsc2UsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuc2hvd0RpZmZcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIGluZmx1ZW5jZXMgd2hldGhlciBvciBub3RcbiAgICogdGhlIGBzaG93RGlmZmAgZmxhZyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHRocm93blxuICAgKiBBc3NlcnRpb25FcnJvcnMuIGBmYWxzZWAgd2lsbCBhbHdheXMgYmUgYGZhbHNlYDsgYHRydWVgXG4gICAqIHdpbGwgYmUgdHJ1ZSB3aGVuIHRoZSBhc3NlcnRpb24gaGFzIHJlcXVlc3RlZCBhIGRpZmZcbiAgICogYmUgc2hvd24uXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgc2hvd0RpZmY6IHRydWUsXG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGRcbiAgICpcbiAgICogVXNlciBjb25maWd1cmFibGUgcHJvcGVydHksIHNldHMgbGVuZ3RoIHRocmVzaG9sZCBmb3IgYWN0dWFsIGFuZFxuICAgKiBleHBlY3RlZCB2YWx1ZXMgaW4gYXNzZXJ0aW9uIGVycm9ycy4gSWYgdGhpcyB0aHJlc2hvbGQgaXMgZXhjZWVkZWQsXG4gICAqIHRoZSB2YWx1ZSBpcyB0cnVuY2F0ZWQuXG4gICAqXG4gICAqIFNldCBpdCB0byB6ZXJvIGlmIHlvdSB3YW50IHRvIGRpc2FibGUgdHJ1bmNhdGluZyBhbHRvZ2V0aGVyLlxuICAgKlxuICAgKiAgICAgY2hhaS5jb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgPSAwOyAgLy8gZGlzYWJsZSB0cnVuY2F0aW5nXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB0cnVuY2F0ZVRocmVzaG9sZDogNDBcblxufTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCBfKSB7XG4gIHZhciBBc3NlcnRpb24gPSBjaGFpLkFzc2VydGlvblxuICAgICwgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgLCBmbGFnID0gXy5mbGFnO1xuXG4gIC8qKlxuICAgKiAjIyMgTGFuZ3VhZ2UgQ2hhaW5zXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgYXJlIHByb3ZpZGVkIGFzIGNoYWluYWJsZSBnZXR0ZXJzIHRvXG4gICAqIGltcHJvdmUgdGhlIHJlYWRhYmlsaXR5IG9mIHlvdXIgYXNzZXJ0aW9ucy4gVGhleVxuICAgKiBkbyBub3QgcHJvdmlkZSB0ZXN0aW5nIGNhcGFiaWxpdGllcyB1bmxlc3MgdGhleVxuICAgKiBoYXZlIGJlZW4gb3ZlcndyaXR0ZW4gYnkgYSBwbHVnaW4uXG4gICAqXG4gICAqICoqQ2hhaW5zKipcbiAgICpcbiAgICogLSB0b1xuICAgKiAtIGJlXG4gICAqIC0gYmVlblxuICAgKiAtIGlzXG4gICAqIC0gdGhhdFxuICAgKiAtIGFuZFxuICAgKiAtIGhhc1xuICAgKiAtIGhhdmVcbiAgICogLSB3aXRoXG4gICAqIC0gYXRcbiAgICogLSBvZlxuICAgKiAtIHNhbWVcbiAgICpcbiAgICogQG5hbWUgbGFuZ3VhZ2UgY2hhaW5zXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIFsgJ3RvJywgJ2JlJywgJ2JlZW4nXG4gICwgJ2lzJywgJ2FuZCcsICdoYXMnLCAnaGF2ZSdcbiAgLCAnd2l0aCcsICd0aGF0JywgJ2F0J1xuICAsICdvZicsICdzYW1lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KGNoYWluLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAubm90XG4gICAqXG4gICAqIE5lZ2F0ZXMgYW55IG9mIGFzc2VydGlvbnMgZm9sbG93aW5nIGluIHRoZSBjaGFpbi5cbiAgICpcbiAgICogICAgIGV4cGVjdChmb28pLnRvLm5vdC5lcXVhbCgnYmFyJyk7XG4gICAqICAgICBleHBlY3QoZ29vZEZuKS50by5ub3QudGhyb3coRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmF6JyB9KS50by5oYXZlLnByb3BlcnR5KCdmb28nKVxuICAgKiAgICAgICAuYW5kLm5vdC5lcXVhbCgnYmFyJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ25vdCcsIGZ1bmN0aW9uICgpIHtcbiAgICBmbGFnKHRoaXMsICduZWdhdGUnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFxuICAgKlxuICAgKiBTZXRzIHRoZSBgZGVlcGAgZmxhZywgbGF0ZXIgdXNlZCBieSB0aGUgYGVxdWFsYCBhbmRcbiAgICogYHByb3BlcnR5YCBhc3NlcnRpb25zLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uZGVlcC5lcXVhbCh7IGJhcjogJ2JheicgfSk7XG4gICAqICAgICBleHBlY3QoeyBmb286IHsgYmFyOiB7IGJhejogJ3F1dXgnIH0gfSB9KVxuICAgKiAgICAgICAudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdmb28uYmFyLmJheicsICdxdXV4Jyk7XG4gICAqXG4gICAqIEBuYW1lIGRlZXBcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdkZWVwJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2RlZXAnLCB0cnVlKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuYSh0eXBlKVxuICAgKlxuICAgKiBUaGUgYGFgIGFuZCBgYW5gIGFzc2VydGlvbnMgYXJlIGFsaWFzZXMgdGhhdCBjYW4gYmVcbiAgICogdXNlZCBlaXRoZXIgYXMgbGFuZ3VhZ2UgY2hhaW5zIG9yIHRvIGFzc2VydCBhIHZhbHVlJ3NcbiAgICogdHlwZS5cbiAgICpcbiAgICogICAgIC8vIHR5cGVvZlxuICAgKiAgICAgZXhwZWN0KCd0ZXN0JykudG8uYmUuYSgnc3RyaW5nJyk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLmJlLmFuKCdvYmplY3QnKTtcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5hKCdudWxsJyk7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS5hbigndW5kZWZpbmVkJyk7XG4gICAqXG4gICAqICAgICAvLyBsYW5ndWFnZSBjaGFpblxuICAgKiAgICAgZXhwZWN0KGZvbykudG8uYmUuYW4uaW5zdGFuY2VvZihGb28pO1xuICAgKlxuICAgKiBAbmFtZSBhXG4gICAqIEBhbGlhcyBhblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFuICh0eXBlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBhcnRpY2xlID0gflsgJ2EnLCAnZScsICdpJywgJ28nLCAndScgXS5pbmRleE9mKHR5cGUuY2hhckF0KDApKSA/ICdhbiAnIDogJ2EgJztcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0eXBlID09PSBfLnR5cGUob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSAnICsgYXJ0aWNsZSArIHR5cGVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhbicsIGFuKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnYScsIGFuKTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKHZhbHVlKVxuICAgKlxuICAgKiBUaGUgYGluY2x1ZGVgIGFuZCBgY29udGFpbmAgYXNzZXJ0aW9ucyBjYW4gYmUgdXNlZCBhcyBlaXRoZXIgcHJvcGVydHlcbiAgICogYmFzZWQgbGFuZ3VhZ2UgY2hhaW5zIG9yIGFzIG1ldGhvZHMgdG8gYXNzZXJ0IHRoZSBpbmNsdXNpb24gb2YgYW4gb2JqZWN0XG4gICAqIGluIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGluIGEgc3RyaW5nLiBXaGVuIHVzZWQgYXMgbGFuZ3VhZ2UgY2hhaW5zLFxuICAgKiB0aGV5IHRvZ2dsZSB0aGUgYGNvbnRhaW5gIGZsYWcgZm9yIHRoZSBga2V5c2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFsxLDIsM10pLnRvLmluY2x1ZGUoMik7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmNvbnRhaW4oJ2ZvbycpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJywgaGVsbG86ICd1bml2ZXJzZScgfSkudG8uaW5jbHVkZS5rZXlzKCdmb28nKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAYWxpYXMgY29udGFpblxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8TnVtYmVyfSBvYmpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBpbmNsdWRlQ2hhaW5pbmdCZWhhdmlvciAoKSB7XG4gICAgZmxhZyh0aGlzLCAnY29udGFpbnMnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciBleHBlY3RlZCA9IGZhbHNlO1xuICAgIGlmIChfLnR5cGUob2JqKSA9PT0gJ2FycmF5JyAmJiBfLnR5cGUodmFsKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChfLmVxbChvYmpbaV0sIHZhbCkpIHtcbiAgICAgICAgICBleHBlY3RlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF8udHlwZSh2YWwpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKCFmbGFnKHRoaXMsICduZWdhdGUnKSkge1xuICAgICAgICBmb3IgKHZhciBrIGluIHZhbCkgbmV3IEFzc2VydGlvbihvYmopLnByb3BlcnR5KGssIHZhbFtrXSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdWJzZXQgPSB7fVxuICAgICAgZm9yICh2YXIgayBpbiB2YWwpIHN1YnNldFtrXSA9IG9ialtrXVxuICAgICAgZXhwZWN0ZWQgPSBfLmVxbChzdWJzZXQsIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGVjdGVkID0gb2JqICYmIH5vYmouaW5kZXhPZih2YWwpXG4gICAgfVxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBleHBlY3RlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaW5jbHVkZSAnICsgXy5pbnNwZWN0KHZhbCkpO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnaW5jbHVkZScsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcbiAgQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnY29udGFpbicsIGluY2x1ZGUsIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yKTtcblxuICAvKipcbiAgICogIyMjIC5va1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2V2ZXJ0aGluZycpLnRvLmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KDEpLnRvLmJlLm9rO1xuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5ub3QuYmUub2s7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5ub3QuYmUub2s7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8ubm90LmJlLm9rO1xuICAgKlxuICAgKiBAbmFtZSBva1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ29rJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnV0aHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHN5Jyk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnRydWVcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYHRydWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHRydWUpLnRvLmJlLnRydWU7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmJlLnRydWU7XG4gICAqXG4gICAqIEBuYW1lIHRydWVcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd0cnVlJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgdGhpcy5uZWdhdGUgPyBmYWxzZSA6IHRydWVcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5mYWxzZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgZmFsc2VgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZhbHNlKS50by5iZS5mYWxzZTtcbiAgICogICAgIGV4cGVjdCgwKS50by5ub3QuYmUuZmFsc2U7XG4gICAqXG4gICAqIEBuYW1lIGZhbHNlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZmFsc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZhbHNlID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBmYWxzZSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdHJ1ZSdcbiAgICAgICwgdGhpcy5uZWdhdGUgPyB0cnVlIDogZmFsc2VcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5udWxsXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBudWxsYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChudWxsKS50by5iZS5udWxsO1xuICAgKiAgICAgZXhwZWN0KHVuZGVmaW5lZCkubm90LnRvLmJlLm51bGw7XG4gICAqXG4gICAqIEBuYW1lIG51bGxcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdudWxsJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsID09PSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBudWxsJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgbnVsbCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC51bmRlZmluZWRcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS50by5iZS51bmRlZmluZWQ7XG4gICAqICAgICBleHBlY3QobnVsbCkudG8ubm90LmJlLnVuZGVmaW5lZDtcbiAgICpcbiAgICogQG5hbWUgdW5kZWZpbmVkXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgndW5kZWZpbmVkJywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB1bmRlZmluZWQgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHVuZGVmaW5lZCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIHVuZGVmaW5lZCdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5leGlzdFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBuZWl0aGVyIGBudWxsYCBub3IgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgZm9vID0gJ2hpJ1xuICAgKiAgICAgICAsIGJhciA9IG51bGxcbiAgICogICAgICAgLCBiYXo7XG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXIpLnRvLm5vdC5leGlzdDtcbiAgICogICAgIGV4cGVjdChiYXopLnRvLm5vdC5leGlzdDtcbiAgICpcbiAgICogQG5hbWUgZXhpc3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdleGlzdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgbnVsbCAhPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBleGlzdCdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGV4aXN0J1xuICAgICk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAuZW1wdHlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQncyBsZW5ndGggaXMgYDBgLiBGb3IgYXJyYXlzLCBpdCBjaGVja3NcbiAgICogdGhlIGBsZW5ndGhgIHByb3BlcnR5LiBGb3Igb2JqZWN0cywgaXQgZ2V0cyB0aGUgY291bnQgb2ZcbiAgICogZW51bWVyYWJsZSBrZXlzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KFtdKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCgnJykudG8uYmUuZW1wdHk7XG4gICAqICAgICBleHBlY3Qoe30pLnRvLmJlLmVtcHR5O1xuICAgKlxuICAgKiBAbmFtZSBlbXB0eVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2VtcHR5JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBleHBlY3RlZCA9IG9iajtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgfHwgJ3N0cmluZycgPT09IHR5cGVvZiBvYmplY3QpIHtcbiAgICAgIGV4cGVjdGVkID0gb2JqLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICBleHBlY3RlZCA9IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAhZXhwZWN0ZWRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZW1wdHknXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBlbXB0eSdcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hcmd1bWVudHNcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gYXJndW1lbnRzIG9iamVjdC5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHRlc3QgKCkge1xuICAgKiAgICAgICBleHBlY3QoYXJndW1lbnRzKS50by5iZS5hcmd1bWVudHM7XG4gICAqICAgICB9XG4gICAqXG4gICAqIEBuYW1lIGFyZ3VtZW50c1xuICAgKiBAYWxpYXMgQXJndW1lbnRzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrQXJndW1lbnRzICgpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnW29iamVjdCBBcmd1bWVudHNdJyA9PT0gdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYXJndW1lbnRzJ1xuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdBcmd1bWVudHMnLCBjaGVja0FyZ3VtZW50cyk7XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHN0cmljdGx5IGVxdWFsIChgPT09YCkgdG8gYHZhbHVlYC5cbiAgICogQWx0ZXJuYXRlbHksIGlmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIGFzc2VydHMgdGhhdFxuICAgKiB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdoZWxsbycpLnRvLmVxdWFsKCdoZWxsbycpO1xuICAgKiAgICAgZXhwZWN0KDQyKS50by5lcXVhbCg0Mik7XG4gICAqICAgICBleHBlY3QoMSkudG8ubm90LmVxdWFsKHRydWUpO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5ub3QuZXF1YWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5kZWVwLmVxdWFsKHsgZm9vOiAnYmFyJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQGFsaWFzIGVxdWFsc1xuICAgKiBAYWxpYXMgZXFcbiAgICogQGFsaWFzIGRlZXAuZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcXVhbCAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RlZXAnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZXFsKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gb2JqXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgdmFsXG4gICAgICAgICwgdGhpcy5fb2JqXG4gICAgICAgICwgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbCcsIGFzc2VydEVxdWFsKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZXF1YWxzJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcScsIGFzc2VydEVxdWFsKTtcblxuICAvKipcbiAgICogIyMjIC5lcWwodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGRlZXBseSBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAnYmFyJyB9KS50by5lcWwoeyBmb286ICdiYXInIH0pO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5lcWwoWyAxLCAyLCAzIF0pO1xuICAgKlxuICAgKiBAbmFtZSBlcWxcbiAgICogQGFsaWFzIGVxbHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRFcWwob2JqLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgXy5lcWwob2JqLCBmbGFnKHRoaXMsICdvYmplY3QnKSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGRlZXBseSBlcXVhbCAje2V4cH0nXG4gICAgICAsIG9ialxuICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWwnLCBhc3NlcnRFcWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcWxzJywgYXNzZXJ0RXFsKTtcblxuICAvKipcbiAgICogIyMjIC5hYm92ZSh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZ3JlYXRlciB0aGFuIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMTApLnRvLmJlLmFib3ZlKDUpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWluaW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICpcbiAgICogQG5hbWUgYWJvdmVcbiAgICogQGFsaWFzIGd0XG4gICAqIEBhbGlhcyBncmVhdGVyVGhhblxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRBYm92ZSAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID4gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIGFib3ZlICN7ZXhwfSdcbiAgICAgICAgLCBuXG4gICAgICAgICwgbGVuXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2Fib3ZlJywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndCcsIGFzc2VydEFib3ZlKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3JlYXRlclRoYW4nLCBhc3NlcnRBYm92ZSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVhc3QodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEwKS50by5iZS5hdC5sZWFzdCgxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtaW5pbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgub2YuYXQubGVhc3QoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLm9mLmF0LmxlYXN0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBsZWFzdFxuICAgKiBAYWxpYXMgZ3RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydExlYXN0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbGVhc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgJyArIG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZWFzdCcsIGFzc2VydExlYXN0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnZ3RlJywgYXNzZXJ0TGVhc3QpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmJlbG93KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg1KS50by5iZS5iZWxvdygxMCk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtYXhpbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKlxuICAgKiBAbmFtZSBiZWxvd1xuICAgKiBAYWxpYXMgbHRcbiAgICogQGFsaWFzIGxlc3NUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEJlbG93IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPCBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYmVsb3cgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBiZWxvdyAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IGxlYXN0ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2JlbG93JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdCcsIGFzc2VydEJlbG93KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVzc1RoYW4nLCBhc3NlcnRCZWxvdyk7XG5cbiAgLyoqXG4gICAqICMjIyAubW9zdCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoNSkudG8uYmUuYXQubW9zdCg1KTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1heGltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5vZi5hdC5tb3N0KDMpO1xuICAgKlxuICAgKiBAbmFtZSBtb3N0XG4gICAqIEBhbGlhcyBsdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TW9zdCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGF0IG1vc3QgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA8PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbW9zdCAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFib3ZlICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21vc3QnLCBhc3NlcnRNb3N0KTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbHRlJywgYXNzZXJ0TW9zdCk7XG5cbiAgLyoqXG4gICAqICMjIyAud2l0aGluKHN0YXJ0LCBmaW5pc2gpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHdpdGhpbiBhIHJhbmdlLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDcpLnRvLmJlLndpdGhpbig1LDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIGxlbmd0aCByYW5nZS4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBAbmFtZSB3aXRoaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IGxvd2VyYm91bmQgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmaW5pc2ggdXBwZXJib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd3aXRoaW4nLCBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHJhbmdlID0gc3RhcnQgKyAnLi4nICsgZmluaXNoO1xuICAgIGlmIChmbGFnKHRoaXMsICdkb0xlbmd0aCcpKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgbGVuID49IHN0YXJ0ICYmIGxlbiA8PSBmaW5pc2hcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBvYmogPj0gc3RhcnQgJiYgb2JqIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluc3RhbmNlb2YoY29uc3RydWN0b3IpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIENoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBleHBlY3QoQ2hhaSkudG8uYmUuYW4uaW5zdGFuY2VvZihUZWEpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5iZS5pbnN0YW5jZW9mKEFycmF5KTtcbiAgICpcbiAgICogQG5hbWUgaW5zdGFuY2VvZlxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhbGlhcyBpbnN0YW5jZU9mXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEluc3RhbmNlT2YgKGNvbnN0cnVjdG9yLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgbmFtZSA9IF8uZ2V0TmFtZShjb25zdHJ1Y3Rvcik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpIGluc3RhbmNlb2YgY29uc3RydWN0b3JcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGJlIGFuIGluc3RhbmNlIG9mICcgKyBuYW1lXG4gICAgKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdpbnN0YW5jZW9mJywgYXNzZXJ0SW5zdGFuY2VPZik7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlT2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShuYW1lLCBbdmFsdWVdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBwcm9wZXJ0eSBgbmFtZWAsIG9wdGlvbmFsbHkgYXNzZXJ0aW5nIHRoYXRcbiAgICogdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkgaXMgc3RyaWN0bHkgZXF1YWwgdG8gIGB2YWx1ZWAuXG4gICAqIElmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIHlvdSBjYW4gdXNlIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXBcbiAgICogcmVmZXJlbmNlcyBpbnRvIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICpcbiAgICogICAgIC8vIHNpbXBsZSByZWZlcmVuY2luZ1xuICAgKiAgICAgdmFyIG9iaiA9IHsgZm9vOiAnYmFyJyB9O1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJyk7XG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nLCAnYmFyJyk7XG4gICAqXG4gICAqICAgICAvLyBkZWVwIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgZGVlcE9iaiA9IHtcbiAgICogICAgICAgICBncmVlbjogeyB0ZWE6ICdtYXRjaGEnIH1cbiAgICogICAgICAgLCB0ZWFzOiBbICdjaGFpJywgJ21hdGNoYScsIHsgdGVhOiAna29uYWNoYScgfSBdXG4gICAqICAgICB9O1xuXG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdncmVlbi50ZWEnLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd0ZWFzWzFdJywgJ21hdGNoYScpO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgndGVhc1syXS50ZWEnLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBZb3UgY2FuIGFsc28gdXNlIGFuIGFycmF5IGFzIHRoZSBzdGFydGluZyBwb2ludCBvZiBhIGBkZWVwLnByb3BlcnR5YFxuICAgKiBhc3NlcnRpb24sIG9yIHRyYXZlcnNlIG5lc3RlZCBhcnJheXMuXG4gICAqXG4gICAqICAgICB2YXIgYXJyID0gW1xuICAgKiAgICAgICAgIFsgJ2NoYWknLCAnbWF0Y2hhJywgJ2tvbmFjaGEnIF1cbiAgICogICAgICAgLCBbIHsgdGVhOiAnY2hhaScgfVxuICAgKiAgICAgICAgICwgeyB0ZWE6ICdtYXRjaGEnIH1cbiAgICogICAgICAgICAsIHsgdGVhOiAna29uYWNoYScgfSBdXG4gICAqICAgICBdO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KGFycikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCdbMF1bMV0nLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoYXJyKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1sxXVsyXS50ZWEnLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBGdXJ0aGVybW9yZSwgYHByb3BlcnR5YCBjaGFuZ2VzIHRoZSBzdWJqZWN0IG9mIHRoZSBhc3NlcnRpb25cbiAgICogdG8gYmUgdGhlIHZhbHVlIG9mIHRoYXQgcHJvcGVydHkgZnJvbSB0aGUgb3JpZ2luYWwgb2JqZWN0LiBUaGlzXG4gICAqIHBlcm1pdHMgZm9yIGZ1cnRoZXIgY2hhaW5hYmxlIGFzc2VydGlvbnMgb24gdGhhdCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdChvYmopLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycpXG4gICAqICAgICAgIC50aGF0LmlzLmEoJ3N0cmluZycpO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUucHJvcGVydHkoJ2dyZWVuJylcbiAgICogICAgICAgLnRoYXQuaXMuYW4oJ29iamVjdCcpXG4gICAqICAgICAgIC50aGF0LmRlZXAuZXF1YWxzKHsgdGVhOiAnbWF0Y2hhJyB9KTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLnByb3BlcnR5KCd0ZWFzJylcbiAgICogICAgICAgLnRoYXQuaXMuYW4oJ2FycmF5JylcbiAgICogICAgICAgLndpdGguZGVlcC5wcm9wZXJ0eSgnWzJdJylcbiAgICogICAgICAgICAudGhhdC5kZWVwLmVxdWFscyh7IHRlYTogJ2tvbmFjaGEnIH0pO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAYWxpYXMgZGVlcC5wcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQHJldHVybnMgdmFsdWUgb2YgcHJvcGVydHkgZm9yIGNoYWluaW5nXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Byb3BlcnR5JywgZnVuY3Rpb24gKG5hbWUsIHZhbCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG5cbiAgICB2YXIgZGVzY3JpcHRvciA9IGZsYWcodGhpcywgJ2RlZXAnKSA/ICdkZWVwIHByb3BlcnR5ICcgOiAncHJvcGVydHkgJ1xuICAgICAgLCBuZWdhdGUgPSBmbGFnKHRoaXMsICduZWdhdGUnKVxuICAgICAgLCBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCB2YWx1ZSA9IGZsYWcodGhpcywgJ2RlZXAnKVxuICAgICAgICA/IF8uZ2V0UGF0aFZhbHVlKG5hbWUsIG9iailcbiAgICAgICAgOiBvYmpbbmFtZV07XG5cbiAgICBpZiAobmVnYXRlICYmIHVuZGVmaW5lZCAhPT0gdmFsKSB7XG4gICAgICBpZiAodW5kZWZpbmVkID09PSB2YWx1ZSkge1xuICAgICAgICBtc2cgPSAobXNnICE9IG51bGwpID8gbXNnICsgJzogJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnICsgXy5pbnNwZWN0KG9iaikgKyAnIGhhcyBubyAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHVuZGVmaW5lZCAhPT0gdmFsdWVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gdmFsKSB7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICB2YWwgPT09IHZhbHVlXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpICsgJyBvZiAje2V4cH0sIGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7YWN0fSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB2YWx1ZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCB2YWx1ZSk7XG4gIH0pO1xuXG5cbiAgLyoqXG4gICAqICMjIyAub3duUHJvcGVydHkobmFtZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGFuIG93biBwcm9wZXJ0eSBgbmFtZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5oYXZlLm93blByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICpcbiAgICogQG5hbWUgb3duUHJvcGVydHlcbiAgICogQGFsaWFzIGhhdmVPd25Qcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydE93blByb3BlcnR5IChuYW1lLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIG93biBwcm9wZXJ0eSAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIG93biBwcm9wZXJ0eSAnICsgXy5pbnNwZWN0KG5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ293blByb3BlcnR5JywgYXNzZXJ0T3duUHJvcGVydHkpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdoYXZlT3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG5cbiAgLyoqXG4gICAqICMjIyAubGVuZ3RoKHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGBsZW5ndGhgIHByb3BlcnR5IGhhc1xuICAgKiB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzXSkudG8uaGF2ZS5sZW5ndGgoMyk7XG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUubGVuZ3RoKDYpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGFzIGEgY2hhaW4gcHJlY3Vyc29yIHRvIGEgdmFsdWVcbiAgICogY29tcGFyaXNvbiBmb3IgdGhlIGxlbmd0aCBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICpcbiAgICogQG5hbWUgbGVuZ3RoXG4gICAqIEBhbGlhcyBsZW5ndGhPZlxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVuZ3RoQ2hhaW4gKCkge1xuICAgIGZsYWcodGhpcywgJ2RvTGVuZ3RoJywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGggKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KCdsZW5ndGgnKTtcbiAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBsZW4gPT0gblxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIG9mICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggb2YgI3thY3R9J1xuICAgICAgLCBuXG4gICAgICAsIGxlblxuICAgICk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdsZW5ndGgnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbGVuZ3RoT2YnLCBhc3NlcnRMZW5ndGgsIGFzc2VydExlbmd0aENoYWluKTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaChyZWdleHApXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLm1hdGNoKC9eZm9vLyk7XG4gICAqXG4gICAqIEBuYW1lIG1hdGNoXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBSZWd1bGFyRXhwcmVzc2lvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ21hdGNoJywgZnVuY3Rpb24gKHJlLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlLmV4ZWMob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBtYXRjaCAnICsgcmVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIG1hdGNoICcgKyByZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmluZyhzdHJpbmcpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgc3RyaW5nIHRhcmdldCBjb250YWlucyBhbm90aGVyIHN0cmluZy5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5zdHJpbmcoJ2JhcicpO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3N0cmluZycsIGZ1bmN0aW9uIChzdHIsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS5pcy5hKCdzdHJpbmcnKTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB+b2JqLmluZGV4T2Yoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBjb250YWluICcgKyBfLmluc3BlY3Qoc3RyKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICApO1xuICB9KTtcblxuXG4gIC8qKlxuICAgKiAjIyMgLmtleXMoa2V5MSwgW2tleTJdLCBbLi4uXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaGFzIGV4YWN0bHkgdGhlIGdpdmVuIGtleXMsIG9yXG4gICAqIGFzc2VydHMgdGhlIGluY2x1c2lvbiBvZiBzb21lIGtleXMgd2hlbiB1c2luZyB0aGVcbiAgICogYGluY2x1ZGVgIG9yIGBjb250YWluYCBtb2RpZmllcnMuXG4gICAqXG4gICAqICAgICBleHBlY3QoeyBmb286IDEsIGJhcjogMiB9KS50by5oYXZlLmtleXMoWydmb28nLCAnYmFyJ10pO1xuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIsIGJhejogMyB9KS50by5jb250YWluLmtleXMoJ2ZvbycsICdiYXInKTtcbiAgICpcbiAgICogQG5hbWUga2V5c1xuICAgKiBAYWxpYXMga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nLi4ufEFycmF5fSBrZXlzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEtleXMgKGtleXMpIHtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgc3RyXG4gICAgICAsIG9rID0gdHJ1ZTtcblxuICAgIGtleXMgPSBrZXlzIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgID8ga2V5c1xuICAgICAgOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKCFrZXlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdrZXlzIHJlcXVpcmVkJyk7XG5cbiAgICB2YXIgYWN0dWFsID0gT2JqZWN0LmtleXMob2JqKVxuICAgICAgLCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICAgIC8vIEluY2x1c2lvblxuICAgIG9rID0ga2V5cy5ldmVyeShmdW5jdGlvbihrZXkpe1xuICAgICAgcmV0dXJuIH5hY3R1YWwuaW5kZXhPZihrZXkpO1xuICAgIH0pO1xuXG4gICAgLy8gU3RyaWN0XG4gICAgaWYgKCFmbGFnKHRoaXMsICduZWdhdGUnKSAmJiAhZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgb2sgPSBvayAmJiBrZXlzLmxlbmd0aCA9PSBhY3R1YWwubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEtleSBzdHJpbmdcbiAgICBpZiAobGVuID4gMSkge1xuICAgICAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIHJldHVybiBfLmluc3BlY3Qoa2V5KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBrZXlzLnBvcCgpO1xuICAgICAgc3RyID0ga2V5cy5qb2luKCcsICcpICsgJywgYW5kICcgKyBsYXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBfLmluc3BlY3Qoa2V5c1swXSk7XG4gICAgfVxuXG4gICAgLy8gRm9ybVxuICAgIHN0ciA9IChsZW4gPiAxID8gJ2tleXMgJyA6ICdrZXkgJykgKyBzdHI7XG5cbiAgICAvLyBIYXZlIC8gaW5jbHVkZVxuICAgIHN0ciA9IChmbGFnKHRoaXMsICdjb250YWlucycpID8gJ2NvbnRhaW4gJyA6ICdoYXZlICcpICsgc3RyO1xuXG4gICAgLy8gQXNzZXJ0aW9uXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG9rXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvICcgKyBzdHJcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90ICcgKyBzdHJcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5cycsIGFzc2VydEtleXMpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdrZXknLCBhc3NlcnRLZXlzKTtcblxuICAvKipcbiAgICogIyMjIC50aHJvdyhjb25zdHJ1Y3RvcilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSBmdW5jdGlvbiB0YXJnZXQgd2lsbCB0aHJvdyBhIHNwZWNpZmljIGVycm9yLCBvciBzcGVjaWZpYyB0eXBlIG9mIGVycm9yXG4gICAqIChhcyBkZXRlcm1pbmVkIHVzaW5nIGBpbnN0YW5jZW9mYCksIG9wdGlvbmFsbHkgd2l0aCBhIFJlZ0V4cCBvciBzdHJpbmcgaW5jbHVzaW9uIHRlc3RcbiAgICogZm9yIHRoZSBlcnJvcidzIG1lc3NhZ2UuXG4gICAqXG4gICAqICAgICB2YXIgZXJyID0gbmV3IFJlZmVyZW5jZUVycm9yKCdUaGlzIGlzIGEgYmFkIGZ1bmN0aW9uLicpO1xuICAgKiAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkgeyB0aHJvdyBlcnI7IH1cbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KC9iYWQgZnVuY3Rpb24vKTtcbiAgICogICAgIGV4cGVjdChmbikudG8ubm90LnRocm93KCdnb29kIGZ1bmN0aW9uJyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yLCAvYmFkIGZ1bmN0aW9uLyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KGVycik7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLm5vdC50aHJvdyhuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlLicpKTtcbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB3aGVuIGEgdGhyb3cgZXhwZWN0YXRpb24gaXMgbmVnYXRlZCwgaXQgd2lsbCBjaGVjayBlYWNoXG4gICAqIHBhcmFtZXRlciBpbmRlcGVuZGVudGx5LCBzdGFydGluZyB3aXRoIGVycm9yIGNvbnN0cnVjdG9yIHR5cGUuIFRoZSBhcHByb3ByaWF0ZSB3YXlcbiAgICogdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYSB0eXBlIG9mIGVycm9yIGJ1dCBmb3IgYSBtZXNzYWdlIHRoYXQgZG9lcyBub3QgbWF0Y2hcbiAgICogaXMgdG8gdXNlIGBhbmRgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhSZWZlcmVuY2VFcnJvcilcbiAgICogICAgICAgIC5hbmQubm90LnRocm93KC9nb29kIGZ1bmN0aW9uLyk7XG4gICAqXG4gICAqIEBuYW1lIHRocm93XG4gICAqIEBhbGlhcyB0aHJvd3NcbiAgICogQGFsaWFzIFRocm93XG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBleHBlY3RlZCBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAcmV0dXJucyBlcnJvciBmb3IgY2hhaW5pbmcgKG51bGwgaWYgbm8gZXJyb3IpXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydFRocm93cyAoY29uc3RydWN0b3IsIGVyck1zZywgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ2Z1bmN0aW9uJyk7XG5cbiAgICB2YXIgdGhyb3duID0gZmFsc2VcbiAgICAgICwgZGVzaXJlZEVycm9yID0gbnVsbFxuICAgICAgLCBuYW1lID0gbnVsbFxuICAgICAgLCB0aHJvd25FcnJvciA9IG51bGw7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyTXNnID0gbnVsbDtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIFJlZ0V4cCB8fCAnc3RyaW5nJyA9PT0gdHlwZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgZXJyTXNnID0gY29uc3RydWN0b3I7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBkZXNpcmVkRXJyb3IgPSBjb25zdHJ1Y3RvcjtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgIGVyck1zZyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5hbWUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUubmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgaWYgKG5hbWUgPT09ICdFcnJvcicgJiYgY29uc3RydWN0b3IgIT09IEVycm9yKSB7XG4gICAgICAgIG5hbWUgPSAobmV3IGNvbnN0cnVjdG9yKCkpLm5hbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgb2JqKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBmaXJzdCwgY2hlY2sgZGVzaXJlZCBlcnJvclxuICAgICAgaWYgKGRlc2lyZWRFcnJvcikge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGVyciA9PT0gZGVzaXJlZEVycm9yXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICN7ZXhwfSdcbiAgICAgICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIGNvbnN0cnVjdG9yXG4gICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvclxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0gYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgICAgICAgICwgbmFtZVxuICAgICAgICAgICwgKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLnRvU3RyaW5nKCkgOiBlcnIpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFlcnJNc2cpIHtcbiAgICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQsIGNoZWNrIG1lc3NhZ2VcbiAgICAgIHZhciBtZXNzYWdlID0gJ29iamVjdCcgPT09IF8udHlwZShlcnIpICYmIFwibWVzc2FnZVwiIGluIGVyclxuICAgICAgICA/IGVyci5tZXNzYWdlXG4gICAgICAgIDogJycgKyBlcnI7XG5cbiAgICAgIGlmICgobWVzc2FnZSAhPSBudWxsKSAmJiBlcnJNc2cgJiYgZXJyTXNnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZXJyTXNnLmV4ZWMobWVzc2FnZSlcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG1hdGNoaW5nICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG5vdCBtYXRjaGluZyAje2V4cH0nXG4gICAgICAgICAgLCBlcnJNc2dcbiAgICAgICAgICAsIG1lc3NhZ2VcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoKG1lc3NhZ2UgIT0gbnVsbCkgJiYgZXJyTXNnICYmICdzdHJpbmcnID09PSB0eXBlb2YgZXJyTXNnKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgfm1lc3NhZ2UuaW5kZXhPZihlcnJNc2cpXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBpbmNsdWRpbmcgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3Igbm90IGluY2x1ZGluZyAje2FjdH0nXG4gICAgICAgICAgLCBlcnJNc2dcbiAgICAgICAgICAsIG1lc3NhZ2VcbiAgICAgICAgKTtcblxuICAgICAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBlcnIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93biA9IHRydWU7XG4gICAgICAgIHRocm93bkVycm9yID0gZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhY3R1YWxseUdvdCA9ICcnXG4gICAgICAsIGV4cGVjdGVkVGhyb3duID0gbmFtZSAhPT0gbnVsbFxuICAgICAgICA/IG5hbWVcbiAgICAgICAgOiBkZXNpcmVkRXJyb3JcbiAgICAgICAgICA/ICcje2V4cH0nIC8vXy5pbnNwZWN0KGRlc2lyZWRFcnJvcilcbiAgICAgICAgICA6ICdhbiBlcnJvcic7XG5cbiAgICBpZiAodGhyb3duKSB7XG4gICAgICBhY3R1YWxseUdvdCA9ICcgYnV0ICN7YWN0fSB3YXMgdGhyb3duJ1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICB0aHJvd24gPT09IHRydWVcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgJyArIGV4cGVjdGVkVGhyb3duICsgYWN0dWFsbHlHb3RcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHRocm93ICcgKyBleHBlY3RlZFRocm93biArIGFjdHVhbGx5R290XG4gICAgICAsIChkZXNpcmVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRlc2lyZWRFcnJvci50b1N0cmluZygpIDogZGVzaXJlZEVycm9yKVxuICAgICAgLCAodGhyb3duRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHRocm93bkVycm9yLnRvU3RyaW5nKCkgOiB0aHJvd25FcnJvcilcbiAgICApO1xuXG4gICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdGhyb3duRXJyb3IpO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Rocm93JywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgndGhyb3dzJywgYXNzZXJ0VGhyb3dzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnVGhyb3cnLCBhc3NlcnRUaHJvd3MpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnJlc3BvbmRUbyhtZXRob2QpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgb2JqZWN0IG9yIGNsYXNzIHRhcmdldCB3aWxsIHJlc3BvbmQgdG8gYSBtZXRob2QuXG4gICAqXG4gICAqICAgICBLbGFzcy5wcm90b3R5cGUuYmFyID0gZnVuY3Rpb24oKXt9O1xuICAgKiAgICAgZXhwZWN0KEtsYXNzKS50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKiAgICAgZXhwZWN0KG9iaikudG8ucmVzcG9uZFRvKCdiYXInKTtcbiAgICpcbiAgICogVG8gY2hlY2sgaWYgYSBjb25zdHJ1Y3RvciB3aWxsIHJlc3BvbmQgdG8gYSBzdGF0aWMgZnVuY3Rpb24sXG4gICAqIHNldCB0aGUgYGl0c2VsZmAgZmxhZy5cbiAgICpcbiAgICogICAgIEtsYXNzLmJheiA9IGZ1bmN0aW9uKCl7fTtcbiAgICogICAgIGV4cGVjdChLbGFzcykuaXRzZWxmLnRvLnJlc3BvbmRUbygnYmF6Jyk7XG4gICAqXG4gICAqIEBuYW1lIHJlc3BvbmRUb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncmVzcG9uZFRvJywgZnVuY3Rpb24gKG1ldGhvZCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGl0c2VsZiA9IGZsYWcodGhpcywgJ2l0c2VsZicpXG4gICAgICAsIGNvbnRleHQgPSAoJ2Z1bmN0aW9uJyA9PT0gXy50eXBlKG9iaikgJiYgIWl0c2VsZilcbiAgICAgICAgPyBvYmoucHJvdG90eXBlW21ldGhvZF1cbiAgICAgICAgOiBvYmpbbWV0aG9kXTtcblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAnZnVuY3Rpb24nID09PSB0eXBlb2YgY29udGV4dFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byByZXNwb25kIHRvICcgKyBfLmluc3BlY3QobWV0aG9kKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5pdHNlbGZcbiAgICpcbiAgICogU2V0cyB0aGUgYGl0c2VsZmAgZmxhZywgbGF0ZXIgdXNlZCBieSB0aGUgYHJlc3BvbmRUb2AgYXNzZXJ0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gRm9vKCkge31cbiAgICogICAgIEZvby5iYXIgPSBmdW5jdGlvbigpIHt9XG4gICAqICAgICBGb28ucHJvdG90eXBlLmJheiA9IGZ1bmN0aW9uKCkge31cbiAgICpcbiAgICogICAgIGV4cGVjdChGb28pLml0c2VsZi50by5yZXNwb25kVG8oJ2JhcicpO1xuICAgKiAgICAgZXhwZWN0KEZvbykuaXRzZWxmLm5vdC50by5yZXNwb25kVG8oJ2JheicpO1xuICAgKlxuICAgKiBAbmFtZSBpdHNlbGZcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdpdHNlbGYnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnaXRzZWxmJywgdHJ1ZSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhdGlzZnkobWV0aG9kKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBwYXNzZXMgYSBnaXZlbiB0cnV0aCB0ZXN0LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDEpLnRvLnNhdGlzZnkoZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gPiAwOyB9KTtcbiAgICpcbiAgICogQG5hbWUgc2F0aXNmeVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYXRjaGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnc2F0aXNmeScsIGZ1bmN0aW9uIChtYXRjaGVyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG1hdGNoZXIob2JqKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBzYXRpc2Z5ICcgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHNhdGlzZnknICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsIHRoaXMubmVnYXRlID8gZmFsc2UgOiB0cnVlXG4gICAgICAsIG1hdGNoZXIob2JqKVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMC41KTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2xvc2VUbycsIGZ1bmN0aW9uIChleHBlY3RlZCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgTWF0aC5hYnMob2JqIC0gZXhwZWN0ZWQpIDw9IGRlbHRhXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgY2xvc2UgdG8gJyArIGV4cGVjdGVkICsgJyArLy0gJyArIGRlbHRhXG4gICAgKTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gaXNTdWJzZXRPZihzdWJzZXQsIHN1cGVyc2V0LCBjbXApIHtcbiAgICByZXR1cm4gc3Vic2V0LmV2ZXJ5KGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIGlmICghY21wKSByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG5cbiAgICAgIHJldHVybiBzdXBlcnNldC5zb21lKGZ1bmN0aW9uKGVsZW0yKSB7XG4gICAgICAgIHJldHVybiBjbXAoZWxlbSwgZWxlbTIpO1xuICAgICAgfSk7XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiAjIyMgLm1lbWJlcnMoc2V0KVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhIHN1cGVyc2V0IG9mIGBzZXRgLFxuICAgKiBvciB0aGF0IHRoZSB0YXJnZXQgYW5kIGBzZXRgIGhhdmUgdGhlIHNhbWUgc3RyaWN0bHktZXF1YWwgKD09PSkgbWVtYmVycy5cbiAgICogQWx0ZXJuYXRlbHksIGlmIHRoZSBgZGVlcGAgZmxhZyBpcyBzZXQsIHNldCBtZW1iZXJzIGFyZSBjb21wYXJlZCBmb3IgZGVlcFxuICAgKiBlcXVhbGl0eS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLmluY2x1ZGUubWVtYmVycyhbMywgMl0pO1xuICAgKiAgICAgZXhwZWN0KFsxLCAyLCAzXSkudG8ubm90LmluY2x1ZGUubWVtYmVycyhbMywgMiwgOF0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KFs0LCAyXSkudG8uaGF2ZS5tZW1iZXJzKFsyLCA0XSk7XG4gICAqICAgICBleHBlY3QoWzUsIDJdKS50by5ub3QuaGF2ZS5tZW1iZXJzKFs1LCAyLCAxXSk7XG4gICAqXG4gICAqICAgICBleHBlY3QoW3sgaWQ6IDEgfV0pLnRvLmRlZXAuaW5jbHVkZS5tZW1iZXJzKFt7IGlkOiAxIH1dKTtcbiAgICpcbiAgICogQG5hbWUgbWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtZW1iZXJzJywgZnVuY3Rpb24gKHN1YnNldCwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuXG4gICAgbmV3IEFzc2VydGlvbihvYmopLnRvLmJlLmFuKCdhcnJheScpO1xuICAgIG5ldyBBc3NlcnRpb24oc3Vic2V0KS50by5iZS5hbignYXJyYXknKTtcblxuICAgIHZhciBjbXAgPSBmbGFnKHRoaXMsICdkZWVwJykgPyBfLmVxbCA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICByZXR1cm4gdGhpcy5hc3NlcnQoXG4gICAgICAgICAgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGEgc3VwZXJzZXQgb2YgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhIHN1cGVyc2V0IG9mICN7YWN0fSdcbiAgICAgICAgLCBvYmpcbiAgICAgICAgLCBzdWJzZXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGlzU3Vic2V0T2Yob2JqLCBzdWJzZXQsIGNtcCkgJiYgaXNTdWJzZXRPZihzdWJzZXQsIG9iaiwgY21wKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgdGhlIHNhbWUgbWVtYmVycyBhcyAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgdGhlIHNhbWUgbWVtYmVycyBhcyAje2FjdH0nXG4gICAgICAgICwgb2JqXG4gICAgICAgICwgc3Vic2V0XG4gICAgKTtcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG5cbiAgLyohXG4gICAqIENoYWkgZGVwZW5kZW5jaWVzLlxuICAgKi9cblxuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb25cbiAgICAsIGZsYWcgPSB1dGlsLmZsYWc7XG5cbiAgLyohXG4gICAqIE1vZHVsZSBleHBvcnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiAjIyMgYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UpXG4gICAqXG4gICAqIFdyaXRlIHlvdXIgb3duIHRlc3QgZXhwcmVzc2lvbnMuXG4gICAqXG4gICAqICAgICBhc3NlcnQoJ2ZvbycgIT09ICdiYXInLCAnZm9vIGlzIG5vdCBiYXInKTtcbiAgICogICAgIGFzc2VydChBcnJheS5pc0FycmF5KFtdKSwgJ2VtcHR5IGFycmF5cyBhcmUgYXJyYXlzJyk7XG4gICAqXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cHJlc3Npb24gdG8gdGVzdCBmb3IgdHJ1dGhpbmVzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0byBkaXNwbGF5IG9uIGVycm9yXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICB2YXIgYXNzZXJ0ID0gY2hhaS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwcmVzcywgZXJybXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKG51bGwsIG51bGwsIGNoYWkuYXNzZXJ0KTtcbiAgICB0ZXN0LmFzc2VydChcbiAgICAgICAgZXhwcmVzc1xuICAgICAgLCBlcnJtc2dcbiAgICAgICwgJ1sgbmVnYXRpb24gbWVzc2FnZSB1bmF2YWlsYWJsZSBdJ1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0sIFtvcGVyYXRvcl0pXG4gICAqXG4gICAqIFRocm93IGEgZmFpbHVyZS4gTm9kZS5qcyBgYXNzZXJ0YCBtb2R1bGUtY29tcGF0aWJsZS5cbiAgICpcbiAgICogQG5hbWUgZmFpbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5mYWlsID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ2Fzc2VydC5mYWlsKCknO1xuICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKG1lc3NhZ2UsIHtcbiAgICAgICAgYWN0dWFsOiBhY3R1YWxcbiAgICAgICwgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAsIG9wZXJhdG9yOiBvcGVyYXRvclxuICAgIH0sIGFzc2VydC5mYWlsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5vaygnZXZlcnl0aGluZycsICdldmVyeXRoaW5nIGlzIG9rJyk7XG4gICAqICAgICBhc3NlcnQub2soZmFsc2UsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKlxuICAgKiBAbmFtZSBva1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQub2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pcy5vaztcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RPayhvYmplY3QsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGlzIGZhbHN5LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE9rKCdldmVyeXRoaW5nJywgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqICAgICBhc3NlcnQubm90T2soZmFsc2UsICd0aGlzIHdpbGwgcGFzcycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RPa1xuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90T2sgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pcy5ub3Qub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIG5vbi1zdHJpY3QgZXF1YWxpdHkgKGA9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmVxdWFsKDMsICczJywgJz09IGNvZXJjZXMgdmFsdWVzIHRvIHN0cmluZ3MnKTtcbiAgICpcbiAgICogQG5hbWUgZXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQuZXF1YWwpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCA9PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGluZXF1YWxpdHkgKGAhPWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdEVxdWFsKDMsIDQsICd0aGVzZSBudW1iZXJzIGFyZSBub3QgZXF1YWwnKTtcbiAgICpcbiAgICogQG5hbWUgbm90RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgdmFyIHRlc3QgPSBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnLCBhc3NlcnQubm90RXF1YWwpO1xuXG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cCAhPSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2FjdH0nXG4gICAgICAsIGV4cFxuICAgICAgLCBhY3RcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgZXF1YWxpdHkgKGA9PT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCB0cnVlLCAndGhlc2UgYm9vbGVhbnMgYXJlIHN0cmljdGx5IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIHN0cmljdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHN0cmljdCBpbmVxdWFsaXR5IChgIT09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90U3RyaWN0RXF1YWwoMywgJzMnLCAnbm8gY29lcmNpb24gZm9yIHN0cmljdCBlcXVhbGl0eScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RTdHJpY3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5ub3QuZXF1YWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGFjdHVhbGAgaXMgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnZ3JlZW4nIH0pO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwRXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oYWN0LCBtc2cpLnRvLmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydCB0aGF0IGBhY3R1YWxgIGlzIG5vdCBkZWVwbHkgZXF1YWwgdG8gYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwRXF1YWwoeyB0ZWE6ICdncmVlbicgfSwgeyB0ZWE6ICdqYXNtaW5lJyB9KTtcbiAgICpcbiAgICogQG5hbWUgbm90RGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5ub3QuZXFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNUcnVlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIHRydWUuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gdHJ1ZTtcbiAgICogICAgIGFzc2VydC5pc1RydWUodGVhU2VydmVkLCAndGhlIHRlYSBoYXMgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNUcnVlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1RydWUgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pc1sndHJ1ZSddO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRmFsc2UodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgZmFsc2UuXG4gICAqXG4gICAqICAgICB2YXIgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqICAgICBhc3NlcnQuaXNGYWxzZSh0ZWFTZXJ2ZWQsICdubyB0ZWEgeWV0PyBobW0uLi4nKTtcbiAgICpcbiAgICogQG5hbWUgaXNGYWxzZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNGYWxzZSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLmlzWydmYWxzZSddO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTnVsbCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBudWxsLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTnVsbChlcnIsICd0aGVyZSB3YXMgbm8gZXJyb3InKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5lcXVhbChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE51bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IG51bGwuXG4gICAqXG4gICAqICAgICB2YXIgdGVhID0gJ3Rhc3R5IGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90TnVsbCh0ZWEsICdncmVhdCwgdGltZSBmb3IgdGVhIScpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bGxcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90TnVsbCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5lcXVhbChudWxsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc1VuZGVmaW5lZCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWE7XG4gICAqICAgICBhc3NlcnQuaXNVbmRlZmluZWQodGVhLCAnbm8gdGVhIGRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNVbmRlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwodW5kZWZpbmVkKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0RlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbm90IGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICdjdXAgb2YgY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNEZWZpbmVkKHRlYSwgJ3RlYSBoYXMgYmVlbiBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRGVmaW5lZFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNEZWZpbmVkID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNGdW5jdGlvbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gc2VydmVUZWEoKSB7IHJldHVybiAnY3VwIG9mIHRlYSc7IH07XG4gICAqICAgICBhc3NlcnQuaXNGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBjYW4gaGF2ZSB0ZWEgbm93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90RnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIHZhciBzZXJ2ZVRlYSA9IFsgJ2hlYXQnLCAncG91cicsICdzaXAnIF07XG4gICAqICAgICBhc3NlcnQuaXNOb3RGdW5jdGlvbihzZXJ2ZVRlYSwgJ2dyZWF0LCB3ZSBoYXZlIGxpc3RlZCB0aGUgc3RlcHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RGdW5jdGlvblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdmdW5jdGlvbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzT2JqZWN0KHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIG9iamVjdCAoYXMgcmV2ZWFsZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgKS5cbiAgICpcbiAgICogICAgIHZhciBzZWxlY3Rpb24gPSB7IG5hbWU6ICdDaGFpJywgc2VydmU6ICd3aXRoIHNwaWNlcycgfTtcbiAgICogICAgIGFzc2VydC5pc09iamVjdChzZWxlY3Rpb24sICd0ZWEgc2VsZWN0aW9uIGlzIGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc09iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdE9iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBvYmplY3QuXG4gICAqXG4gICAqICAgICB2YXIgc2VsZWN0aW9uID0gJ2NoYWknXG4gICAqICAgICBhc3NlcnQuaXNOb3RPYmplY3Qoc2VsZWN0aW9uLCAndGVhIHNlbGVjdGlvbiBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RPYmplY3QobnVsbCwgJ251bGwgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE9iamVjdFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RPYmplY3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gWyAnZ3JlZW4nLCAnY2hhaScsICdvb2xvbmcnIF07XG4gICAqICAgICBhc3NlcnQuaXNBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0FycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RBcnJheSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhbiBhcnJheS5cbiAgICpcbiAgICogICAgIHZhciBtZW51ID0gJ2dyZWVufGNoYWl8b29sb25nJztcbiAgICogICAgIGFzc2VydC5pc05vdEFycmF5KG1lbnUsICd3aGF0IGtpbmQgb2YgdGVhIGRvIHdlIHdhbnQ/Jyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90QXJyYXlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90QXJyYXkgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYW4oJ2FycmF5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSAnY2hhaSc7XG4gICAqICAgICBhc3NlcnQuaXNTdHJpbmcodGVhT3JkZXIsICdvcmRlciBwbGFjZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNTdHJpbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RTdHJpbmcodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBzdHJpbmcuXG4gICAqXG4gICAqICAgICB2YXIgdGVhT3JkZXIgPSA0O1xuICAgKiAgICAgYXNzZXJ0LmlzTm90U3RyaW5nKHRlYU9yZGVyLCAnb3JkZXIgcGxhY2VkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90U3RyaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdFN0cmluZyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdzdHJpbmcnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bWJlcih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIG51bWJlci5cbiAgICpcbiAgICogICAgIHZhciBjdXBzID0gMjtcbiAgICogICAgIGFzc2VydC5pc051bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc051bWJlclxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9ICcyIGN1cHMgcGxlYXNlJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bWJlcihjdXBzLCAnaG93IG1hbnkgY3VwcycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdE51bWJlclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3ROdW1iZXIgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnbnVtYmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9IHRydWVcbiAgICogICAgICAgLCB0ZWFTZXJ2ZWQgPSBmYWxzZTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pc0Jvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RCb29sZWFuKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgYm9vbGVhbi5cbiAgICpcbiAgICogICAgIHZhciB0ZWFSZWFkeSA9ICd5ZXAnXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gJ25vcGUnO1xuICAgKlxuICAgKiAgICAgYXNzZXJ0LmlzTm90Qm9vbGVhbih0ZWFSZWFkeSwgJ2lzIHRoZSB0ZWEgcmVhZHknKTtcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhU2VydmVkLCAnaGFzIHRlYSBiZWVuIHNlcnZlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEJvb2xlYW5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90Qm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5iZS5hKCdib29sZWFuJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAudHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih7IHRlYTogJ2NoYWknIH0sICdvYmplY3QnLCAnd2UgaGF2ZSBhbiBvYmplY3QnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoWydjaGFpJywgJ2phc21pbmUnXSwgJ2FycmF5JywgJ3dlIGhhdmUgYW4gYXJyYXknKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoJ3RlYScsICdzdHJpbmcnLCAnd2UgaGF2ZSBhIHN0cmluZycpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZigvdGVhLywgJ3JlZ2V4cCcsICd3ZSBoYXZlIGEgcmVndWxhciBleHByZXNzaW9uJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKG51bGwsICdudWxsJywgJ3dlIGhhdmUgYSBudWxsJyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKHVuZGVmaW5lZCwgJ3VuZGVmaW5lZCcsICd3ZSBoYXZlIGFuIHVuZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSB0eXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnR5cGVPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90VHlwZU9mKHZhbHVlLCBuYW1lLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgJ3MgdHlwZSBpcyBfbm90XyBgbmFtZWAsIGFzIGRldGVybWluZWQgYnlcbiAgICogYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFR5cGVPZigndGVhJywgJ251bWJlcicsICdzdHJpbmdzIGFyZSBub3QgbnVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBub3RUeXBlT2ZcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVvZiBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RUeXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbnN0YW5jZU9mKG9iamVjdCwgY29uc3RydWN0b3IsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBUZWEoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5pbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgYW4gaW5zdGFuY2Ugb2YgdGVhJyk7XG4gICAqXG4gICAqIEBuYW1lIGluc3RhbmNlT2ZcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge0NvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5zdGFuY2VPZiA9IGZ1bmN0aW9uICh2YWwsIHR5cGUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90SW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgYHZhbHVlYCBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgY2hhaSA9IG5ldyBTdHJpbmcoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RJbnN0YW5jZU9mKGNoYWksIFRlYSwgJ2NoYWkgaXMgbm90IGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuaW5zdGFuY2VPZih0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgaW5jbHVkZXMgYG5lZWRsZWAuIFdvcmtzXG4gICAqIGZvciBzdHJpbmdzIGFuZCBhcnJheXMuXG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5jbHVkZSgnZm9vYmFyJywgJ2JhcicsICdmb29iYXIgY29udGFpbnMgc3RyaW5nIFwiYmFyXCInKTtcbiAgICogICAgIGFzc2VydC5pbmNsdWRlKFsgMSwgMiwgMyBdLCAzLCAnYXJyYXkgY29udGFpbnMgdmFsdWUnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQuaW5jbHVkZSkuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluY2x1ZGUoaGF5c3RhY2ssIG5lZWRsZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGhheXN0YWNrYCBkb2VzIG5vdCBpbmNsdWRlIGBuZWVkbGVgLiBXb3Jrc1xuICAgKiBmb3Igc3RyaW5ncyBhbmQgYXJyYXlzLlxuICAgKmlcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKCdmb29iYXInLCAnYmF6JywgJ3N0cmluZyBub3QgaW5jbHVkZSBzdWJzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC5ub3RJbmNsdWRlKFsgMSwgMiwgMyBdLCA0LCAnYXJyYXkgbm90IGluY2x1ZGUgY29udGFpbiB2YWx1ZScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RJbmNsdWRlXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBoYXlzdGFja1xuICAgKiBAcGFyYW0ge01peGVkfSBuZWVkbGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdEluY2x1ZGUgPSBmdW5jdGlvbiAoZXhwLCBpbmMsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2csIGFzc2VydC5ub3RJbmNsdWRlKS5ub3QuaW5jbHVkZShpbmMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgbWF0Y2hlcycpO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5tYXRjaCA9IGZ1bmN0aW9uIChleHAsIHJlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnKS50by5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90TWF0Y2godmFsdWUsIHJlZ2V4cCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBkb2VzIG5vdCBtYXRjaCB0aGUgcmVndWxhciBleHByZXNzaW9uIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdE1hdGNoKCdmb29iYXInLCAvXmZvby8sICdyZWdleHAgZG9lcyBub3QgbWF0Y2gnKTtcbiAgICpcbiAgICogQG5hbWUgbm90TWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90TWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8ubm90Lm1hdGNoKHJlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYScpO1xuICAgKlxuICAgKiBAbmFtZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQucHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90UHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAnY29mZmVlJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLnByb3BlcnR5KHByb3ApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCB3aGljaCBjYW4gYmUgYVxuICAgKiBzdHJpbmcgdXNpbmcgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcCByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgZG9lcyBfbm90XyBoYXZlIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgd2hpY2hcbiAgICogY2FuIGJlIGEgc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEub29sb25nJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RGVlcFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5wcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBhc3NlcnQucHJvcGVydHlWYWwoeyB0ZWE6ICdpcyBnb29kJyB9LCAndGVhJywgJ2lzIGdvb2QnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHlOb3RWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIGJ1dCB3aXRoIGEgdmFsdWVcbiAgICogZGlmZmVyZW50IGZyb20gdGhhdCBnaXZlbiBieSBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBiYWQnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5Tm90VmFsID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgdmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eVZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCB3aXRoIHZhbHVlIGdpdmVuXG4gICAqIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwXG4gICAqIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHlWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJywgJ21hdGNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5kZWVwLnByb3BlcnR5KHByb3AsIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcFByb3BlcnR5Tm90VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCBidXQgd2l0aCBhIHZhbHVlXG4gICAqIGRpZmZlcmVudCBmcm9tIHRoYXQgZ2l2ZW4gYnkgYHZhbHVlYC4gYHByb3BlcnR5YCBjYW4gdXNlIGRvdC0gYW5kXG4gICAqIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nLCAna29uYWNoYScpO1xuICAgKlxuICAgKiBAbmFtZSBkZWVwUHJvcGVydHlOb3RWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmRlZXBQcm9wZXJ0eU5vdFZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmxlbmd0aE9mKG9iamVjdCwgbGVuZ3RoLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBgbGVuZ3RoYCBwcm9wZXJ0eSB3aXRoIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5sZW5ndGhPZihbMSwyLDNdLCAzLCAnYXJyYXkgaGFzIGxlbmd0aCBvZiAzJyk7XG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoJ2Zvb2JhcicsIDUsICdzdHJpbmcgaGFzIGxlbmd0aCBvZiA2Jyk7XG4gICAqXG4gICAqIEBuYW1lIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5sZW5ndGhPZiA9IGZ1bmN0aW9uIChleHAsIGxlbiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8uaGF2ZS5sZW5ndGgobGVuKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC50aHJvd3MoZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9zdHJpbmcvcmVnZXhwXSwgW3N0cmluZy9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igd2l0aCBtZXNzYWdlXG4gICAqIG1hdGNoaW5nIGByZWdleHBgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCAnZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yJyk7XG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICogICAgIGFzc2VydC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCBSZWZlcmVuY2VFcnJvciwgL2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvci8pO1xuICAgKlxuICAgKiBAbmFtZSB0aHJvd3NcbiAgICogQGFsaWFzIHRocm93XG4gICAqIEBhbGlhcyBUaHJvd1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIGVycnQgfHwgZXJydCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJycyA9IGVycnQ7XG4gICAgICBlcnJ0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYXNzZXJ0RXJyID0gbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICByZXR1cm4gZmxhZyhhc3NlcnRFcnIsICdvYmplY3QnKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kb2VzTm90VGhyb3coZnVuY3Rpb24sIFtjb25zdHJ1Y3Rvci9yZWdleHBdLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgZnVuY3Rpb25gIHdpbGwgX25vdF8gdGhyb3cgYW4gZXJyb3IgdGhhdCBpcyBhbiBpbnN0YW5jZSBvZlxuICAgKiBgY29uc3RydWN0b3JgLCBvciBhbHRlcm5hdGVseSB0aGF0IGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5kb2VzTm90VGhyb3coZm4sIEVycm9yLCAnZnVuY3Rpb24gZG9lcyBub3QgdGhyb3cnKTtcbiAgICpcbiAgICogQG5hbWUgZG9lc05vdFRocm93XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RXJyb3JDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yI0Vycm9yX3R5cGVzXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbiAoZm4sIHR5cGUsIG1zZykge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHR5cGUpIHtcbiAgICAgIG1zZyA9IHR5cGU7XG4gICAgICB0eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyh0eXBlKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5vcGVyYXRvcih2YWwxLCBvcGVyYXRvciwgdmFsMiwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBDb21wYXJlcyB0d28gdmFsdWVzIHVzaW5nIGBvcGVyYXRvcmAuXG4gICAqXG4gICAqICAgICBhc3NlcnQub3BlcmF0b3IoMSwgJzwnLCAyLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc+JywgMiwgJ3RoaXMgd2lsbCBmYWlsJyk7XG4gICAqXG4gICAqIEBuYW1lIG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wZXJhdG9yXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbDJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9wZXJhdG9yID0gZnVuY3Rpb24gKHZhbCwgb3BlcmF0b3IsIHZhbDIsIG1zZykge1xuICAgIGlmICghflsnPT0nLCAnPT09JywgJz4nLCAnPj0nLCAnPCcsICc8PScsICchPScsICchPT0nXS5pbmRleE9mKG9wZXJhdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wZXJhdG9yIFwiJyArIG9wZXJhdG9yICsgJ1wiJyk7XG4gICAgfVxuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihldmFsKHZhbCArIG9wZXJhdG9yICsgdmFsMiksIG1zZyk7XG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGVzdCwgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAnICsgdXRpbC5pbnNwZWN0KHZhbCkgKyAnIHRvIGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBub3QgYmUgJyArIG9wZXJhdG9yICsgJyAnICsgdXRpbC5pbnNwZWN0KHZhbDIpICk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuY2xvc2VUbyhhY3R1YWwsIGV4cGVjdGVkLCBkZWx0YSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5jbG9zZVRvKDEuNSwgMSwgMC41LCAnbnVtYmVycyBhcmUgY2xvc2UnKTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmNsb3NlVG8gPSBmdW5jdGlvbiAoYWN0LCBleHAsIGRlbHRhLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5iZS5jbG9zZVRvKGV4cCwgZGVsdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnNhbWVNZW1iZXJzKHNldDEsIHNldDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBzZXQxYCBhbmQgYHNldDJgIGhhdmUgdGhlIHNhbWUgbWVtYmVycy5cbiAgICogT3JkZXIgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgIGFzc2VydC5zYW1lTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxLCAzIF0sICdzYW1lIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgc2FtZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5zYW1lTWVtYmVycyA9IGZ1bmN0aW9uIChzZXQxLCBzZXQyLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHNldDEsIG1zZykudG8uaGF2ZS5zYW1lLm1lbWJlcnMoc2V0Mik7XG4gIH1cblxuICAvKipcbiAgICogIyMjIC5pbmNsdWRlTWVtYmVycyhzdXBlcnNldCwgc3Vic2V0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc3Vic2V0YCBpcyBpbmNsdWRlZCBpbiBgc3VwZXJzZXRgLlxuICAgKiBPcmRlciBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzKFsgMSwgMiwgMyBdLCBbIDIsIDEgXSwgJ2luY2x1ZGUgbWVtYmVycycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlTWVtYmVyc1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdXBlcnNldFxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmluY2x1ZGVNZW1iZXJzID0gZnVuY3Rpb24gKHN1cGVyc2V0LCBzdWJzZXQsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oc3VwZXJzZXQsIG1zZykudG8uaW5jbHVkZS5tZW1iZXJzKHN1YnNldCk7XG4gIH1cblxuICAvKiFcbiAgICogVW5kb2N1bWVudGVkIC8gdW50ZXN0ZWRcbiAgICovXG5cbiAgYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUub2s7XG4gIH07XG5cbiAgLyohXG4gICAqIEFsaWFzZXMuXG4gICAqL1xuXG4gIChmdW5jdGlvbiBhbGlhcyhuYW1lLCBhcyl7XG4gICAgYXNzZXJ0W2FzXSA9IGFzc2VydFtuYW1lXTtcbiAgICByZXR1cm4gYWxpYXM7XG4gIH0pXG4gICgnVGhyb3cnLCAndGhyb3cnKVxuICAoJ1Rocm93JywgJ3Rocm93cycpO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgY2hhaS5leHBlY3QgPSBmdW5jdGlvbiAodmFsLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBjaGFpLkFzc2VydGlvbih2YWwsIG1lc3NhZ2UpO1xuICB9O1xufTtcblxuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMS0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuICB2YXIgQXNzZXJ0aW9uID0gY2hhaS5Bc3NlcnRpb247XG5cbiAgZnVuY3Rpb24gbG9hZFNob3VsZCAoKSB7XG4gICAgLy8gZXhwbGljaXRseSBkZWZpbmUgdGhpcyBtZXRob2QgYXMgZnVuY3Rpb24gYXMgdG8gaGF2ZSBpdCdzIG5hbWUgdG8gaW5jbHVkZSBhcyBgc3NmaWBcbiAgICBmdW5jdGlvbiBzaG91bGRHZXR0ZXIoKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFN0cmluZyB8fCB0aGlzIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMuY29uc3RydWN0b3IodGhpcyksIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMgPT0gdHJ1ZSwgbnVsbCwgc2hvdWxkR2V0dGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHRoaXMsIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFNldHRlcih2YWx1ZSkge1xuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFpanMvY2hhaS9pc3N1ZXMvODY6IHRoaXMgbWFrZXNcbiAgICAgIC8vIGB3aGF0ZXZlci5zaG91bGQgPSBzb21lVmFsdWVgIGFjdHVhbGx5IHNldCBgc29tZVZhbHVlYCwgd2hpY2ggaXNcbiAgICAgIC8vIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBgZ2xvYmFsLnNob3VsZCA9IHJlcXVpcmUoJ2NoYWknKS5zaG91bGQoKWAuXG4gICAgICAvL1xuICAgICAgLy8gTm90ZSB0aGF0IHdlIGhhdmUgdG8gdXNlIFtbRGVmaW5lUHJvcGVydHldXSBpbnN0ZWFkIG9mIFtbUHV0XV1cbiAgICAgIC8vIHNpbmNlIG90aGVyd2lzZSB3ZSB3b3VsZCB0cmlnZ2VyIHRoaXMgdmVyeSBzZXR0ZXIhXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Nob3VsZCcsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gbW9kaWZ5IE9iamVjdC5wcm90b3R5cGUgdG8gaGF2ZSBgc2hvdWxkYFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnc2hvdWxkJywge1xuICAgICAgc2V0OiBzaG91bGRTZXR0ZXJcbiAgICAgICwgZ2V0OiBzaG91bGRHZXR0ZXJcbiAgICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB2YXIgc2hvdWxkID0ge307XG5cbiAgICBzaG91bGQuZXF1YWwgPSBmdW5jdGlvbiAodmFsMSwgdmFsMiwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbDEsIG1zZykudG8uZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIHNob3VsZC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLlRocm93KGVycnQsIGVycnMpO1xuICAgIH07XG5cbiAgICBzaG91bGQuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmV4aXN0O1xuICAgIH1cblxuICAgIC8vIG5lZ2F0aW9uXG4gICAgc2hvdWxkLm5vdCA9IHt9XG5cbiAgICBzaG91bGQubm90LmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLm5vdC5lcXVhbCh2YWwyKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLm5vdC5UaHJvdyA9IGZ1bmN0aW9uIChmbiwgZXJydCwgZXJycywgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKGZuLCBtc2cpLnRvLm5vdC5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLm5vdC5leGlzdCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmV4aXN0O1xuICAgIH1cblxuICAgIHNob3VsZFsndGhyb3cnXSA9IHNob3VsZFsnVGhyb3cnXTtcbiAgICBzaG91bGQubm90Wyd0aHJvdyddID0gc2hvdWxkLm5vdFsnVGhyb3cnXTtcblxuICAgIHJldHVybiBzaG91bGQ7XG4gIH07XG5cbiAgY2hhaS5zaG91bGQgPSBsb2FkU2hvdWxkO1xuICBjaGFpLlNob3VsZCA9IGxvYWRTaG91bGQ7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkQ2hhaW5pbmdNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpO1xuXG4vKiFcbiAqIE1vZHVsZSB2YXJpYWJsZXNcbiAqL1xuXG4vLyBDaGVjayB3aGV0aGVyIGBfX3Byb3RvX19gIGlzIHN1cHBvcnRlZFxudmFyIGhhc1Byb3RvU3VwcG9ydCA9ICdfX3Byb3RvX18nIGluIE9iamVjdDtcblxuLy8gV2l0aG91dCBgX19wcm90b19fYCBzdXBwb3J0LCB0aGlzIG1vZHVsZSB3aWxsIG5lZWQgdG8gYWRkIHByb3BlcnRpZXMgdG8gYSBmdW5jdGlvbi5cbi8vIEhvd2V2ZXIsIHNvbWUgRnVuY3Rpb24ucHJvdG90eXBlIG1ldGhvZHMgY2Fubm90IGJlIG92ZXJ3cml0dGVuLFxuLy8gYW5kIHRoZXJlIHNlZW1zIG5vIGVhc3kgY3Jvc3MtcGxhdGZvcm0gd2F5IHRvIGRldGVjdCB0aGVtIChAc2VlIGNoYWlqcy9jaGFpL2lzc3Vlcy82OSkuXG52YXIgZXhjbHVkZU5hbWVzID0gL14oPzpsZW5ndGh8bmFtZXxhcmd1bWVudHN8Y2FsbGVyKSQvO1xuXG4vLyBDYWNoZSBgRnVuY3Rpb25gIHByb3BlcnRpZXNcbnZhciBjYWxsICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsLFxuICAgIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vKipcbiAqICMjIyBhZGRDaGFpbmFibGVNZXRob2QgKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKVxuICpcbiAqIEFkZHMgYSBtZXRob2QgdG8gYW4gb2JqZWN0LCBzdWNoIHRoYXQgdGhlIG1ldGhvZCBjYW4gYWxzbyBiZSBjaGFpbmVkLlxuICpcbiAqICAgICB1dGlscy5hZGRDaGFpbmFibGVNZXRob2QoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKHN0cikge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuZXF1YWwoc3RyKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZENoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGNoYWluaW5nQmVoYXZpb3IpO1xuICpcbiAqIFRoZSByZXN1bHQgY2FuIHRoZW4gYmUgdXNlZCBhcyBib3RoIGEgbWV0aG9kIGFzc2VydGlvbiwgZXhlY3V0aW5nIGJvdGggYG1ldGhvZGAgYW5kXG4gKiBgY2hhaW5pbmdCZWhhdmlvcmAsIG9yIGFzIGEgbGFuZ3VhZ2UgY2hhaW4sIHdoaWNoIG9ubHkgZXhlY3V0ZXMgYGNoYWluaW5nQmVoYXZpb3JgLlxuICpcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28oJ2JhcicpO1xuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvby5lcXVhbCgnZm9vJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIGBuYW1lYCwgd2hlbiBjYWxsZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4gKiBAbmFtZSBhZGRDaGFpbmFibGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QsIGNoYWluaW5nQmVoYXZpb3IpIHtcbiAgaWYgKHR5cGVvZiBjaGFpbmluZ0JlaGF2aW9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hhaW5pbmdCZWhhdmlvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgfVxuXG4gIHZhciBjaGFpbmFibGVCZWhhdmlvciA9IHtcbiAgICAgIG1ldGhvZDogbWV0aG9kXG4gICAgLCBjaGFpbmluZ0JlaGF2aW9yOiBjaGFpbmluZ0JlaGF2aW9yXG4gIH07XG5cbiAgLy8gc2F2ZSB0aGUgbWV0aG9kcyBzbyB3ZSBjYW4gb3ZlcndyaXRlIHRoZW0gbGF0ZXIsIGlmIHdlIG5lZWQgdG8uXG4gIGlmICghY3R4Ll9fbWV0aG9kcykge1xuICAgIGN0eC5fX21ldGhvZHMgPSB7fTtcbiAgfVxuICBjdHguX19tZXRob2RzW25hbWVdID0gY2hhaW5hYmxlQmVoYXZpb3I7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFpbmFibGVCZWhhdmlvci5jaGFpbmluZ0JlaGF2aW9yLmNhbGwodGhpcyk7XG5cbiAgICAgICAgdmFyIGFzc2VydCA9IGZ1bmN0aW9uIGFzc2VydCgpIHtcbiAgICAgICAgICB2YXIgb2xkX3NzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgICAgICAgaWYgKG9sZF9zc2ZpICYmIGNvbmZpZy5pbmNsdWRlU3RhY2sgPT09IGZhbHNlKVxuICAgICAgICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGFzc2VydCk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXNlIGBfX3Byb3RvX19gIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoaGFzUHJvdG9TdXBwb3J0KSB7XG4gICAgICAgICAgLy8gSW5oZXJpdCBhbGwgcHJvcGVydGllcyBmcm9tIHRoZSBvYmplY3QgYnkgcmVwbGFjaW5nIHRoZSBgRnVuY3Rpb25gIHByb3RvdHlwZVxuICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBhc3NlcnQuX19wcm90b19fID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBgY2FsbGAgYW5kIGBhcHBseWAgbWV0aG9kcyBmcm9tIGBGdW5jdGlvbmBcbiAgICAgICAgICBwcm90b3R5cGUuY2FsbCA9IGNhbGw7XG4gICAgICAgICAgcHJvdG90eXBlLmFwcGx5ID0gYXBwbHk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZWRlZmluZSBhbGwgcHJvcGVydGllcyAoc2xvdyEpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhc3NlcnRlck5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3R4KTtcbiAgICAgICAgICBhc3NlcnRlck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGFzc2VydGVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKCFleGNsdWRlTmFtZXMudGVzdChhc3NlcnRlck5hbWUpKSB7XG4gICAgICAgICAgICAgIHZhciBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBhc3NlcnRlck5hbWUpO1xuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXNzZXJ0LCBhc3NlcnRlck5hbWUsIHBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZmVyRmxhZ3ModGhpcywgYXNzZXJ0KTtcbiAgICAgICAgcmV0dXJuIGFzc2VydDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLmFkZE1ldGhvZCAoY3R4LCBuYW1lLCBtZXRob2QpXG4gKlxuICogQWRkcyBhIG1ldGhvZCB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRNZXRob2QoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChmb29TdHIpLnRvLmJlLmZvbygnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3QgdG8gd2hpY2ggdGhlIG1ldGhvZCBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIGFkZE1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgY3R4W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvbGRfc3NmaSA9IGZsYWcodGhpcywgJ3NzZmknKTtcbiAgICBpZiAob2xkX3NzZmkgJiYgY29uZmlnLmluY2x1ZGVTdGFjayA9PT0gZmFsc2UpXG4gICAgICBmbGFnKHRoaXMsICdzc2ZpJywgY3R4W25hbWVdKTtcbiAgICB2YXIgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBhZGRQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgYWRkUHJvcGVydHkgKGN0eCwgbmFtZSwgZ2V0dGVyKVxuICpcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkUHJvcGVydHkoY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLCAnZm9vJywgZnVuY3Rpb24gKCkge1xuICogICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iaikudG8uYmUuaW5zdGFuY2VvZihGb28pO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUuZm9vO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBwcm9wZXJ0eSBpcyBhZGRlZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gYWRkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgYWRkUHJvcGVydHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBnZXR0ZXIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgZmxhZyhvYmplY3QgLGtleSwgW3ZhbHVlXSlcbiAqXG4gKiBHZXQgb3Igc2V0IGEgZmxhZyB2YWx1ZSBvbiBhbiBvYmplY3QuIElmIGFcbiAqIHZhbHVlIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgc2V0LCBlbHNlIGl0IHdpbGxcbiAqIHJldHVybiB0aGUgY3VycmVudGx5IHNldCB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZlxuICogdGhlIHZhbHVlIGlzIG5vdCBzZXQuXG4gKlxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycsICdiYXInKTsgLy8gc2V0dGVyXG4gKiAgICAgdXRpbHMuZmxhZyh0aGlzLCAnZm9vJyk7IC8vIGdldHRlciwgcmV0dXJucyBgYmFyYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgKG9wdGlvbmFsKVxuICogQG5hbWUgZmxhZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIHZhciBmbGFncyA9IG9iai5fX2ZsYWdzIHx8IChvYmouX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGZsYWdzW2tleV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmxhZ3Nba2V5XTtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldEFjdHVhbCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIGdldEFjdHVhbChvYmplY3QsIFthY3R1YWxdKVxuICpcbiAqIFJldHVybnMgdGhlIGBhY3R1YWxgIHZhbHVlIGZvciBhbiBBc3NlcnRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb24pXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gY2hhaS5Bc3NlcnRpb24ucHJvdG90eXBlLmFzc2VydCBhcmd1bWVudHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MubGVuZ3RoID4gNCA/IGFyZ3NbNF0gOiBvYmouX29iajtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LFxuICogaW5oZXJpdGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAbmFtZSBnZXRFbnVtZXJhYmxlUHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBtZXNzYWdlIGNvbXBvc2l0aW9uIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpXG4gICwgZ2V0QWN0dWFsID0gcmVxdWlyZSgnLi9nZXRBY3R1YWwnKVxuICAsIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKVxuICAsIG9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyoqXG4gKiAjIyMgLmdldE1lc3NhZ2Uob2JqZWN0LCBtZXNzYWdlLCBuZWdhdGVNZXNzYWdlKVxuICpcbiAqIENvbnN0cnVjdCB0aGUgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiBmbGFnc1xuICogYW5kIHRlbXBsYXRlIHRhZ3MuIFRlbXBsYXRlIHRhZ3Mgd2lsbCByZXR1cm5cbiAqIGEgc3RyaW5naWZpZWQgaW5zcGVjdGlvbiBvZiB0aGUgb2JqZWN0IHJlZmVyZW5jZWQuXG4gKlxuICogTWVzc2FnZSB0ZW1wbGF0ZSB0YWdzOlxuICogLSBgI3t0aGlzfWAgY3VycmVudCBhc3NlcnRlZCBvYmplY3RcbiAqIC0gYCN7YWN0fWAgYWN0dWFsIHZhbHVlXG4gKiAtIGAje2V4cH1gIGV4cGVjdGVkIHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKiBAbmFtZSBnZXRNZXNzYWdlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgdmFsID0gZmxhZyhvYmosICdvYmplY3QnKVxuICAgICwgZXhwZWN0ZWQgPSBhcmdzWzNdXG4gICAgLCBhY3R1YWwgPSBnZXRBY3R1YWwob2JqLCBhcmdzKVxuICAgICwgbXNnID0gbmVnYXRlID8gYXJnc1syXSA6IGFyZ3NbMV1cbiAgICAsIGZsYWdNc2cgPSBmbGFnKG9iaiwgJ21lc3NhZ2UnKTtcblxuICBtc2cgPSBtc2cgfHwgJyc7XG4gIG1zZyA9IG1zZ1xuICAgIC5yZXBsYWNlKC8je3RoaXN9L2csIG9iakRpc3BsYXkodmFsKSlcbiAgICAucmVwbGFjZSgvI3thY3R9L2csIG9iakRpc3BsYXkoYWN0dWFsKSlcbiAgICAucmVwbGFjZSgvI3tleHB9L2csIG9iakRpc3BsYXkoZXhwZWN0ZWQpKTtcblxuICByZXR1cm4gZmxhZ01zZyA/IGZsYWdNc2cgKyAnOiAnICsgbXNnIDogbXNnO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldE5hbWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyBnZXROYW1lKGZ1bmMpXG4gKlxuICogR2V0cyB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uLCBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGEgZnVuY3Rpb24gKHVzdWFsbHkgYSBjb25zdHJ1Y3RvcilcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmIChmdW5jLm5hbWUpIHJldHVybiBmdW5jLm5hbWU7XG5cbiAgdmFyIG1hdGNoID0gL15cXHM/ZnVuY3Rpb24gKFteKF0qKVxcKC8uZXhlYyhmdW5jKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdID8gbWF0Y2hbMV0gOiBcIlwiO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldFBhdGhWYWx1ZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbG9naWNhbHBhcmFkb3gvZmlsdHJcbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRQYXRoVmFsdWUocGF0aCwgb2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgdmFsdWVzIGluIGFuXG4gKiBvYmplY3QgZ2l2ZW4gYSBzdHJpbmcgcGF0aC5cbiAqXG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgcHJvcDE6IHtcbiAqICAgICAgICAgICAgIGFycjogWydhJywgJ2InLCAnYyddXG4gKiAgICAgICAgICAgLCBzdHI6ICdIZWxsbydcbiAqICAgICAgICAgfVxuICogICAgICAgLCBwcm9wMjoge1xuICogICAgICAgICAgICAgYXJyOiBbIHsgbmVzdGVkOiAnVW5pdmVyc2UnIH0gXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8gYWdhaW4hJ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgd291bGQgYmUgdGhlIHJlc3VsdHMuXG4gKlxuICogICAgIGdldFBhdGhWYWx1ZSgncHJvcDEuc3RyJywgb2JqKTsgLy8gSGVsbG9cbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AxLmF0dFsyXScsIG9iaik7IC8vIGJcbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AyLmFyclswXS5uZXN0ZWQnLCBvYmopOyAvLyBVbml2ZXJzZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvciBgdW5kZWZpbmVkYFxuICogQG5hbWUgZ2V0UGF0aFZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnZhciBnZXRQYXRoVmFsdWUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXRoLCBvYmopIHtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aChwYXRoKTtcbiAgcmV0dXJuIF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopO1xufTtcblxuLyohXG4gKiAjIyBwYXJzZVBhdGgocGF0aClcbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBwYXJzZSBzdHJpbmcgb2JqZWN0XG4gKiBwYXRocy4gVXNlIGluIGNvbmp1bmN0aW9uIHdpdGggYF9nZXRQYXRoVmFsdWVgLlxuICpcbiAqICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlUGF0aCgnbXlvYmplY3QucHJvcGVydHkuc3VicHJvcCcpO1xuICpcbiAqICMjIyBQYXRoczpcbiAqXG4gKiAqIENhbiBiZSBhcyBuZWFyIGluZmluaXRlbHkgZGVlcCBhbmQgbmVzdGVkXG4gKiAqIEFycmF5cyBhcmUgYWxzbyB2YWxpZCB1c2luZyB0aGUgZm9ybWFsIGBteW9iamVjdC5kb2N1bWVudFszXS5wcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBhcnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBzdHIgPSBwYXRoLnJlcGxhY2UoL1xcWy9nLCAnLlsnKVxuICAgICwgcGFydHMgPSBzdHIubWF0Y2goLyhcXFxcXFwufFteLl0rPykrL2cpO1xuICByZXR1cm4gcGFydHMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZSA9IC9cXFsoXFxkKylcXF0kL1xuICAgICAgLCBtQXJyID0gcmUuZXhlYyh2YWx1ZSlcbiAgICBpZiAobUFycikgcmV0dXJuIHsgaTogcGFyc2VGbG9hdChtQXJyWzFdKSB9O1xuICAgIGVsc2UgcmV0dXJuIHsgcDogdmFsdWUgfTtcbiAgfSk7XG59O1xuXG4vKiFcbiAqICMjIF9nZXRQYXRoVmFsdWUocGFyc2VkLCBvYmopXG4gKlxuICogSGVscGVyIGNvbXBhbmlvbiBmdW5jdGlvbiBmb3IgYC5wYXJzZVBhdGhgIHRoYXQgcmV0dXJuc1xuICogdGhlIHZhbHVlIGxvY2F0ZWQgYXQgdGhlIHBhcnNlZCBhZGRyZXNzLlxuICpcbiAqICAgICAgdmFyIHZhbHVlID0gZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkIGRlZmluaXRpb24gZnJvbSBgcGFyc2VQYXRoYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gc2VhcmNoIGFnYWluc3RcbiAqIEByZXR1cm5zIHtPYmplY3R8VW5kZWZpbmVkfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBhdGhWYWx1ZSAocGFyc2VkLCBvYmopIHtcbiAgdmFyIHRtcCA9IG9ialxuICAgICwgcmVzO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBpZiAodG1wKSB7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJ0LnApXG4gICAgICAgIHRtcCA9IHRtcFtwYXJ0LnBdO1xuICAgICAgZWxzZSBpZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBwYXJ0LmkpXG4gICAgICAgIHRtcCA9IHRtcFtwYXJ0LmldO1xuICAgICAgaWYgKGkgPT0gKGwgLSAxKSkgcmVzID0gdG1wO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0UHJvcGVydGllcyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgLmdldFByb3BlcnRpZXMob2JqZWN0KVxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSByZXRyaWV2YWwgb2YgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LCBlbnVtZXJhYmxlIG9yIG5vdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWUgZ2V0UHJvcGVydGllc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFByb3BlcnRpZXMob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdWJqZWN0KTtcblxuICBmdW5jdGlvbiBhZGRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xKSB7XG4gICAgICByZXN1bHQucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHN1YmplY3QpO1xuICB3aGlsZSAocHJvdG8gIT09IG51bGwpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bykuZm9yRWFjaChhZGRQcm9wZXJ0eSk7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNYWluIGV4cG9ydHNcbiAqL1xuXG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qIVxuICogdGVzdCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50ZXN0ID0gcmVxdWlyZSgnLi90ZXN0Jyk7XG5cbi8qIVxuICogdHlwZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50eXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qIVxuICogbWVzc2FnZSB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRNZXNzYWdlID0gcmVxdWlyZSgnLi9nZXRNZXNzYWdlJyk7XG5cbi8qIVxuICogYWN0dWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJyk7XG5cbi8qIVxuICogSW5zcGVjdCB1dGlsXG4gKi9cblxuZXhwb3J0cy5pbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG5cbi8qIVxuICogT2JqZWN0IERpc3BsYXkgdXRpbFxuICovXG5cbmV4cG9ydHMub2JqRGlzcGxheSA9IHJlcXVpcmUoJy4vb2JqRGlzcGxheScpO1xuXG4vKiFcbiAqIEZsYWcgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKiFcbiAqIEZsYWcgdHJhbnNmZXJyaW5nIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLnRyYW5zZmVyRmxhZ3MgPSByZXF1aXJlKCcuL3RyYW5zZmVyRmxhZ3MnKTtcblxuLyohXG4gKiBEZWVwIGVxdWFsIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmVxbCA9IHJlcXVpcmUoJ2RlZXAtZXFsJyk7XG5cbi8qIVxuICogRGVlcCBwYXRoIHZhbHVlXG4gKi9cblxuZXhwb3J0cy5nZXRQYXRoVmFsdWUgPSByZXF1aXJlKCcuL2dldFBhdGhWYWx1ZScpO1xuXG4vKiFcbiAqIEZ1bmN0aW9uIG5hbWVcbiAqL1xuXG5leHBvcnRzLmdldE5hbWUgPSByZXF1aXJlKCcuL2dldE5hbWUnKTtcblxuLyohXG4gKiBhZGQgUHJvcGVydHlcbiAqL1xuXG5leHBvcnRzLmFkZFByb3BlcnR5ID0gcmVxdWlyZSgnLi9hZGRQcm9wZXJ0eScpO1xuXG4vKiFcbiAqIGFkZCBNZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZE1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkTWV0aG9kJyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlUHJvcGVydHknKTtcblxuLyohXG4gKiBvdmVyd3JpdGUgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZU1ldGhvZCcpO1xuXG4vKiFcbiAqIEFkZCBhIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLmFkZENoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vYWRkQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbi8qIVxuICogT3ZlcndyaXRlIGNoYWluYWJsZSBtZXRob2RcbiAqL1xuXG5leHBvcnRzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IHJlcXVpcmUoJy4vb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kJyk7XG5cbiIsIi8vIFRoaXMgaXMgKGFsbW9zdCkgZGlyZWN0bHkgZnJvbSBOb2RlLmpzIHV0aWxzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvYmxvYi9mOGMzMzVkMGNhZjQ3ZjE2ZDMxNDEzZjg5YWEyOGVkYTM4NzhlM2FhL2xpYi91dGlsLmpzXG5cbnZhciBnZXROYW1lID0gcmVxdWlyZSgnLi9nZXROYW1lJyk7XG52YXIgZ2V0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0UHJvcGVydGllcycpO1xudmFyIGdldEVudW1lcmFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9nZXRFbnVtZXJhYmxlUHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3BlY3Q7XG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd0hpZGRlbiBGbGFnIHRoYXQgc2hvd3MgaGlkZGVuIChub3QgZW51bWVyYWJsZSlcbiAqICAgIHByb3BlcnRpZXMgb2Ygb2JqZWN0cy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXB0aCBEZXB0aCBpbiB3aGljaCB0byBkZXNjZW5kIGluIG9iamVjdC4gRGVmYXVsdCBpcyAyLlxuICogQHBhcmFtIHtCb29sZWFufSBjb2xvcnMgRmxhZyB0byB0dXJuIG9uIEFOU0kgZXNjYXBlIGNvZGVzIHRvIGNvbG9yIHRoZVxuICogICAgb3V0cHV0LiBEZWZhdWx0IGlzIGZhbHNlIChubyBjb2xvcmluZykuXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBjdHggPSB7XG4gICAgc2hvd0hpZGRlbjogc2hvd0hpZGRlbixcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHI7IH1cbiAgfTtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufVxuXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMDQ0MTI4L1xudmFyIGdldE91dGVySFRNTCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgaWYgKCdvdXRlckhUTUwnIGluIGVsZW1lbnQpIHJldHVybiBlbGVtZW50Lm91dGVySFRNTDtcbiAgdmFyIG5zID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobnMsICdfJyk7XG4gIHZhciBlbGVtUHJvdG8gPSAod2luZG93LkhUTUxFbGVtZW50IHx8IHdpbmRvdy5FbGVtZW50KS5wcm90b3R5cGU7XG4gIHZhciB4bWxTZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcbiAgdmFyIGh0bWw7XG4gIGlmIChkb2N1bWVudC54bWxWZXJzaW9uKSB7XG4gICAgcmV0dXJuIHhtbFNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQuY2xvbmVOb2RlKGZhbHNlKSk7XG4gICAgaHRtbCA9IGNvbnRhaW5lci5pbm5lckhUTUwucmVwbGFjZSgnPjwnLCAnPicgKyBlbGVtZW50LmlubmVySFRNTCArICc8Jyk7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgIHJldHVybiBodG1sO1xuICB9XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnQuXG52YXIgaXNET01FbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0ICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0Lm5vZGVUeXBlID09PSAxICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgfVxufTtcblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5zcGVjdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcyk7XG4gICAgaWYgKHR5cGVvZiByZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gSWYgaXQncyBET00gZWxlbSwgZ2V0IG91dGVyIEhUTUwuXG4gIGlmIChpc0RPTUVsZW1lbnQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGdldE91dGVySFRNTCh2YWx1ZSk7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciB2aXNpYmxlS2V5cyA9IGdldEVudW1lcmFibGVQcm9wZXJ0aWVzKHZhbHVlKTtcbiAgdmFyIGtleXMgPSBjdHguc2hvd0hpZGRlbiA/IGdldFByb3BlcnRpZXModmFsdWUpIDogdmlzaWJsZUtleXM7XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAvLyBJbiBJRSwgZXJyb3JzIGhhdmUgYSBzaW5nbGUgYHN0YWNrYCBwcm9wZXJ0eSwgb3IgaWYgdGhleSBhcmUgdmFuaWxsYSBgRXJyb3JgLFxuICAvLyBhIGBzdGFja2AgcGx1cyBgZGVzY3JpcHRpb25gIHByb3BlcnR5OyBpZ25vcmUgdGhvc2UgZm9yIGNvbnNpc3RlbmN5LlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgfHwgKGlzRXJyb3IodmFsdWUpICYmIChcbiAgICAgIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnc3RhY2snKSB8fFxuICAgICAgKGtleXMubGVuZ3RoID09PSAyICYmIGtleXNbMF0gPT09ICdkZXNjcmlwdGlvbicgJiYga2V5c1sxXSA9PT0gJ3N0YWNrJylcbiAgICAgKSkpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgICAgdmFyIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWVTdWZmaXggKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBuYW1lID0gZ2V0TmFtZSh2YWx1ZSk7XG4gICAgdmFyIG5hbWVTdWZmaXggPSBuYW1lID8gJzogJyArIG5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbmFtZVN1ZmZpeCArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICB9XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyO1xuICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXykge1xuICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aXNpYmxlS2V5cy5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKHZhbHVlW2tleV0pIDwgMCkge1xuICAgICAgaWYgKHJlY3Vyc2VUaW1lcyA9PT0gbnVsbCkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlW2tleV0sIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKHR5cGVvZiBhciA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoYXIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiBvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcbn1cblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiLyohXG4gKiBDaGFpIC0gZmxhZyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2luc3BlY3QnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyoqXG4gKiAjIyMgLm9iakRpc3BsYXkgKG9iamVjdClcbiAqXG4gKiBEZXRlcm1pbmVzIGlmIGFuIG9iamVjdCBvciBhbiBhcnJheSBtYXRjaGVzXG4gKiBjcml0ZXJpYSB0byBiZSBpbnNwZWN0ZWQgaW4tbGluZSBmb3IgZXJyb3JcbiAqIG1lc3NhZ2VzIG9yIHNob3VsZCBiZSB0cnVuY2F0ZWQuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gamF2YXNjcmlwdCBvYmplY3QgdG8gaW5zcGVjdFxuICogQG5hbWUgb2JqRGlzcGxheVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9IGluc3BlY3Qob2JqKVxuICAgICwgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuXG4gIGlmIChjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQgJiYgc3RyLmxlbmd0aCA+PSBjb25maWcudHJ1bmNhdGVUaHJlc2hvbGQpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgcmV0dXJuICFvYmoubmFtZSB8fCBvYmoubmFtZSA9PT0gJydcbiAgICAgICAgPyAnW0Z1bmN0aW9uXSdcbiAgICAgICAgOiAnW0Z1bmN0aW9uOiAnICsgb2JqLm5hbWUgKyAnXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gJ1sgQXJyYXkoJyArIG9iai5sZW5ndGggKyAnKSBdJztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLCBrc3RyID0ga2V5cy5sZW5ndGggPiAyXG4gICAgICAgICAgPyBrZXlzLnNwbGljZSgwLCAyKS5qb2luKCcsICcpICsgJywgLi4uJ1xuICAgICAgICAgIDoga2V5cy5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuICd7IE9iamVjdCAoJyArIGtzdHIgKyAnKSB9JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kIChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIGNoYWluYWJsZSBtZXRob2RcbiAqIGFuZCBwcm92aWRlcyBhY2Nlc3MgdG8gdGhlIHByZXZpb3VzIGZ1bmN0aW9uIG9yXG4gKiBwcm9wZXJ0eS4gIE11c3QgcmV0dXJuIGZ1bmN0aW9ucyB0byBiZSB1c2VkIGZvclxuICogbmFtZS5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2xlbmd0aCcsXG4gKiAgICAgICBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICB9XG4gKiAgICAgLCBmdW5jdGlvbiAoX3N1cGVyKSB7XG4gKiAgICAgICB9XG4gKiAgICAgKTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCgnZm9vJywgZm4sIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGgoMyk7XG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5oYXZlLmxlbmd0aC5hYm92ZSgzKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBtZXRob2QgLyBwcm9wZXJ0eSBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgbWV0aG9kIC8gcHJvcGVydHkgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hhaW5pbmdCZWhhdmlvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBwcm9wZXJ0eVxuICogQG5hbWUgb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gIHZhciBjaGFpbmFibGVCZWhhdmlvciA9IGN0eC5fX21ldGhvZHNbbmFtZV07XG5cbiAgdmFyIF9jaGFpbmluZ0JlaGF2aW9yID0gY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvcjtcbiAgY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2hhaW5pbmdCZWhhdmlvcihfY2hhaW5pbmdCZWhhdmlvcikuY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xuXG4gIHZhciBfbWV0aG9kID0gY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kO1xuICBjaGFpbmFibGVCZWhhdmlvci5tZXRob2QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZChfbWV0aG9kKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gb3ZlcndyaXRlTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBvdmVyd3JpdGVNZXRob2QgKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgbWV0aG9kIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIGZ1bmN0aW9uLiBNdXN0IHJldHVybiBmdW5jdGlvblxuICogdG8gYmUgdXNlZCBmb3IgbmFtZS5cbiAqXG4gKiAgICAgdXRpbHMub3ZlcndyaXRlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2VxdWFsJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai52YWx1ZSkudG8uZXF1YWwoc3RyKTtcbiAqICAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmVxdWFsKCdiYXInKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBtZXRob2QgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBvdmVyd3JpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZSBvdmVyd3JpdGVNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3R4LCBuYW1lLCBtZXRob2QpIHtcbiAgdmFyIF9tZXRob2QgPSBjdHhbbmFtZV1cbiAgICAsIF9zdXBlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbiAgaWYgKF9tZXRob2QgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9tZXRob2QpXG4gICAgX3N1cGVyID0gX21ldGhvZDtcblxuICBjdHhbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZChfc3VwZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfVxufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZVByb3BlcnR5IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyBvdmVyd3JpdGVQcm9wZXJ0eSAoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBwcm9wZXJ0eSBnZXR0ZXIgYW5kIHByb3ZpZGVzXG4gKiBhY2Nlc3MgdG8gcHJldmlvdXMgdmFsdWUuIE11c3QgcmV0dXJuIGZ1bmN0aW9uIHRvIHVzZSBhcyBnZXR0ZXIuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZVByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ29rJywgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgICAgdmFyIG9iaiA9IHV0aWxzLmZsYWcodGhpcywgJ29iamVjdCcpO1xuICogICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgRm9vKSB7XG4gKiAgICAgICAgICAgbmV3IGNoYWkuQXNzZXJ0aW9uKG9iai5uYW1lKS50by5lcXVhbCgnYmFyJyk7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVQcm9wZXJ0eSgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5iZS5vaztcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB3aG9zZSBwcm9wZXJ0eSBpcyB0byBiZSBvdmVyd3JpdHRlblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgcHJvcGVydHkgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZ2V0dGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIG92ZXJ3cml0ZVByb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIHZhciBfZ2V0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjdHgsIG5hbWUpXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBpZiAoX2dldCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgX2dldC5nZXQpXG4gICAgX3N1cGVyID0gX2dldC5nZXRcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBuYW1lLFxuICAgIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXR0ZXIoX3N1cGVyKS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIHRlc3QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbi8qKlxuICogIyB0ZXN0KG9iamVjdCwgZXhwcmVzc2lvbilcbiAqXG4gKiBUZXN0IGFuZCBvYmplY3QgZm9yIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHZhciBuZWdhdGUgPSBmbGFnKG9iaiwgJ25lZ2F0ZScpXG4gICAgLCBleHByID0gYXJnc1swXTtcbiAgcmV0dXJuIG5lZ2F0ZSA/ICFleHByIDogZXhwcjtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0cmFuc2ZlckZsYWdzIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyB0cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsID0gdHJ1ZSlcbiAqXG4gKiBUcmFuc2ZlciBhbGwgdGhlIGZsYWdzIGZvciBgYXNzZXJ0aW9uYCB0byBgb2JqZWN0YC4gSWZcbiAqIGBpbmNsdWRlQWxsYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhlbiB0aGUgYmFzZSBDaGFpXG4gKiBhc3NlcnRpb24gZmxhZ3MgKG5hbWVseSBgb2JqZWN0YCwgYHNzZmlgLCBhbmQgYG1lc3NhZ2VgKVxuICogd2lsbCBub3QgYmUgdHJhbnNmZXJyZWQuXG4gKlxuICpcbiAqICAgICB2YXIgbmV3QXNzZXJ0aW9uID0gbmV3IEFzc2VydGlvbigpO1xuICogICAgIHV0aWxzLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBuZXdBc3NlcnRpb24pO1xuICpcbiAqICAgICB2YXIgYW5vdGhlckFzc2VyaXRvbiA9IG5ldyBBc3NlcnRpb24obXlPYmopO1xuICogICAgIHV0aWxzLnRyYW5zZmVyRmxhZ3MoYXNzZXJ0aW9uLCBhbm90aGVyQXNzZXJ0aW9uLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtBc3NlcnRpb259IGFzc2VydGlvbiB0aGUgYXNzZXJ0aW9uIHRvIHRyYW5zZmVyIHRoZSBmbGFncyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRoZSBvYmplY3QgdG8gdHJhbnNmZXIgdGhlIGZsYWdzIHRvbzsgdXN1YWxseSBhIG5ldyBhc3NlcnRpb25cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZUFsbFxuICogQG5hbWUgZ2V0QWxsRmxhZ3NcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFzc2VydGlvbiwgb2JqZWN0LCBpbmNsdWRlQWxsKSB7XG4gIHZhciBmbGFncyA9IGFzc2VydGlvbi5fX2ZsYWdzIHx8IChhc3NlcnRpb24uX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG4gIGlmICghb2JqZWN0Ll9fZmxhZ3MpIHtcbiAgICBvYmplY3QuX19mbGFncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpbmNsdWRlQWxsID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMyA/IGluY2x1ZGVBbGwgOiB0cnVlO1xuXG4gIGZvciAodmFyIGZsYWcgaW4gZmxhZ3MpIHtcbiAgICBpZiAoaW5jbHVkZUFsbCB8fFxuICAgICAgICAoZmxhZyAhPT0gJ29iamVjdCcgJiYgZmxhZyAhPT0gJ3NzZmknICYmIGZsYWcgIT0gJ21lc3NhZ2UnKSkge1xuICAgICAgb2JqZWN0Ll9fZmxhZ3NbZmxhZ10gPSBmbGFnc1tmbGFnXTtcbiAgICB9XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0eXBlIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIERldGVjdGFibGUgamF2YXNjcmlwdCBuYXRpdmVzXG4gKi9cblxudmFyIG5hdGl2ZXMgPSB7XG4gICAgJ1tvYmplY3QgQXJndW1lbnRzXSc6ICdhcmd1bWVudHMnXG4gICwgJ1tvYmplY3QgQXJyYXldJzogJ2FycmF5J1xuICAsICdbb2JqZWN0IERhdGVdJzogJ2RhdGUnXG4gICwgJ1tvYmplY3QgRnVuY3Rpb25dJzogJ2Z1bmN0aW9uJ1xuICAsICdbb2JqZWN0IE51bWJlcl0nOiAnbnVtYmVyJ1xuICAsICdbb2JqZWN0IFJlZ0V4cF0nOiAncmVnZXhwJ1xuICAsICdbb2JqZWN0IFN0cmluZ10nOiAnc3RyaW5nJ1xufTtcblxuLyoqXG4gKiAjIyMgdHlwZShvYmplY3QpXG4gKlxuICogQmV0dGVyIGltcGxlbWVudGF0aW9uIG9mIGB0eXBlb2ZgIGRldGVjdGlvbiB0aGF0IGNhblxuICogYmUgdXNlZCBjcm9zcy1icm93c2VyLiBIYW5kbGVzIHRoZSBpbmNvbnNpc3RlbmNpZXMgb2ZcbiAqIEFycmF5LCBgbnVsbGAsIGFuZCBgdW5kZWZpbmVkYCBkZXRlY3Rpb24uXG4gKlxuICogICAgIHV0aWxzLnR5cGUoe30pIC8vICdvYmplY3QnXG4gKiAgICAgdXRpbHMudHlwZShudWxsKSAvLyBgbnVsbCdcbiAqICAgICB1dGlscy50eXBlKHVuZGVmaW5lZCkgLy8gYHVuZGVmaW5lZGBcbiAqICAgICB1dGlscy50eXBlKFtdKSAvLyBgYXJyYXlgXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIGRldGVjdCB0eXBlIG9mXG4gKiBAbmFtZSB0eXBlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICBpZiAobmF0aXZlc1tzdHJdKSByZXR1cm4gbmF0aXZlc1tzdHJdO1xuICBpZiAob2JqID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKG9iaiA9PT0gT2JqZWN0KG9iaikpIHJldHVybiAnb2JqZWN0JztcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59O1xuIiwiLyohXG4gKiBhc3NlcnRpb24tZXJyb3JcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBxdWFsaWFuY3kuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHdpbGwgY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIG9uZSBvYmplY3QgdG8gYW5vdGhlciBleGNsdWRpbmcgYW55IG9yaWdpbmFsbHlcbiAqIGxpc3RlZC4gUmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBjcmVhdGUgYSBuZXcgYHt9YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhjbHVkZWQgcHJvcGVydGllcyAuLi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGV4Y2x1ZGUgKCkge1xuICB2YXIgZXhjbHVkZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgZnVuY3Rpb24gZXhjbHVkZVByb3BzIChyZXMsIG9iaikge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIX5leGNsdWRlcy5pbmRleE9mKGtleSkpIHJlc1trZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gZXh0ZW5kRXhjbHVkZSAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICwgaSA9IDBcbiAgICAgICwgcmVzID0ge307XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4Y2x1ZGVQcm9wcyhyZXMsIGFyZ3NbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG59O1xuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogIyMjIEFzc2VydGlvbkVycm9yXG4gKlxuICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBKYXZhU2NyaXB0IGBFcnJvcmAgY29uc3RydWN0b3IgZm9yXG4gKiBhc3NlcnRpb24gYW5kIHZhbGlkYXRpb24gc2NlbmFyaW9zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyB0byBpbmNsdWRlIChvcHRpb25hbClcbiAqIEBwYXJhbSB7Y2FsbGVlfSBzdGFydCBzdGFjayBmdW5jdGlvbiAob3B0aW9uYWwpXG4gKi9cblxuZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3IgKG1lc3NhZ2UsIF9wcm9wcywgc3NmKSB7XG4gIHZhciBleHRlbmQgPSBleGNsdWRlKCduYW1lJywgJ21lc3NhZ2UnLCAnc3RhY2snLCAnY29uc3RydWN0b3InLCAndG9KU09OJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKF9wcm9wcyB8fCB7fSk7XG5cbiAgLy8gZGVmYXVsdCB2YWx1ZXNcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVW5zcGVjaWZpZWQgQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLnNob3dEaWZmID0gZmFsc2U7XG5cbiAgLy8gY29weSBmcm9tIHByb3BlcnRpZXNcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdGhpc1trZXldID0gcHJvcHNba2V5XTtcbiAgfVxuXG4gIC8vIGNhcHR1cmUgc3RhY2sgdHJhY2VcbiAgc3NmID0gc3NmIHx8IGFyZ3VtZW50cy5jYWxsZWU7XG4gIGlmIChzc2YgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzc2YpO1xuICB9XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEVycm9yLnByb3RvdHlwZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblxuLyohXG4gKiBTdGF0aWNhbGx5IHNldCBuYW1lXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuXG4vKiFcbiAqIEVuc3VyZSBjb3JyZWN0IGNvbnN0cnVjdG9yXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzZXJ0aW9uRXJyb3I7XG5cbi8qKlxuICogQWxsb3cgZXJyb3JzIHRvIGJlIGNvbnZlcnRlZCB0byBKU09OIGZvciBzdGF0aWMgdHJhbnNmZXIuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlIHN0YWNrIChkZWZhdWx0OiBgdHJ1ZWApXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCB0aGF0IGNhbiBiZSBgSlNPTi5zdHJpbmdpZnlgXG4gKi9cblxuQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChzdGFjaykge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnY29uc3RydWN0b3InLCAndG9KU09OJywgJ3N0YWNrJylcbiAgICAsIHByb3BzID0gZXh0ZW5kKHsgbmFtZTogdGhpcy5uYW1lIH0sIHRoaXMpO1xuXG4gIC8vIGluY2x1ZGUgc3RhY2sgaWYgZXhpc3RzIGFuZCBub3QgdHVybmVkIG9mZlxuICBpZiAoZmFsc2UgIT09IHN0YWNrICYmIHRoaXMuc3RhY2spIHtcbiAgICBwcm9wcy5zdGFjayA9IHRoaXMuc3RhY2s7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9lcWwnKTtcbiIsIi8qIVxuICogZGVlcC1lcWxcbiAqIENvcHlyaWdodChjKSAyMDEzIEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIHR5cGUgPSByZXF1aXJlKCd0eXBlLWRldGVjdCcpO1xuXG4vKiFcbiAqIEJ1ZmZlci5pc0J1ZmZlciBicm93c2VyIHNoaW1cbiAqL1xuXG52YXIgQnVmZmVyO1xudHJ5IHsgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyOyB9XG5jYXRjaChleCkge1xuICBCdWZmZXIgPSB7fTtcbiAgQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfVxufVxuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwRXF1YWw7XG5cbi8qKlxuICogQXNzZXJ0IHN1cGVyLXN0cmljdCAoZWdhbCkgZXF1YWxpdHkgYmV0d2VlblxuICogdHdvIG9iamVjdHMgb2YgYW55IHR5cGUuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHBhcmFtIHtBcnJheX0gbWVtb2lzZWQgKG9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYiwgbSkge1xuICBpZiAoc2FtZVZhbHVlKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoJ2RhdGUnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIGRhdGVFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmICgncmVnZXhwJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiByZWdleHBFcXVhbChhLCBiKTtcbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYSkpIHtcbiAgICByZXR1cm4gYnVmZmVyRXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoJ2FyZ3VtZW50cycgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzRXF1YWwoYSwgYiwgbSk7XG4gIH0gZWxzZSBpZiAoIXR5cGVFcXVhbChhLCBiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmICgoJ29iamVjdCcgIT09IHR5cGUoYSkgJiYgJ29iamVjdCcgIT09IHR5cGUoYikpXG4gICYmICgnYXJyYXknICE9PSB0eXBlKGEpICYmICdhcnJheScgIT09IHR5cGUoYikpKSB7XG4gICAgcmV0dXJuIHNhbWVWYWx1ZShhLCBiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqZWN0RXF1YWwoYSwgYiwgbSk7XG4gIH1cbn1cblxuLyohXG4gKiBTdHJpY3QgKGVnYWwpIGVxdWFsaXR5IHRlc3QuIEVuc3VyZXMgdGhhdCBOYU4gYWx3YXlzXG4gKiBlcXVhbHMgTmFOIGFuZCBgLTBgIGRvZXMgbm90IGVxdWFsIGArMGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gZXF1YWwgbWF0Y2hcbiAqL1xuXG5mdW5jdGlvbiBzYW1lVmFsdWUoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdGhlIHR5cGVzIG9mIHR3byBnaXZlbiBvYmplY3RzIGFuZFxuICogcmV0dXJuIGlmIHRoZXkgYXJlIGVxdWFsLiBOb3RlIHRoYXQgYW4gQXJyYXlcbiAqIGhhcyBhIHR5cGUgb2YgYGFycmF5YCAobm90IGBvYmplY3RgKSBhbmQgYXJndW1lbnRzXG4gKiBoYXZlIGEgdHlwZSBvZiBgYXJndW1lbnRzYCAobm90IGBhcnJheWAvYG9iamVjdGApLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIHR5cGVFcXVhbChhLCBiKSB7XG4gIHJldHVybiB0eXBlKGEpID09PSB0eXBlKGIpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIERhdGUgb2JqZWN0cyBieSBhc3NlcnRpbmcgdGhhdFxuICogdGhlIHRpbWUgdmFsdWVzIGFyZSBlcXVhbCB1c2luZyBgc2F2ZVZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV9IGFcbiAqIEBwYXJhbSB7RGF0ZX0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZGF0ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKCdkYXRlJyAhPT0gdHlwZShiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gc2FtZVZhbHVlKGEuZ2V0VGltZSgpLCBiLmdldFRpbWUoKSk7XG59XG5cbi8qIVxuICogQ29tcGFyZSB0d28gcmVndWxhciBleHByZXNzaW9ucyBieSBjb252ZXJ0aW5nIHRoZW1cbiAqIHRvIHN0cmluZyBhbmQgY2hlY2tpbmcgZm9yIGBzYW1lVmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7UmVnRXhwfSBhXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwRXF1YWwoYSwgYikge1xuICBpZiAoJ3JlZ2V4cCcgIT09IHR5cGUoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNhbWVWYWx1ZShhLnRvU3RyaW5nKCksIGIudG9TdHJpbmcoKSk7XG59XG5cbi8qIVxuICogQXNzZXJ0IGRlZXAgZXF1YWxpdHkgb2YgdHdvIGBhcmd1bWVudHNgIG9iamVjdHMuXG4gKiBVbmZvcnR1bmF0ZWx5LCB0aGVzZSBtdXN0IGJlIHNsaWNlZCB0byBhcnJheXNcbiAqIHByaW9yIHRvIHRlc3QgdG8gZW5zdXJlIG5vIGJhZCBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0FyZ3VtZW50c30gYVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IG1lbW9pemUgKG9wdGlvbmFsKVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gYXJndW1lbnRzRXF1YWwoYSwgYiwgbSkge1xuICBpZiAoJ2FyZ3VtZW50cycgIT09IHR5cGUoYikpIHJldHVybiBmYWxzZTtcbiAgYSA9IFtdLnNsaWNlLmNhbGwoYSk7XG4gIGIgPSBbXS5zbGljZS5jYWxsKGIpO1xuICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG0pO1xufVxuXG4vKiFcbiAqIEdldCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEByZXR1cm4ge0FycmF5fSBwcm9wZXJ0eSBuYW1lc1xuICovXG5cbmZ1bmN0aW9uIGVudW1lcmFibGUoYSkge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBhKSByZXMucHVzaChrZXkpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKiFcbiAqIFNpbXBsZSBlcXVhbGl0eSBmb3IgZmxhdCBpdGVyYWJsZSBvYmplY3RzXG4gKiBzdWNoIGFzIEFycmF5cyBvciBOb2RlLmpzIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtJdGVyYWJsZX0gYVxuICogQHBhcmFtIHtJdGVyYWJsZX0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gaXRlcmFibGVFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gIGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbWF0Y2ggPSB0cnVlO1xuXG4gIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoO1xufVxuXG4vKiFcbiAqIEV4dGVuc2lvbiB0byBgaXRlcmFibGVFcXVhbGAgc3BlY2lmaWNhbGx5XG4gKiBmb3IgTm9kZS5qcyBCdWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBidWZmZXJFcXVhbChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpdGVyYWJsZUVxdWFsKGEsIGIpO1xufVxuXG4vKiFcbiAqIEJsb2NrIGZvciBgb2JqZWN0RXF1YWxgIGVuc3VyaW5nIG5vbi1leGlzdGluZ1xuICogdmFsdWVzIGRvbid0IGdldCBpbi5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsdWUoYSkge1xuICByZXR1cm4gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgY2hlY2sgdGhlIGVxdWFsaXR5IG9mIHR3byBvYmplY3RzLlxuICogT25jZSBiYXNpYyBzYW1lbmVzcyBoYXMgYmVlbiBlc3RhYmxpc2hlZCBpdCB3aWxsXG4gKiBkZWZlciB0byBgZGVlcEVxdWFsYCBmb3IgZWFjaCBlbnVtZXJhYmxlIGtleVxuICogaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBvYmplY3RFcXVhbChhLCBiLCBtKSB7XG4gIGlmICghaXNWYWx1ZShhKSB8fCAhaXNWYWx1ZShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKG0pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKChtW2ldWzBdID09PSBhICYmIG1baV1bMV0gPT09IGIpXG4gICAgICB8fCAgKG1baV1bMF0gPT09IGIgJiYgbVtpXVsxXSA9PT0gYSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG0gPSBbXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGthID0gZW51bWVyYWJsZShhKTtcbiAgICB2YXIga2IgPSBlbnVtZXJhYmxlKGIpO1xuICB9IGNhdGNoIChleCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuXG4gIGlmICghaXRlcmFibGVFcXVhbChrYSwga2IpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbS5wdXNoKFsgYSwgYiBdKTtcblxuICB2YXIga2V5O1xuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi90eXBlJyk7XG4iLCIvKiFcbiAqIHR5cGUtZGV0ZWN0XG4gKiBDb3B5cmlnaHQoYykgMjAxMyBqYWtlIGx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUHJpbWFyeSBFeHBvcnRzXG4gKi9cblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGdldFR5cGU7XG5cbi8qIVxuICogRGV0ZWN0YWJsZSBqYXZhc2NyaXB0IG5hdGl2ZXNcbiAqL1xuXG52YXIgbmF0aXZlcyA9IHtcbiAgICAnW29iamVjdCBBcnJheV0nOiAnYXJyYXknXG4gICwgJ1tvYmplY3QgUmVnRXhwXSc6ICdyZWdleHAnXG4gICwgJ1tvYmplY3QgRnVuY3Rpb25dJzogJ2Z1bmN0aW9uJ1xuICAsICdbb2JqZWN0IEFyZ3VtZW50c10nOiAnYXJndW1lbnRzJ1xuICAsICdbb2JqZWN0IERhdGVdJzogJ2RhdGUnXG59O1xuXG4vKipcbiAqICMjIyB0eXBlT2YgKG9iailcbiAqXG4gKiBVc2Ugc2V2ZXJhbCBkaWZmZXJlbnQgdGVjaG5pcXVlcyB0byBkZXRlcm1pbmVcbiAqIHRoZSB0eXBlIG9mIG9iamVjdCBiZWluZyB0ZXN0ZWQuXG4gKlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfSBvYmplY3QgdHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBnZXRUeXBlIChvYmopIHtcbiAgdmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xuICBpZiAobmF0aXZlc1tzdHJdKSByZXR1cm4gbmF0aXZlc1tzdHJdO1xuICBpZiAob2JqID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAob2JqID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKG9iaiA9PT0gT2JqZWN0KG9iaikpIHJldHVybiAnb2JqZWN0JztcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59XG5cbmV4cG9ydHMuTGlicmFyeSA9IExpYnJhcnk7XG5cbi8qKlxuICogIyMjIExpYnJhcnlcbiAqXG4gKiBDcmVhdGUgYSByZXBvc2l0b3J5IGZvciBjdXN0b20gdHlwZSBkZXRlY3Rpb24uXG4gKlxuICogYGBganNcbiAqIHZhciBsaWIgPSBuZXcgdHlwZS5MaWJyYXJ5O1xuICogYGBgXG4gKlxuICovXG5cbmZ1bmN0aW9uIExpYnJhcnkgKCkge1xuICB0aGlzLnRlc3RzID0ge307XG59XG5cbi8qKlxuICogIyMjIyAub2YgKG9iailcbiAqXG4gKiBFeHBvc2UgcmVwbGFjZW1lbnQgYHR5cGVvZmAgZGV0ZWN0aW9uIHRvIHRoZSBsaWJyYXJ5LlxuICpcbiAqIGBgYGpzXG4gKiBpZiAoJ3N0cmluZycgPT09IGxpYi5vZignaGVsbG8gd29ybGQnKSkge1xuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byB0ZXN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IHR5cGVcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5vZiA9IGdldFR5cGU7XG5cbi8qKlxuICogIyMjIyAuZGVmaW5lICh0eXBlLCB0ZXN0KVxuICpcbiAqIEFkZCBhIHRlc3QgdG8gZm9yIHRoZSBgLnRlc3QoKWAgYXNzZXJ0aW9uLlxuICpcbiAqIENhbiBiZSBkZWZpbmVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdpbnQnLCAvXlswLTldKyQvKTtcbiAqIGBgYFxuICpcbiAqIC4uLiBvciBhcyBhIGZ1bmN0aW9uOlxuICpcbiAqIGBgYGpzXG4gKiBsaWIuZGVmaW5lKCdibG4nLCBmdW5jdGlvbiAob2JqKSB7XG4gKiAgIGlmICgnYm9vbGVhbicgPT09IGxpYi5vZihvYmopKSByZXR1cm4gdHJ1ZTtcbiAqICAgdmFyIGJsbnMgPSBbICd5ZXMnLCAnbm8nLCAndHJ1ZScsICdmYWxzZScsIDEsIDAgXTtcbiAqICAgaWYgKCdzdHJpbmcnID09PSBsaWIub2Yob2JqKSkgb2JqID0gb2JqLnRvTG93ZXJDYXNlKCk7XG4gKiAgIHJldHVybiAhISB+Ymxucy5pbmRleE9mKG9iaik7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbn0gdGVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiAodHlwZSwgdGVzdCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMudGVzdHNbdHlwZV07XG4gIHRoaXMudGVzdHNbdHlwZV0gPSB0ZXN0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogIyMjIyAudGVzdCAob2JqLCB0ZXN0KVxuICpcbiAqIEFzc2VydCB0aGF0IGFuIG9iamVjdCBpcyBvZiB0eXBlLiBXaWxsIGZpcnN0XG4gKiBjaGVjayBuYXRpdmVzLCBhbmQgaWYgdGhhdCBkb2VzIG5vdCBwYXNzIGl0IHdpbGxcbiAqIHVzZSB0aGUgdXNlciBkZWZpbmVkIGN1c3RvbSB0ZXN0cy5cbiAqXG4gKiBgYGBqc1xuICogYXNzZXJ0KGxpYi50ZXN0KCcxJywgJ2ludCcpKTtcbiAqIGFzc2VydChsaWIudGVzdCgneWVzJywgJ2JsbicpKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaWJyYXJ5LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKG9iaiwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gZ2V0VHlwZShvYmopKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHRlc3QgPSB0aGlzLnRlc3RzW3R5cGVdO1xuXG4gIGlmICh0ZXN0ICYmICdyZWdleHAnID09PSBnZXRUeXBlKHRlc3QpKSB7XG4gICAgcmV0dXJuIHRlc3QudGVzdChvYmopO1xuICB9IGVsc2UgaWYgKHRlc3QgJiYgJ2Z1bmN0aW9uJyA9PT0gZ2V0VHlwZSh0ZXN0KSkge1xuICAgIHJldHVybiB0ZXN0KG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdUeXBlIHRlc3QgXCInICsgdHlwZSArICdcIiBub3QgZGVmaW5lZCBvciBpbnZhbGlkLicpO1xuICB9XG59O1xuIiwiLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgZm9yaW46IHRydWUsIG5vbWVuOiBmYWxzZSwgcmVnZXhwOiBmYWxzZSwgcGx1c3BsdXM6IGZhbHNlKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgX19kaXJuYW1lLCBkb2N1bWVudCovXG4vKipcbiAqIFNpbm9uIGNvcmUgdXRpbGl0aWVzLiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzaW5vbiA9IChmdW5jdGlvbiAoZm9ybWF0aW8pIHtcbiAgICB2YXIgZGl2ID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIGlzRE9NTm9kZShvYmopIHtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqLmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICBzdWNjZXNzID0gZGl2LnBhcmVudE5vZGUgPT0gb2JqO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9iai5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmYWlsZWQsIG5vdCBtdWNoIHdlIGNhbiBkbyBhYm91dCB0aGF0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiBkaXYgJiYgb2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSAmJiBpc0RPTU5vZGUob2JqKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiIHx8ICEhKG9iaiAmJiBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNhbGwgJiYgb2JqLmFwcGx5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1JlYWxseU5hTih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWlycm9yUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh0YXJnZXQsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNSZXN0b3JhYmxlIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLnJlc3RvcmUgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmoucmVzdG9yZS5zaW5vbjtcbiAgICB9XG5cbiAgICB2YXIgc2lub24gPSB7XG4gICAgICAgIHdyYXBNZXRob2Q6IGZ1bmN0aW9uIHdyYXBNZXRob2Qob2JqZWN0LCBwcm9wZXJ0eSwgbWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAoIW9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTaG91bGQgd3JhcCBwcm9wZXJ0eSBvZiBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNZXRob2Qgd3JhcHBlciBzaG91bGQgYmUgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3cmFwcGVkTWV0aG9kID0gb2JqZWN0W3Byb3BlcnR5XSxcbiAgICAgICAgICAgICAgICBlcnJvcjtcblxuICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHdyYXBwZWRNZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFwiQXR0ZW1wdGVkIHRvIHdyYXAgXCIgKyAodHlwZW9mIHdyYXBwZWRNZXRob2QpICsgXCIgcHJvcGVydHkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgKyBcIiBhcyBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdyYXBwZWRNZXRob2QucmVzdG9yZSAmJiB3cmFwcGVkTWV0aG9kLnJlc3RvcmUuc2lub24pIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBUeXBlRXJyb3IoXCJBdHRlbXB0ZWQgdG8gd3JhcCBcIiArIHByb3BlcnR5ICsgXCIgd2hpY2ggaXMgYWxyZWFkeSB3cmFwcGVkXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod3JhcHBlZE1ldGhvZC5jYWxsZWRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmVyYiA9ICEhd3JhcHBlZE1ldGhvZC5yZXR1cm5zID8gXCJzdHViYmVkXCIgOiBcInNwaWVkIG9uXCI7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFwiQXR0ZW1wdGVkIHRvIHdyYXAgXCIgKyBwcm9wZXJ0eSArIFwiIHdoaWNoIGlzIGFscmVhZHkgXCIgKyB2ZXJiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdyYXBwZWRNZXRob2QuX3N0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnN0YWNrICs9ICdcXG4tLS0tLS0tLS0tLS0tLVxcbicgKyB3cmFwcGVkTWV0aG9kLl9zdGFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElFIDggZG9lcyBub3Qgc3VwcG9ydCBoYXNPd25Qcm9wZXJ0eSBvbiB0aGUgd2luZG93IG9iamVjdCBhbmQgRmlyZWZveCBoYXMgYSBwcm9ibGVtXG4gICAgICAgICAgICAvLyB3aGVuIHVzaW5nIGhhc093bi5jYWxsIG9uIG9iamVjdHMgZnJvbSBvdGhlciBmcmFtZXMuXG4gICAgICAgICAgICB2YXIgb3duZWQgPSBvYmplY3QuaGFzT3duUHJvcGVydHkgPyBvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHkpIDogaGFzT3duLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gbWV0aG9kO1xuICAgICAgICAgICAgbWV0aG9kLmRpc3BsYXlOYW1lID0gcHJvcGVydHk7XG4gICAgICAgICAgICAvLyBTZXQgdXAgYSBzdGFjayB0cmFjZSB3aGljaCBjYW4gYmUgdXNlZCBsYXRlciB0byBmaW5kIHdoYXQgbGluZSBvZlxuICAgICAgICAgICAgLy8gY29kZSB0aGUgb3JpZ2luYWwgbWV0aG9kIHdhcyBjcmVhdGVkIG9uLlxuICAgICAgICAgICAgbWV0aG9kLl9zdGFjayA9IChuZXcgRXJyb3IoJ1N0YWNrIFRyYWNlIGZvciBvcmlnaW5hbCcpKS5zdGFjaztcblxuICAgICAgICAgICAgbWV0aG9kLnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHByb3RvdHlwZSBwcm9wZXJ0aWVzIHRyeSB0byByZXNldCBieSBkZWxldGUgZmlyc3QuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmYWlscyAoZXg6IGxvY2FsU3RvcmFnZSBvbiBtb2JpbGUgc2FmYXJpKSB0aGVuIGZvcmNlIGEgcmVzZXRcbiAgICAgICAgICAgICAgICAvLyB2aWEgZGlyZWN0IGFzc2lnbm1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFvd25lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdFtwcm9wZXJ0eV0gPT09IG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gd3JhcHBlZE1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBtZXRob2QucmVzdG9yZS5zaW5vbiA9IHRydWU7XG4gICAgICAgICAgICBtaXJyb3JQcm9wZXJ0aWVzKG1ldGhvZCwgd3JhcHBlZE1ldGhvZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBhcmd1bWVudHNbaV1bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBET05UIEVOVU0gYnVnLCBvbmx5IGNhcmUgYWJvdXQgdG9TdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShcInRvU3RyaW5nXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbaV0udG9TdHJpbmcgIT0gdGFyZ2V0LnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQudG9TdHJpbmcgPSBhcmd1bWVudHNbaV0udG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUocHJvdG8pIHtcbiAgICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVlcEVxdWFsOiBmdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICAgICAgICAgICAgaWYgKHNpbm9uLm1hdGNoICYmIHNpbm9uLm1hdGNoLmlzTWF0Y2hlcihhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnRlc3QoYik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlYWxseU5hTihhKSAmJiBpc1JlYWxseU5hTihiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0VsZW1lbnQoYSkgfHwgaXNFbGVtZW50KGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgoYSA9PT0gbnVsbCAmJiBiICE9PSBudWxsKSB8fCAoYSAhPT0gbnVsbCAmJiBiID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHAgJiYgYiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICByZXR1cm4gKGEuc291cmNlID09PSBiLnNvdXJjZSkgJiYgKGEuZ2xvYmFsID09PSBiLmdsb2JhbCkgJiZcbiAgICAgICAgICAgICAgICAoYS5pZ25vcmVDYXNlID09PSBiLmlnbm9yZUNhc2UpICYmIChhLm11bHRpbGluZSA9PT0gYi5tdWx0aWxpbmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYVN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKTtcbiAgICAgICAgICAgIGlmIChhU3RyaW5nICE9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFTdHJpbmcgPT0gXCJbb2JqZWN0IERhdGVdXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvcCwgYUxlbmd0aCA9IDAsIGJMZW5ndGggPSAwO1xuXG4gICAgICAgICAgICBpZiAoYVN0cmluZyA9PSBcIltvYmplY3QgQXJyYXldXCIgJiYgYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHByb3AgaW4gYSkge1xuICAgICAgICAgICAgICAgIGFMZW5ndGggKz0gMTtcblxuICAgICAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFbcHJvcF0sIGJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBiKSB7XG4gICAgICAgICAgICAgICAgYkxlbmd0aCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYUxlbmd0aCA9PSBiTGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZ1bmMpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZnVuYy5kaXNwbGF5TmFtZSB8fCBmdW5jLm5hbWU7XG5cbiAgICAgICAgICAgIC8vIFVzZSBmdW5jdGlvbiBkZWNvbXBvc2l0aW9uIGFzIGEgbGFzdCByZXNvcnQgdG8gZ2V0IGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBuYW1lLiBEb2VzIG5vdCByZWx5IG9uIGZ1bmN0aW9uIGRlY29tcG9zaXRpb24gdG8gd29yayAtIGlmIGl0XG4gICAgICAgICAgICAvLyBkb2Vzbid0IGRlYnVnZ2luZyB3aWxsIGJlIHNsaWdodGx5IGxlc3MgaW5mb3JtYXRpdmVcbiAgICAgICAgICAgIC8vIChpLmUuIHRvU3RyaW5nIHdpbGwgc2F5ICdzcHknIHJhdGhlciB0aGFuICdteUZ1bmMnKS5cbiAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gZnVuYy50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvbiAoW15cXHNcXChdKykvKTtcbiAgICAgICAgICAgICAgICBuYW1lID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfSxcblxuICAgICAgICBmdW5jdGlvblRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdldENhbGwgJiYgdGhpcy5jYWxsQ291bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1ZhbHVlLCBwcm9wLCBpID0gdGhpcy5jYWxsQ291bnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNWYWx1ZSA9IHRoaXMuZ2V0Q2FsbChpKS50aGlzVmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwcm9wIGluIHRoaXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNWYWx1ZVtwcm9wXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5TmFtZSB8fCBcInNpbm9uIGZha2VcIjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb25maWc6IGZ1bmN0aW9uIChjdXN0b20pIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB7fTtcbiAgICAgICAgICAgIGN1c3RvbSA9IGN1c3RvbSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IHNpbm9uLmRlZmF1bHRDb25maWc7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnW3Byb3BdID0gY3VzdG9tLmhhc093blByb3BlcnR5KHByb3ApID8gY3VzdG9tW3Byb3BdIDogZGVmYXVsdHNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVmYXVsdENvbmZpZzoge1xuICAgICAgICAgICAgaW5qZWN0SW50b1RoaXM6IHRydWUsXG4gICAgICAgICAgICBpbmplY3RJbnRvOiBudWxsLFxuICAgICAgICAgICAgcHJvcGVydGllczogW1wic3B5XCIsIFwic3R1YlwiLCBcIm1vY2tcIiwgXCJjbG9ja1wiLCBcInNlcnZlclwiLCBcInJlcXVlc3RzXCJdLFxuICAgICAgICAgICAgdXNlRmFrZVRpbWVyczogdHJ1ZSxcbiAgICAgICAgICAgIHVzZUZha2VTZXJ2ZXI6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICB0aW1lc0luV29yZHM6IGZ1bmN0aW9uIHRpbWVzSW5Xb3Jkcyhjb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ID09IDEgJiYgXCJvbmNlXCIgfHxcbiAgICAgICAgICAgICAgICBjb3VudCA9PSAyICYmIFwidHdpY2VcIiB8fFxuICAgICAgICAgICAgICAgIGNvdW50ID09IDMgJiYgXCJ0aHJpY2VcIiB8fFxuICAgICAgICAgICAgICAgIChjb3VudCB8fCAwKSArIFwiIHRpbWVzXCI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbGVkSW5PcmRlcjogZnVuY3Rpb24gKHNwaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHNwaWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghc3BpZXNbaSAtIDFdLmNhbGxlZEJlZm9yZShzcGllc1tpXSkgfHwgIXNwaWVzW2ldLmNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcmRlckJ5Rmlyc3RDYWxsOiBmdW5jdGlvbiAoc3BpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGllcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgLy8gdXVpZCwgd29uJ3QgZXZlciBiZSBlcXVhbFxuICAgICAgICAgICAgICAgIHZhciBhQ2FsbCA9IGEuZ2V0Q2FsbCgwKTtcbiAgICAgICAgICAgICAgICB2YXIgYkNhbGwgPSBiLmdldENhbGwoMCk7XG4gICAgICAgICAgICAgICAgdmFyIGFJZCA9IGFDYWxsICYmIGFDYWxsLmNhbGxJZCB8fCAtMTtcbiAgICAgICAgICAgICAgICB2YXIgYklkID0gYkNhbGwgJiYgYkNhbGwuY2FsbElkIHx8IC0xO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFJZCA8IGJJZCA/IC0xIDogMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvZzogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgbG9nRXJyb3I6IGZ1bmN0aW9uIChsYWJlbCwgZXJyKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gbGFiZWwgKyBcIiB0aHJldyBleGNlcHRpb246IFwiO1xuICAgICAgICAgICAgc2lub24ubG9nKG1zZyArIFwiW1wiICsgZXJyLm5hbWUgKyBcIl0gXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoZXJyLnN0YWNrKSB7IHNpbm9uLmxvZyhlcnIuc3RhY2spOyB9XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gbXNnICsgZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHlwZU9mOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoOCwgc3RyaW5nLmxlbmd0aCAtIDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlU3R1Ykluc3RhbmNlOiBmdW5jdGlvbiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igc2hvdWxkIGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpbm9uLnN0dWIoc2lub24uY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc3RvcmFibGUob2JqZWN0W3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3Byb3BdLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVzdG9yYWJsZShvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaXNOb2RlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cztcbiAgICB2YXIgaXNBTUQgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kO1xuXG4gICAgaWYgKGlzQU1EKSB7XG4gICAgICAgIGRlZmluZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHNpbm9uO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzTm9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9ybWF0aW8gPSByZXF1aXJlKFwiZm9ybWF0aW9cIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gc2lub247XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLnNweSA9IHJlcXVpcmUoXCIuL3Npbm9uL3NweVwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuc3B5Q2FsbCA9IHJlcXVpcmUoXCIuL3Npbm9uL2NhbGxcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLmJlaGF2aW9yID0gcmVxdWlyZShcIi4vc2lub24vYmVoYXZpb3JcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLnN0dWIgPSByZXF1aXJlKFwiLi9zaW5vbi9zdHViXCIpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5tb2NrID0gcmVxdWlyZShcIi4vc2lub24vbW9ja1wiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuY29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuL3Npbm9uL2NvbGxlY3Rpb25cIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLmFzc2VydCA9IHJlcXVpcmUoXCIuL3Npbm9uL2Fzc2VydFwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuc2FuZGJveCA9IHJlcXVpcmUoXCIuL3Npbm9uL3NhbmRib3hcIik7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzLnRlc3QgPSByZXF1aXJlKFwiLi9zaW5vbi90ZXN0XCIpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy50ZXN0Q2FzZSA9IHJlcXVpcmUoXCIuL3Npbm9uL3Rlc3RfY2FzZVwiKTtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMuYXNzZXJ0ID0gcmVxdWlyZShcIi4vc2lub24vYXNzZXJ0XCIpO1xuICAgICAgICBtb2R1bGUuZXhwb3J0cy5tYXRjaCA9IHJlcXVpcmUoXCIuL3Npbm9uL21hdGNoXCIpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXRpbykge1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0aW8uY29uZmlndXJlKHsgcXVvdGVTdHJpbmdzOiBmYWxzZSB9KTtcbiAgICAgICAgc2lub24uZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5hc2NpaS5hcHBseShmb3JtYXR0ZXIsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc05vZGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG4gICAgICAgICAgICBzaW5vbi5mb3JtYXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUudG9TdHJpbmcgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPyB1dGlsLmluc3BlY3QodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBOb2RlLCBidXQgbm8gdXRpbCBtb2R1bGUgLSB3b3VsZCBiZSB2ZXJ5IG9sZCwgYnV0IGJldHRlciBzYWZlIHRoYW5cbiAgICAgICAgICAgICBzb3JyeSAqL1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbm9uO1xufSh0eXBlb2YgZm9ybWF0aW8gPT0gXCJvYmplY3RcIiAmJiBmb3JtYXRpbykpO1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBAZGVwZW5kIC4uL3Npbm9uLmpzXG4gKiBAZGVwZW5kIHN0dWIuanNcbiAqL1xuLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgbm9tZW46IGZhbHNlLCBwbHVzcGx1czogZmFsc2UqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlLCBzaW5vbiovXG4vKipcbiAqIEFzc2VydGlvbnMgbWF0Y2hpbmcgdGhlIHRlc3Qgc3B5IHJldHJpZXZhbCBpbnRlcmZhY2UuXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbiAoc2lub24sIGdsb2JhbCkge1xuICAgIHZhciBjb21tb25KU01vZHVsZSA9IHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHM7XG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIHZhciBhc3NlcnQ7XG5cbiAgICBpZiAoIXNpbm9uICYmIGNvbW1vbkpTTW9kdWxlKSB7XG4gICAgICAgIHNpbm9uID0gcmVxdWlyZShcIi4uL3Npbm9uXCIpO1xuICAgIH1cblxuICAgIGlmICghc2lub24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZlcmlmeUlzU3R1YigpIHtcbiAgICAgICAgdmFyIG1ldGhvZDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbChcImZha2UgaXMgbm90IGEgc3B5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbChtZXRob2QgKyBcIiBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuZ2V0Q2FsbCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZmFpbChtZXRob2QgKyBcIiBpcyBub3Qgc3R1YmJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWxBc3NlcnRpb24ob2JqZWN0LCBtc2cpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0IHx8IGdsb2JhbDtcbiAgICAgICAgdmFyIGZhaWxNZXRob2QgPSBvYmplY3QuZmFpbCB8fCBhc3NlcnQuZmFpbDtcbiAgICAgICAgZmFpbE1ldGhvZC5jYWxsKG9iamVjdCwgbXNnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtaXJyb3JQcm9wQXNBc3NlcnRpb24obmFtZSwgbWV0aG9kLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXRob2Q7XG4gICAgICAgICAgICBtZXRob2QgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0W25hbWVdID0gZnVuY3Rpb24gKGZha2UpIHtcbiAgICAgICAgICAgIHZlcmlmeUlzU3R1YihmYWtlKTtcblxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICB2YXIgZmFpbGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGZhaWxlZCA9ICFtZXRob2QoZmFrZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZhaWxlZCA9IHR5cGVvZiBmYWtlW21ldGhvZF0gPT0gXCJmdW5jdGlvblwiID9cbiAgICAgICAgICAgICAgICAgICAgIWZha2VbbWV0aG9kXS5hcHBseShmYWtlLCBhcmdzKSA6ICFmYWtlW21ldGhvZF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICBmYWlsQXNzZXJ0aW9uKHRoaXMsIGZha2UucHJpbnRmLmFwcGx5KGZha2UsIFttZXNzYWdlXS5jb25jYXQoYXJncykpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LnBhc3MobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3NlZE5hbWUocHJlZml4LCBwcm9wKSB7XG4gICAgICAgIHJldHVybiAhcHJlZml4IHx8IC9eZmFpbC8udGVzdChwcm9wKSA/IHByb3AgOlxuICAgICAgICAgICAgcHJlZml4ICsgcHJvcC5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBhc3NlcnQgPSB7XG4gICAgICAgIGZhaWxFeGNlcHRpb246IFwiQXNzZXJ0RXJyb3JcIixcblxuICAgICAgICBmYWlsOiBmdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSB0aGlzLmZhaWxFeGNlcHRpb24gfHwgYXNzZXJ0LmZhaWxFeGNlcHRpb247XG5cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhc3M6IGZ1bmN0aW9uIHBhc3MoYXNzZXJ0aW9uKSB7fSxcblxuICAgICAgICBjYWxsT3JkZXI6IGZ1bmN0aW9uIGFzc2VydENhbGxPcmRlcigpIHtcbiAgICAgICAgICAgIHZlcmlmeUlzU3R1Yi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkID0gXCJcIiwgYWN0dWFsID0gXCJcIjtcblxuICAgICAgICAgICAgaWYgKCFzaW5vbi5jYWxsZWRJbk9yZGVyKGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsIFwiLCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYWxscyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBjYWxscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxzWy0taV0uY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbCA9IHNpbm9uLm9yZGVyQnlGaXJzdENhbGwoY2FsbHMpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZmFpbHMsIHdlJ2xsIGp1c3QgZmFsbCBiYWNrIHRvIHRoZSBibGFuayBzdHJpbmdcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmYWlsQXNzZXJ0aW9uKHRoaXMsIFwiZXhwZWN0ZWQgXCIgKyBleHBlY3RlZCArIFwiIHRvIGJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FsbGVkIGluIG9yZGVyIGJ1dCB3ZXJlIGNhbGxlZCBhcyBcIiArIGFjdHVhbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydC5wYXNzKFwiY2FsbE9yZGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGxDb3VudDogZnVuY3Rpb24gYXNzZXJ0Q2FsbENvdW50KG1ldGhvZCwgY291bnQpIHtcbiAgICAgICAgICAgIHZlcmlmeUlzU3R1YihtZXRob2QpO1xuXG4gICAgICAgICAgICBpZiAobWV0aG9kLmNhbGxDb3VudCAhPSBjb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCBcIiArIHNpbm9uLnRpbWVzSW5Xb3Jkcyhjb3VudCkgK1xuICAgICAgICAgICAgICAgICAgICBcIiBidXQgd2FzIGNhbGxlZCAlYyVDXCI7XG4gICAgICAgICAgICAgICAgZmFpbEFzc2VydGlvbih0aGlzLCBtZXRob2QucHJpbnRmKG1zZykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQucGFzcyhcImNhbGxDb3VudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBleHBvc2U6IGZ1bmN0aW9uIGV4cG9zZSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRhcmdldCBpcyBudWxsIG9yIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG8gPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHR5cGVvZiBvLnByZWZpeCA9PSBcInVuZGVmaW5lZFwiICYmIFwiYXNzZXJ0XCIgfHwgby5wcmVmaXg7XG4gICAgICAgICAgICB2YXIgaW5jbHVkZUZhaWwgPSB0eXBlb2Ygby5pbmNsdWRlRmFpbCA9PSBcInVuZGVmaW5lZFwiIHx8ICEhby5pbmNsdWRlRmFpbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgbWV0aG9kIGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9IFwiZXhwb3J0XCIgJiYgKGluY2x1ZGVGYWlsIHx8ICEvXihmYWlsKS8udGVzdChtZXRob2QpKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbZXhwb3NlZE5hbWUocHJlZml4LCBtZXRob2QpXSA9IHRoaXNbbWV0aG9kXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF0Y2g6IGZ1bmN0aW9uIG1hdGNoKGFjdHVhbCwgZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGVyID0gc2lub24ubWF0Y2goZXhwZWN0YXRpb24pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIudGVzdChhY3R1YWwpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LnBhc3MoXCJtYXRjaFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZCA9IFtcbiAgICAgICAgICAgICAgICAgICAgXCJleHBlY3RlZCB2YWx1ZSB0byBtYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICBcIiAgICBleHBlY3RlZCA9IFwiICsgc2lub24uZm9ybWF0KGV4cGVjdGF0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgXCIgICAgYWN0dWFsID0gXCIgKyBzaW5vbi5mb3JtYXQoYWN0dWFsKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICBmYWlsQXNzZXJ0aW9uKHRoaXMsIGZvcm1hdHRlZC5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJjYWxsZWRcIiwgXCJleHBlY3RlZCAlbiB0byBoYXZlIGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2UgYnV0IHdhcyBuZXZlciBjYWxsZWRcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwibm90Q2FsbGVkXCIsIGZ1bmN0aW9uIChzcHkpIHsgcmV0dXJuICFzcHkuY2FsbGVkOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVjdGVkICVuIHRvIG5vdCBoYXZlIGJlZW4gY2FsbGVkIGJ1dCB3YXMgY2FsbGVkICVjJUNcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiY2FsbGVkT25jZVwiLCBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCBvbmNlIGJ1dCB3YXMgY2FsbGVkICVjJUNcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiY2FsbGVkVHdpY2VcIiwgXCJleHBlY3RlZCAlbiB0byBiZSBjYWxsZWQgdHdpY2UgYnV0IHdhcyBjYWxsZWQgJWMlQ1wiKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJjYWxsZWRUaHJpY2VcIiwgXCJleHBlY3RlZCAlbiB0byBiZSBjYWxsZWQgdGhyaWNlIGJ1dCB3YXMgY2FsbGVkICVjJUNcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiY2FsbGVkT25cIiwgXCJleHBlY3RlZCAlbiB0byBiZSBjYWxsZWQgd2l0aCAlMSBhcyB0aGlzIGJ1dCB3YXMgY2FsbGVkIHdpdGggJXRcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiYWx3YXlzQ2FsbGVkT25cIiwgXCJleHBlY3RlZCAlbiB0byBhbHdheXMgYmUgY2FsbGVkIHdpdGggJTEgYXMgdGhpcyBidXQgd2FzIGNhbGxlZCB3aXRoICV0XCIpO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImNhbGxlZFdpdGhOZXdcIiwgXCJleHBlY3RlZCAlbiB0byBiZSBjYWxsZWQgd2l0aCBuZXdcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiYWx3YXlzQ2FsbGVkV2l0aE5ld1wiLCBcImV4cGVjdGVkICVuIHRvIGFsd2F5cyBiZSBjYWxsZWQgd2l0aCBuZXdcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiY2FsbGVkV2l0aFwiLCBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyAlKiVDXCIpO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImNhbGxlZFdpdGhNYXRjaFwiLCBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB3aXRoIG1hdGNoICUqJUNcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiYWx3YXlzQ2FsbGVkV2l0aFwiLCBcImV4cGVjdGVkICVuIHRvIGFsd2F5cyBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHMgJSolQ1wiKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJhbHdheXNDYWxsZWRXaXRoTWF0Y2hcIiwgXCJleHBlY3RlZCAlbiB0byBhbHdheXMgYmUgY2FsbGVkIHdpdGggbWF0Y2ggJSolQ1wiKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJjYWxsZWRXaXRoRXhhY3RseVwiLCBcImV4cGVjdGVkICVuIHRvIGJlIGNhbGxlZCB3aXRoIGV4YWN0IGFyZ3VtZW50cyAlKiVDXCIpO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcImFsd2F5c0NhbGxlZFdpdGhFeGFjdGx5XCIsIFwiZXhwZWN0ZWQgJW4gdG8gYWx3YXlzIGJlIGNhbGxlZCB3aXRoIGV4YWN0IGFyZ3VtZW50cyAlKiVDXCIpO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcIm5ldmVyQ2FsbGVkV2l0aFwiLCBcImV4cGVjdGVkICVuIHRvIG5ldmVyIGJlIGNhbGxlZCB3aXRoIGFyZ3VtZW50cyAlKiVDXCIpO1xuICAgIG1pcnJvclByb3BBc0Fzc2VydGlvbihcIm5ldmVyQ2FsbGVkV2l0aE1hdGNoXCIsIFwiZXhwZWN0ZWQgJW4gdG8gbmV2ZXIgYmUgY2FsbGVkIHdpdGggbWF0Y2ggJSolQ1wiKTtcbiAgICBtaXJyb3JQcm9wQXNBc3NlcnRpb24oXCJ0aHJld1wiLCBcIiVuIGRpZCBub3QgdGhyb3cgZXhjZXB0aW9uJUNcIik7XG4gICAgbWlycm9yUHJvcEFzQXNzZXJ0aW9uKFwiYWx3YXlzVGhyZXdcIiwgXCIlbiBkaWQgbm90IGFsd2F5cyB0aHJvdyBleGNlcHRpb24lQ1wiKTtcblxuICAgIGlmIChjb21tb25KU01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5vbi5hc3NlcnQgPSBhc3NlcnQ7XG4gICAgfVxufSh0eXBlb2Ygc2lub24gPT0gXCJvYmplY3RcIiAmJiBzaW5vbiB8fCBudWxsLCB0eXBlb2Ygd2luZG93ICE9IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT0gXCJ1bmRlZmluZWRcIikgPyBzZWxmIDogZ2xvYmFsKSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQGRlcGVuZCAuLi9zaW5vbi5qc1xuICovXG4vKmpzbGludCBlcWVxZXE6IGZhbHNlLCBvbmV2YXI6IGZhbHNlKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgc2lub24sIHByb2Nlc3MsIHNldEltbWVkaWF0ZSwgc2V0VGltZW91dCovXG4vKipcbiAqIFN0dWIgYmVoYXZpb3JcbiAqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBhdXRob3IgVGltIEZpc2NoYmFjaCAobWFpbEB0aW1maXNjaGJhY2guZGUpXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbiAoc2lub24pIHtcbiAgICB2YXIgY29tbW9uSlNNb2R1bGUgPSB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cztcblxuICAgIGlmICghc2lub24gJiYgY29tbW9uSlNNb2R1bGUpIHtcbiAgICAgICAgc2lub24gPSByZXF1aXJlKFwiLi4vc2lub25cIik7XG4gICAgfVxuXG4gICAgaWYgKCFzaW5vbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIHZhciBqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW47XG4gICAgdmFyIHByb3RvO1xuXG4gICAgdmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgZnVuY3Rpb24gdGhyb3dzRXhjZXB0aW9uKGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhpcy5leGNlcHRpb24gPSBuZXcgRXJyb3IobWVzc2FnZSB8fCBcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9uLm5hbWUgPSBlcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9uID0gbmV3IEVycm9yKFwiRXJyb3JcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4Y2VwdGlvbiA9IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2soYmVoYXZpb3IsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGNhbGxBcmdBdCA9IGJlaGF2aW9yLmNhbGxBcmdBdDtcblxuICAgICAgICBpZiAoY2FsbEFyZ0F0IDwgMCkge1xuICAgICAgICAgICAgdmFyIGNhbGxBcmdQcm9wID0gYmVoYXZpb3IuY2FsbEFyZ1Byb3A7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxBcmdQcm9wICYmIHR5cGVvZiBhcmdzW2ldID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsbEFyZ1Byb3AgJiYgYXJnc1tpXSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYXJnc1tpXVtjYWxsQXJnUHJvcF0gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2ldW2NhbGxBcmdQcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyZ3NbY2FsbEFyZ0F0XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxsYmFja0Vycm9yKGJlaGF2aW9yLCBmdW5jLCBhcmdzKSB7XG4gICAgICAgIGlmIChiZWhhdmlvci5jYWxsQXJnQXQgPCAwKSB7XG4gICAgICAgICAgICB2YXIgbXNnO1xuXG4gICAgICAgICAgICBpZiAoYmVoYXZpb3IuY2FsbEFyZ1Byb3ApIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBzaW5vbi5mdW5jdGlvbk5hbWUoYmVoYXZpb3Iuc3R1YikgK1xuICAgICAgICAgICAgICAgICAgICBcIiBleHBlY3RlZCB0byB5aWVsZCB0byAnXCIgKyBiZWhhdmlvci5jYWxsQXJnUHJvcCArXG4gICAgICAgICAgICAgICAgICAgIFwiJywgYnV0IG5vIG9iamVjdCB3aXRoIHN1Y2ggYSBwcm9wZXJ0eSB3YXMgcGFzc2VkLlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBzaW5vbi5mdW5jdGlvbk5hbWUoYmVoYXZpb3Iuc3R1YikgK1xuICAgICAgICAgICAgICAgICAgICBcIiBleHBlY3RlZCB0byB5aWVsZCwgYnV0IG5vIGNhbGxiYWNrIHdhcyBwYXNzZWQuXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gXCIgUmVjZWl2ZWQgW1wiICsgam9pbi5jYWxsKGFyZ3MsIFwiLCBcIikgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcImFyZ3VtZW50IGF0IGluZGV4IFwiICsgYmVoYXZpb3IuY2FsbEFyZ0F0ICsgXCIgaXMgbm90IGEgZnVuY3Rpb246IFwiICsgZnVuYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soYmVoYXZpb3IsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiZWhhdmlvci5jYWxsQXJnQXQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBnZXRDYWxsYmFjayhiZWhhdmlvciwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGdldENhbGxiYWNrRXJyb3IoYmVoYXZpb3IsIGZ1bmMsIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJlaGF2aW9yLmNhbGxiYWNrQXN5bmMpIHtcbiAgICAgICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseShiZWhhdmlvci5jYWxsYmFja0NvbnRleHQsIGJlaGF2aW9yLmNhbGxiYWNrQXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShiZWhhdmlvci5jYWxsYmFja0NvbnRleHQsIGJlaGF2aW9yLmNhbGxiYWNrQXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RvID0ge1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKHN0dWIpIHtcbiAgICAgICAgICAgIHZhciBiZWhhdmlvciA9IHNpbm9uLmV4dGVuZCh7fSwgc2lub24uYmVoYXZpb3IpO1xuICAgICAgICAgICAgZGVsZXRlIGJlaGF2aW9yLmNyZWF0ZTtcbiAgICAgICAgICAgIGJlaGF2aW9yLnN0dWIgPSBzdHViO1xuXG4gICAgICAgICAgICByZXR1cm4gYmVoYXZpb3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNQcmVzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHRoaXMuY2FsbEFyZ0F0ID09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhjZXB0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLnJldHVybkFyZ0F0ID09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuVGhpcyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHVyblZhbHVlRGVmaW5lZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW52b2tlOiBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgICAgICAgICBjYWxsQ2FsbGJhY2sodGhpcywgYXJncyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZXhjZXB0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5yZXR1cm5BcmdBdCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW3RoaXMucmV0dXJuQXJnQXRdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJldHVyblRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0dXJuVmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYWxsOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R1Yi5vbkNhbGwoaW5kZXgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRmlyc3RDYWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0dWIub25GaXJzdENhbGwoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblNlY29uZENhbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R1Yi5vblNlY29uZENhbGwoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblRoaXJkQ2FsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHViLm9uVGhpcmRDYWxsKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2l0aEFyZ3M6IGZ1bmN0aW9uKC8qIGFyZ3VtZW50cyAqLykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZpbmluZyBhIHN0dWIgYnkgaW52b2tpbmcgXCJzdHViLm9uQ2FsbCguLi4pLndpdGhBcmdzKC4uLilcIiBpcyBub3Qgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXNlIFwic3R1Yi53aXRoQXJncyguLi4pLm9uQ2FsbCguLi4pXCIgdG8gZGVmaW5lIHNlcXVlbnRpYWwgYmVoYXZpb3IgZm9yIGNhbGxzIHdpdGggY2VydGFpbiBhcmd1bWVudHMuJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbHNBcmc6IGZ1bmN0aW9uIGNhbGxzQXJnKHBvcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBpbmRleCBpcyBub3QgbnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbGxBcmdBdCA9IHBvcztcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBcmd1bWVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5jYWxsQXJnUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBjYWxsc0FyZ09uOiBmdW5jdGlvbiBjYWxsc0FyZ09uKHBvcywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBpbmRleCBpcyBub3QgbnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgY29udGV4dCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbGxBcmdBdCA9IHBvcztcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBcmd1bWVudHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuY2FsbEFyZ1Byb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQXN5bmMgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbHNBcmdXaXRoOiBmdW5jdGlvbiBjYWxsc0FyZ1dpdGgocG9zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvcyAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFyZ0F0ID0gcG9zO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FyZ3VtZW50cyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5jYWxsQXJnUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBjYWxsc0FyZ09uV2l0aDogZnVuY3Rpb24gY2FsbHNBcmdXaXRoKHBvcywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBpbmRleCBpcyBub3QgbnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgY29udGV4dCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbGxBcmdBdCA9IHBvcztcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLmNhbGxBcmdQcm9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FzeW5jID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHlpZWxkczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsQXJnQXQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY2FsbEFyZ1Byb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQXN5bmMgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgeWllbGRzT246IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBjb250ZXh0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbEFyZ0F0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQXJndW1lbnRzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgdGhpcy5jYWxsQXJnUHJvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB5aWVsZHNUbzogZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbEFyZ0F0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrQXJndW1lbnRzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmNhbGxBcmdQcm9wID0gcHJvcDtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tBc3luYyA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICB5aWVsZHNUb09uOiBmdW5jdGlvbiAocHJvcCwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgY29udGV4dCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbGxBcmdBdCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FyZ3VtZW50cyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHRoaXMuY2FsbEFyZ1Byb3AgPSBwcm9wO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FzeW5jID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgXCJ0aHJvd3NcIjogdGhyb3dzRXhjZXB0aW9uLFxuICAgICAgICB0aHJvd3NFeGNlcHRpb246IHRocm93c0V4Y2VwdGlvbixcblxuICAgICAgICByZXR1cm5zOiBmdW5jdGlvbiByZXR1cm5zKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJldHVyblZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnJldHVyblZhbHVlRGVmaW5lZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJldHVybnNBcmc6IGZ1bmN0aW9uIHJldHVybnNBcmcocG9zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvcyAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IGluZGV4IGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmV0dXJuQXJnQXQgPSBwb3M7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJldHVybnNUaGlzOiBmdW5jdGlvbiByZXR1cm5zVGhpcygpIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuVGhpcyA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGNyZWF0ZSBhc3luY2hyb25vdXMgdmVyc2lvbnMgb2YgY2FsbHNBcmcqIGFuZCB5aWVsZHMqIG1ldGhvZHNcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gcHJvdG8pIHtcbiAgICAgICAgLy8gbmVlZCB0byBhdm9pZCBjcmVhdGluZyBhbm90aGVyYXN5bmMgdmVyc2lvbnMgb2YgdGhlIG5ld2x5IGFkZGVkIGFzeW5jIG1ldGhvZHNcbiAgICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG1ldGhvZCkgJiZcbiAgICAgICAgICAgIG1ldGhvZC5tYXRjaCgvXihjYWxsc0FyZ3x5aWVsZHMpLykgJiZcbiAgICAgICAgICAgICFtZXRob2QubWF0Y2goL0FzeW5jLykpIHtcbiAgICAgICAgICAgIHByb3RvW21ldGhvZCArICdBc3luYyddID0gKGZ1bmN0aW9uIChzeW5jRm5OYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXNbc3luY0ZuTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkobWV0aG9kKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb21tb25KU01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHByb3RvO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbm9uLmJlaGF2aW9yID0gcHJvdG87XG4gICAgfVxufSh0eXBlb2Ygc2lub24gPT0gXCJvYmplY3RcIiAmJiBzaW5vbiB8fCBudWxsKSk7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcImQ6XFxcXHhhbXBwXFxcXGh0ZG9jc1xcXFx1bml2ZXJzYWwtZWRpdG9yLXdlYlxcXFxub2RlX21vZHVsZXNcXFxcYnJvd3NlcmlmeVxcXFxub2RlX21vZHVsZXNcXFxcaW5zZXJ0LW1vZHVsZS1nbG9iYWxzXFxcXG5vZGVfbW9kdWxlc1xcXFxwcm9jZXNzXFxcXGJyb3dzZXIuanNcIikpIiwiLyoqXG4gICogQGRlcGVuZCAuLi9zaW5vbi5qc1xuICAqIEBkZXBlbmQgbWF0Y2guanNcbiAgKi9cbi8qanNsaW50IGVxZXFlcTogZmFsc2UsIG9uZXZhcjogZmFsc2UsIHBsdXNwbHVzOiBmYWxzZSovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUsIHNpbm9uKi9cbi8qKlxuICAqIFNweSBjYWxsc1xuICAqXG4gICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gICogQGF1dGhvciBNYXhpbWlsaWFuIEFudG9uaSAobWFpbEBtYXhhbnRvbmkuZGUpXG4gICogQGxpY2Vuc2UgQlNEXG4gICpcbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTMgTWF4aW1pbGlhbiBBbnRvbmlcbiAgKi9cblwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24gKHNpbm9uKSB7XG4gICAgdmFyIGNvbW1vbkpTTW9kdWxlID0gdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHM7XG4gICAgaWYgKCFzaW5vbiAmJiBjb21tb25KU01vZHVsZSkge1xuICAgICAgICBzaW5vbiA9IHJlcXVpcmUoXCIuLi9zaW5vblwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXNpbm9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aHJvd1lpZWxkRXJyb3IocHJveHksIHRleHQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIG1zZyA9IHNpbm9uLmZ1bmN0aW9uTmFtZShwcm94eSkgKyB0ZXh0O1xuICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1zZyArPSBcIiBSZWNlaXZlZCBbXCIgKyBzbGljZS5jYWxsKGFyZ3MpLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIHZhciBjYWxsUHJvdG8gPSB7XG4gICAgICAgIGNhbGxlZE9uOiBmdW5jdGlvbiBjYWxsZWRPbih0aGlzVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChzaW5vbi5tYXRjaCAmJiBzaW5vbi5tYXRjaC5pc01hdGNoZXIodGhpc1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzVmFsdWUudGVzdCh0aGlzLnRoaXNWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aGlzVmFsdWUgPT09IHRoaXNWYWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYWxsZWRXaXRoOiBmdW5jdGlvbiBjYWxsZWRXaXRoKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaW5vbi5kZWVwRXF1YWwoYXJndW1lbnRzW2ldLCB0aGlzLmFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGxlZFdpdGhNYXRjaDogZnVuY3Rpb24gY2FsbGVkV2l0aE1hdGNoKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHRoaXMuYXJnc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZXhwZWN0YXRpb24gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFzaW5vbi5tYXRjaCB8fCAhc2lub24ubWF0Y2goZXhwZWN0YXRpb24pLnRlc3QoYWN0dWFsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbGVkV2l0aEV4YWN0bHk6IGZ1bmN0aW9uIGNhbGxlZFdpdGhFeGFjdGx5KCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT0gdGhpcy5hcmdzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGVkV2l0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5vdENhbGxlZFdpdGg6IGZ1bmN0aW9uIG5vdENhbGxlZFdpdGgoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuY2FsbGVkV2l0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5vdENhbGxlZFdpdGhNYXRjaDogZnVuY3Rpb24gbm90Q2FsbGVkV2l0aE1hdGNoKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmNhbGxlZFdpdGhNYXRjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJldHVybmVkOiBmdW5jdGlvbiByZXR1cm5lZCh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbm9uLmRlZXBFcXVhbCh2YWx1ZSwgdGhpcy5yZXR1cm5WYWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdGhyZXc6IGZ1bmN0aW9uIHRocmV3KGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcInVuZGVmaW5lZFwiIHx8ICF0aGlzLmV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZXhjZXB0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGNlcHRpb24gPT09IGVycm9yIHx8IHRoaXMuZXhjZXB0aW9uLm5hbWUgPT09IGVycm9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGxlZFdpdGhOZXc6IGZ1bmN0aW9uIGNhbGxlZFdpdGhOZXcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eS5wcm90b3R5cGUgJiYgdGhpcy50aGlzVmFsdWUgaW5zdGFuY2VvZiB0aGlzLnByb3h5O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGxlZEJlZm9yZTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsSWQgPCBvdGhlci5jYWxsSWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbGVkQWZ0ZXI6IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkID4gb3RoZXIuY2FsbElkO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbGxBcmc6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHRoaXMuYXJnc1twb3NdKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbEFyZ09uOiBmdW5jdGlvbiAocG9zLCB0aGlzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXJnc1twb3NdLmFwcGx5KHRoaXNWYWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbEFyZ1dpdGg6IGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbEFyZ09uV2l0aC5hcHBseSh0aGlzLCBbcG9zLCBudWxsXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbEFyZ09uV2l0aDogZnVuY3Rpb24gKHBvcywgdGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHRoaXMuYXJnc1twb3NdLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJ5aWVsZFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnlpZWxkT24uYXBwbHkodGhpcywgW251bGxdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpKTtcbiAgICAgICAgfSxcblxuICAgICAgICB5aWVsZE9uOiBmdW5jdGlvbiAodGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldLmFwcGx5KHRoaXNWYWx1ZSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93WWllbGRFcnJvcih0aGlzLnByb3h5LCBcIiBjYW5ub3QgeWllbGQgc2luY2Ugbm8gY2FsbGJhY2sgd2FzIHBhc3NlZC5cIiwgYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgeWllbGRUbzogZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHRoaXMueWllbGRUb09uLmFwcGx5KHRoaXMsIFtwcm9wLCBudWxsXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgeWllbGRUb09uOiBmdW5jdGlvbiAocHJvcCwgdGhpc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHRoaXMuYXJncztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnc1tpXSAmJiB0eXBlb2YgYXJnc1tpXVtwcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV1bcHJvcF0uYXBwbHkodGhpc1ZhbHVlLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3dZaWVsZEVycm9yKHRoaXMucHJveHksIFwiIGNhbm5vdCB5aWVsZCB0byAnXCIgKyBwcm9wICtcbiAgICAgICAgICAgICAgICBcIicgc2luY2Ugbm8gY2FsbGJhY2sgd2FzIHBhc3NlZC5cIiwgYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjYWxsU3RyID0gdGhpcy5wcm94eS50b1N0cmluZygpICsgXCIoXCI7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuYXJncy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goc2lub24uZm9ybWF0KHRoaXMuYXJnc1tpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsU3RyID0gY2FsbFN0ciArIGFyZ3Muam9pbihcIiwgXCIpICsgXCIpXCI7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5yZXR1cm5WYWx1ZSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY2FsbFN0ciArPSBcIiA9PiBcIiArIHNpbm9uLmZvcm1hdCh0aGlzLnJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FsbFN0ciArPSBcIiAhXCIgKyB0aGlzLmV4Y2VwdGlvbi5uYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhjZXB0aW9uLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFN0ciArPSBcIihcIiArIHRoaXMuZXhjZXB0aW9uLm1lc3NhZ2UgKyBcIilcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxsU3RyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNhbGxQcm90by5pbnZva2VDYWxsYmFjayA9IGNhbGxQcm90by55aWVsZDtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNweUNhbGwoc3B5LCB0aGlzVmFsdWUsIGFyZ3MsIHJldHVyblZhbHVlLCBleGNlcHRpb24sIGlkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYWxsIGlkIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJveHlDYWxsID0gc2lub24uY3JlYXRlKGNhbGxQcm90byk7XG4gICAgICAgIHByb3h5Q2FsbC5wcm94eSA9IHNweTtcbiAgICAgICAgcHJveHlDYWxsLnRoaXNWYWx1ZSA9IHRoaXNWYWx1ZTtcbiAgICAgICAgcHJveHlDYWxsLmFyZ3MgPSBhcmdzO1xuICAgICAgICBwcm94eUNhbGwucmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZTtcbiAgICAgICAgcHJveHlDYWxsLmV4Y2VwdGlvbiA9IGV4Y2VwdGlvbjtcbiAgICAgICAgcHJveHlDYWxsLmNhbGxJZCA9IGlkO1xuXG4gICAgICAgIHJldHVybiBwcm94eUNhbGw7XG4gICAgfVxuICAgIGNyZWF0ZVNweUNhbGwudG9TdHJpbmcgPSBjYWxsUHJvdG8udG9TdHJpbmc7IC8vIHVzZWQgYnkgbW9ja3NcblxuICAgIGlmIChjb21tb25KU01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNweUNhbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lub24uc3B5Q2FsbCA9IGNyZWF0ZVNweUNhbGw7XG4gICAgfVxufSh0eXBlb2Ygc2lub24gPT0gXCJvYmplY3RcIiAmJiBzaW5vbiB8fCBudWxsKSk7XG5cbiIsIi8qKlxuICogQGRlcGVuZCAuLi9zaW5vbi5qc1xuICogQGRlcGVuZCBzdHViLmpzXG4gKiBAZGVwZW5kIG1vY2suanNcbiAqL1xuLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgZm9yaW46IHRydWUqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlLCBzaW5vbiovXG4vKipcbiAqIENvbGxlY3Rpb25zIG9mIHN0dWJzLCBzcGllcyBhbmQgbW9ja3MuXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbiAoc2lub24pIHtcbiAgICB2YXIgY29tbW9uSlNNb2R1bGUgPSB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgICB2YXIgcHVzaCA9IFtdLnB1c2g7XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIGlmICghc2lub24gJiYgY29tbW9uSlNNb2R1bGUpIHtcbiAgICAgICAgc2lub24gPSByZXF1aXJlKFwiLi4vc2lub25cIik7XG4gICAgfVxuXG4gICAgaWYgKCFzaW5vbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RmFrZXMoZmFrZUNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKCFmYWtlQ29sbGVjdGlvbi5mYWtlcykge1xuICAgICAgICAgICAgZmFrZUNvbGxlY3Rpb24uZmFrZXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWtlQ29sbGVjdGlvbi5mYWtlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlYWNoKGZha2VDb2xsZWN0aW9uLCBtZXRob2QpIHtcbiAgICAgICAgdmFyIGZha2VzID0gZ2V0RmFrZXMoZmFrZUNvbGxlY3Rpb24pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZmFrZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZha2VzW2ldW21ldGhvZF0gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZmFrZXNbaV1bbWV0aG9kXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFjdChmYWtlQ29sbGVjdGlvbikge1xuICAgICAgICB2YXIgZmFrZXMgPSBnZXRGYWtlcyhmYWtlQ29sbGVjdGlvbik7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBmYWtlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmYWtlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29sbGVjdGlvbiA9IHtcbiAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgICAgICAgICAgZWFjaCh0aGlzLCBcInZlcmlmeVwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgICAgICAgZWFjaCh0aGlzLCBcInJlc3RvcmVcIik7XG4gICAgICAgICAgICBjb21wYWN0KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZlcmlmeUFuZFJlc3RvcmU6IGZ1bmN0aW9uIHZlcmlmeUFuZFJlc3RvcmUoKSB7XG4gICAgICAgICAgICB2YXIgZXhjZXB0aW9uO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIGlmIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZmFrZSkge1xuICAgICAgICAgICAgcHVzaC5jYWxsKGdldEZha2VzKHRoaXMpLCBmYWtlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWtlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNweTogZnVuY3Rpb24gc3B5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHNpbm9uLnNweS5hcHBseShzaW5vbiwgYXJndW1lbnRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3R1YjogZnVuY3Rpb24gc3R1YihvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gb2JqZWN0W3Byb3BlcnR5XTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBzdHViIG5vbi1leGlzdGVudCBvd24gcHJvcGVydHkgXCIgKyBwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJvcGVydHldID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJvcGVydHkgJiYgISFvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0dWJiZWRPYmogPSBzaW5vbi5zdHViLmFwcGx5KHNpbm9uLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHViYmVkT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R1YmJlZE9ialtwcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChzdHViYmVkT2JqW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzdHViYmVkT2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoc2lub24uc3R1Yi5hcHBseShzaW5vbiwgYXJndW1lbnRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW9jazogZnVuY3Rpb24gbW9jaygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChzaW5vbi5tb2NrLmFwcGx5KHNpbm9uLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChvYmopIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSB0aGlzO1xuXG4gICAgICAgICAgICBvYmouc3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wuc3B5LmFwcGx5KGNvbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9iai5zdHViID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2wuc3R1Yi5hcHBseShjb2wsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBvYmoubW9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sLm1vY2suYXBwbHkoY29sLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoY29tbW9uSlNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbm9uLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIH1cbn0odHlwZW9mIHNpbm9uID09IFwib2JqZWN0XCIgJiYgc2lub24gfHwgbnVsbCkpO1xuIiwiLyogQGRlcGVuZCAuLi9zaW5vbi5qcyAqL1xuLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgcGx1c3BsdXM6IGZhbHNlKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgc2lub24qL1xuLyoqXG4gKiBNYXRjaCBmdW5jdGlvbnNcbiAqXG4gKiBAYXV0aG9yIE1heGltaWxpYW4gQW50b25pIChtYWlsQG1heGFudG9uaS5kZSlcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBNYXhpbWlsaWFuIEFudG9uaVxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uIChzaW5vbikge1xuICAgIHZhciBjb21tb25KU01vZHVsZSA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzO1xuXG4gICAgaWYgKCFzaW5vbiAmJiBjb21tb25KU01vZHVsZSkge1xuICAgICAgICBzaW5vbiA9IHJlcXVpcmUoXCIuLi9zaW5vblwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXNpbm9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlLCBuYW1lKSB7XG4gICAgICAgIHZhciBhY3R1YWwgPSBzaW5vbi50eXBlT2YodmFsdWUpO1xuICAgICAgICBpZiAoYWN0dWFsICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgdHlwZSBvZiBcIiArIG5hbWUgKyBcIiB0byBiZSBcIiArXG4gICAgICAgICAgICAgICAgdHlwZSArIFwiLCBidXQgd2FzIFwiICsgYWN0dWFsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXRjaGVyID0ge1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc01hdGNoZXIob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLmlzUHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaE9iamVjdChleHBlY3RhdGlvbiwgYWN0dWFsKSB7XG4gICAgICAgIGlmIChhY3R1YWwgPT09IG51bGwgfHwgYWN0dWFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChleHBlY3RhdGlvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cCA9IGV4cGVjdGF0aW9uW2tleV07XG4gICAgICAgICAgICAgICAgdmFyIGFjdCA9IGFjdHVhbFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pc01hdGNoZXIoZXhwKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cC50ZXN0KGFjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lub24udHlwZU9mKGV4cCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaE9iamVjdChleHAsIGFjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNpbm9uLmRlZXBFcXVhbChleHAsIGFjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBtYXRjaGVyLm9yID0gZnVuY3Rpb24gKG0yKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1hdGNoZXIgZXhwZWN0ZWRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWF0Y2hlcihtMikpIHtcbiAgICAgICAgICAgIG0yID0gbWF0Y2gobTIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtMSA9IHRoaXM7XG4gICAgICAgIHZhciBvciA9IHNpbm9uLmNyZWF0ZShtYXRjaGVyKTtcbiAgICAgICAgb3IudGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtMS50ZXN0KGFjdHVhbCkgfHwgbTIudGVzdChhY3R1YWwpO1xuICAgICAgICB9O1xuICAgICAgICBvci5tZXNzYWdlID0gbTEubWVzc2FnZSArIFwiLm9yKFwiICsgbTIubWVzc2FnZSArIFwiKVwiO1xuICAgICAgICByZXR1cm4gb3I7XG4gICAgfTtcblxuICAgIG1hdGNoZXIuYW5kID0gZnVuY3Rpb24gKG0yKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1hdGNoZXIgZXhwZWN0ZWRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWF0Y2hlcihtMikpIHtcbiAgICAgICAgICAgIG0yID0gbWF0Y2gobTIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtMSA9IHRoaXM7XG4gICAgICAgIHZhciBhbmQgPSBzaW5vbi5jcmVhdGUobWF0Y2hlcik7XG4gICAgICAgIGFuZC50ZXN0ID0gZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgcmV0dXJuIG0xLnRlc3QoYWN0dWFsKSAmJiBtMi50ZXN0KGFjdHVhbCk7XG4gICAgICAgIH07XG4gICAgICAgIGFuZC5tZXNzYWdlID0gbTEubWVzc2FnZSArIFwiLmFuZChcIiArIG0yLm1lc3NhZ2UgKyBcIilcIjtcbiAgICAgICAgcmV0dXJuIGFuZDtcbiAgICB9O1xuXG4gICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gKGV4cGVjdGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBtID0gc2lub24uY3JlYXRlKG1hdGNoZXIpO1xuICAgICAgICB2YXIgdHlwZSA9IHNpbm9uLnR5cGVPZihleHBlY3RhdGlvbik7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGF0aW9uLnRlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG0udGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uLnRlc3QoYWN0dWFsKSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG0ubWVzc2FnZSA9IFwibWF0Y2goXCIgKyBzaW5vbi5mdW5jdGlvbk5hbWUoZXhwZWN0YXRpb24udGVzdCkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdHIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBleHBlY3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChleHBlY3RhdGlvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ci5wdXNoKGtleSArIFwiOiBcIiArIGV4cGVjdGF0aW9uW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0udGVzdCA9IGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hPYmplY3QoZXhwZWN0YXRpb24sIGFjdHVhbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbS5tZXNzYWdlID0gXCJtYXRjaChcIiArIHN0ci5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBtLnRlc3QgPSBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGF0aW9uID09IGFjdHVhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgbS50ZXN0ID0gZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0dWFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdHVhbC5pbmRleE9mKGV4cGVjdGF0aW9uKSAhPT0gLTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbS5tZXNzYWdlID0gXCJtYXRjaChcXFwiXCIgKyBleHBlY3RhdGlvbiArIFwiXFxcIilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVnZXhwXCI6XG4gICAgICAgICAgICBtLnRlc3QgPSBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3R1YWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb24udGVzdChhY3R1YWwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIG0udGVzdCA9IGV4cGVjdGF0aW9uO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBtLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtLm1lc3NhZ2UgPSBcIm1hdGNoKFwiICsgc2lub24uZnVuY3Rpb25OYW1lKGV4cGVjdGF0aW9uKSArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtLnRlc3QgPSBmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaW5vbi5kZWVwRXF1YWwoZXhwZWN0YXRpb24sIGFjdHVhbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbS5tZXNzYWdlKSB7XG4gICAgICAgICAgICBtLm1lc3NhZ2UgPSBcIm1hdGNoKFwiICsgZXhwZWN0YXRpb24gKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTtcbiAgICB9O1xuXG4gICAgbWF0Y2guaXNNYXRjaGVyID0gaXNNYXRjaGVyO1xuXG4gICAgbWF0Y2guYW55ID0gbWF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBcImFueVwiKTtcblxuICAgIG1hdGNoLmRlZmluZWQgPSBtYXRjaChmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgIHJldHVybiBhY3R1YWwgIT09IG51bGwgJiYgYWN0dWFsICE9PSB1bmRlZmluZWQ7XG4gICAgfSwgXCJkZWZpbmVkXCIpO1xuXG4gICAgbWF0Y2gudHJ1dGh5ID0gbWF0Y2goZnVuY3Rpb24gKGFjdHVhbCkge1xuICAgICAgICByZXR1cm4gISFhY3R1YWw7XG4gICAgfSwgXCJ0cnV0aHlcIik7XG5cbiAgICBtYXRjaC5mYWxzeSA9IG1hdGNoKGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgcmV0dXJuICFhY3R1YWw7XG4gICAgfSwgXCJmYWxzeVwiKTtcblxuICAgIG1hdGNoLnNhbWUgPSBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoKGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbiA9PT0gYWN0dWFsO1xuICAgICAgICB9LCBcInNhbWUoXCIgKyBleHBlY3RhdGlvbiArIFwiKVwiKTtcbiAgICB9O1xuXG4gICAgbWF0Y2gudHlwZU9mID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgYXNzZXJ0VHlwZSh0eXBlLCBcInN0cmluZ1wiLCBcInR5cGVcIik7XG4gICAgICAgIHJldHVybiBtYXRjaChmdW5jdGlvbiAoYWN0dWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lub24udHlwZU9mKGFjdHVhbCkgPT09IHR5cGU7XG4gICAgICAgIH0sIFwidHlwZU9mKFxcXCJcIiArIHR5cGUgKyBcIlxcXCIpXCIpO1xuICAgIH07XG5cbiAgICBtYXRjaC5pbnN0YW5jZU9mID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgYXNzZXJ0VHlwZSh0eXBlLCBcImZ1bmN0aW9uXCIsIFwidHlwZVwiKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoKGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3R1YWwgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgICB9LCBcImluc3RhbmNlT2YoXCIgKyBzaW5vbi5mdW5jdGlvbk5hbWUodHlwZSkgKyBcIilcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5TWF0Y2hlcihwcm9wZXJ0eVRlc3QsIG1lc3NhZ2VQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGFzc2VydFR5cGUocHJvcGVydHksIFwic3RyaW5nXCIsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAgICB2YXIgb25seVByb3BlcnR5ID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZVByZWZpeCArIFwiKFxcXCJcIiArIHByb3BlcnR5ICsgXCJcXFwiXCI7XG4gICAgICAgICAgICBpZiAoIW9ubHlQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIsIFwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiKVwiO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoKGZ1bmN0aW9uIChhY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsID09PSB1bmRlZmluZWQgfHwgYWN0dWFsID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhcHJvcGVydHlUZXN0KGFjdHVhbCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ubHlQcm9wZXJ0eSB8fCBzaW5vbi5kZWVwRXF1YWwodmFsdWUsIGFjdHVhbFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfSwgbWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbWF0Y2guaGFzID0gY3JlYXRlUHJvcGVydHlNYXRjaGVyKGZ1bmN0aW9uIChhY3R1YWwsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWN0dWFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gYWN0dWFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3R1YWxbcHJvcGVydHldICE9PSB1bmRlZmluZWQ7XG4gICAgfSwgXCJoYXNcIik7XG5cbiAgICBtYXRjaC5oYXNPd24gPSBjcmVhdGVQcm9wZXJ0eU1hdGNoZXIoZnVuY3Rpb24gKGFjdHVhbCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfSwgXCJoYXNPd25cIik7XG5cbiAgICBtYXRjaC5ib29sID0gbWF0Y2gudHlwZU9mKFwiYm9vbGVhblwiKTtcbiAgICBtYXRjaC5udW1iZXIgPSBtYXRjaC50eXBlT2YoXCJudW1iZXJcIik7XG4gICAgbWF0Y2guc3RyaW5nID0gbWF0Y2gudHlwZU9mKFwic3RyaW5nXCIpO1xuICAgIG1hdGNoLm9iamVjdCA9IG1hdGNoLnR5cGVPZihcIm9iamVjdFwiKTtcbiAgICBtYXRjaC5mdW5jID0gbWF0Y2gudHlwZU9mKFwiZnVuY3Rpb25cIik7XG4gICAgbWF0Y2guYXJyYXkgPSBtYXRjaC50eXBlT2YoXCJhcnJheVwiKTtcbiAgICBtYXRjaC5yZWdleHAgPSBtYXRjaC50eXBlT2YoXCJyZWdleHBcIik7XG4gICAgbWF0Y2guZGF0ZSA9IG1hdGNoLnR5cGVPZihcImRhdGVcIik7XG5cbiAgICBpZiAoY29tbW9uSlNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYXRjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5vbi5tYXRjaCA9IG1hdGNoO1xuICAgIH1cbn0odHlwZW9mIHNpbm9uID09IFwib2JqZWN0XCIgJiYgc2lub24gfHwgbnVsbCkpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIC4uL3Npbm9uLmpzXG4gKiBAZGVwZW5kIHN0dWIuanNcbiAqL1xuLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgbm9tZW46IGZhbHNlKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgc2lub24qL1xuLyoqXG4gKiBNb2NrIGZ1bmN0aW9ucy5cbiAqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIENocmlzdGlhbiBKb2hhbnNlblxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uIChzaW5vbikge1xuICAgIHZhciBjb21tb25KU01vZHVsZSA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzO1xuICAgIHZhciBwdXNoID0gW10ucHVzaDtcbiAgICB2YXIgbWF0Y2g7XG5cbiAgICBpZiAoIXNpbm9uICYmIGNvbW1vbkpTTW9kdWxlKSB7XG4gICAgICAgIHNpbm9uID0gcmVxdWlyZShcIi4uL3Npbm9uXCIpO1xuICAgIH1cblxuICAgIGlmICghc2lub24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1hdGNoID0gc2lub24ubWF0Y2g7XG5cbiAgICBpZiAoIW1hdGNoICYmIGNvbW1vbkpTTW9kdWxlKSB7XG4gICAgICAgIG1hdGNoID0gcmVxdWlyZShcIi4vbWF0Y2hcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9jayhvYmplY3QpIHtcbiAgICAgICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5vbi5leHBlY3RhdGlvbi5jcmVhdGUoXCJBbm9ueW1vdXMgbW9ja1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb2NrLmNyZWF0ZShvYmplY3QpO1xuICAgIH1cblxuICAgIHNpbm9uLm1vY2sgPSBtb2NrO1xuXG4gICAgc2lub24uZXh0ZW5kKG1vY2ssIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGVhY2goY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb2xsZWN0aW9uLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGNvbGxlY3Rpb25baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvYmplY3QgaXMgbnVsbFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbW9ja09iamVjdCA9IHNpbm9uLmV4dGVuZCh7fSwgbW9jayk7XG4gICAgICAgICAgICAgICAgbW9ja09iamVjdC5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1vY2tPYmplY3QuY3JlYXRlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vY2tPYmplY3Q7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBleHBlY3RzOiBmdW5jdGlvbiBleHBlY3RzKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJtZXRob2QgaXMgZmFsc3lcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmV4cGVjdGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdGF0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3hpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZXhwZWN0YXRpb25zW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RhdGlvbnNbbWV0aG9kXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9ja09iamVjdCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICAgICAgc2lub24ud3JhcE1ldGhvZCh0aGlzLm9iamVjdCwgbWV0aG9kLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9ja09iamVjdC5pbnZva2VNZXRob2QobWV0aG9kLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwodGhpcy5wcm94aWVzLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBleHBlY3RhdGlvbiA9IHNpbm9uLmV4cGVjdGF0aW9uLmNyZWF0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgIHB1c2guY2FsbCh0aGlzLmV4cGVjdGF0aW9uc1ttZXRob2RdLCBleHBlY3RhdGlvbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb247XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXN0b3JlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB0aGlzLm9iamVjdDtcblxuICAgICAgICAgICAgICAgIGVhY2godGhpcy5wcm94aWVzLCBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbcHJveHldLnJlc3RvcmUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RbcHJveHldLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGF0aW9ucyA9IHRoaXMuZXhwZWN0YXRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IFtdLCBtZXQgPSBbXTtcblxuICAgICAgICAgICAgICAgIGVhY2godGhpcy5wcm94aWVzLCBmdW5jdGlvbiAocHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWFjaChleHBlY3RhdGlvbnNbcHJveHldLCBmdW5jdGlvbiAoZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhwZWN0YXRpb24ubWV0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwobWVzc2FnZXMsIGV4cGVjdGF0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwobWV0LCBleHBlY3RhdGlvbi50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLmZhaWwobWVzc2FnZXMuY29uY2F0KG1ldCkuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2lub24uZXhwZWN0YXRpb24ucGFzcyhtZXNzYWdlcy5jb25jYXQobWV0KS5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGludm9rZU1ldGhvZDogZnVuY3Rpb24gaW52b2tlTWV0aG9kKG1ldGhvZCwgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGF0aW9ucyA9IHRoaXMuZXhwZWN0YXRpb25zICYmIHRoaXMuZXhwZWN0YXRpb25zW21ldGhvZF07XG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGV4cGVjdGF0aW9ucyAmJiBleHBlY3RhdGlvbnMubGVuZ3RoIHx8IDAsIGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHBlY3RhdGlvbnNbaV0ubWV0KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGF0aW9uc1tpXS5hbGxvd3NDYWxsKHRoaXNWYWx1ZSwgYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbnNbaV0uYXBwbHkodGhpc1ZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlcyA9IFtdLCBhdmFpbGFibGUsIGV4aGF1c3RlZCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGF0aW9uc1tpXS5hbGxvd3NDYWxsKHRoaXNWYWx1ZSwgYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZSA9IGF2YWlsYWJsZSB8fCBleHBlY3RhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGhhdXN0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwobWVzc2FnZXMsIFwiICAgIFwiICsgZXhwZWN0YXRpb25zW2ldLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChleGhhdXN0ZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZS5hcHBseSh0aGlzVmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLnVuc2hpZnQoXCJVbmV4cGVjdGVkIGNhbGw6IFwiICsgc2lub24uc3B5Q2FsbC50b1N0cmluZy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHk6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLmZhaWwobWVzc2FnZXMuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSgpKSk7XG5cbiAgICB2YXIgdGltZXMgPSBzaW5vbi50aW1lc0luV29yZHM7XG5cbiAgICBzaW5vbi5leHBlY3RhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICAgICAgdmFyIF9pbnZva2UgPSBzaW5vbi5zcHkuaW52b2tlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxDb3VudEluV29yZHMoY2FsbENvdW50KSB7XG4gICAgICAgICAgICBpZiAoY2FsbENvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJuZXZlciBjYWxsZWRcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY2FsbGVkIFwiICsgdGltZXMoY2FsbENvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGVjdGVkQ2FsbENvdW50SW5Xb3JkcyhleHBlY3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIG1pbiA9IGV4cGVjdGF0aW9uLm1pbkNhbGxzO1xuICAgICAgICAgICAgdmFyIG1heCA9IGV4cGVjdGF0aW9uLm1heENhbGxzO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1pbiA9PSBcIm51bWJlclwiICYmIHR5cGVvZiBtYXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSB0aW1lcyhtaW4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1pbiAhPSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gXCJhdCBsZWFzdCBcIiArIHN0ciArIFwiIGFuZCBhdCBtb3N0IFwiICsgdGltZXMobWF4KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1pbiA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYXQgbGVhc3QgXCIgKyB0aW1lcyhtaW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gXCJhdCBtb3N0IFwiICsgdGltZXMobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVkTWluQ2FsbHMoZXhwZWN0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBoYXNNaW5MaW1pdCA9IHR5cGVvZiBleHBlY3RhdGlvbi5taW5DYWxscyA9PSBcIm51bWJlclwiO1xuICAgICAgICAgICAgcmV0dXJuICFoYXNNaW5MaW1pdCB8fCBleHBlY3RhdGlvbi5jYWxsQ291bnQgPj0gZXhwZWN0YXRpb24ubWluQ2FsbHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZWNlaXZlZE1heENhbGxzKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGVjdGF0aW9uLm1heENhbGxzICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbi5jYWxsQ291bnQgPT0gZXhwZWN0YXRpb24ubWF4Q2FsbHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2ZXJpZnlNYXRjaGVyKHBvc3NpYmxlTWF0Y2hlciwgYXJnKXtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pc01hdGNoZXIocG9zc2libGVNYXRjaGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3NzaWJsZU1hdGNoZXIudGVzdChhcmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5DYWxsczogMSxcbiAgICAgICAgICAgIG1heENhbGxzOiAxLFxuXG4gICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZShtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGVjdGF0aW9uID0gc2lub24uZXh0ZW5kKHNpbm9uLnN0dWIuY3JlYXRlKCksIHNpbm9uLmV4cGVjdGF0aW9uKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZXhwZWN0YXRpb24uY3JlYXRlO1xuICAgICAgICAgICAgICAgIGV4cGVjdGF0aW9uLm1ldGhvZCA9IG1ldGhvZE5hbWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwZWN0YXRpb247XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbnZva2U6IGZ1bmN0aW9uIGludm9rZShmdW5jLCB0aGlzVmFsdWUsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeUNhbGxBbGxvd2VkKHRoaXNWYWx1ZSwgYXJncyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ludm9rZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYXRMZWFzdDogZnVuY3Rpb24gYXRMZWFzdChudW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInXCIgKyBudW0gKyBcIicgaXMgbm90IG51bWJlclwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGltaXRzU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF4Q2FsbHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbWl0c1NldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5taW5DYWxscyA9IG51bTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYXRNb3N0OiBmdW5jdGlvbiBhdE1vc3QobnVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ1wiICsgbnVtICsgXCInIGlzIG5vdCBudW1iZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxpbWl0c1NldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbkNhbGxzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW1pdHNTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubWF4Q2FsbHMgPSBudW07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG5ldmVyOiBmdW5jdGlvbiBuZXZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGFjdGx5KDApO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25jZTogZnVuY3Rpb24gb25jZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGFjdGx5KDEpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdHdpY2U6IGZ1bmN0aW9uIHR3aWNlKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4YWN0bHkoMik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0aHJpY2U6IGZ1bmN0aW9uIHRocmljZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGFjdGx5KDMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZXhhY3RseTogZnVuY3Rpb24gZXhhY3RseShudW0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInXCIgKyBudW0gKyBcIicgaXMgbm90IGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuYXRMZWFzdChudW0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmF0TW9zdChudW0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbWV0OiBmdW5jdGlvbiBtZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmZhaWxlZCAmJiByZWNlaXZlZE1pbkNhbGxzKHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdmVyaWZ5Q2FsbEFsbG93ZWQ6IGZ1bmN0aW9uIHZlcmlmeUNhbGxBbGxvd2VkKHRoaXNWYWx1ZSwgYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZE1heENhbGxzKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2lub24uZXhwZWN0YXRpb24uZmFpbCh0aGlzLm1ldGhvZCArIFwiIGFscmVhZHkgY2FsbGVkIFwiICsgdGltZXModGhpcy5tYXhDYWxscykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChcImV4cGVjdGVkVGhpc1wiIGluIHRoaXMgJiYgdGhpcy5leHBlY3RlZFRoaXMgIT09IHRoaXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzaW5vbi5leHBlY3RhdGlvbi5mYWlsKHRoaXMubWV0aG9kICsgXCIgY2FsbGVkIHdpdGggXCIgKyB0aGlzVmFsdWUgKyBcIiBhcyB0aGlzVmFsdWUsIGV4cGVjdGVkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0ZWRUaGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShcImV4cGVjdGVkQXJndW1lbnRzXCIgaW4gdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgICAgICAgICBzaW5vbi5leHBlY3RhdGlvbi5mYWlsKHRoaXMubWV0aG9kICsgXCIgcmVjZWl2ZWQgbm8gYXJndW1lbnRzLCBleHBlY3RlZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5vbi5mb3JtYXQodGhpcy5leHBlY3RlZEFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLmZhaWwodGhpcy5tZXRob2QgKyBcIiByZWNlaXZlZCB0b28gZmV3IGFyZ3VtZW50cyAoXCIgKyBzaW5vbi5mb3JtYXQoYXJncykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpLCBleHBlY3RlZCBcIiArIHNpbm9uLmZvcm1hdCh0aGlzLmV4cGVjdGVkQXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXhwZWN0c0V4YWN0QXJnQ291bnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJncy5sZW5ndGggIT0gdGhpcy5leHBlY3RlZEFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lub24uZXhwZWN0YXRpb24uZmFpbCh0aGlzLm1ldGhvZCArIFwiIHJlY2VpdmVkIHRvbyBtYW55IGFyZ3VtZW50cyAoXCIgKyBzaW5vbi5mb3JtYXQoYXJncykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpLCBleHBlY3RlZCBcIiArIHNpbm9uLmZvcm1hdCh0aGlzLmV4cGVjdGVkQXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmV4cGVjdGVkQXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmVyaWZ5TWF0Y2hlcih0aGlzLmV4cGVjdGVkQXJndW1lbnRzW2ldLGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5vbi5leHBlY3RhdGlvbi5mYWlsKHRoaXMubWV0aG9kICsgXCIgcmVjZWl2ZWQgd3JvbmcgYXJndW1lbnRzIFwiICsgc2lub24uZm9ybWF0KGFyZ3MpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiwgZGlkbid0IG1hdGNoIFwiICsgdGhpcy5leHBlY3RlZEFyZ3VtZW50cy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2lub24uZGVlcEVxdWFsKHRoaXMuZXhwZWN0ZWRBcmd1bWVudHNbaV0sIGFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5vbi5leHBlY3RhdGlvbi5mYWlsKHRoaXMubWV0aG9kICsgXCIgcmVjZWl2ZWQgd3JvbmcgYXJndW1lbnRzIFwiICsgc2lub24uZm9ybWF0KGFyZ3MpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiwgZXhwZWN0ZWQgXCIgKyBzaW5vbi5mb3JtYXQodGhpcy5leHBlY3RlZEFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWxsb3dzQ2FsbDogZnVuY3Rpb24gYWxsb3dzQ2FsbCh0aGlzVmFsdWUsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXQoKSAmJiByZWNlaXZlZE1heENhbGxzKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXCJleHBlY3RlZFRoaXNcIiBpbiB0aGlzICYmIHRoaXMuZXhwZWN0ZWRUaGlzICE9PSB0aGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKFwiZXhwZWN0ZWRBcmd1bWVudHNcIiBpbiB0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5leHBlY3RzRXhhY3RBcmdDb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBhcmdzLmxlbmd0aCAhPSB0aGlzLmV4cGVjdGVkQXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmV4cGVjdGVkQXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZlcmlmeU1hdGNoZXIodGhpcy5leHBlY3RlZEFyZ3VtZW50c1tpXSxhcmdzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaW5vbi5kZWVwRXF1YWwodGhpcy5leHBlY3RlZEFyZ3VtZW50c1tpXSwgYXJnc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgd2l0aEFyZ3M6IGZ1bmN0aW9uIHdpdGhBcmdzKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0ZWRBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB3aXRoRXhhY3RBcmdzOiBmdW5jdGlvbiB3aXRoRXhhY3RBcmdzKCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2l0aEFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdHNFeGFjdEFyZ0NvdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uOiBmdW5jdGlvbiBvbih0aGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdGVkVGhpcyA9IHRoaXNWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSAodGhpcy5leHBlY3RlZEFyZ3VtZW50cyB8fCBbXSkuc2xpY2UoKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5leHBlY3RzRXhhY3RBcmdDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwoYXJncywgXCJbLi4uXVwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FsbFN0ciA9IHNpbm9uLnNweUNhbGwudG9TdHJpbmcuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5OiB0aGlzLm1ldGhvZCB8fCBcImFub255bW91cyBtb2NrIGV4cGVjdGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gY2FsbFN0ci5yZXBsYWNlKFwiLCBbLi4uXCIsIFwiWywgLi4uXCIpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZENhbGxDb3VudEluV29yZHModGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZXQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFeHBlY3RhdGlvbiBtZXQ6IFwiICsgbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIG1lc3NhZ2UgKyBcIiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICBjYWxsQ291bnRJbldvcmRzKHRoaXMuY2FsbENvdW50KSArIFwiKVwiO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdmVyaWZ5OiBmdW5jdGlvbiB2ZXJpZnkoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1ldCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbm9uLmV4cGVjdGF0aW9uLmZhaWwodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaW5vbi5leHBlY3RhdGlvbi5wYXNzKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXNzOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgIHNpbm9uLmFzc2VydC5wYXNzKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhaWw6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBleGNlcHRpb24ubmFtZSA9IFwiRXhwZWN0YXRpb25FcnJvclwiO1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICBpZiAoY29tbW9uSlNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtb2NrO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbm9uLm1vY2sgPSBtb2NrO1xuICAgIH1cbn0odHlwZW9mIHNpbm9uID09IFwib2JqZWN0XCIgJiYgc2lub24gfHwgbnVsbCkpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIC4uL3Npbm9uLmpzXG4gKiBAZGVwZW5kIGNvbGxlY3Rpb24uanNcbiAqIEBkZXBlbmQgdXRpbC9mYWtlX3RpbWVycy5qc1xuICogQGRlcGVuZCB1dGlsL2Zha2Vfc2VydmVyX3dpdGhfY2xvY2suanNcbiAqL1xuLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgcGx1c3BsdXM6IGZhbHNlKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSovXG4vKipcbiAqIE1hbmFnZXMgZmFrZSBjb2xsZWN0aW9ucyBhcyB3ZWxsIGFzIGZha2UgdXRpbGl0aWVzIHN1Y2ggYXMgU2lub24nc1xuICogdGltZXJzIGFuZCBmYWtlIFhIUiBpbXBsZW1lbnRhdGlvbiBpbiBvbmUgY29udmVuaWVudCBvYmplY3QuXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIHZhciBzaW5vbiA9IHJlcXVpcmUoXCIuLi9zaW5vblwiKTtcbiAgICBzaW5vbi5leHRlbmQoc2lub24sIHJlcXVpcmUoXCIuL3V0aWwvZmFrZV90aW1lcnNcIikpO1xufVxuXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBwdXNoID0gW10ucHVzaDtcblxuICAgIGZ1bmN0aW9uIGV4cG9zZVZhbHVlKHNhbmRib3gsIGNvbmZpZywga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLmluamVjdEludG8gJiYgIShrZXkgaW4gY29uZmlnLmluamVjdEludG8pKSB7XG4gICAgICAgICAgICBjb25maWcuaW5qZWN0SW50b1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBzYW5kYm94LmluamVjdGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdXNoLmNhbGwoc2FuZGJveC5hcmdzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlU2FuZGJveEZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBzYW5kYm94ID0gc2lub24uY3JlYXRlKHNpbm9uLnNhbmRib3gpO1xuXG4gICAgICAgIGlmIChjb25maWcudXNlRmFrZVNlcnZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcudXNlRmFrZVNlcnZlciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgc2FuZGJveC5zZXJ2ZXJQcm90b3R5cGUgPSBjb25maWcudXNlRmFrZVNlcnZlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2FuZGJveC51c2VGYWtlU2VydmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLnVzZUZha2VUaW1lcnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnVzZUZha2VUaW1lcnMgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHNhbmRib3gudXNlRmFrZVRpbWVycy5hcHBseShzYW5kYm94LCBjb25maWcudXNlRmFrZVRpbWVycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbmRib3gudXNlRmFrZVRpbWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNhbmRib3g7XG4gICAgfVxuXG4gICAgc2lub24uc2FuZGJveCA9IHNpbm9uLmV4dGVuZChzaW5vbi5jcmVhdGUoc2lub24uY29sbGVjdGlvbiksIHtcbiAgICAgICAgdXNlRmFrZVRpbWVyczogZnVuY3Rpb24gdXNlRmFrZVRpbWVycygpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvY2sgPSBzaW5vbi51c2VGYWtlVGltZXJzLmFwcGx5KHNpbm9uLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQodGhpcy5jbG9jayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VydmVyUHJvdG90eXBlOiBzaW5vbi5mYWtlU2VydmVyLFxuXG4gICAgICAgIHVzZUZha2VTZXJ2ZXI6IGZ1bmN0aW9uIHVzZUZha2VTZXJ2ZXIoKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPSB0aGlzLnNlcnZlclByb3RvdHlwZSB8fCBzaW5vbi5mYWtlU2VydmVyO1xuXG4gICAgICAgICAgICBpZiAoIXByb3RvIHx8ICFwcm90by5jcmVhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIgPSBwcm90by5jcmVhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZCh0aGlzLnNlcnZlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5qZWN0OiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBzaW5vbi5jb2xsZWN0aW9uLmluamVjdC5jYWxsKHRoaXMsIG9iaik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsb2NrKSB7XG4gICAgICAgICAgICAgICAgb2JqLmNsb2NrID0gdGhpcy5jbG9jaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgb2JqLnNlcnZlciA9IHRoaXMuc2VydmVyO1xuICAgICAgICAgICAgICAgIG9iai5yZXF1ZXN0cyA9IHRoaXMuc2VydmVyLnJlcXVlc3RzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNpbm9uLmNvbGxlY3Rpb24ucmVzdG9yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlQ29udGV4dCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmplY3RlZEtleXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuaW5qZWN0ZWRLZXlzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbmplY3RJbnRvW3RoaXMuaW5qZWN0ZWRLZXlzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmplY3RlZEtleXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbm9uLmNyZWF0ZShzaW5vbi5zYW5kYm94KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNhbmRib3ggPSBwcmVwYXJlU2FuZGJveEZyb21Db25maWcoY29uZmlnKTtcbiAgICAgICAgICAgIHNhbmRib3guYXJncyA9IHNhbmRib3guYXJncyB8fCBbXTtcbiAgICAgICAgICAgIHNhbmRib3guaW5qZWN0ZWRLZXlzID0gW107XG4gICAgICAgICAgICBzYW5kYm94LmluamVjdEludG8gPSBjb25maWcuaW5qZWN0SW50bztcbiAgICAgICAgICAgIHZhciBwcm9wLCB2YWx1ZSwgZXhwb3NlZCA9IHNhbmRib3guaW5qZWN0KHt9KTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb25maWcucHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZy5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4cG9zZWRbcHJvcF0gfHwgcHJvcCA9PSBcInNhbmRib3hcIiAmJiBzYW5kYm94O1xuICAgICAgICAgICAgICAgICAgICBleHBvc2VWYWx1ZShzYW5kYm94LCBjb25maWcsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cG9zZVZhbHVlKHNhbmRib3gsIGNvbmZpZywgXCJzYW5kYm94XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNhbmRib3g7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNpbm9uLnNhbmRib3gudXNlRmFrZVhNTEh0dHBSZXF1ZXN0ID0gc2lub24uc2FuZGJveC51c2VGYWtlU2VydmVyO1xuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gc2lub24uc2FuZGJveDtcbiAgICB9XG59KCkpO1xuIiwiLyoqXG4gICogQGRlcGVuZCAuLi9zaW5vbi5qc1xuICAqIEBkZXBlbmQgY2FsbC5qc1xuICAqL1xuLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgcGx1c3BsdXM6IGZhbHNlKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgc2lub24qL1xuLyoqXG4gICogU3B5IGZ1bmN0aW9uc1xuICAqXG4gICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gICogQGxpY2Vuc2UgQlNEXG4gICpcbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAgKi9cblwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24gKHNpbm9uKSB7XG4gICAgdmFyIGNvbW1vbkpTTW9kdWxlID0gdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHM7XG4gICAgdmFyIHB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgdmFyIGNhbGxJZCA9IDA7XG5cbiAgICBpZiAoIXNpbm9uICYmIGNvbW1vbkpTTW9kdWxlKSB7XG4gICAgICAgIHNpbm9uID0gcmVxdWlyZShcIi4uL3Npbm9uXCIpO1xuICAgIH1cblxuICAgIGlmICghc2lub24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNweShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghcHJvcGVydHkgJiYgdHlwZW9mIG9iamVjdCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzcHkuY3JlYXRlKG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9iamVjdCAmJiAhcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiBzcHkuY3JlYXRlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWV0aG9kID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgcmV0dXJuIHNpbm9uLndyYXBNZXRob2Qob2JqZWN0LCBwcm9wZXJ0eSwgc3B5LmNyZWF0ZShtZXRob2QpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaGluZ0Zha2UoZmFrZXMsIGFyZ3MsIHN0cmljdCkge1xuICAgICAgICBpZiAoIWZha2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZha2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZha2VzW2ldLm1hdGNoZXMoYXJncywgc3RyaWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWtlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluY3JlbWVudENhbGxDb3VudCgpIHtcbiAgICAgICAgdGhpcy5jYWxsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxDb3VudCArPSAxO1xuICAgICAgICB0aGlzLm5vdENhbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGxlZE9uY2UgPSB0aGlzLmNhbGxDb3VudCA9PSAxO1xuICAgICAgICB0aGlzLmNhbGxlZFR3aWNlID0gdGhpcy5jYWxsQ291bnQgPT0gMjtcbiAgICAgICAgdGhpcy5jYWxsZWRUaHJpY2UgPSB0aGlzLmNhbGxDb3VudCA9PSAzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbGxQcm9wZXJ0aWVzKCkge1xuICAgICAgICB0aGlzLmZpcnN0Q2FsbCA9IHRoaXMuZ2V0Q2FsbCgwKTtcbiAgICAgICAgdGhpcy5zZWNvbmRDYWxsID0gdGhpcy5nZXRDYWxsKDEpO1xuICAgICAgICB0aGlzLnRoaXJkQ2FsbCA9IHRoaXMuZ2V0Q2FsbCgyKTtcbiAgICAgICAgdGhpcy5sYXN0Q2FsbCA9IHRoaXMuZ2V0Q2FsbCh0aGlzLmNhbGxDb3VudCAtIDEpO1xuICAgIH1cblxuICAgIHZhciB2YXJzID0gXCJhLGIsYyxkLGUsZixnLGgsaSxqLGssbFwiO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3h5KGZ1bmMpIHtcbiAgICAgICAgLy8gUmV0YWluIHRoZSBmdW5jdGlvbiBsZW5ndGg6XG4gICAgICAgIHZhciBwO1xuICAgICAgICBpZiAoZnVuYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGV2YWwoXCJwID0gKGZ1bmN0aW9uIHByb3h5KFwiICsgdmFycy5zdWJzdHJpbmcoMCwgZnVuYy5sZW5ndGggKiAyIC0gMSkgK1xuICAgICAgICAgICAgICAgIFwiKSB7IHJldHVybiBwLmludm9rZShmdW5jLCB0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cykpOyB9KTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwID0gZnVuY3Rpb24gcHJveHkoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuaW52b2tlKGZ1bmMsIHRoaXMsIHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHZhciB1dWlkID0gMDtcblxuICAgIC8vIFB1YmxpYyBBUElcbiAgICB2YXIgc3B5QXBpID0ge1xuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubm90Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGVkT25jZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWRUd2ljZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWRUaHJpY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2FsbENvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RDYWxsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kQ2FsbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnRoaXJkQ2FsbCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxhc3RDYWxsID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudGhpc1ZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5leGNlcHRpb25zID0gW107XG4gICAgICAgICAgICB0aGlzLmNhbGxJZHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmZha2VzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZha2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFrZXNbaV0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoZnVuYykge1xuICAgICAgICAgICAgdmFyIG5hbWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gc2lub24uZnVuY3Rpb25OYW1lKGZ1bmMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJveHkgPSBjcmVhdGVQcm94eShmdW5jKTtcblxuICAgICAgICAgICAgc2lub24uZXh0ZW5kKHByb3h5LCBzcHkpO1xuICAgICAgICAgICAgZGVsZXRlIHByb3h5LmNyZWF0ZTtcbiAgICAgICAgICAgIHNpbm9uLmV4dGVuZChwcm94eSwgZnVuYyk7XG5cbiAgICAgICAgICAgIHByb3h5LnJlc2V0KCk7XG4gICAgICAgICAgICBwcm94eS5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgICAgICAgIHByb3h5LmRpc3BsYXlOYW1lID0gbmFtZSB8fCBcInNweVwiO1xuICAgICAgICAgICAgcHJveHkudG9TdHJpbmcgPSBzaW5vbi5mdW5jdGlvblRvU3RyaW5nO1xuICAgICAgICAgICAgcHJveHkuX2NyZWF0ZSA9IHNpbm9uLnNweS5jcmVhdGU7XG4gICAgICAgICAgICBwcm94eS5pZCA9IFwic3B5I1wiICsgdXVpZCsrO1xuXG4gICAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW52b2tlOiBmdW5jdGlvbiBpbnZva2UoZnVuYywgdGhpc1ZhbHVlLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBtYXRjaGluZ0Zha2UodGhpcy5mYWtlcywgYXJncyk7XG4gICAgICAgICAgICB2YXIgZXhjZXB0aW9uLCByZXR1cm5WYWx1ZTtcblxuICAgICAgICAgICAgaW5jcmVtZW50Q2FsbENvdW50LmNhbGwodGhpcyk7XG4gICAgICAgICAgICBwdXNoLmNhbGwodGhpcy50aGlzVmFsdWVzLCB0aGlzVmFsdWUpO1xuICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMuYXJncywgYXJncyk7XG4gICAgICAgICAgICBwdXNoLmNhbGwodGhpcy5jYWxsSWRzLCBjYWxsSWQrKyk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gbWF0Y2hpbmcuaW52b2tlKGZ1bmMsIHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSAodGhpcy5mdW5jIHx8IGZ1bmMpLmFwcGx5KHRoaXNWYWx1ZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRoaXNDYWxsID0gdGhpcy5nZXRDYWxsKHRoaXMuY2FsbENvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNDYWxsLmNhbGxlZFdpdGhOZXcoKSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdGhpc1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwdXNoLmNhbGwodGhpcy5leGNlcHRpb25zLCBleGNlcHRpb24pO1xuICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMucmV0dXJuVmFsdWVzLCByZXR1cm5WYWx1ZSk7XG5cbiAgICAgICAgICAgIGNyZWF0ZUNhbGxQcm9wZXJ0aWVzLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChleGNlcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENhbGw6IGZ1bmN0aW9uIGdldENhbGwoaSkge1xuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5jYWxsQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNpbm9uLnNweUNhbGwodGhpcywgdGhpcy50aGlzVmFsdWVzW2ldLCB0aGlzLmFyZ3NbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJldHVyblZhbHVlc1tpXSwgdGhpcy5leGNlcHRpb25zW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsSWRzW2ldKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDYWxsczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNhbGxzID0gW107XG4gICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY2FsbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxscy5wdXNoKHRoaXMuZ2V0Q2FsbChpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxscztcbiAgICAgICAgfSxcblxuICAgICAgICBjYWxsZWRCZWZvcmU6IGZ1bmN0aW9uIGNhbGxlZEJlZm9yZShzcHlGbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzcHlGbi5jYWxsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkc1swXSA8IHNweUZuLmNhbGxJZHNbc3B5Rm4uY2FsbElkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYWxsZWRBZnRlcjogZnVuY3Rpb24gY2FsbGVkQWZ0ZXIoc3B5Rm4pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsZWQgfHwgIXNweUZuLmNhbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkc1t0aGlzLmNhbGxDb3VudCAtIDFdID4gc3B5Rm4uY2FsbElkc1tzcHlGbi5jYWxsQ291bnQgLSAxXTtcbiAgICAgICAgfSxcblxuICAgICAgICB3aXRoQXJnczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZha2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hpbmdGYWtlKHRoaXMuZmFrZXMsIGFyZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZXMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcztcbiAgICAgICAgICAgIHZhciBmYWtlID0gdGhpcy5fY3JlYXRlKCk7XG4gICAgICAgICAgICBmYWtlLm1hdGNoaW5nQWd1bWVudHMgPSBhcmdzO1xuICAgICAgICAgICAgZmFrZS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgcHVzaC5jYWxsKHRoaXMuZmFrZXMsIGZha2UpO1xuXG4gICAgICAgICAgICBmYWtlLndpdGhBcmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC53aXRoQXJncy5hcHBseShvcmlnaW5hbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZha2UubWF0Y2hlcyh0aGlzLmFyZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudENhbGxDb3VudC5jYWxsKGZha2UpO1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwoZmFrZS50aGlzVmFsdWVzLCB0aGlzLnRoaXNWYWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwoZmFrZS5hcmdzLCB0aGlzLmFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICBwdXNoLmNhbGwoZmFrZS5yZXR1cm5WYWx1ZXMsIHRoaXMucmV0dXJuVmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKGZha2UuZXhjZXB0aW9ucywgdGhpcy5leGNlcHRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKGZha2UuY2FsbElkcywgdGhpcy5jYWxsSWRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcmVhdGVDYWxsUHJvcGVydGllcy5jYWxsKGZha2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFrZTtcbiAgICAgICAgfSxcblxuICAgICAgICBtYXRjaGVzOiBmdW5jdGlvbiAoYXJncywgc3RyaWN0KSB7XG4gICAgICAgICAgICB2YXIgbWFyZ3MgPSB0aGlzLm1hdGNoaW5nQWd1bWVudHM7XG5cbiAgICAgICAgICAgIGlmIChtYXJncy5sZW5ndGggPD0gYXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBzaW5vbi5kZWVwRXF1YWwobWFyZ3MsIGFyZ3Muc2xpY2UoMCwgbWFyZ3MubGVuZ3RoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXN0cmljdCB8fCBtYXJncy5sZW5ndGggPT0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJpbnRmOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgc3B5ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlcjtcblxuICAgICAgICAgICAgcmV0dXJuIChmb3JtYXQgfHwgXCJcIikucmVwbGFjZSgvJSguKS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNwZWNpZnllcikge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlciA9IHNweUFwaS5mb3JtYXR0ZXJzW3NwZWNpZnllcl07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5jYWxsKG51bGwsIHNweSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4ocGFyc2VJbnQoc3BlY2lmeWVyLCAxMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW5vbi5mb3JtYXQoYXJnc1tzcGVjaWZ5ZXIgLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiJVwiICsgc3BlY2lmeWVyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVsZWdhdGVUb0NhbGxzKG1ldGhvZCwgbWF0Y2hBbnksIGFjdHVhbCwgbm90Q2FsbGVkKSB7XG4gICAgICAgIHNweUFwaVttZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbGxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChub3RDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vdENhbGxlZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2FsbDtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmNhbGxDb3VudDsgaSA8IGw7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDYWxsID0gdGhpcy5nZXRDYWxsKGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDYWxsW2FjdHVhbCB8fCBtZXRob2RdLmFwcGx5KGN1cnJlbnRDYWxsLCBhcmd1bWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMgKz0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hBbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcyA9PT0gdGhpcy5jYWxsQ291bnQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZGVsZWdhdGVUb0NhbGxzKFwiY2FsbGVkT25cIiwgdHJ1ZSk7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwiYWx3YXlzQ2FsbGVkT25cIiwgZmFsc2UsIFwiY2FsbGVkT25cIik7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwiY2FsbGVkV2l0aFwiLCB0cnVlKTtcbiAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJjYWxsZWRXaXRoTWF0Y2hcIiwgdHJ1ZSk7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwiYWx3YXlzQ2FsbGVkV2l0aFwiLCBmYWxzZSwgXCJjYWxsZWRXaXRoXCIpO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcImFsd2F5c0NhbGxlZFdpdGhNYXRjaFwiLCBmYWxzZSwgXCJjYWxsZWRXaXRoTWF0Y2hcIik7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwiY2FsbGVkV2l0aEV4YWN0bHlcIiwgdHJ1ZSk7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwiYWx3YXlzQ2FsbGVkV2l0aEV4YWN0bHlcIiwgZmFsc2UsIFwiY2FsbGVkV2l0aEV4YWN0bHlcIik7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwibmV2ZXJDYWxsZWRXaXRoXCIsIGZhbHNlLCBcIm5vdENhbGxlZFdpdGhcIixcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwibmV2ZXJDYWxsZWRXaXRoTWF0Y2hcIiwgZmFsc2UsIFwibm90Q2FsbGVkV2l0aE1hdGNoXCIsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcInRocmV3XCIsIHRydWUpO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcImFsd2F5c1RocmV3XCIsIGZhbHNlLCBcInRocmV3XCIpO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcInJldHVybmVkXCIsIHRydWUpO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcImFsd2F5c1JldHVybmVkXCIsIGZhbHNlLCBcInJldHVybmVkXCIpO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcImNhbGxlZFdpdGhOZXdcIiwgdHJ1ZSk7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwiYWx3YXlzQ2FsbGVkV2l0aE5ld1wiLCBmYWxzZSwgXCJjYWxsZWRXaXRoTmV3XCIpO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcImNhbGxBcmdcIiwgZmFsc2UsIFwiY2FsbEFyZ1dpdGhcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50b1N0cmluZygpICsgXCIgY2Fubm90IGNhbGwgYXJnIHNpbmNlIGl0IHdhcyBub3QgeWV0IGludm9rZWQuXCIpO1xuICAgIH0pO1xuICAgIHNweUFwaS5jYWxsQXJnV2l0aCA9IHNweUFwaS5jYWxsQXJnO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcImNhbGxBcmdPblwiLCBmYWxzZSwgXCJjYWxsQXJnT25XaXRoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGNhbm5vdCBjYWxsIGFyZyBzaW5jZSBpdCB3YXMgbm90IHlldCBpbnZva2VkLlwiKTtcbiAgICB9KTtcbiAgICBzcHlBcGkuY2FsbEFyZ09uV2l0aCA9IHNweUFwaS5jYWxsQXJnT247XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwieWllbGRcIiwgZmFsc2UsIFwieWllbGRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50b1N0cmluZygpICsgXCIgY2Fubm90IHlpZWxkIHNpbmNlIGl0IHdhcyBub3QgeWV0IGludm9rZWQuXCIpO1xuICAgIH0pO1xuICAgIC8vIFwiaW52b2tlQ2FsbGJhY2tcIiBpcyBhbiBhbGlhcyBmb3IgXCJ5aWVsZFwiIHNpbmNlIFwieWllbGRcIiBpcyBpbnZhbGlkIGluIHN0cmljdCBtb2RlLlxuICAgIHNweUFwaS5pbnZva2VDYWxsYmFjayA9IHNweUFwaS55aWVsZDtcbiAgICBkZWxlZ2F0ZVRvQ2FsbHMoXCJ5aWVsZE9uXCIsIGZhbHNlLCBcInlpZWxkT25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy50b1N0cmluZygpICsgXCIgY2Fubm90IHlpZWxkIHNpbmNlIGl0IHdhcyBub3QgeWV0IGludm9rZWQuXCIpO1xuICAgIH0pO1xuICAgIGRlbGVnYXRlVG9DYWxscyhcInlpZWxkVG9cIiwgZmFsc2UsIFwieWllbGRUb1wiLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGNhbm5vdCB5aWVsZCB0byAnXCIgKyBwcm9wZXJ0eSArXG4gICAgICAgICAgICBcIicgc2luY2UgaXQgd2FzIG5vdCB5ZXQgaW52b2tlZC5cIik7XG4gICAgfSk7XG4gICAgZGVsZWdhdGVUb0NhbGxzKFwieWllbGRUb09uXCIsIGZhbHNlLCBcInlpZWxkVG9PblwiLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMudG9TdHJpbmcoKSArIFwiIGNhbm5vdCB5aWVsZCB0byAnXCIgKyBwcm9wZXJ0eSArXG4gICAgICAgICAgICBcIicgc2luY2UgaXQgd2FzIG5vdCB5ZXQgaW52b2tlZC5cIik7XG4gICAgfSk7XG5cbiAgICBzcHlBcGkuZm9ybWF0dGVycyA9IHtcbiAgICAgICAgXCJjXCI6IGZ1bmN0aW9uIChzcHkpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5vbi50aW1lc0luV29yZHMoc3B5LmNhbGxDb3VudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgXCJuXCI6IGZ1bmN0aW9uIChzcHkpIHtcbiAgICAgICAgICAgIHJldHVybiBzcHkudG9TdHJpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIkNcIjogZnVuY3Rpb24gKHNweSkge1xuICAgICAgICAgICAgdmFyIGNhbGxzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3B5LmNhbGxDb3VudDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHJpbmdpZmllZENhbGwgPSBcIiAgICBcIiArIHNweS5nZXRDYWxsKGkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKC9cXG4vLnRlc3QoY2FsbHNbaSAtIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdpZmllZENhbGwgPSBcIlxcblwiICsgc3RyaW5naWZpZWRDYWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdXNoLmNhbGwoY2FsbHMsIHN0cmluZ2lmaWVkQ2FsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxscy5sZW5ndGggPiAwID8gXCJcXG5cIiArIGNhbGxzLmpvaW4oXCJcXG5cIikgOiBcIlwiO1xuICAgICAgICB9LFxuXG4gICAgICAgIFwidFwiOiBmdW5jdGlvbiAoc3B5KSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0cyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNweS5jYWxsQ291bnQ7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwdXNoLmNhbGwob2JqZWN0cywgc2lub24uZm9ybWF0KHNweS50aGlzVmFsdWVzW2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmplY3RzLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBcIipcIjogZnVuY3Rpb24gKHNweSwgYXJncykge1xuICAgICAgICAgICAgdmFyIGZvcm1hdHRlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3MubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcHVzaC5jYWxsKGZvcm1hdHRlZCwgc2lub24uZm9ybWF0KGFyZ3NbaV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZC5qb2luKFwiLCBcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2lub24uZXh0ZW5kKHNweSwgc3B5QXBpKTtcblxuICAgIHNweS5zcHlDYWxsID0gc2lub24uc3B5Q2FsbDtcblxuICAgIGlmIChjb21tb25KU01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHNweTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5vbi5zcHkgPSBzcHk7XG4gICAgfVxufSh0eXBlb2Ygc2lub24gPT0gXCJvYmplY3RcIiAmJiBzaW5vbiB8fCBudWxsKSk7XG4iLCIvKipcbiAqIEBkZXBlbmQgLi4vc2lub24uanNcbiAqIEBkZXBlbmQgc3B5LmpzXG4gKiBAZGVwZW5kIGJlaGF2aW9yLmpzXG4gKi9cbi8qanNsaW50IGVxZXFlcTogZmFsc2UsIG9uZXZhcjogZmFsc2UqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlLCBzaW5vbiovXG4vKipcbiAqIFN0dWIgZnVuY3Rpb25zXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbiAoc2lub24pIHtcbiAgICB2YXIgY29tbW9uSlNNb2R1bGUgPSB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cztcblxuICAgIGlmICghc2lub24gJiYgY29tbW9uSlNNb2R1bGUpIHtcbiAgICAgICAgc2lub24gPSByZXF1aXJlKFwiLi4vc2lub25cIik7XG4gICAgfVxuXG4gICAgaWYgKCFzaW5vbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3R1YihvYmplY3QsIHByb3BlcnR5LCBmdW5jKSB7XG4gICAgICAgIGlmICghIWZ1bmMgJiYgdHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ3VzdG9tIHN0dWIgc2hvdWxkIGJlIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdyYXBwZXI7XG5cbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSBzaW5vbi5zcHkgJiYgc2lub24uc3B5LmNyZWF0ZSA/IHNpbm9uLnNweS5jcmVhdGUoZnVuYykgOiBmdW5jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IHN0dWIuY3JlYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9iamVjdCAmJiB0eXBlb2YgcHJvcGVydHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5vbi5zdHViLmNyZWF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygb2JqZWN0ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbcHJvcF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBzdHViKG9iamVjdCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNpbm9uLndyYXBNZXRob2Qob2JqZWN0LCBwcm9wZXJ0eSwgd3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdEJlaGF2aW9yKHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHN0dWIuZGVmYXVsdEJlaGF2aW9yIHx8IGdldFBhcmVudEJlaGF2aW91cihzdHViKSB8fCBzaW5vbi5iZWhhdmlvci5jcmVhdGUoc3R1Yik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyZW50QmVoYXZpb3VyKHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIChzdHViLnBhcmVudCAmJiBnZXRDdXJyZW50QmVoYXZpb3Ioc3R1Yi5wYXJlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50QmVoYXZpb3Ioc3R1Yikge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSBzdHViLmJlaGF2aW9yc1tzdHViLmNhbGxDb3VudCAtIDFdO1xuICAgICAgICByZXR1cm4gYmVoYXZpb3IgJiYgYmVoYXZpb3IuaXNQcmVzZW50KCkgPyBiZWhhdmlvciA6IGdldERlZmF1bHRCZWhhdmlvcihzdHViKTtcbiAgICB9XG5cbiAgICB2YXIgdXVpZCA9IDA7XG5cbiAgICBzaW5vbi5leHRlbmQoc3R1YiwgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3RvID0ge1xuICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uU3R1YiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRCZWhhdmlvcihmdW5jdGlvblN0dWIpLmludm9rZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvblN0dWIuaWQgPSBcInN0dWIjXCIgKyB1dWlkKys7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBmdW5jdGlvblN0dWI7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25TdHViID0gc2lub24uc3B5LmNyZWF0ZShmdW5jdGlvblN0dWIpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uU3R1Yi5mdW5jID0gb3JpZztcblxuICAgICAgICAgICAgICAgIHNpbm9uLmV4dGVuZChmdW5jdGlvblN0dWIsIHN0dWIpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uU3R1Yi5fY3JlYXRlID0gc2lub24uc3R1Yi5jcmVhdGU7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25TdHViLmRpc3BsYXlOYW1lID0gXCJzdHViXCI7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25TdHViLnRvU3RyaW5nID0gc2lub24uZnVuY3Rpb25Ub1N0cmluZztcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uU3R1Yi5kZWZhdWx0QmVoYXZpb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uU3R1Yi5iZWhhdmlvcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvblN0dWI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXNldEJlaGF2aW9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5iZWhhdmlvcnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJldHVyblZhbHVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJldHVybkFyZ0F0O1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuVGhpcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmFrZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZmFrZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmFrZXNbaV0ucmVzZXRCZWhhdmlvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25DYWxsOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5iZWhhdmlvcnNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmVoYXZpb3JzW2luZGV4XSA9IHNpbm9uLmJlaGF2aW9yLmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvcnNbaW5kZXhdO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25GaXJzdENhbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uQ2FsbCgwKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uU2Vjb25kQ2FsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25DYWxsKDEpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25UaGlyZENhbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uQ2FsbCgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBtZXRob2QgaW4gc2lub24uYmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGlmIChzaW5vbi5iZWhhdmlvci5oYXNPd25Qcm9wZXJ0eShtZXRob2QpICYmXG4gICAgICAgICAgICAgICAgIXByb3RvLmhhc093blByb3BlcnR5KG1ldGhvZCkgJiZcbiAgICAgICAgICAgICAgICBtZXRob2QgIT0gJ2NyZWF0ZScgJiZcbiAgICAgICAgICAgICAgICBtZXRob2QgIT0gJ3dpdGhBcmdzJyAmJlxuICAgICAgICAgICAgICAgIG1ldGhvZCAhPSAnaW52b2tlJykge1xuICAgICAgICAgICAgICAgIHByb3RvW21ldGhvZF0gPSAoZnVuY3Rpb24oYmVoYXZpb3JNZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0QmVoYXZpb3IgPSB0aGlzLmRlZmF1bHRCZWhhdmlvciB8fCBzaW5vbi5iZWhhdmlvci5jcmVhdGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRCZWhhdmlvcltiZWhhdmlvck1ldGhvZF0uYXBwbHkodGhpcy5kZWZhdWx0QmVoYXZpb3IsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KG1ldGhvZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgIH0oKSkpO1xuXG4gICAgaWYgKGNvbW1vbkpTTW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gc3R1YjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaW5vbi5zdHViID0gc3R1YjtcbiAgICB9XG59KHR5cGVvZiBzaW5vbiA9PSBcIm9iamVjdFwiICYmIHNpbm9uIHx8IG51bGwpKTtcbiIsIi8qKlxuICogQGRlcGVuZCAuLi9zaW5vbi5qc1xuICogQGRlcGVuZCBzdHViLmpzXG4gKiBAZGVwZW5kIG1vY2suanNcbiAqIEBkZXBlbmQgc2FuZGJveC5qc1xuICovXG4vKmpzbGludCBlcWVxZXE6IGZhbHNlLCBvbmV2YXI6IGZhbHNlLCBmb3JpbjogdHJ1ZSwgcGx1c3BsdXM6IGZhbHNlKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgc2lub24qL1xuLyoqXG4gKiBUZXN0IGZ1bmN0aW9uLCBzYW5kYm94ZXMgZmFrZXNcbiAqXG4gKiBAYXV0aG9yIENocmlzdGlhbiBKb2hhbnNlbiAoY2hyaXN0aWFuQGNqb2hhbnNlbi5ubylcbiAqIEBsaWNlbnNlIEJTRFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMC0yMDEzIENocmlzdGlhbiBKb2hhbnNlblxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuKGZ1bmN0aW9uIChzaW5vbikge1xuICAgIHZhciBjb21tb25KU01vZHVsZSA9IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzO1xuXG4gICAgaWYgKCFzaW5vbiAmJiBjb21tb25KU01vZHVsZSkge1xuICAgICAgICBzaW5vbiA9IHJlcXVpcmUoXCIuLi9zaW5vblwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXNpbm9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0KGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNhbGxiYWNrO1xuXG4gICAgICAgIGlmICh0eXBlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNpbm9uLnRlc3QgbmVlZHMgdG8gd3JhcCBhIHRlc3QgZnVuY3Rpb24sIGdvdCBcIiArIHR5cGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBzaW5vbi5nZXRDb25maWcoc2lub24uY29uZmlnKTtcbiAgICAgICAgICAgIGNvbmZpZy5pbmplY3RJbnRvID0gY29uZmlnLmluamVjdEludG9UaGlzICYmIHRoaXMgfHwgY29uZmlnLmluamVjdEludG87XG4gICAgICAgICAgICB2YXIgc2FuZGJveCA9IHNpbm9uLnNhbmRib3guY3JlYXRlKGNvbmZpZyk7XG4gICAgICAgICAgICB2YXIgZXhjZXB0aW9uLCByZXN1bHQ7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KHNhbmRib3guYXJncyk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uID0gZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleGNlcHRpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBzYW5kYm94LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYW5kYm94LnZlcmlmeUFuZFJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB0ZXN0LmNvbmZpZyA9IHtcbiAgICAgICAgaW5qZWN0SW50b1RoaXM6IHRydWUsXG4gICAgICAgIGluamVjdEludG86IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXM6IFtcInNweVwiLCBcInN0dWJcIiwgXCJtb2NrXCIsIFwiY2xvY2tcIiwgXCJzZXJ2ZXJcIiwgXCJyZXF1ZXN0c1wiXSxcbiAgICAgICAgdXNlRmFrZVRpbWVyczogdHJ1ZSxcbiAgICAgICAgdXNlRmFrZVNlcnZlcjogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAoY29tbW9uSlNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB0ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbm9uLnRlc3QgPSB0ZXN0O1xuICAgIH1cbn0odHlwZW9mIHNpbm9uID09IFwib2JqZWN0XCIgJiYgc2lub24gfHwgbnVsbCkpO1xuIiwiLyoqXG4gKiBAZGVwZW5kIC4uL3Npbm9uLmpzXG4gKiBAZGVwZW5kIHRlc3QuanNcbiAqL1xuLypqc2xpbnQgZXFlcWVxOiBmYWxzZSwgb25ldmFyOiBmYWxzZSwgZXFlcWVxOiBmYWxzZSovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUsIHNpbm9uKi9cbi8qKlxuICogVGVzdCBjYXNlLCBzYW5kYm94ZXMgYWxsIHRlc3QgZnVuY3Rpb25zXG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbiAoc2lub24pIHtcbiAgICB2YXIgY29tbW9uSlNNb2R1bGUgPSB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cztcblxuICAgIGlmICghc2lub24gJiYgY29tbW9uSlNNb2R1bGUpIHtcbiAgICAgICAgc2lub24gPSByZXF1aXJlKFwiLi4vc2lub25cIik7XG4gICAgfVxuXG4gICAgaWYgKCFzaW5vbiB8fCAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVGVzdChwcm9wZXJ0eSwgc2V0VXAsIHRlYXJEb3duKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2V0VXApIHtcbiAgICAgICAgICAgICAgICBzZXRVcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXhjZXB0aW9uLCByZXN1bHQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvcGVydHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBleGNlcHRpb24gPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGVhckRvd24pIHtcbiAgICAgICAgICAgICAgICB0ZWFyRG93bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RDYXNlKHRlc3RzLCBwcmVmaXgpIHtcbiAgICAgICAgLypqc2w6aWdub3JlKi9cbiAgICAgICAgaWYgKCF0ZXN0cyB8fCB0eXBlb2YgdGVzdHMgIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNpbm9uLnRlc3RDYXNlIG5lZWRzIGFuIG9iamVjdCB3aXRoIHRlc3QgZnVuY3Rpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qanNsOmVuZCovXG5cbiAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8IFwidGVzdFwiO1xuICAgICAgICB2YXIgclByZWZpeCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwcmVmaXgpO1xuICAgICAgICB2YXIgbWV0aG9kcyA9IHt9LCB0ZXN0TmFtZSwgcHJvcGVydHksIG1ldGhvZDtcbiAgICAgICAgdmFyIHNldFVwID0gdGVzdHMuc2V0VXA7XG4gICAgICAgIHZhciB0ZWFyRG93biA9IHRlc3RzLnRlYXJEb3duO1xuXG4gICAgICAgIGZvciAodGVzdE5hbWUgaW4gdGVzdHMpIHtcbiAgICAgICAgICAgIGlmICh0ZXN0cy5oYXNPd25Qcm9wZXJ0eSh0ZXN0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHRlc3RzW3Rlc3ROYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmICgvXihzZXRVcHx0ZWFyRG93bikkLy50ZXN0KHRlc3ROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09IFwiZnVuY3Rpb25cIiAmJiByUHJlZml4LnRlc3QodGVzdE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHByb3BlcnR5O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXRVcCB8fCB0ZWFyRG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gY3JlYXRlVGVzdChwcm9wZXJ0eSwgc2V0VXAsIHRlYXJEb3duKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHNbdGVzdE5hbWVdID0gc2lub24udGVzdChtZXRob2QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZHNbdGVzdE5hbWVdID0gdGVzdHNbdGVzdE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgIH1cblxuICAgIGlmIChjb21tb25KU01vZHVsZSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHRlc3RDYXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpbm9uLnRlc3RDYXNlID0gdGVzdENhc2U7XG4gICAgfVxufSh0eXBlb2Ygc2lub24gPT0gXCJvYmplY3RcIiAmJiBzaW5vbiB8fCBudWxsKSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKmpzbGludCBlcWVxZXE6IGZhbHNlLCBwbHVzcGx1czogZmFsc2UsIGV2aWw6IHRydWUsIG9uZXZhcjogZmFsc2UsIGJyb3dzZXI6IHRydWUsIGZvcmluOiBmYWxzZSovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUsIHdpbmRvdyovXG4vKipcbiAqIEZha2UgdGltZXIgQVBJXG4gKiBzZXRUaW1lb3V0XG4gKiBzZXRJbnRlcnZhbFxuICogY2xlYXJUaW1lb3V0XG4gKiBjbGVhckludGVydmFsXG4gKiB0aWNrXG4gKiByZXNldFxuICogRGF0ZVxuICpcbiAqIEluc3BpcmVkIGJ5IGpzVW5pdE1vY2tUaW1lT3V0IGZyb20gSnNVbml0XG4gKlxuICogQGF1dGhvciBDaHJpc3RpYW4gSm9oYW5zZW4gKGNocmlzdGlhbkBjam9oYW5zZW4ubm8pXG4gKiBAbGljZW5zZSBCU0RcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBDaHJpc3RpYW4gSm9oYW5zZW5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2Ygc2lub24gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzaW5vbiA9IHt9O1xufVxuXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIC8vIG5vZGUgZXhwZWN0cyBzZXRUaW1lb3V0L3NldEludGVydmFsIHRvIHJldHVybiBhIGZuIG9iamVjdCB3LyAucmVmKCkvLnVucmVmKClcbiAgICAvLyBicm93c2VycywgYSBudW1iZXIuXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jam9oYW5zZW4vU2lub24uSlMvcHVsbC80MzZcbiAgICB2YXIgdGltZW91dFJlc3VsdCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7fSwgMCk7XG4gICAgdmFyIGFkZFRpbWVyUmV0dXJuc09iamVjdCA9IHR5cGVvZiB0aW1lb3V0UmVzdWx0ID09PSAnb2JqZWN0JztcbiAgICBjbGVhclRpbWVvdXQodGltZW91dFJlc3VsdCk7XG5cbiAgICB2YXIgaWQgPSAxO1xuXG4gICAgZnVuY3Rpb24gYWRkVGltZXIoYXJncywgcmVjdXJyaW5nKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gcmVxdWlyZXMgYXQgbGVhc3QgMSBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIG11c3QgYmUgcHJvdmlkZWQgdG8gdGltZXIgY2FsbHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9JZCA9IGlkKys7XG4gICAgICAgIHZhciBkZWxheSA9IGFyZ3NbMV0gfHwgMDtcblxuICAgICAgICBpZiAoIXRoaXMudGltZW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZW91dHNbdG9JZF0gPSB7XG4gICAgICAgICAgICBpZDogdG9JZCxcbiAgICAgICAgICAgIGZ1bmM6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWxsQXQ6IHRoaXMubm93ICsgZGVsYXksXG4gICAgICAgICAgICBpbnZva2VBcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAyKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChyZWN1cnJpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudGltZW91dHNbdG9JZF0uaW50ZXJ2YWwgPSBkZWxheTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRUaW1lclJldHVybnNPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IHRvSWQsXG4gICAgICAgICAgICAgICAgcmVmOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAgICAgICAgIHVucmVmOiBmdW5jdGlvbigpIHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRvSWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRpbWUoc3RyKSB7XG4gICAgICAgIGlmICghc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHJpbmdzID0gc3RyLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgdmFyIGwgPSBzdHJpbmdzLmxlbmd0aCwgaSA9IGw7XG4gICAgICAgIHZhciBtcyA9IDAsIHBhcnNlZDtcblxuICAgICAgICBpZiAobCA+IDMgfHwgIS9eKFxcZFxcZDopezAsMn1cXGRcXGQ/JC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0aWNrIG9ubHkgdW5kZXJzdGFuZHMgbnVtYmVycyBhbmQgJ2g6bTpzJ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZ3NbaV0sIDEwKTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlZCA+PSA2MCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdGltZSBcIiArIHN0cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1zICs9IHBhcnNlZCAqIE1hdGgucG93KDYwLCAobCAtIGkgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXMgKiAxMDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgdmFyIG5ld09iamVjdDtcblxuICAgICAgICBpZiAoT2JqZWN0LmNyZWF0ZSkge1xuICAgICAgICAgICAgbmV3T2JqZWN0ID0gT2JqZWN0LmNyZWF0ZShvYmplY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqZWN0O1xuICAgICAgICAgICAgbmV3T2JqZWN0ID0gbmV3IEYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld09iamVjdC5EYXRlLmNsb2NrID0gbmV3T2JqZWN0O1xuICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH1cblxuICAgIHNpbm9uLmNsb2NrID0ge1xuICAgICAgICBub3c6IDAsXG5cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUobm93KSB7XG4gICAgICAgICAgICB2YXIgY2xvY2sgPSBjcmVhdGVPYmplY3QodGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm93ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjbG9jay5ub3cgPSBub3c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghIW5vdyAmJiB0eXBlb2Ygbm93ID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibm93IHNob3VsZCBiZSBtaWxsaXNlY29uZHMgc2luY2UgVU5JWCBlcG9jaFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNsb2NrO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFRpbWVvdXQ6IGZ1bmN0aW9uIHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRUaW1lci5jYWxsKHRoaXMsIGFyZ3VtZW50cywgZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyVGltZW91dDogZnVuY3Rpb24gY2xlYXJUaW1lb3V0KHRpbWVySWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lb3V0cykge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dHMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpbWVySWQgaW4gdGhpcy50aW1lb3V0cykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRpbWVvdXRzW3RpbWVySWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldEludGVydmFsOiBmdW5jdGlvbiBzZXRJbnRlcnZhbChjYWxsYmFjaywgdGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFRpbWVyLmNhbGwodGhpcywgYXJndW1lbnRzLCB0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckludGVydmFsOiBmdW5jdGlvbiBjbGVhckludGVydmFsKHRpbWVySWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEltbWVkaWF0ZTogZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgcGFzc1RocnVBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFkZFRpbWVyLmNhbGwodGhpcywgW2NhbGxiYWNrLCAwXS5jb25jYXQocGFzc1RocnVBcmdzKSwgZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFySW1tZWRpYXRlOiBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZSh0aW1lcklkKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0aWNrOiBmdW5jdGlvbiB0aWNrKG1zKSB7XG4gICAgICAgICAgICBtcyA9IHR5cGVvZiBtcyA9PSBcIm51bWJlclwiID8gbXMgOiBwYXJzZVRpbWUobXMpO1xuICAgICAgICAgICAgdmFyIHRpY2tGcm9tID0gdGhpcy5ub3csIHRpY2tUbyA9IHRoaXMubm93ICsgbXMsIHByZXZpb3VzID0gdGhpcy5ub3c7XG4gICAgICAgICAgICB2YXIgdGltZXIgPSB0aGlzLmZpcnN0VGltZXJJblJhbmdlKHRpY2tGcm9tLCB0aWNrVG8pO1xuXG4gICAgICAgICAgICB2YXIgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICB3aGlsZSAodGltZXIgJiYgdGlja0Zyb20gPD0gdGlja1RvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGltZW91dHNbdGltZXIuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2tGcm9tID0gdGhpcy5ub3cgPSB0aW1lci5jYWxsQXQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVGltZXIodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZmlyc3RFeGNlcHRpb24gPSBmaXJzdEV4Y2VwdGlvbiB8fCBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGltZXIgPSB0aGlzLmZpcnN0VGltZXJJblJhbmdlKHByZXZpb3VzLCB0aWNrVG8pO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gdGlja0Zyb207XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubm93ID0gdGlja1RvO1xuXG4gICAgICAgICAgICBpZiAoZmlyc3RFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgdGhyb3cgZmlyc3RFeGNlcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdztcbiAgICAgICAgfSxcblxuICAgICAgICBmaXJzdFRpbWVySW5SYW5nZTogZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgICAgICB2YXIgdGltZXIsIHNtYWxsZXN0ID0gbnVsbCwgb3JpZ2luYWxUaW1lcjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy50aW1lb3V0cykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVvdXRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50aW1lb3V0c1tpZF0uY2FsbEF0IDwgZnJvbSB8fCB0aGlzLnRpbWVvdXRzW2lkXS5jYWxsQXQgPiB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc21hbGxlc3QgPT09IG51bGwgfHwgdGhpcy50aW1lb3V0c1tpZF0uY2FsbEF0IDwgc21hbGxlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsVGltZXIgPSB0aGlzLnRpbWVvdXRzW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0ID0gdGhpcy50aW1lb3V0c1tpZF0uY2FsbEF0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jOiB0aGlzLnRpbWVvdXRzW2lkXS5mdW5jLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxBdDogdGhpcy50aW1lb3V0c1tpZF0uY2FsbEF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsOiB0aGlzLnRpbWVvdXRzW2lkXS5pbnRlcnZhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy50aW1lb3V0c1tpZF0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlQXJnczogdGhpcy50aW1lb3V0c1tpZF0uaW52b2tlQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRpbWVyIHx8IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2FsbFRpbWVyOiBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZXIuaW50ZXJ2YWwgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dHNbdGltZXIuaWRdLmNhbGxBdCArPSB0aW1lci5pbnRlcnZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGltZW91dHNbdGltZXIuaWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGltZXIuZnVuYyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIuZnVuYy5hcHBseShudWxsLCB0aW1lci5pbnZva2VBcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBldmFsKHRpbWVyLmZ1bmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy50aW1lb3V0c1t0aW1lci5pZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0cyA9IHt9O1xuICAgICAgICB9LFxuXG4gICAgICAgIERhdGU6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgTmF0aXZlRGF0ZSA9IERhdGU7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIENsb2NrRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1zKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZW5zaXZlIGFuZCB2ZXJib3NlIHRvIGF2b2lkIHBvdGVudGlhbCBoYXJtIGluIHBhc3NpbmdcbiAgICAgICAgICAgICAgICAvLyBleHBsaWNpdCB1bmRlZmluZWQgd2hlbiB1c2VyIGRvZXMgbm90IHBhc3MgYXJndW1lbnRcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZShDbG9ja0RhdGUuY2xvY2subm93KTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZSh5ZWFyKTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZURhdGUoeWVhciwgbW9udGgsIGRhdGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVEYXRlKHllYXIsIG1vbnRoLCBkYXRlLCBob3VyKTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSwgaG91ciwgbWludXRlKTtcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSwgaG91ciwgbWludXRlLCBzZWNvbmQpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmF0aXZlRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtaXJyb3JEYXRlUHJvcGVydGllcyhDbG9ja0RhdGUsIE5hdGl2ZURhdGUpO1xuICAgICAgICB9KCkpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1pcnJvckRhdGVQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2Uubm93KSB7XG4gICAgICAgICAgICB0YXJnZXQubm93ID0gZnVuY3Rpb24gbm93KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuY2xvY2subm93O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQubm93O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZS50b1NvdXJjZSkge1xuICAgICAgICAgICAgdGFyZ2V0LnRvU291cmNlID0gZnVuY3Rpb24gdG9Tb3VyY2UoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS50b1NvdXJjZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQudG9Tb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0YXJnZXQucHJvdG90eXBlID0gc291cmNlLnByb3RvdHlwZTtcbiAgICAgICAgdGFyZ2V0LnBhcnNlID0gc291cmNlLnBhcnNlO1xuICAgICAgICB0YXJnZXQuVVRDID0gc291cmNlLlVUQztcbiAgICAgICAgdGFyZ2V0LnByb3RvdHlwZS50b1VUQ1N0cmluZyA9IHNvdXJjZS5wcm90b3R5cGUudG9VVENTdHJpbmc7XG5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBtZXRob2RzID0gW1wiRGF0ZVwiLCBcInNldFRpbWVvdXRcIiwgXCJzZXRJbnRlcnZhbFwiLFxuICAgICAgICAgICAgICAgICAgIFwiY2xlYXJUaW1lb3V0XCIsIFwiY2xlYXJJbnRlcnZhbFwiXTtcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsLnNldEltbWVkaWF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBtZXRob2RzLnB1c2goXCJzZXRJbW1lZGlhdGVcIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbWV0aG9kcy5wdXNoKFwiY2xlYXJJbW1lZGlhdGVcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICAgICAgdmFyIG1ldGhvZDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubWV0aG9kcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IHRoaXMubWV0aG9kc1tpXTtcblxuICAgICAgICAgICAgaWYgKGdsb2JhbFttZXRob2RdLmhhZE93blByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsW21ldGhvZF0gPSB0aGlzW1wiX1wiICsgbWV0aG9kXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdsb2JhbFttZXRob2RdO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGV4ZWN1dGlvbnMgd2hpY2ggd2lsbCBjb21wbGV0ZWx5IHJlbW92ZSB0aGVzZSBwcm9wc1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHViR2xvYmFsKG1ldGhvZCwgY2xvY2spIHtcbiAgICAgICAgY2xvY2tbbWV0aG9kXS5oYWRPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnbG9iYWwsIG1ldGhvZCk7XG4gICAgICAgIGNsb2NrW1wiX1wiICsgbWV0aG9kXSA9IGdsb2JhbFttZXRob2RdO1xuXG4gICAgICAgIGlmIChtZXRob2QgPT0gXCJEYXRlXCIpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbWlycm9yRGF0ZVByb3BlcnRpZXMoY2xvY2tbbWV0aG9kXSwgZ2xvYmFsW21ldGhvZF0pO1xuICAgICAgICAgICAgZ2xvYmFsW21ldGhvZF0gPSBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb2NrW21ldGhvZF0uYXBwbHkoY2xvY2ssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsb2NrW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvY2tbbWV0aG9kXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxbbWV0aG9kXVtwcm9wXSA9IGNsb2NrW21ldGhvZF1bcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2xvYmFsW21ldGhvZF0uY2xvY2sgPSBjbG9jaztcbiAgICB9XG5cbiAgICBzaW5vbi51c2VGYWtlVGltZXJzID0gZnVuY3Rpb24gdXNlRmFrZVRpbWVycyhub3cpIHtcbiAgICAgICAgdmFyIGNsb2NrID0gc2lub24uY2xvY2suY3JlYXRlKG5vdyk7XG4gICAgICAgIGNsb2NrLnJlc3RvcmUgPSByZXN0b3JlO1xuICAgICAgICBjbG9jay5tZXRob2RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG5vdyA9PSBcIm51bWJlclwiID8gMSA6IDApO1xuXG4gICAgICAgIGlmIChjbG9jay5tZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY2xvY2subWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNsb2NrLm1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBzdHViR2xvYmFsKGNsb2NrLm1ldGhvZHNbaV0sIGNsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9jaztcbiAgICB9O1xufSh0eXBlb2YgZ2xvYmFsICE9IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gXCJmdW5jdGlvblwiID8gZ2xvYmFsIDogdGhpcykpO1xuXG5zaW5vbi50aW1lcnMgPSB7XG4gICAgc2V0VGltZW91dDogc2V0VGltZW91dCxcbiAgICBjbGVhclRpbWVvdXQ6IGNsZWFyVGltZW91dCxcbiAgICBzZXRJbW1lZGlhdGU6ICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSBcInVuZGVmaW5lZFwiID8gc2V0SW1tZWRpYXRlIDogdW5kZWZpbmVkKSxcbiAgICBjbGVhckltbWVkaWF0ZTogKHR5cGVvZiBjbGVhckltbWVkaWF0ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IGNsZWFySW1tZWRpYXRlOiB1bmRlZmluZWQpLFxuICAgIHNldEludGVydmFsOiBzZXRJbnRlcnZhbCxcbiAgICBjbGVhckludGVydmFsOiBjbGVhckludGVydmFsLFxuICAgIERhdGU6IERhdGVcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2lub247XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuKCh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCAmJiBmdW5jdGlvbiAobSkge1xuICAgIGRlZmluZShcImZvcm1hdGlvXCIsIFtcInNhbXNhbVwiXSwgbSk7XG59KSB8fCAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBmdW5jdGlvbiAobSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbShyZXF1aXJlKFwic2Ftc2FtXCIpKTtcbn0pIHx8IGZ1bmN0aW9uIChtKSB7IHRoaXMuZm9ybWF0aW8gPSBtKHRoaXMuc2Ftc2FtKTsgfVxuKShmdW5jdGlvbiAoc2Ftc2FtKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgZm9ybWF0aW8gPSB7XG4gICAgICAgIGV4Y2x1ZGVDb25zdHJ1Y3RvcnM6IFtcIk9iamVjdFwiLCAvXi4kL10sXG4gICAgICAgIHF1b3RlU3RyaW5nczogdHJ1ZVxuICAgIH07XG5cbiAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICAgIHZhciBzcGVjaWFsT2JqZWN0cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNwZWNpYWxPYmplY3RzLnB1c2goeyBvYmplY3Q6IGdsb2JhbCwgdmFsdWU6IFwiW29iamVjdCBnbG9iYWxdXCIgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc3BlY2lhbE9iamVjdHMucHVzaCh7XG4gICAgICAgICAgICBvYmplY3Q6IGRvY3VtZW50LFxuICAgICAgICAgICAgdmFsdWU6IFwiW29iamVjdCBIVE1MRG9jdW1lbnRdXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNwZWNpYWxPYmplY3RzLnB1c2goeyBvYmplY3Q6IHdpbmRvdywgdmFsdWU6IFwiW29iamVjdCBXaW5kb3ddXCIgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZ1bmMpIHtcbiAgICAgICAgaWYgKCFmdW5jKSB7IHJldHVybiBcIlwiOyB9XG4gICAgICAgIGlmIChmdW5jLmRpc3BsYXlOYW1lKSB7IHJldHVybiBmdW5jLmRpc3BsYXlOYW1lOyB9XG4gICAgICAgIGlmIChmdW5jLm5hbWUpIHsgcmV0dXJuIGZ1bmMubmFtZTsgfVxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGZ1bmMudG9TdHJpbmcoKS5tYXRjaCgvZnVuY3Rpb25cXHMrKFteXFwoXSspL20pO1xuICAgICAgICByZXR1cm4gKG1hdGNoZXMgJiYgbWF0Y2hlc1sxXSkgfHwgXCJcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3Rvck5hbWUoZiwgb2JqZWN0KSB7XG4gICAgICAgIHZhciBuYW1lID0gZnVuY3Rpb25OYW1lKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IpO1xuICAgICAgICB2YXIgZXhjbHVkZXMgPSBmLmV4Y2x1ZGVDb25zdHJ1Y3RvcnMgfHxcbiAgICAgICAgICAgICAgICBmb3JtYXRpby5leGNsdWRlQ29uc3RydWN0b3JzIHx8IFtdO1xuXG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXhjbHVkZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4Y2x1ZGVzW2ldID09PSBcInN0cmluZ1wiICYmIGV4Y2x1ZGVzW2ldID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4Y2x1ZGVzW2ldLnRlc3QgJiYgZXhjbHVkZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDaXJjdWxhcihvYmplY3QsIG9iamVjdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSBvYmplY3QpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNjaWkoZiwgb2JqZWN0LCBwcm9jZXNzZWQsIGluZGVudCkge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIHFzID0gZi5xdW90ZVN0cmluZ3M7XG4gICAgICAgICAgICB2YXIgcXVvdGUgPSB0eXBlb2YgcXMgIT09IFwiYm9vbGVhblwiIHx8IHFzO1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZCB8fCBxdW90ZSA/ICdcIicgKyBvYmplY3QgKyAnXCInIDogb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09IFwiZnVuY3Rpb25cIiAmJiAhKG9iamVjdCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhc2NpaS5mdW5jKG9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzZWQgPSBwcm9jZXNzZWQgfHwgW107XG5cbiAgICAgICAgaWYgKGlzQ2lyY3VsYXIob2JqZWN0LCBwcm9jZXNzZWQpKSB7IHJldHVybiBcIltDaXJjdWxhcl1cIjsgfVxuXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNjaWkuYXJyYXkuY2FsbChmLCBvYmplY3QsIHByb2Nlc3NlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9iamVjdCkgeyByZXR1cm4gU3RyaW5nKCgxL29iamVjdCkgPT09IC1JbmZpbml0eSA/IFwiLTBcIiA6IG9iamVjdCk7IH1cbiAgICAgICAgaWYgKHNhbXNhbS5pc0VsZW1lbnQob2JqZWN0KSkgeyByZXR1cm4gYXNjaWkuZWxlbWVudChvYmplY3QpOyB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdC50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcGVjaWFsT2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT09IHNwZWNpYWxPYmplY3RzW2ldLm9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjaWFsT2JqZWN0c1tpXS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc2NpaS5vYmplY3QuY2FsbChmLCBvYmplY3QsIHByb2Nlc3NlZCwgaW5kZW50KTtcbiAgICB9XG5cbiAgICBhc2NpaS5mdW5jID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb24gXCIgKyBmdW5jdGlvbk5hbWUoZnVuYykgKyBcIigpIHt9XCI7XG4gICAgfTtcblxuICAgIGFzY2lpLmFycmF5ID0gZnVuY3Rpb24gKGFycmF5LCBwcm9jZXNzZWQpIHtcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkIHx8IFtdO1xuICAgICAgICBwcm9jZXNzZWQucHVzaChhcnJheSk7XG4gICAgICAgIHZhciBpLCBsLCBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgcGllY2VzLnB1c2goYXNjaWkodGhpcywgYXJyYXlbaV0sIHByb2Nlc3NlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIltcIiArIHBpZWNlcy5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICB9O1xuXG4gICAgYXNjaWkub2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvY2Vzc2VkLCBpbmRlbnQpIHtcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkIHx8IFtdO1xuICAgICAgICBwcm9jZXNzZWQucHVzaChvYmplY3QpO1xuICAgICAgICBpbmRlbnQgPSBpbmRlbnQgfHwgMDtcbiAgICAgICAgdmFyIHBpZWNlcyA9IFtdLCBwcm9wZXJ0aWVzID0gc2Ftc2FtLmtleXMob2JqZWN0KS5zb3J0KCk7XG4gICAgICAgIHZhciBsZW5ndGggPSAzO1xuICAgICAgICB2YXIgcHJvcCwgc3RyLCBvYmosIGksIGw7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBwcm9wID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIG9iaiA9IG9iamVjdFtwcm9wXTtcblxuICAgICAgICAgICAgaWYgKGlzQ2lyY3VsYXIob2JqLCBwcm9jZXNzZWQpKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gXCJbQ2lyY3VsYXJdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IGFzY2lpKHRoaXMsIG9iaiwgcHJvY2Vzc2VkLCBpbmRlbnQgKyAyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyID0gKC9cXHMvLnRlc3QocHJvcCkgPyAnXCInICsgcHJvcCArICdcIicgOiBwcm9wKSArIFwiOiBcIiArIHN0cjtcbiAgICAgICAgICAgIGxlbmd0aCArPSBzdHIubGVuZ3RoO1xuICAgICAgICAgICAgcGllY2VzLnB1c2goc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25zID0gY29uc3RydWN0b3JOYW1lKHRoaXMsIG9iamVjdCk7XG4gICAgICAgIHZhciBwcmVmaXggPSBjb25zID8gXCJbXCIgKyBjb25zICsgXCJdIFwiIDogXCJcIjtcbiAgICAgICAgdmFyIGlzID0gXCJcIjtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGluZGVudDsgaSA8IGw7ICsraSkgeyBpcyArPSBcIiBcIjsgfVxuXG4gICAgICAgIGlmIChsZW5ndGggKyBpbmRlbnQgPiA4MCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIFwie1xcbiAgXCIgKyBpcyArIHBpZWNlcy5qb2luKFwiLFxcbiAgXCIgKyBpcykgKyBcIlxcblwiICtcbiAgICAgICAgICAgICAgICBpcyArIFwifVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVmaXggKyBcInsgXCIgKyBwaWVjZXMuam9pbihcIiwgXCIpICsgXCIgfVwiO1xuICAgIH07XG5cbiAgICBhc2NpaS5lbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGF0dHJzID0gZWxlbWVudC5hdHRyaWJ1dGVzLCBhdHRyLCBwYWlycyA9IFtdLCBhdHRyTmFtZSwgaSwgbCwgdmFsO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGF0dHIgPSBhdHRycy5pdGVtKGkpO1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcImh0bWw6XCIsIFwiXCIpO1xuICAgICAgICAgICAgdmFsID0gYXR0ci5ub2RlVmFsdWU7XG4gICAgICAgICAgICBpZiAoYXR0ck5hbWUgIT09IFwiY29udGVudGVkaXRhYmxlXCIgfHwgdmFsICE9PSBcImluaGVyaXRcIikge1xuICAgICAgICAgICAgICAgIGlmICghIXZhbCkgeyBwYWlycy5wdXNoKGF0dHJOYW1lICsgXCI9XFxcIlwiICsgdmFsICsgXCJcXFwiXCIpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZm9ybWF0dGVkID0gXCI8XCIgKyB0YWdOYW1lICsgKHBhaXJzLmxlbmd0aCA+IDAgPyBcIiBcIiA6IFwiXCIpO1xuICAgICAgICB2YXIgY29udGVudCA9IGVsZW1lbnQuaW5uZXJIVE1MO1xuXG4gICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA+IDIwKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHIoMCwgMjApICsgXCJbLi4uXVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcyA9IGZvcm1hdHRlZCArIHBhaXJzLmpvaW4oXCIgXCIpICsgXCI+XCIgKyBjb250ZW50ICtcbiAgICAgICAgICAgICAgICBcIjwvXCIgKyB0YWdOYW1lICsgXCI+XCI7XG5cbiAgICAgICAgcmV0dXJuIHJlcy5yZXBsYWNlKC8gY29udGVudEVkaXRhYmxlPVwiaW5oZXJpdFwiLywgXCJcIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZvcm1hdGlvKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXNbb3B0XSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEZvcm1hdGlvLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG5cbiAgICAgICAgY29uZmlndXJlOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRpbyhvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb25zdHJ1Y3Rvck5hbWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zdHJ1Y3Rvck5hbWUodGhpcywgb2JqZWN0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhc2NpaTogZnVuY3Rpb24gKG9iamVjdCwgcHJvY2Vzc2VkLCBpbmRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhc2NpaSh0aGlzLCBvYmplY3QsIHByb2Nlc3NlZCwgaW5kZW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRm9ybWF0aW8ucHJvdG90eXBlO1xufSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKCh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCAmJiBmdW5jdGlvbiAobSkgeyBkZWZpbmUoXCJzYW1zYW1cIiwgbSk7IH0pIHx8XG4gKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgIGZ1bmN0aW9uIChtKSB7IG1vZHVsZS5leHBvcnRzID0gbSgpOyB9KSB8fCAvLyBOb2RlXG4gZnVuY3Rpb24gKG0pIHsgdGhpcy5zYW1zYW0gPSBtKCk7IH0gLy8gQnJvd3NlciBnbG9iYWxzXG4pKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgdmFyIGRpdiA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgICAgLy8gVW5saWtlIGdsb2JhbCBpc05hTiwgdGhpcyBhdm9pZHMgdHlwZSBjb2VyY2lvblxuICAgICAgICAvLyB0eXBlb2YgY2hlY2sgYXZvaWRzIElFIGhvc3Qgb2JqZWN0IGlzc3VlcywgaGF0IHRpcCB0b1xuICAgICAgICAvLyBsb2Rhc2hcbiAgICAgICAgdmFyIHZhbCA9IHZhbHVlOyAvLyBKc0xpbnQgdGhpbmtzIHZhbHVlICE9PSB2YWx1ZSBpcyBcIndlaXJkXCJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSAhPT0gdmFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENsYXNzKHZhbHVlKSB7XG4gICAgICAgIC8vIFJldHVybnMgdGhlIGludGVybmFsIFtbQ2xhc3NdXSBieSBjYWxsaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUgYXMgdGhpcy4gUmV0dXJuIHZhbHVlIGlzIGEgc3RyaW5nLCBuYW1pbmcgdGhlXG4gICAgICAgIC8vIGludGVybmFsIGNsYXNzLCBlLmcuIFwiQXJyYXlcIlxuICAgICAgICByZXR1cm4gby50b1N0cmluZy5jYWxsKHZhbHVlKS5zcGxpdCgvWyBcXF1dLylbMV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2Ftc2FtLmlzQXJndW1lbnRzXG4gICAgICogQHBhcmFtIE9iamVjdCBvYmplY3RcbiAgICAgKlxuICAgICAqIFJldHVybnMgYGB0cnVlYGAgaWYgYGBvYmplY3RgYCBpcyBhbiBgYGFyZ3VtZW50c2BgIG9iamVjdCxcbiAgICAgKiBgYGZhbHNlYGAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICAgICAgICBpZiAoZ2V0Q2xhc3Mob2JqZWN0KSA9PT0gJ0FyZ3VtZW50cycpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iamVjdC5sZW5ndGggIT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICBnZXRDbGFzcyhvYmplY3QpID09PSBcIkFycmF5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jYWxsZWUgPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvYmplY3Rbb2JqZWN0Lmxlbmd0aF0gPSA2O1xuICAgICAgICAgICAgZGVsZXRlIG9iamVjdFtvYmplY3QubGVuZ3RoXTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHNhbXNhbS5pc0VsZW1lbnRcbiAgICAgKiBAcGFyYW0gT2JqZWN0IG9iamVjdFxuICAgICAqXG4gICAgICogUmV0dXJucyBgYHRydWVgYCBpZiBgYG9iamVjdGBgIGlzIGEgRE9NIGVsZW1lbnQgbm9kZS4gVW5saWtlXG4gICAgICogVW5kZXJzY29yZS5qcy9sb2Rhc2gsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gYGBmYWxzZWBgIGlmIGBgb2JqZWN0YGBcbiAgICAgKiBpcyBhbiAqZWxlbWVudC1saWtlKiBvYmplY3QsIGkuZS4gYSByZWd1bGFyIG9iamVjdCB3aXRoIGEgYGBub2RlVHlwZWBgXG4gICAgICogcHJvcGVydHkgdGhhdCBob2xkcyB0aGUgdmFsdWUgYGAxYGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICAgICAgICBpZiAoIW9iamVjdCB8fCBvYmplY3Qubm9kZVR5cGUgIT09IDEgfHwgIWRpdikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9iamVjdC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgb2JqZWN0LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzYW1zYW0ua2V5c1xuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqZWN0XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygb3duIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICAgIHZhciBrcyA9IFtdLCBwcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcCkpIHsga3MucHVzaChwcm9wKTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBzYW1zYW0uaXNEYXRlXG4gICAgICogQHBhcmFtIE9iamVjdCB2YWx1ZVxuICAgICAqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSBgYERhdGVgYCwgb3IgKmRhdGUtbGlrZSouIER1Y2sgdHlwaW5nXG4gICAgICogb2YgZGF0ZSBvYmplY3RzIHdvcmsgYnkgY2hlY2tpbmcgdGhhdCB0aGUgb2JqZWN0IGhhcyBhIGBgZ2V0VGltZWBgXG4gICAgICogZnVuY3Rpb24gd2hvc2UgcmV0dXJuIHZhbHVlIGVxdWFscyB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIG9iamVjdCdzXG4gICAgICogYGB2YWx1ZU9mYGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUuZ2V0VGltZSA9PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHZhbHVlLmdldFRpbWUoKSA9PSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2Ftc2FtLmlzTmVnWmVyb1xuICAgICAqIEBwYXJhbSBPYmplY3QgdmFsdWVcbiAgICAgKlxuICAgICAqIFJldHVybnMgYGB0cnVlYGAgaWYgYGB2YWx1ZWBgIGlzIGBgLTBgYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05lZ1plcm8odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA9PT0gLUluZmluaXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHNhbXNhbS5lcXVhbFxuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqMVxuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqMlxuICAgICAqXG4gICAgICogUmV0dXJucyBgYHRydWVgYCBpZiB0d28gb2JqZWN0cyBhcmUgc3RyaWN0bHkgZXF1YWwuIENvbXBhcmVkIHRvXG4gICAgICogYGA9PT1gYCB0aGVyZSBhcmUgdHdvIGV4Y2VwdGlvbnM6XG4gICAgICpcbiAgICAgKiAgIC0gTmFOIGlzIGNvbnNpZGVyZWQgZXF1YWwgdG8gTmFOXG4gICAgICogICAtIC0wIGFuZCArMCBhcmUgbm90IGNvbnNpZGVyZWQgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGljYWwob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAob2JqMSA9PT0gb2JqMiB8fCAoaXNOYU4ob2JqMSkgJiYgaXNOYU4ob2JqMikpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqMSAhPT0gMCB8fCBpc05lZ1plcm8ob2JqMSkgPT09IGlzTmVnWmVybyhvYmoyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2Ftc2FtLmRlZXBFcXVhbFxuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqMVxuICAgICAqIEBwYXJhbSBPYmplY3Qgb2JqMlxuICAgICAqXG4gICAgICogRGVlcCBlcXVhbCBjb21wYXJpc29uLiBUd28gdmFsdWVzIGFyZSBcImRlZXAgZXF1YWxcIiBpZjpcbiAgICAgKlxuICAgICAqICAgLSBUaGV5IGFyZSBlcXVhbCwgYWNjb3JkaW5nIHRvIHNhbXNhbS5pZGVudGljYWxcbiAgICAgKiAgIC0gVGhleSBhcmUgYm90aCBkYXRlIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBzYW1lIHRpbWVcbiAgICAgKiAgIC0gVGhleSBhcmUgYm90aCBhcnJheXMgY29udGFpbmluZyBlbGVtZW50cyB0aGF0IGFyZSBhbGwgZGVlcEVxdWFsXG4gICAgICogICAtIFRoZXkgYXJlIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBzZXQgb2YgcHJvcGVydGllcywgYW5kIGVhY2ggcHJvcGVydHlcbiAgICAgKiAgICAgaW4gYGBvYmoxYGAgaXMgZGVlcEVxdWFsIHRvIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IGluIGBgb2JqMmBgXG4gICAgICpcbiAgICAgKiBTdXBwb3J0cyBjeWNsaWMgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWVwRXF1YWxDeWNsaWMob2JqMSwgb2JqMikge1xuXG4gICAgICAgIC8vIHVzZWQgZm9yIGN5Y2xpYyBjb21wYXJpc29uXG4gICAgICAgIC8vIGNvbnRhaW4gYWxyZWFkeSB2aXNpdGVkIG9iamVjdHNcbiAgICAgICAgdmFyIG9iamVjdHMxID0gW10sXG4gICAgICAgICAgICBvYmplY3RzMiA9IFtdLFxuICAgICAgICAvLyBjb250YWluIHBhdGhlcyAocG9zaXRpb24gaW4gdGhlIG9iamVjdCBzdHJ1Y3R1cmUpXG4gICAgICAgIC8vIG9mIHRoZSBhbHJlYWR5IHZpc2l0ZWQgb2JqZWN0c1xuICAgICAgICAvLyBpbmRleGVzIHNhbWUgYXMgaW4gb2JqZWN0cyBhcnJheXNcbiAgICAgICAgICAgIHBhdGhzMSA9IFtdLFxuICAgICAgICAgICAgcGF0aHMyID0gW10sXG4gICAgICAgIC8vIGNvbnRhaW5zIGNvbWJpbmF0aW9ucyBvZiBhbHJlYWR5IGNvbXBhcmVkIG9iamVjdHNcbiAgICAgICAgLy8gaW4gdGhlIG1hbm5lcjogeyBcIiQxWydyZWYnXSQyWydyZWYnXVwiOiB0cnVlIH1cbiAgICAgICAgICAgIGNvbXBhcmVkID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVzZWQgdG8gY2hlY2ssIGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzIGFuIG9iamVjdFxuICAgICAgICAgKiAoY3ljbGljIGxvZ2ljIGlzIG9ubHkgbmVlZGVkIGZvciBvYmplY3RzKVxuICAgICAgICAgKiBvbmx5IG5lZWRlZCBmb3IgY3ljbGljIGxvZ2ljXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikgJiZcbiAgICAgICAgICAgICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICAgICYmXG4gICAgICAgICAgICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICAmJlxuICAgICAgICAgICAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSAgJiZcbiAgICAgICAgICAgICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIG9iamVjdCBpbiB0aGVcbiAgICAgICAgICogZ2l2ZW4gb2JqZWN0cyBhcnJheSwgLTEgaWYgbm90IGNvbnRhaW5lZFxuICAgICAgICAgKiBvbmx5IG5lZWRlZCBmb3IgY3ljbGljIGxvZ2ljXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRJbmRleChvYmplY3RzLCBvYmopIHtcblxuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkb2VzIHRoZSByZWN1cnNpb24gZm9yIHRoZSBkZWVwIGVxdWFsIGNoZWNrXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gZGVlcEVxdWFsKG9iajEsIG9iajIsIHBhdGgxLCBwYXRoMikge1xuICAgICAgICAgICAgdmFyIHR5cGUxID0gdHlwZW9mIG9iajE7XG4gICAgICAgICAgICB2YXIgdHlwZTIgPSB0eXBlb2Ygb2JqMjtcblxuICAgICAgICAgICAgLy8gPT0gbnVsbCBhbHNvIG1hdGNoZXMgdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAob2JqMSA9PT0gb2JqMiB8fFxuICAgICAgICAgICAgICAgICAgICBpc05hTihvYmoxKSB8fCBpc05hTihvYmoyKSB8fFxuICAgICAgICAgICAgICAgICAgICBvYmoxID09IG51bGwgfHwgb2JqMiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGUxICE9PSBcIm9iamVjdFwiIHx8IHR5cGUyICE9PSBcIm9iamVjdFwiKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaWRlbnRpY2FsKG9iajEsIG9iajIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbGVtZW50cyBhcmUgb25seSBlcXVhbCBpZiBpZGVudGljYWwoZXhwZWN0ZWQsIGFjdHVhbClcbiAgICAgICAgICAgIGlmIChpc0VsZW1lbnQob2JqMSkgfHwgaXNFbGVtZW50KG9iajIpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgICB2YXIgaXNEYXRlMSA9IGlzRGF0ZShvYmoxKSwgaXNEYXRlMiA9IGlzRGF0ZShvYmoyKTtcbiAgICAgICAgICAgIGlmIChpc0RhdGUxIHx8IGlzRGF0ZTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGF0ZTEgfHwgIWlzRGF0ZTIgfHwgb2JqMS5nZXRUaW1lKCkgIT09IG9iajIuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvYmoxIGluc3RhbmNlb2YgUmVnRXhwICYmIG9iajIgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqMS50b1N0cmluZygpICE9PSBvYmoyLnRvU3RyaW5nKCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbGFzczEgPSBnZXRDbGFzcyhvYmoxKTtcbiAgICAgICAgICAgIHZhciBjbGFzczIgPSBnZXRDbGFzcyhvYmoyKTtcbiAgICAgICAgICAgIHZhciBrZXlzMSA9IGtleXMob2JqMSk7XG4gICAgICAgICAgICB2YXIga2V5czIgPSBrZXlzKG9iajIpO1xuXG4gICAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqMSkgfHwgaXNBcmd1bWVudHMob2JqMikpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZTEgIT09IHR5cGUyIHx8IGNsYXNzMSAhPT0gY2xhc3MyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIga2V5LCBpLCBsLFxuICAgICAgICAgICAgICAgIC8vIGZvbGxvd2luZyB2YXJzIGFyZSB1c2VkIGZvciB0aGUgY3ljbGljIGxvZ2ljXG4gICAgICAgICAgICAgICAgdmFsdWUxLCB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgaXNPYmplY3QxLCBpc09iamVjdDIsXG4gICAgICAgICAgICAgICAgaW5kZXgxLCBpbmRleDIsXG4gICAgICAgICAgICAgICAgbmV3UGF0aDEsIG5ld1BhdGgyO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0ga2V5czEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5czFbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFvLmhhc093blByb3BlcnR5LmNhbGwob2JqMiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgb2YgdGhlIGN5Y2xpYyBsb2dpY1xuXG4gICAgICAgICAgICAgICAgdmFsdWUxID0gb2JqMVtrZXldO1xuICAgICAgICAgICAgICAgIHZhbHVlMiA9IG9iajJba2V5XTtcblxuICAgICAgICAgICAgICAgIGlzT2JqZWN0MSA9IGlzT2JqZWN0KHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgaXNPYmplY3QyID0gaXNPYmplY3QodmFsdWUyKTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSwgaWYgdGhlIG9iamVjdHMgd2VyZSBhbHJlYWR5IHZpc2l0ZWRcbiAgICAgICAgICAgICAgICAvLyAoaXQncyBmYXN0ZXIgdG8gY2hlY2sgZm9yIGlzT2JqZWN0IGZpcnN0LCB0aGFuIHRvXG4gICAgICAgICAgICAgICAgLy8gZ2V0IC0xIGZyb20gZ2V0SW5kZXggZm9yIG5vbiBvYmplY3RzKVxuICAgICAgICAgICAgICAgIGluZGV4MSA9IGlzT2JqZWN0MSA/IGdldEluZGV4KG9iamVjdHMxLCB2YWx1ZTEpIDogLTE7XG4gICAgICAgICAgICAgICAgaW5kZXgyID0gaXNPYmplY3QyID8gZ2V0SW5kZXgob2JqZWN0czIsIHZhbHVlMikgOiAtMTtcblxuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgbmV3IHBhdGhlcyBvZiB0aGUgb2JqZWN0c1xuICAgICAgICAgICAgICAgIC8vIC0gZm9yIG5vbiBjeWNsaWMgb2JqZWN0cyB0aGUgY3VycmVudCBwYXRoIHdpbGwgYmUgZXh0ZW5kZWRcbiAgICAgICAgICAgICAgICAvLyAgIGJ5IGN1cnJlbnQgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIC8vIC0gZm9yIGN5Y2xpYyBvYmplY3RzIHRoZSBzdG9yZWQgcGF0aCBpcyB0YWtlblxuICAgICAgICAgICAgICAgIG5ld1BhdGgxID0gaW5kZXgxICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICA/IHBhdGhzMVtpbmRleDFdXG4gICAgICAgICAgICAgICAgICAgIDogcGF0aDEgKyAnWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nO1xuICAgICAgICAgICAgICAgIG5ld1BhdGgyID0gaW5kZXgyICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICA/IHBhdGhzMltpbmRleDJdXG4gICAgICAgICAgICAgICAgICAgIDogcGF0aDIgKyAnWycgKyBKU09OLnN0cmluZ2lmeShrZXkpICsgJ10nO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcCByZWN1cnNpb24gaWYgY3VycmVudCBvYmplY3RzIGFyZSBhbHJlYWR5IGNvbXBhcmVkXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVkW25ld1BhdGgxICsgbmV3UGF0aDJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoZSBjdXJyZW50IG9iamVjdHMgYW5kIHRoZWlyIHBhdGhlc1xuICAgICAgICAgICAgICAgIGlmIChpbmRleDEgPT09IC0xICYmIGlzT2JqZWN0MSkge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RzMS5wdXNoKHZhbHVlMSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzMS5wdXNoKG5ld1BhdGgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4MiA9PT0gLTEgJiYgaXNPYmplY3QyKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdHMyLnB1c2godmFsdWUyKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMyLnB1c2gobmV3UGF0aDIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGN1cnJlbnQgb2JqZWN0cyBhcmUgYWxyZWFkeSBjb21wYXJlZFxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdDEgJiYgaXNPYmplY3QyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVkW25ld1BhdGgxICsgbmV3UGF0aDJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBFbmQgb2YgY3ljbGljIGxvZ2ljXG5cbiAgICAgICAgICAgICAgICAvLyBuZWl0aGVyIHZhbHVlMSBub3IgdmFsdWUyIGlzIGEgY3ljbGVcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSB3aXRoIG5leHQgbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbCh2YWx1ZTEsIHZhbHVlMiwgbmV3UGF0aDEsIG5ld1BhdGgyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9KG9iajEsIG9iajIsICckMScsICckMicpKTtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2g7XG5cbiAgICBmdW5jdGlvbiBhcnJheUNvbnRhaW5zKGFycmF5LCBzdWJzZXQpIHtcbiAgICAgICAgaWYgKHN1YnNldC5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgdmFyIGksIGwsIGosIGs7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaChhcnJheVtpXSwgc3Vic2V0WzBdKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGsgPSBzdWJzZXQubGVuZ3RoOyBqIDwgazsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2goYXJyYXlbaSArIGpdLCBzdWJzZXRbal0pKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc2Ftc2FtLm1hdGNoXG4gICAgICogQHBhcmFtIE9iamVjdCBvYmplY3RcbiAgICAgKiBAcGFyYW0gT2JqZWN0IG1hdGNoZXJcbiAgICAgKlxuICAgICAqIENvbXBhcmUgYXJiaXRyYXJ5IHZhbHVlIGBgb2JqZWN0YGAgd2l0aCBtYXRjaGVyLlxuICAgICAqL1xuICAgIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2gob2JqZWN0LCBtYXRjaGVyKSB7XG4gICAgICAgIGlmIChtYXRjaGVyICYmIHR5cGVvZiBtYXRjaGVyLnRlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIudGVzdChvYmplY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyKG9iamVjdCkgPT09IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1hdGNoZXIgPSBtYXRjaGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgbm90TnVsbCA9IHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIgfHwgISFvYmplY3Q7XG4gICAgICAgICAgICByZXR1cm4gbm90TnVsbCAmJlxuICAgICAgICAgICAgICAgIChTdHJpbmcob2JqZWN0KSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKG1hdGNoZXIpID49IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyID09PSBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1hdGNoZXIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlciA9PT0gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdldENsYXNzKG9iamVjdCkgPT09IFwiQXJyYXlcIiAmJiBnZXRDbGFzcyhtYXRjaGVyKSA9PT0gXCJBcnJheVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlDb250YWlucyhvYmplY3QsIG1hdGNoZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoZXIgJiYgdHlwZW9mIG1hdGNoZXIgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBwcm9wO1xuICAgICAgICAgICAgZm9yIChwcm9wIGluIG1hdGNoZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG9iamVjdC5nZXRBdHRyaWJ1dGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdC5nZXRBdHRyaWJ1dGUocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgIW1hdGNoKHZhbHVlLCBtYXRjaGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXRjaGVyIHdhcyBub3QgYSBzdHJpbmcsIGEgbnVtYmVyLCBhIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24sIGEgYm9vbGVhbiBvciBhbiBvYmplY3RcIik7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGlzQXJndW1lbnRzOiBpc0FyZ3VtZW50cyxcbiAgICAgICAgaXNFbGVtZW50OiBpc0VsZW1lbnQsXG4gICAgICAgIGlzRGF0ZTogaXNEYXRlLFxuICAgICAgICBpc05lZ1plcm86IGlzTmVnWmVybyxcbiAgICAgICAgaWRlbnRpY2FsOiBpZGVudGljYWwsXG4gICAgICAgIGRlZXBFcXVhbDogZGVlcEVxdWFsQ3ljbGljLFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIGtleXM6IGtleXNcbiAgICB9O1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy9qcy91ZS9zZWxlY3Rpb24nKTtcclxudmFyIEtleWJvYXJkQmluZGluZ3MgPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvS2V5Ym9hcmRCaW5kaW5ncycpO1xyXG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuL0Zha2VOb2RlJyk7XHJcbnZhciBzaW5vbiA9IHJlcXVpcmUoJ3Npbm9uJyk7XHJcblxyXG5cclxudmFyIENyb3NzU2VnbWVudFNlbGVjdGlvbk9iamVjdE1vdGhlciA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmtleWJvYXJkQmluZGluZ3MgPSBuZXcgS2V5Ym9hcmRCaW5kaW5ncygnZmFrZSB0YXJnZXQnKTtcclxufTtcclxuXHJcbnZhciBwcm90byA9IENyb3NzU2VnbWVudFNlbGVjdGlvbk9iamVjdE1vdGhlci5wcm90b3R5cGU7XHJcblxyXG5wcm90by5zZXR1cFNlbGVjdGlvbkNvbnRleHRUb0hhdmVDb21tb25BbmNlc3RvciA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG4gIG1lLnN0b3JlID0gU2VsZWN0aW9uLlNlbGVjdGlvbkNvbnRleHQ7XHJcbiAgbWUuc3R1YiA9IHNpbm9uLmNyZWF0ZVN0dWJJbnN0YW5jZShTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCk7XHJcblxyXG4gIG1lLnN0dWIuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSBuZXcgRmFrZU5vZGUoKS53aXRoQ2xhc3MoY2xhc3NOYW1lKTtcclxuICBtZS5zdHViLmhhc0NvbW1vbkFuY2VzdG9yQ2xhc3MucmVzdG9yZSgpO1xyXG5cclxuICBTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtZS5zdHViO1xyXG4gIH07XHJcbn07XHJcblxyXG5wcm90by5yZXNldFNlbGVjdGlvbkNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuICBTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCA9IG1lLnN0b3JlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDcm9zc1NlZ21lbnRTZWxlY3Rpb25PYmplY3RNb3RoZXI7XHJcbiIsIi8qIEZpbGU6IERhdGFQcm92aWRlck9iamVjdE1vdGhlci5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIHByb3RvO1xyXG52YXIgRGF0YVByb3ZpZGVyID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2pzL3VlL0RhdGFQcm92aWRlcicpO1xyXG5cclxuZnVuY3Rpb24gRGF0YVByb3ZpZGVyT2JqZWN0TW90aGVyKCkge1xyXG59XHJcblxyXG5wcm90byA9IERhdGFQcm92aWRlck9iamVjdE1vdGhlci5wcm90b3R5cGU7XHJcblxyXG5wcm90by5oYWNrSW5pdGlhbGl6YXRpb24gPSBmdW5jdGlvbiAocGFyYWdyYXBocywgdWVEb2N1bWVudCkge1xyXG4gIERhdGFQcm92aWRlci5pbml0RGF0YSh1ZURvY3VtZW50LmlkLCB1ZURvY3VtZW50KTtcclxuICBEYXRhUHJvdmlkZXIubWFwU2tlbGV0b25EYXRhKHVlRG9jdW1lbnQuc2tlbGV0b25zWzBdKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRGF0YVByb3ZpZGVyT2JqZWN0TW90aGVyO1xyXG4iLCIvKiBGaWxlOiBGYWtlRXZlbnQuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuZnVuY3Rpb24gRmFrZUV2ZW50KCkge1xyXG4gIHRoaXMua2V5Q29kZSA9IC0xO1xyXG4gIHRoaXMuY3RybEtleSA9IGZhbHNlO1xyXG4gIHRoaXMuc2hpZnRLZXkgPSBmYWxzZTtcclxuICB0aGlzLnR5cGUgPSAnJztcclxuICB0aGlzLndoaWNoID0gdW5kZWZpbmVkO1xyXG5cclxuICB0aGlzLmhhc1ByZXZlbnRlZERlZmF1bHQgPSBmYWxzZTtcclxuICB0aGlzLmhhc1N0b3BwZWRQcm9wYWdhdGlvbiA9IGZhbHNlO1xyXG59XHJcblxyXG5GYWtlRXZlbnQucHJvdG90eXBlLnNldEtleUNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBtZS5rZXlDb2RlID0gdmFsdWU7XHJcbn07XHJcblxyXG5GYWtlRXZlbnQucHJvdG90eXBlLnNldFNoaWZ0S2V5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgbWUuc2hpZnRLZXkgPSB2YWx1ZTtcclxufTtcclxuXHJcbkZha2VFdmVudC5wcm90b3R5cGUuc2V0Q3RybEtleSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIG1lLmN0cmxLZXkgPSB2YWx1ZTtcclxufTtcclxuXHJcbkZha2VFdmVudC5wcm90b3R5cGUuc2V0VHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gIHRoaXMudHlwZSA9IHZhbHVlO1xyXG59O1xyXG5cclxuRmFrZUV2ZW50LnByb3RvdHlwZS5zZXRDdXJyZW50VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gIHRoaXMuY3VycmVudFRhcmdldCA9IHRhcmdldDtcclxufTtcclxuXHJcbkZha2VFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgbWUuaGFzUHJldmVudGVkRGVmYXVsdCA9IHRydWU7XHJcbn07XHJcblxyXG5GYWtlRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBtZS5oYXNTdG9wcGVkUHJvcGFnYXRpb24gPSB0cnVlO1xyXG59O1xyXG5cclxuRmFrZUV2ZW50LnByb3RvdHlwZS5zZXRMZWZ0QnV0dG9uUHJlc3NlZCA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLndoaWNoID0gMTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWtlRXZlbnQ7XHJcbiIsImZ1bmN0aW9uIEZha2VOb2RlKCl7XHJcbiAgdGhpcy5ub2RlVHlwZSA9IC0xO1xyXG4gIHRoaXMucGFyZW50Tm9kZSA9IG51bGw7XHJcblxyXG4gIHRoaXMuZmlyc3RDaGlsZCA9IG51bGw7XHJcbiAgdGhpcy5uZXh0U2libGluZyA9IG51bGw7XHJcbiAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xyXG4gIHRoaXMuY2hpbGROb2RlcyA9IFtdO1xyXG5cclxuICB0aGlzLmNsYXNzTGlzdCA9IHtcclxuICAgIGNvbnRlbnRzOiBbXSxcclxuICAgIGNvbnRhaW5zOmZ1bmN0aW9uKGNsYXNzTmFtZSl7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHRoaXMuZGF0YXNldCA9IHt9O1xyXG59XHJcblxyXG5GYWtlTm9kZS5wcm90b3R5cGUudGV4dE5vZGUgPSBmdW5jdGlvbigpe1xyXG4gIHRoaXMubm9kZVR5cGUgPSAzO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuRmFrZU5vZGUucHJvdG90eXBlLndpdGhDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSl7XHJcbiAgdGhpcy5jbGFzc0xpc3QuY29udGVudHMucHVzaChjbGFzc05hbWUpO1xyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRmFrZU5vZGU7XHJcblxyXG4iLCJ2YXIgc2lub24gPSByZXF1aXJlKCdzaW5vbicpO1xyXG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuL0Zha2VOb2RlJyk7XHJcblxyXG5mdW5jdGlvbiBGYWtlUmFuZ2UoKXtcclxuICB0aGlzLmNvbGxhcHNlZCA9IGZhbHNlO1xyXG4gIHRoaXMuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSBuZXcgRmFrZU5vZGUoKTtcclxuICB0aGlzLmVuZENvbnRhaW5lciA9IG5ldyBGYWtlTm9kZSgpO1xyXG4gIHRoaXMuZW5kT2Zmc2V0ID0gMzY7XHJcbiAgdGhpcy5zdGFydENvbnRhaW5lciA9IG5ldyBGYWtlTm9kZSgpO1xyXG4gIHRoaXMuc3RhcnRPZmZzZXQgPSAzMztcclxufVxyXG5cclxuRmFrZVJhbmdlLnByb3RvdHlwZS5jbG9uZUNvbnRlbnRzID0gc2lub24uc3R1YigpO1xyXG5GYWtlUmFuZ2UucHJvdG90eXBlLmRlbGV0ZUNvbnRlbnRzID0gc2lub24uc3B5KCk7XHJcbkZha2VSYW5nZS5wcm90b3R5cGUuaW5zZXJ0Tm9kZSA9IHNpbm9uLnNweSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBGYWtlUmFuZ2U7IiwidmFyIEZha2VOb2RlID0gcmVxdWlyZSgnLi9GYWtlTm9kZScpO1xyXG5mdW5jdGlvbiBGYWtlU2VsZWN0aW9uKCl7XHJcbiAgdGhpcy5hbmNob3JOb2RlID0gbmV3IEZha2VOb2RlKCk7XHJcbiAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xyXG4gIHRoaXMuZm9jdXNOb2RlID0gbmV3IEZha2VOb2RlKCk7XHJcbiAgdGhpcy5mb2N1c09mZnNldCA9IDA7XHJcbiAgdGhpcy5pc0NvbGxhcHNlZCA9IHRydWU7XHJcbiAgdGhpcy5yYW5nZUNvdW50ID0gMDtcclxuXHJcbiAgdGhpcy5yYW5nZXMgPSB7fTtcclxufVxyXG5cclxuRmFrZVNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0UmFuZ2VBdCA9IGZ1bmN0aW9uKGluZGV4KXtcclxuICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXhdO1xyXG59O1xyXG5cclxuRmFrZVNlbGVjdGlvbi5wcm90b3R5cGUuc2V0UmFuZ2VBdCA9IGZ1bmN0aW9uKGluZGV4LCByYW5nZSl7XHJcbiAgdGhpcy5yYW5nZXNbaW5kZXhdID0gcmFuZ2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEZha2VTZWxlY3Rpb247XHJcblxyXG4iLCJ2YXIgSGVscGVycyA9IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy9qcy91ZS9IZWxwZXJzJyk7XHJcbnZhciBwcm90bztcclxuXHJcbnZhciBIYW5kbGVDbGVhclRhZ3NGaXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbnByb3RvID0gSGFuZGxlQ2xlYXJUYWdzRml4dHVyZXMucHJvdG90eXBlO1xyXG5cclxucHJvdG8udGFnUGFpclNhbXBsZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcmVzdWx0O1xyXG4gIHJlc3VsdCA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCI+dGV4dDwvc3Bhbj4nICtcclxuICAgICc8ZGl2IGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIiBkYXRhLWlkPVwiMVwiIGRhdGEtY2FuLWhpZGU9XCJ0cnVlXCIgZGF0YS10eXBlPVwic3RhcnQtdGFnXCI+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWcgdWUtdGFnLXN0YXJ0XCI+Y2Y8L3NwYW4+Jnp3bmo7JyArXHJcbiAgICAnPC9kaXY+JyArXHJcbiAgICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50IHVlLXRhZ3BhaXItY29udGVudFwiIGRhdGEtaWQ9XCIxXCI+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCI+aW5uZXIgY29udGVudDwvc3Bhbj4nICtcclxuICAgICc8L2Rpdj4nICtcclxuICAgICc8ZGl2IGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIiBkYXRhLWlkPVwiMVwiIGRhdGEtY2FuLWhpZGU9XCJ0cnVlXCIgZGF0YS10eXBlPVwiZW5kLXRhZ1wiPicgK1xyXG4gICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnIHVlLXRhZy1lbmRcIj5jZjwvc3Bhbj4menduajsnICtcclxuICAgICc8L2Rpdj4nICtcclxuICAgICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIj5hdCBlbmQuPC9zcGFuPicgK1xyXG4gICAgJzwvZGl2PicpO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBIYW5kbGVDbGVhclRhZ3NGaXh0dXJlcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBIZWxwZXJzID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2pzL3VlL0hlbHBlcnMnKTtcclxudmFyIEtleWJvYXJkQmluZGluZ3MgPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvS2V5Ym9hcmRCaW5kaW5ncycpO1xyXG52YXIgc2lub24gPSByZXF1aXJlKCdzaW5vbicpO1xyXG5cclxudmFyIEtleWJvYXJkQmluZGluZ3NPYmplY3RNb3RoZXIgPSBmdW5jdGlvbiBLZXlib2FyZEJpbmRpbmdzT2JqZWN0TW90aGVyICgpIHtcclxuICB0aGlzLmtiID0gbmV3IEtleWJvYXJkQmluZGluZ3MoKTtcclxufTtcclxuXHJcbnZhciBwcm90byA9IEtleWJvYXJkQmluZGluZ3NPYmplY3RNb3RoZXIucHJvdG90eXBlO1xyXG5wcm90by5hc3NpZ25UYWdzQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMua2IudGFncyA9IHt9O1xyXG4gIHRoaXMua2IubW92ZVRhZ3NUb0Zyb250ID0gW107XHJcbiAgdGhpcy5rYi5tb3ZlVGFnc1RvRW5kID0gW107XHJcbn07XHJcblxyXG5wcm90by5kZWxldGVUYWdzQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIGRlbGV0ZSB0aGlzLmtiLnRhZ3M7XHJcbiAgZGVsZXRlIHRoaXMubW92ZVRhZ3NUb0Zyb250O1xyXG4gIGRlbGV0ZSB0aGlzLm1vdmVUYWdzVG9FbmQ7XHJcbn07XHJcblxyXG5wcm90by5oYXNDb2xsZWN0ZWRUYWcgPSBmdW5jdGlvbiAodGFnSWQpIHtcclxuICByZXR1cm4gdGhpcy5rYi50YWdzLmhhc093blByb3BlcnR5KHRhZ0lkKTtcclxufTtcclxuXHJcbnByb3RvLmdldFRhZyA9IGZ1bmN0aW9uICh0YWdJZCkge1xyXG4gIHJldHVybiB0aGlzLmtiLnRhZ3NbdGFnSWRdO1xyXG59O1xyXG5cclxucHJvdG8uc2V0dXBTaW1wbGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHJlc3VsdCA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCI+U29tZSBiYXNpYyB0ZXh0IGhlcmU8L3NwYW4+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCI+ZW5kIHRleHQ8L3NwYW4+JyArXHJcbiAgICAnPC9kaXY+Jyk7XHJcblxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5wcm90by5zaW5nbGVTdGFydFRhZ1NhbXBsZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcmVzdWx0O1xyXG4gIHJlc3VsdCA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCI+dGV4dDwvc3Bhbj4nICtcclxuICAgICc8ZGl2IGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIiBkYXRhLWlkPVwiMVwiIGRhdGEtY2FuLWhpZGU9XCJ0cnVlXCIgZGF0YS10eXBlPVwic3RhcnQtdGFnXCI+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWcgdWUtdGFnLXN0YXJ0XCI+Y2Y8L3NwYW4+Jnp3bmo7JyArXHJcbiAgICAnPC9kaXY+JyArXHJcbiAgICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50IHVlLXRhZ3BhaXItY29udGVudFwiIGRhdGEtaWQ9XCIxXCI+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCI+aW5uZXIgY29udGVudDwvc3Bhbj4nICtcclxuICAgICc8L2Rpdj4nICtcclxuICAgICc8L2Rpdj4nKTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnByb3RvLnNpbmdsZUVuZFRhZ1NhbXBsZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcmVzdWx0O1xyXG4gIHJlc3VsdCA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+JyArXHJcbiAgICAnPGRpdiBjbGFzcz1cInVlLXRhZy13cmFwcGVyXCIgZGF0YS1pZD1cIjFcIiBkYXRhLWNhbi1oaWRlPVwidHJ1ZVwiIGRhdGEtdHlwZT1cInN0YXJ0LXRhZ1wiPicgK1xyXG4gICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnIHVlLXRhZy1zdGFydFwiPmNmPC9zcGFuPiZ6d25qOycgK1xyXG4gICAgJzwvZGl2PicgK1xyXG4gICAgJzxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudCB1ZS10YWdwYWlyLWNvbnRlbnRcIj4nICtcclxuICAgICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIj5pbm5lciBjb250ZW50PC9zcGFuPicgK1xyXG4gICAgJzwvZGl2PicgK1xyXG4gICAgJzxkaXYgY2xhc3M9XCJ1ZS10YWctd3JhcHBlclwiIGRhdGEtaWQ9XCIxXCIgZGF0YS1jYW4taGlkZT1cInRydWVcIiBkYXRhLXR5cGU9XCJlbmQtdGFnXCI+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWcgdWUtdGFnLWVuZFwiPmNmPC9zcGFuPiZ6d25qOycgK1xyXG4gICAgJzwvZGl2PicgK1xyXG4gICAgJzxzcGFuIGNsYXNzPVwidWUtdGV4dFwiPnRleHQgY29udGVudDwvc3Bhbj4nICtcclxuICAgICc8L2Rpdj4nKTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnByb3RvLnN0dWJSZW1vdmVJbmxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgc2lub24uc3R1Yih0aGlzLmtiLCAnX3JlbW92ZUlubGluZScpO1xyXG59O1xyXG5cclxucHJvdG8ucmVzZXRSZW1vdmVJbmxpbmVTdHViID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMua2IuX3JlbW92ZUlubGluZS5yZXNldCgpO1xyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IEtleWJvYXJkQmluZGluZ3NPYmplY3RNb3RoZXI7IiwiLyogRmlsZTogU2VnbWVudENsZWFudXBGaXh0dXJlLmpzICovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvSGVscGVycycpLnN0cmluZ1RvSFRNTEVsZW1lbnQ7XHJcbnZhciBwcm90bztcclxuXHJcbmZ1bmN0aW9uIFNlZ21lbnRDbGVhbnVwRml4dHVyZSgpIHtcclxufVxyXG5cclxucHJvdG8gPSBTZWdtZW50Q2xlYW51cEZpeHR1cmUucHJvdG90eXBlO1xyXG5cclxucHJvdG8uY29udGVudEJlZm9yZUlubGluZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGgoJzxkaXYgY2xhc3M9XCJ1ZS1zZWdtZW50IHVlLXJvdy1hY3RpdmVcIiBkYXRhLXNlZ21lbnQtbnVtYmVyPVwiMTZcIiBkYXRhLXB1aWQ9XCJkZWFmN2IyZC1mMzMyLTQ1ZjktOTdmNS00ZTkwZTE2NDgzN2FcIiBzdHlsZT1cImhlaWdodDogMjdweDtcIj4nICtcclxuICAgICAgJ291dHNpZGUgY29udGVudDxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudFwiPjwvZGl2PicgK1xyXG4gICAgJzwvZGl2PicpO1xyXG59O1xyXG5cclxucHJvdG8uc2VnbWVudFdpdGhOb0lubGluZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIGgoJzxkaXYgY2xhc3M9XCJ1ZS1zZWdtZW50IHVlLXJvdy1hY3RpdmVcIiBkYXRhLXNlZ21lbnQtbnVtYmVyPVwiMTZcIiBkYXRhLXB1aWQ9XCJkZWFmN2IyZC1mMzMyLTQ1ZjktOTdmNS00ZTkwZTE2NDgzN2FcIiBzdHlsZT1cImhlaWdodDogMjdweDtcIj4nICtcclxuICAgICc8L2Rpdj4nKTtcclxufTtcclxuXHJcbnByb3RvLmNvbnRlbnRBZnRlcklubGluZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIHJldHVybiBoKCc8ZGl2IGNsYXNzPVwidWUtc2VnbWVudCB1ZS1yb3ctYWN0aXZlXCIgZGF0YS1zZWdtZW50LW51bWJlcj1cIjE2XCIgZGF0YS1wdWlkPVwiZGVhZjdiMmQtZjMzMi00NWY5LTk3ZjUtNGU5MGUxNjQ4MzdhXCIgc3R5bGU9XCJoZWlnaHQ6IDI3cHg7XCI+JyArXHJcbiAgICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+PC9kaXY+IGNvbnRlbnQgb3V0c2lkZScgK1xyXG4gICAgJzwvZGl2PicpO1xyXG59O1xyXG5cclxucHJvdG8ucGxhY2Vob2xkZXJJbnNpZGVUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBoKCc8ZGl2IGNsYXNzPVwidWUtc2VnbWVudCB1ZS1yb3ctYWN0aXZlXCIgZGF0YS1zZWdtZW50LW51bWJlcj1cIjhcIiBkYXRhLXB1aWQ9XCI5NDIyMGI2MC04ZmY5LTQ2ZmUtYjFhNy0wNTA3NzA5MThkODdcIiBzdHlsZT1cImhlaWdodDogMjdweDtcIj4nICtcclxuICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+4oCMJyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCIgZGF0YS10eXBlPVwidGV4dFwiPm5vdDxzcGFuIGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIiBkYXRhLXR5cGU9XCJwbGFjZWhvbGRlclwiIGRhdGEtaWQ9XCI0NFwiIGRhdGEtZGVmaW5pdGlvbmlkPVwiMTBcIiBkYXRhLW1ldGFkYXRhPVwiMTEzNDQwNDctNTM3Njg3OC01NDY3Njk4XCIgZGF0YS10YWctY29weT1cImZhbHNlXCI+PHNwYW4gY2xhc3M9XCJ1ZS10YWdcIiBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiIGRhdGEtZGlzcGxheS1jb250ZW50PVwieFwiPjwvc3Bhbj7igIw8L3NwYW4+IGVtcHR5PC9zcGFuPicgK1xyXG4gICc8L2Rpdj48L2Rpdj4nKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2VnbWVudENsZWFudXBGaXh0dXJlOyIsInZhciBLZXlib2FyZEJpbmRpbmdzID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2pzL3VlL0tleWJvYXJkQmluZGluZ3MnKTtcclxudmFyIEZha2VSYW5nZSA9IHJlcXVpcmUoJy4vRmFrZVJhbmdlJyk7XHJcbnZhciBGYWtlTm9kZSA9IHJlcXVpcmUoJy4vRmFrZU5vZGUnKTtcclxudmFyIEZha2VTZWxlY3Rpb24gPSByZXF1aXJlKCcuL0Zha2VTZWxlY3Rpb24nKTtcclxuXHJcbnZhciBTZWxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvc2VsZWN0aW9uJyk7XHJcbnZhciBIZWxwZXJzID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2pzL3VlL0hlbHBlcnMnKTtcclxuXHJcbnZhciBzaW5vbiA9IHJlcXVpcmUoJ3Npbm9uJyk7XHJcblxyXG52YXIgZmFrZVRhcmdldCA9ICdhbnl0aGluZyc7XHJcblxyXG52YXIgU2VsZWN0aW9uQ29udGV4dE9iamVjdE1vdGhlciA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmtleWJvYXJkQmluZGluZ3MgPSBuZXcgS2V5Ym9hcmRCaW5kaW5ncyhmYWtlVGFyZ2V0KTtcclxuICB0aGlzLmZha2VSYW5nZSA9IG5ldyBGYWtlUmFuZ2UoKTtcclxuICB0aGlzLmZha2VTZWxlY3Rpb24gPSBuZXcgRmFrZVNlbGVjdGlvbigpO1xyXG5cclxuICB0aGlzLmZha2VTZWxlY3Rpb24uc2V0UmFuZ2VBdCgwLCB0aGlzLmZha2VSYW5nZSk7XHJcbn07XHJcblxyXG52YXIgcHJvdG8gPSBTZWxlY3Rpb25Db250ZXh0T2JqZWN0TW90aGVyLnByb3RvdHlwZTtcclxuXHJcbnByb3RvLnN0dWJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuICBzaW5vbi5zdHViKGRvY3VtZW50LCAnZ2V0U2VsZWN0aW9uJywgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1lLmZha2VTZWxlY3Rpb247XHJcbiAgfSk7XHJcbn07XHJcblxyXG5wcm90by5yZXN0b3JlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIGRvY3VtZW50LmdldFNlbGVjdGlvbi5yZXN0b3JlKCk7XHJcbn07XHJcblxyXG5wcm90by5kZWZpbmVGb2N1c05vZGVQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5mYWtlU2VsZWN0aW9uLmZvY3VzTm9kZS5wYXJlbnROb2RlID0gbmV3IEZha2VOb2RlKCk7XHJcbn07XHJcblxyXG5wcm90by5hc3NpZ25UZXh0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdGhpcy5mYWtlU2VsZWN0aW9uLmZvY3VzTm9kZS50ZXh0Tm9kZSgpO1xyXG4gIHRoaXMuZmFrZVJhbmdlLnN0YXJ0Q29udGFpbmVyLnRleHROb2RlKCk7XHJcbiAgdGhpcy5mYWtlUmFuZ2UuZW5kQ29udGFpbmVyLnRleHROb2RlKCk7XHJcbn07XHJcblxyXG5wcm90by5zZXRSYW5nZUNvbGxhcHNlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gIHRoaXMuZmFrZVJhbmdlLmNvbGxhcHNlZCA9IHN0YXRlO1xyXG59O1xyXG5cclxucHJvdG8uc2V0dXBFbXB0eUNsb25lQ29udGVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuXHJcbiAgbWUuZmFrZUNsb25lQ29udGVudHMgPSBuZXcgRmFrZU5vZGUoKTtcclxuXHJcbiAgbWUuZmFrZVJhbmdlLmNsb25lQ29udGVudHMucmV0dXJucyhcclxuICAgIG1lLmZha2VDbG9uZUNvbnRlbnRzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBzZXRDcm9zc1NlZ21lbnRTZWxlY3Rpb25UbyBzZXRzIHRoZSByZXR1cm4gdmFsdWUgdG8gQHBhcmFtIHZhbHVlXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uXHJcbiAqIHdoZW4gdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQgdGhlIG9yaWdpbmFsIG1ldGhvZCBpcyByZXN0b3JlZFxyXG4gKi9cclxucHJvdG8uc2V0Q3Jvc3NTZWdtZW50U2VsZWN0aW9uVG8gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBzaW5vbi5zdHViKG1lLmtleWJvYXJkQmluZGluZ3MsICdpc0Nyb3NzU2VnbWVudFNlbGVjdGlvbicpLlxyXG4gICAgcmV0dXJucyh2YWx1ZSk7XHJcbiAgbWUuc3R1YlNlbGVjdGlvbkNvbnRleHQoKTtcclxufTtcclxuXHJcbnByb3RvLnJlc2V0Q3Jvc3NTZWdtZW50U2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXM7XHJcblxyXG4gIG1lLmtleWJvYXJkQmluZGluZ3MuaXNDcm9zc1NlZ21lbnRTZWxlY3Rpb24ucmVzdG9yZSgpO1xyXG4gIG1lLnJlc3RvcmVTZWxlY3Rpb25Db250ZXh0KCk7XHJcbn07XHJcblxyXG5wcm90by5zZXRDb2xsYXBzZWRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcztcclxuICBtZS5zdHViU2VsZWN0aW9uQ29udGV4dCgpO1xyXG4gIG1lLnN0dWJTZWxlY3Rpb25Db250ZXh0LmlzQ29sbGFwc2VkLnJldHVybnModHJ1ZSk7XHJcbn07XHJcblxyXG5wcm90by5zZXR1cFNhbWVDb250YWluZXJGb3JTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgZmFrZUNvbnRhaW5lcjtcclxuICBmYWtlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gIG1lLnN0dWJTZWxlY3Rpb25Db250ZXh0KCk7XHJcblxyXG4gIG1lLnN0dWJTZWxlY3Rpb25Db250ZXh0LnN0YXJ0Q29udGFpbmVyID0gbWUuc3R1YlNlbGVjdGlvbkNvbnRleHQuZW5kQ29udGFpbmVyID0gZmFrZUNvbnRhaW5lcjtcclxuICBtZS5zdHViU2VsZWN0aW9uQ29udGV4dC5jb21tb25BbmNlc3RvckNvbnRhaW5lciA9IGZha2VDb250YWluZXI7XHJcbn07XHJcblxyXG5wcm90by5zZXR1cFNpbXBsZUFuY2VzdG9yU3RhcnRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAgZmFrZUNvbnRhaW5lcixcclxuICAgICAgc3RhcnRUZXh0Q29udGFpbmVyLFxyXG4gICAgICBzdGFydFRleHROb2RlO1xyXG5cclxuICBtZS5zdHViU2VsZWN0aW9uQ29udGV4dCgpO1xyXG5cclxuICBmYWtlQ29udGFpbmVyID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KFwiPGRpdiBjbGFzcz0ndWUtaW5saW5lLWNvbnRlbnQnPlwiICtcclxuICAgIFwiPHNwYW4gY2xhc3M9J3VlLXRleHQnPnN0YXJ0IGNvbnRhaW5lciBpcyB0ZXh0IG5vZGU8L3NwYW4+XCIgK1xyXG4gICAgXCI8L2Rpdj5cIik7XHJcbiAgc3RhcnRUZXh0Q29udGFpbmVyID0gZmFrZUNvbnRhaW5lci5maXJzdENoaWxkO1xyXG4gIHN0YXJ0VGV4dE5vZGUgPSBzdGFydFRleHRDb250YWluZXIuZmlyc3RDaGlsZDtcclxuXHJcbiAgbWUuc3R1YlNlbGVjdGlvbkNvbnRleHQuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSBmYWtlQ29udGFpbmVyO1xyXG4gIG1lLnN0dWJTZWxlY3Rpb25Db250ZXh0LnN0YXJ0Q29udGFpbmVyID0gc3RhcnRUZXh0Tm9kZTtcclxuICBtZS5zdHViU2VsZWN0aW9uQ29udGV4dC5zdGFydE9mZnNldCA9IDA7XHJcbiAgbWUuc3R1YlNlbGVjdGlvbkNvbnRleHQuZW5kQ29udGFpbmVyID0gbnVsbDtcclxuXHJcbiAgbWUuc3R1YlNlbGVjdGlvbkNvbnRleHQuY2xvbmVDb250ZW50cy5yZXR1cm5zKGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XHJcbn07XHJcblxyXG5wcm90by5jb21tb25BbmNlc3RvclRvVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG4gIHJldHVybiBtZS5zdHViU2VsZWN0aW9uQ29udGV4dC5jb21tb25BbmNlc3RvckNvbnRhaW5lci5vdXRlckhUTUw7XHJcbn07XHJcblxyXG5wcm90by5zdHViU2VsZWN0aW9uQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzO1xyXG5cclxuICBtZS5vcmlnaW5hbFNlbGVjdGlvbkNvbnRleHQgPSBTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dDtcclxuICBtZS5zdHViU2VsZWN0aW9uQ29udGV4dCA9IHNpbm9uLmNyZWF0ZVN0dWJJbnN0YW5jZShTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCk7XHJcblxyXG4gIFNlbGVjdGlvbi5TZWxlY3Rpb25Db250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1lLnN0dWJTZWxlY3Rpb25Db250ZXh0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBtZS5zdHViU2VsZWN0aW9uQ29udGV4dDtcclxufTtcclxuXHJcbnByb3RvLnJlc3RvcmVTZWxlY3Rpb25Db250ZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gIFNlbGVjdGlvbi5TZWxlY3Rpb25Db250ZXh0ID0gdGhpcy5vcmlnaW5hbFNlbGVjdGlvbkNvbnRleHQ7XHJcbn07XHJcblxyXG5cclxucHJvdG8uc3B5S2V5Ym9hcmRCaW5kaW5nc01ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBrZXlib2FyZEJpbmRpbmdzID0gbWUua2V5Ym9hcmRCaW5kaW5ncztcclxuXHJcbiAgc2lub24uc3B5KGtleWJvYXJkQmluZGluZ3MsIG1ldGhvZCk7XHJcbn07XHJcblxyXG5wcm90by5yZXN0b3JlS2V5Ym9hcmRCaW5kaW5nc01ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBrZXlib2FyZEJpbmRpbmdzID0gbWUua2V5Ym9hcmRCaW5kaW5ncztcclxuXHJcbiAga2V5Ym9hcmRCaW5kaW5nc1ttZXRob2RdLnJlc3RvcmUoKTtcclxufTtcclxuXHJcbnByb3RvLmtleWJvYXJkQmluZGluZ3NTcHkgPSBmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgdmFyIG1lID0gdGhpcyxcclxuICAgICAga2V5Ym9hcmRCaW5kaW5ncyA9IG1lLmtleWJvYXJkQmluZGluZ3M7XHJcblxyXG4gIHJldHVybiBrZXlib2FyZEJpbmRpbmdzW21ldGhvZF07XHJcbn07XHJcblxyXG5wcm90by5hdHRhY2hNb3ZlVGFnc1RvRW5kU3R1YiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbWUgPSB0aGlzLFxyXG4gICAgICBrYiA9IG1lLmtleWJvYXJkQmluZGluZ3MsXHJcbiAgICAgIHRyYW5zZm9ybVRhZ3NPcmlnaW5hbE1ldGhvZCA9IGtiLnRyYW5zZm9ybVRhZ3M7XHJcbiAgbWUubm9kZVdhbGtlclN0dWIgPSBzaW5vbi5jcmVhdGVTdHViSW5zdGFuY2UoU2VsZWN0aW9uLk5vZGVXYWxrZXIpO1xyXG5cclxuICBrYi50cmFuc2Zvcm1UYWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAga2IubW92ZVRhZ3NUb0VuZCA9IFttZS5ub2RlV2Fsa2VyU3R1Yl07XHJcbiAgICBrYi50cmFuc2Zvcm1UYWdzID0gdHJhbnNmb3JtVGFnc09yaWdpbmFsTWV0aG9kO1xyXG4gIH07XHJcbn07XHJcblxyXG5wcm90by5hdHRhY2hNb3ZlVGFnc1RvRnJvbnRTdHViID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtZSA9IHRoaXMsXHJcbiAgICAgIGtiID0gbWUua2V5Ym9hcmRCaW5kaW5ncyxcclxuICAgICAgdHJhbnNmb3JtVGFnc09yaWdpbmFsTWV0aG9kID0ga2IudHJhbnNmb3JtVGFncztcclxuICBtZS5ub2RlV2Fsa2VyU3R1YiA9IHNpbm9uLmNyZWF0ZVN0dWJJbnN0YW5jZShTZWxlY3Rpb24uTm9kZVdhbGtlcik7XHJcblxyXG4gIGtiLnRyYW5zZm9ybVRhZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBrYi5tb3ZlVGFnc1RvRnJvbnQgPSBbbWUubm9kZVdhbGtlclN0dWJdO1xyXG4gICAga2IudHJhbnNmb3JtVGFncyA9IHRyYW5zZm9ybVRhZ3NPcmlnaW5hbE1ldGhvZDtcclxuICB9O1xyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXI7XHJcbiIsInZhciBIZWxwZXJzID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2pzL3VlL0hlbHBlcnMnKTtcclxudmFyIHByb3RvO1xyXG5cclxudmFyIFNoaWZ0RW50ZXJIYW5kbGVyRml4dHVyZSA9IGZ1bmN0aW9uICgpIHtcclxufTtcclxuXHJcbnByb3RvID0gU2hpZnRFbnRlckhhbmRsZXJGaXh0dXJlLnByb3RvdHlwZTtcclxuXHJcbnByb3RvLnNlZ21lbnRXaXRoVGV4dFNhbXBsZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2FtcGxlO1xyXG5cclxuICBzYW1wbGUgPSBIZWxwZXJzLnN0cmluZ1RvSFRNTEVsZW1lbnQoJzxkaXYgY2xhc3M9XCJ1ZS1zZWdtZW50XCIgZGF0YS1zZWdtZW50LW51bWJlcj1cIjFcIj4nICtcclxuICAgICcmenduajsnICtcclxuICAgICc8ZGl2IGNsYXNzPVwidWUtaW5saW5lLWNvbnRlbnRcIj4nICtcclxuICAgICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIj50ZXh0PC9zcGFuPicgK1xyXG4gICAgJzwvZGl2PicgK1xyXG4gICAgJzwvZGl2PicpXHJcbiAgcmV0dXJuIHNhbXBsZTtcclxufTtcclxuXHJcbnByb3RvLmJyZWFrQXRTZWdtZW50U3RhcnRTYW1wbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNhbXBsZTtcclxuXHJcbiAgc2FtcGxlID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KCc8ZGl2IGNsYXNzPVwidWUtc2VnbWVudFwiPicgK1xyXG4gICAgJzxicj4nICtcclxuICAgICcmenduajsnICtcclxuICAgICc8ZGl2IGNsYXNzPVwidWUtaW5saW5lLWNvbnRlbnRcIj4nICtcclxuICAgICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIj50ZXh0PC9zcGFuPicgK1xyXG4gICAgJzwvZGl2PicgK1xyXG4gICAgJzwvZGl2PicpXHJcbiAgcmV0dXJuIHNhbXBsZTtcclxufTtcclxuXHJcbnByb3RvLm5ld0xpbmVJbnNpZGVTdGFydFRhZ1dyYXBwZXJTYW1wbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNhbXBsZTtcclxuXHJcbiAgc2FtcGxlID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KCc8ZGl2IGNsYXNzPVwidWUtc2VnbWVudFwiIGRhdGEtc2VnbWVudC1udW1iZXI9XCIxXCI+JyArXHJcbiAgICAgICcmenduajsnICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudFwiPicgK1xyXG4gICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWctd3JhcHBlclwiIGRhdGEtdHlwZT1cInN0YXJ0LXRhZ1wiIGRhdGEtdGFnLWNvcHk9XCJ0cnVlXCIgZGF0YS1pZD1cIjI4XCIgZGF0YS1tZXRhZGF0YT1cIjE1OTAxNjAyLTY1OTE3NDAtNzA2MDM4MVwiIGRhdGEtY2FuLWhpZGU9XCJ0cnVlXCI+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZyB1ZS10YWctc3RhcnRcIiBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiPmNmPC9zcGFuPicgK1xyXG4gICAgICAnXFxuJyArXHJcbiAgICAgICfigIwmenduajsnICtcclxuICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudCB1ZS10YWdwYWlyLWNvbnRlbnRcIiBkYXRhLXR5cGU9XCJ0YWdwYWlyXCIgZGF0YS1pZD1cIjI4XCIgZGF0YS1kZWZpbml0aW9uaWQ9XCIxMlwiIGRhdGEtbWV0YWRhdGE9XCIxNTkwMTYwMi02NTkxNzQwLTcwNjAzODFcIiBkYXRhLXN0eWxlPVwieyZxdW90O0ZvbnROYW1lJnF1b3Q7OiZxdW90O0FyaWFsJnF1b3Q7LCZxdW90O0ZvbnRTaXplJnF1b3Q7OiZxdW90OzcmcXVvdDssJnF1b3Q7VGV4dENvbG9yJnF1b3Q7OiZxdW90OzAsIDAsIDExMiwgMTkyJnF1b3Q7fVwiIHN0eWxlPVwiZm9udC1mYW1pbHk6IEFyaWFsOyBmb250LXNpemU6IDdweDsgY29sb3I6IHJnYigwLCAxMTIsIDE5Mik7XCI+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIiBkYXRhLXR5cGU9XCJ0ZXh0XCI+YW5kIDwvc3Bhbj4nICtcclxuICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAnPC9kaXY+J1xyXG4gICk7XHJcblxyXG4gIHJldHVybiBzYW1wbGU7XHJcbn07XHJcblxyXG5wcm90by5uZXdMaW5lSW5zaWRlRW5kVGFnV3JhcHBlclNhbXBsZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2FtcGxlO1xyXG5cclxuICBzYW1wbGUgPSBIZWxwZXJzLnN0cmluZ1RvSFRNTEVsZW1lbnQoJzxkaXYgY2xhc3M9XCJ1ZS1zZWdtZW50XCIgZGF0YS1zZWdtZW50LW51bWJlcj1cIjFcIj4nICtcclxuICAgICAgJyZ6d25qOycgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZy13cmFwcGVyXCIgZGF0YS10eXBlPVwic3RhcnQtdGFnXCIgZGF0YS10YWctY29weT1cInRydWVcIiBkYXRhLWlkPVwiMjhcIiBkYXRhLW1ldGFkYXRhPVwiMTU5MDE2MDItNjU5MTc0MC03MDYwMzgxXCIgZGF0YS1jYW4taGlkZT1cInRydWVcIj4nICtcclxuICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnIHVlLXRhZy1zdGFydFwiIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCI+Y2Y8L3NwYW4+JyArXHJcbiAgICAgICfigIwmenduajsnICtcclxuICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudCB1ZS10YWdwYWlyLWNvbnRlbnRcIiBkYXRhLXR5cGU9XCJ0YWdwYWlyXCIgZGF0YS1pZD1cIjI4XCIgZGF0YS1kZWZpbml0aW9uaWQ9XCIxMlwiIGRhdGEtbWV0YWRhdGE9XCIxNTkwMTYwMi02NTkxNzQwLTcwNjAzODFcIiBkYXRhLXN0eWxlPVwieyZxdW90O0ZvbnROYW1lJnF1b3Q7OiZxdW90O0FyaWFsJnF1b3Q7LCZxdW90O0ZvbnRTaXplJnF1b3Q7OiZxdW90OzcmcXVvdDssJnF1b3Q7VGV4dENvbG9yJnF1b3Q7OiZxdW90OzAsIDAsIDExMiwgMTkyJnF1b3Q7fVwiIHN0eWxlPVwiZm9udC1mYW1pbHk6IEFyaWFsOyBmb250LXNpemU6IDdweDsgY29sb3I6IHJnYigwLCAxMTIsIDE5Mik7XCI+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIiBkYXRhLXR5cGU9XCJ0ZXh0XCI+YW5kIDwvc3Bhbj4nICtcclxuICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWctd3JhcHBlclwiIGRhdGEtdHlwZT1cImVuZC10YWdcIiBkYXRhLXRhZy1jb3B5PVwidHJ1ZVwiIGRhdGEtaWQ9XCIyOFwiIGRhdGEtbWV0YWRhdGE9XCIxNDM4MjI4MS03ODMzNzc5LTQxNzYxMTJcIiBkYXRhLWNhbi1oaWRlPVwidHJ1ZVwiPicgK1xyXG4gICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWcgdWUtdGFnLWVuZFwiIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCI+Y2Y8L3NwYW4+4oCMJyArXHJcbiAgICAgICdcXG4nICtcclxuICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgJzwvZGl2PidcclxuICApO1xyXG5cclxuICByZXR1cm4gc2FtcGxlO1xyXG59O1xyXG5cclxucHJvdG8ubmV3TGluZXNJbnNpZGVUZXh0Q29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzYW1wbGUsXHJcbiAgICAgIGlubGluZUNvbnRlbnQsXHJcbiAgICAgIHRleHRDb250YWluZXI7XHJcblxyXG4gIHNhbXBsZSA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRpdiBjbGFzcz1cInVlLXNlZ21lbnRcIiBkYXRhLXNlZ21lbnQtbnVtYmVyPVwiMVwiPicgK1xyXG4gICAgICAnJnp3bmo7JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwidWUtaW5saW5lLWNvbnRlbnRcIj4nICtcclxuICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGV4dFwiIGRhdGEtdHlwZT1cInRleHRcIj48L3NwYW4+JyArXHJcbiAgICAgICc8L2Rpdj4nXHJcbiAgKTtcclxuXHJcbiAgaW5saW5lQ29udGVudCA9IHNhbXBsZS5jaGlsZE5vZGVzWzFdO1xyXG4gIHRleHRDb250YWluZXIgPSBpbmxpbmVDb250ZW50LmZpcnN0Q2hpbGQ7XHJcblxyXG4gIHZhciBzdGFydCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdJdCBoYXMgc3Vydml2ZWQgbm90IG9ubHkgZml2ZSBjZW50dXJpZXMnKSxcclxuICAgICAgbWlkZGxlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcbicpLFxyXG4gICAgICBlbmQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLCBidXQgYWxzbyB0aGUgbGVhcCBpbnRvIGVsZWN0cm9uaWMgdHlwZXNldHRpbmcuJyk7XHJcblxyXG4gIHRleHRDb250YWluZXIuYXBwZW5kQ2hpbGQoc3RhcnQpO1xyXG4gIHRleHRDb250YWluZXIuYXBwZW5kQ2hpbGQobWlkZGxlKTtcclxuICB0ZXh0Q29udGFpbmVyLmFwcGVuZENoaWxkKGVuZCk7XHJcblxyXG4gIHJldHVybiBzYW1wbGU7XHJcbn07XHJcblxyXG5wcm90by5zdGFydFRhZ1dpdGhCcmVhayA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2FtcGxlO1xyXG5cclxuICBzYW1wbGUgPSBIZWxwZXJzLnN0cmluZ1RvSFRNTEVsZW1lbnQoJzxkaXYgY2xhc3M9XCJ1ZS1zZWdtZW50XCIgZGF0YS1zZWdtZW50LW51bWJlcj1cIjFcIj4nICtcclxuICAgICAgJyZ6d25qOycgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50XCI+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZy13cmFwcGVyXCIgZGF0YS10eXBlPVwic3RhcnQtdGFnXCIgZGF0YS10YWctY29weT1cInRydWVcIiBkYXRhLWlkPVwiMjhcIiBkYXRhLW1ldGFkYXRhPVwiMTU5MDE2MDItNjU5MTc0MC03MDYwMzgxXCIgZGF0YS1jYW4taGlkZT1cInRydWVcIj4nICtcclxuICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnIHVlLXRhZy1zdGFydFwiIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCI+Y2Y8L3NwYW4+JyArXHJcblxyXG4gICAgICAnPGJyPicgK1xyXG5cclxuICAgICAgJ+KAjCZ6d25qOycgK1xyXG4gICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50IHVlLXRhZ3BhaXItY29udGVudFwiIGRhdGEtdHlwZT1cInRhZ3BhaXJcIiBkYXRhLWlkPVwiMjhcIiBkYXRhLWRlZmluaXRpb25pZD1cIjEyXCIgZGF0YS1tZXRhZGF0YT1cIjE1OTAxNjAyLTY1OTE3NDAtNzA2MDM4MVwiIGRhdGEtc3R5bGU9XCJ7JnF1b3Q7Rm9udE5hbWUmcXVvdDs6JnF1b3Q7QXJpYWwmcXVvdDssJnF1b3Q7Rm9udFNpemUmcXVvdDs6JnF1b3Q7NyZxdW90OywmcXVvdDtUZXh0Q29sb3ImcXVvdDs6JnF1b3Q7MCwgMCwgMTEyLCAxOTImcXVvdDt9XCIgc3R5bGU9XCJmb250LWZhbWlseTogQXJpYWw7IGZvbnQtc2l6ZTogN3B4OyBjb2xvcjogcmdiKDAsIDExMiwgMTkyKTtcIj4nICtcclxuICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGV4dFwiIGRhdGEtdHlwZT1cInRleHRcIj5hbmQgPC9zcGFuPicgK1xyXG4gICAgICAnPC9kaXY+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZy13cmFwcGVyXCIgZGF0YS10eXBlPVwiZW5kLXRhZ1wiIGRhdGEtdGFnLWNvcHk9XCJ0cnVlXCIgZGF0YS1pZD1cIjI4XCIgZGF0YS1tZXRhZGF0YT1cIjE0MzgyMjgxLTc4MzM3NzktNDE3NjExMlwiIGRhdGEtY2FuLWhpZGU9XCJ0cnVlXCI+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZyB1ZS10YWctZW5kXCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIj5jZjwvc3Bhbj7igIwnICtcclxuICAgICAgJ+KAjCZ6d25qOycgK1xyXG4gICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAnPC9kaXY+JyArXHJcbiAgICAgICc8L2Rpdj4nXHJcbiAgKTtcclxuICByZXR1cm4gc2FtcGxlO1xyXG59O1xyXG5cclxucHJvdG8uZW5kVGFnV2l0aEJyZWFrID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzYW1wbGU7XHJcblxyXG4gIHNhbXBsZSA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRpdiBjbGFzcz1cInVlLXNlZ21lbnRcIiBkYXRhLXNlZ21lbnQtbnVtYmVyPVwiMVwiPicgK1xyXG4gICAgICAnJnp3bmo7JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwidWUtaW5saW5lLWNvbnRlbnRcIj4nICtcclxuICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIiBkYXRhLXR5cGU9XCJzdGFydC10YWdcIiBkYXRhLXRhZy1jb3B5PVwidHJ1ZVwiIGRhdGEtaWQ9XCIyOFwiIGRhdGEtbWV0YWRhdGE9XCIxNTkwMTYwMi02NTkxNzQwLTcwNjAzODFcIiBkYXRhLWNhbi1oaWRlPVwidHJ1ZVwiPicgK1xyXG4gICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWcgdWUtdGFnLXN0YXJ0XCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIj5jZjwvc3Bhbj4nICtcclxuICAgICAgJ+KAjCZ6d25qOycgK1xyXG4gICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50IHVlLXRhZ3BhaXItY29udGVudFwiIGRhdGEtdHlwZT1cInRhZ3BhaXJcIiBkYXRhLWlkPVwiMjhcIiBkYXRhLWRlZmluaXRpb25pZD1cIjEyXCIgZGF0YS1tZXRhZGF0YT1cIjE1OTAxNjAyLTY1OTE3NDAtNzA2MDM4MVwiIGRhdGEtc3R5bGU9XCJ7JnF1b3Q7Rm9udE5hbWUmcXVvdDs6JnF1b3Q7QXJpYWwmcXVvdDssJnF1b3Q7Rm9udFNpemUmcXVvdDs6JnF1b3Q7NyZxdW90OywmcXVvdDtUZXh0Q29sb3ImcXVvdDs6JnF1b3Q7MCwgMCwgMTEyLCAxOTImcXVvdDt9XCIgc3R5bGU9XCJmb250LWZhbWlseTogQXJpYWw7IGZvbnQtc2l6ZTogN3B4OyBjb2xvcjogcmdiKDAsIDExMiwgMTkyKTtcIj4nICtcclxuICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGV4dFwiIGRhdGEtdHlwZT1cInRleHRcIj5hbmQgPC9zcGFuPicgK1xyXG4gICAgICAnPC9kaXY+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZy13cmFwcGVyXCIgZGF0YS10eXBlPVwiZW5kLXRhZ1wiIGRhdGEtdGFnLWNvcHk9XCJ0cnVlXCIgZGF0YS1pZD1cIjI4XCIgZGF0YS1tZXRhZGF0YT1cIjE0MzgyMjgxLTc4MzM3NzktNDE3NjExMlwiIGRhdGEtY2FuLWhpZGU9XCJ0cnVlXCI+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZyB1ZS10YWctZW5kXCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIj5jZjwvc3Bhbj7igIwnICtcclxuICAgICAgJ+KAjCZ6d25qOycgK1xyXG5cclxuICAgICAgJzxicj4nICtcclxuXHJcbiAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICc8L2Rpdj4nICtcclxuICAgICAgJzwvZGl2PidcclxuICApO1xyXG5cclxuICByZXR1cm4gc2FtcGxlO1xyXG59O1xyXG5cclxucHJvdG8uZW1wdHlTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzYW1wbGU7XHJcblxyXG4gIHNhbXBsZSA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRpdiBjbGFzcz1cInVlLXNlZ21lbnRcIiBkYXRhLXNlZ21lbnQtbnVtYmVyPVwiMVwiPicgK1xyXG4gICAgICAnJnp3bmo7JyArXHJcbiAgICAgICc8YnI+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwidWUtaW5saW5lLWNvbnRlbnRcIj4nICtcclxuICAgICAgJzwvZGl2PidcclxuICApO1xyXG5cclxuICByZXR1cm4gc2FtcGxlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTaGlmdEVudGVySGFuZGxlckZpeHR1cmU7XHJcbiIsIi8qIEZpbGU6IFNpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyRml4dHVyZS5qcyAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBwcm90bztcclxuXHJcbmZ1bmN0aW9uIFNpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyRml4dHVyZSgpIHtcclxufVxyXG5wcm90byA9IFNpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyRml4dHVyZS5wcm90b3R5cGU7XHJcblxyXG5wcm90by5kZWZhdWx0RG9jdW1lbnRTYW1wbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHVlRG9jdW1lbnQ7XHJcblxyXG4gIHVlRG9jdW1lbnQgPSB7XHJcbiAgICBcImRhdGFcIjoge1xyXG4gICAgICBcImZpbGVzXCI6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBcImRlcGVuZGVuY3lGaWxlc1wiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICBcImZpbGVOYW1lXCI6IFwiYzpcXFxcTG9jYWxGaWxlc0Zwc1xcXFwxNGIyYTgxZGIwODg0ZGJjYWNjMWFiZjFjOWQzZDcwZl9Xb3JkV2l0aEZvcm1hdHRpbmcuZG9jeFwiLFxyXG4gICAgICAgICAgICAgIFwiaWRcIjogXCJpbnB1dGZpbGVcIixcclxuICAgICAgICAgICAgICBcImxvY2F0aW9uXCI6IFwiaHR0cDovL2NsdWpnd3FhMTU6ODA4MC9ndy1maWxlLW1hbmFnZW1lbnQtd2ViL2ZpbGVzLzUzMGIzMzA2ODRhZTk0MGE5ZmYyNzZiZS9maWxlP0RPV05MT0FEX1RPS0VOPVNwNzZXQnpyMVhtaTVXeWFkSk8xOHclM0QlM0RfMS4wXCIsXHJcbiAgICAgICAgICAgICAgXCJ1c2FnZVwiOiBcIkdlbmVyYXRpb25cIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICBdLFxyXG4gICAgICAgICAgXCJmaWxlVHlwZURlZmluaXRpb25JZFwiOiBcIldvcmQgMjAwNyB2IDIuMC4wLjBcIixcclxuICAgICAgICAgIFwiaWRcIjogXCI0NDczZDIxNDk1ZDQ0NmM1YjBkMjI5MDhhN2RlMDQwY1wiLFxyXG4gICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgIFwiRXh0cmFjdERvY3VtZW50UHJvcGVydGllc1wiOiBcIkZhbHNlXCIsXHJcbiAgICAgICAgICAgIFwiRXh0cmFjdEh5cGVybGlua3NcIjogXCJUcnVlXCIsXHJcbiAgICAgICAgICAgIFwiRXh0cmFjdFNoYXBlT3JkZXJcIjogXCJUb3BMZWZ0VG9Cb3R0b21SaWdodEJ5Um93XCIsXHJcbiAgICAgICAgICAgIFwiRXh0cmFjdFRyYWNrQ2hhbmdlc01vZGVcIjogXCJNZXJnZVwiLFxyXG4gICAgICAgICAgICBcIlByb2Nlc3NMaXN0SXRlbVZhbHVlc1wiOiBcIkZhbHNlXCIsXHJcbiAgICAgICAgICAgIFwiUHJvY2Vzc0xvY2tlZENvbnRlbnRDb250cm9sc1wiOiBcIkZhbHNlXCIsXHJcbiAgICAgICAgICAgIFwiU0RMOkF1dG9DbG9uZWRGbGFnU3VwcG9ydGVkXCI6IFwiVHJ1ZVwiLFxyXG4gICAgICAgICAgICBcIlNETDpDcmVhdGlvbkRhdGVcIjogXCIwMi8yNC8yMDE0IDEzOjU0OjQyXCIsXHJcbiAgICAgICAgICAgIFwiU0RMOkZpbGVJZFwiOiBcImFhNzk4YjFhLWRiMmQtNDIyOS1hZmQ1LWQ2MzA1ZmNjNWEwNFwiLFxyXG4gICAgICAgICAgICBcIlNETDpGaWxlVHlwZURlZmluaXRpb25JZFwiOiBcIldvcmQgMjAwNyB2IDIuMC4wLjBcIixcclxuICAgICAgICAgICAgXCJTREw6T3JpZ2luYWxGaWxlUGF0aFwiOiBcImM6XFxcXExvY2FsRmlsZXNGcHNcXFxcMTRiMmE4MWRiMDg4NGRiY2FjYzFhYmYxYzlkM2Q3MGZfV29yZFdpdGhGb3JtYXR0aW5nLmRvY3hcIixcclxuICAgICAgICAgICAgXCJTREw6U291cmNlTGFuZ3VhZ2VcIjogXCJlbi1HQlwiLFxyXG4gICAgICAgICAgICBcIlNETDpUYXJnZXRMYW5ndWFnZVwiOiBcImVuLUdCXCIsXHJcbiAgICAgICAgICAgIFwiU2tpcEFkdmFuY2VkRm9udEZvcm1hdHRpbmdcIjogXCJUcnVlXCIsXHJcbiAgICAgICAgICAgIFwiU2tpcENvbXBsZXhTY3JpcHRBbmRBc2lhblRleHRGb250XCI6IFwiVHJ1ZVwiLFxyXG4gICAgICAgICAgICBcIlNraXBOb25BY2NlcHRlZFJlamVjdGVkQ2hhbmdlc1wiOiBcIkZhbHNlXCIsXHJcbiAgICAgICAgICAgIFwiVHJhbnNsYXRlQ29tbWVudHNcIjogXCJUcnVlXCIsXHJcbiAgICAgICAgICAgIFwiV3JpdGVTdHVkaW9Db21tZW50c1RvVGFyZ2V0XCI6IFwiVHJ1ZVwiXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgXCJvcmlnaW5hbEZpbGVOYW1lXCI6IFwiMTRiMmE4MWRiMDg4NGRiY2FjYzFhYmYxYzlkM2Q3MGZfV29yZFdpdGhGb3JtYXR0aW5nLmRvY3hcIixcclxuICAgICAgICAgIFwicGFyYWdyYXBoVW5pdENvdW50XCI6IDEsXHJcbiAgICAgICAgICBcInBhcmFncmFwaFVuaXRzXCI6IFtcclxuICAgICAgICAgICAgbnVsbFxyXG4gICAgICAgICAgXSxcclxuICAgICAgICAgIFwic3RydWN0dXJlUGFyYWdyYXBoVW5pdENvdW50XCI6IDBcclxuICAgICAgICB9XHJcbiAgICAgIF0sXHJcbiAgICAgIFwiaWRcIjogXCI4ZTc0MTQ0My1kNjMyLTQwYjEtODgwOS0wNjRiY2Y1ZDFiMGNcIixcclxuICAgICAgXCJuYW1lXCI6IFwiMTRiMmE4MWRiMDg4NGRiY2FjYzFhYmYxYzlkM2Q3MGZfV29yZFdpdGhGb3JtYXR0aW5nLmRvY3hcIixcclxuICAgICAgXCJwYXJhZ3JhcGhVbml0Q291bnRcIjogMSxcclxuICAgICAgXCJzb3VyY2VMYW5ndWFnZUNvZGVcIjogXCJlbi1HQlwiLFxyXG4gICAgICBcInNvdXJjZUxhbmd1YWdlTmFtZVwiOiBcIkVuZ2xpc2ggKFVuaXRlZCBLaW5nZG9tKVwiLFxyXG4gICAgICBcInN0cnVjdHVyZVBhcmFncmFwaFVuaXRDb3VudFwiOiAwLFxyXG4gICAgICBcInRhcmdldExhbmd1YWdlQ29kZVwiOiBcImVuLUdCXCIsXHJcbiAgICAgIFwidGFyZ2V0TGFuZ3VhZ2VOYW1lXCI6IFwiRW5nbGlzaCAoVW5pdGVkIEtpbmdkb20pXCJcclxuICAgIH0sXHJcbiAgICBcImlkXCI6IFwiOGU3NDE0NDMtZDYzMi00MGIxLTg4MDktMDY0YmNmNWQxYjBjXCIsXHJcbiAgICBcImxvYWRlZFBhcmFncmFwaHNcIjogNCxcclxuICAgIFwicGFyYWdyYXBoQ291bnRcIjogMSxcclxuICAgIFwic2tlbGV0b25zXCI6IFtcclxuICAgICAge1xyXG4gICAgICAgIFwiY29tbWVudHNcIjogW10sXHJcbiAgICAgICAgXCJjb250ZXh0RGVmaW5pdGlvbnNcIjogW10sXHJcbiAgICAgICAgXCJjb250ZXh0c1wiOiBbXSxcclxuICAgICAgICBcImZpbGVJZFwiOiBcIjY5YjA3YTM0NzViYTRkOTY4N2ZkNmJiODAzNjNjYWRiXCIsXHJcbiAgICAgICAgXCJmb3JtYXR0aW5nR3JvdXBzXCI6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJpZFwiOiAxLFxyXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcclxuICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiaWRcIjogMixcclxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7XHJcbiAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCIwLCAyNTUsIDAsIDBcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiaWRcIjogMyxcclxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7XHJcbiAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCIwLCAxOTIsIDgwLCA3N1wiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjogbnVsbFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJpZFwiOiA0LFxyXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcclxuICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICBcIlN0cmlrZXRocm91Z2hcIjogXCJUcnVlXCIsXHJcbiAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCIwLCAxOTIsIDgwLCA3N1wiLFxyXG4gICAgICAgICAgICAgIFwiVW5kZXJsaW5lXCI6IFwiVHJ1ZVwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjogbnVsbFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJpZFwiOiA1LFxyXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcclxuICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICBcIlRleHRDb2xvclwiOiBcIjAsIDAsIDExMiwgMTkyXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiBudWxsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImlkXCI6IDYsXHJcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1xyXG4gICAgICAgICAgICAgIFwiQm9sZFwiOiBcIlRydWVcIixcclxuICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICBcIlN0cmlrZXRocm91Z2hcIjogXCJUcnVlXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiBudWxsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImlkXCI6IDcsXHJcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1xyXG4gICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgIFwiVGV4dENvbG9yXCI6IFwiVHJhbnNwYXJlbnRcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiaWRcIjogOCxcclxuICAgICAgICAgICAgXCJpdGVtc1wiOiB7XHJcbiAgICAgICAgICAgICAgXCJCYWNrZ3JvdW5kQ29sb3JcIjogXCIwLCAyNTUsIDAsIDBcIixcclxuICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICBcIlRleHRDb2xvclwiOiBcIlRyYW5zcGFyZW50XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiBudWxsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImlkXCI6IDksXHJcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1xyXG4gICAgICAgICAgICAgIFwiQmFja2dyb3VuZENvbG9yXCI6IFwiMCwgMCwgMjU1LCAwXCIsXHJcbiAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiBudWxsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImlkXCI6IDEwLFxyXG4gICAgICAgICAgICBcIml0ZW1zXCI6IHtcclxuICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICBcIkl0YWxpY1wiOiBcIlRydWVcIixcclxuICAgICAgICAgICAgICBcIlVuZGVybGluZVwiOiBcIlRydWVcIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiaWRcIjogMTEsXHJcbiAgICAgICAgICAgIFwiaXRlbXNcIjoge1xyXG4gICAgICAgICAgICAgIFwiQmFja2dyb3VuZENvbG9yXCI6IFwiMCwgMCwgMCwgMjU1XCIsXHJcbiAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCJUcmFuc3BhcmVudFwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjogbnVsbFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJwbGFjZWhvbGRlclRhZ0RlZmluaXRpb25zXCI6IFtdLFxyXG4gICAgICAgIFwic3RydWN0dXJlVGFnRGVmaW5pdGlvbnNcIjogW10sXHJcbiAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbnNcIjogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJlbmRUYWdDb250ZW50XCI6IFwiPC9jZj5cIixcclxuICAgICAgICAgICAgXCJlbmRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwiZm9ybWF0dGluZ0dyb3VwSWRcIjogMSxcclxuICAgICAgICAgICAgXCJpZFwiOiAxLFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGwsXHJcbiAgICAgICAgICAgIFwic3RhcnRUYWdDb250ZW50XCI6IFwiPGNmIHNpemU9MTI+XCIsXHJcbiAgICAgICAgICAgIFwic3RhcnRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwic3ViQ29udGVudFwiOiBbXVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJjYW5IaWRlXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwiZW5kVGFnQ29udGVudFwiOiBcIjwvY2Y+XCIsXHJcbiAgICAgICAgICAgIFwiZW5kVGFnRGlzcGxheVRleHRcIjogXCJjZlwiLFxyXG4gICAgICAgICAgICBcImZvcm1hdHRpbmdHcm91cElkXCI6IDIsXHJcbiAgICAgICAgICAgIFwiaWRcIjogMixcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiBudWxsLFxyXG4gICAgICAgICAgICBcInN0YXJ0VGFnQ29udGVudFwiOiBcIjxjZiBjb2xvcj1GRjAwMDA+XCIsXHJcbiAgICAgICAgICAgIFwic3RhcnRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwic3ViQ29udGVudFwiOiBbXVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJjYW5IaWRlXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwiZW5kVGFnQ29udGVudFwiOiBcIjwvY2Y+XCIsXHJcbiAgICAgICAgICAgIFwiZW5kVGFnRGlzcGxheVRleHRcIjogXCJjZlwiLFxyXG4gICAgICAgICAgICBcImZvcm1hdHRpbmdHcm91cElkXCI6IDMsXHJcbiAgICAgICAgICAgIFwiaWRcIjogMyxcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiBudWxsLFxyXG4gICAgICAgICAgICBcInN0YXJ0VGFnQ29udGVudFwiOiBcIjxjZiBjb2xvcj1DMDUwNEQgc2l6ZT0xMj5cIixcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0Rpc3BsYXlUZXh0XCI6IFwiY2ZcIixcclxuICAgICAgICAgICAgXCJzdWJDb250ZW50XCI6IFtdXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJlbmRUYWdDb250ZW50XCI6IFwiPC9jZj5cIixcclxuICAgICAgICAgICAgXCJlbmRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwiZm9ybWF0dGluZ0dyb3VwSWRcIjogNCxcclxuICAgICAgICAgICAgXCJpZFwiOiA0LFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGwsXHJcbiAgICAgICAgICAgIFwic3RhcnRUYWdDb250ZW50XCI6IFwiPGNmIHN0cmlrZXRocm91Z2g9c2luZ2xlIHVuZGVybGluZT1zaW5nbGU+XCIsXHJcbiAgICAgICAgICAgIFwic3RhcnRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwic3ViQ29udGVudFwiOiBbXVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJjYW5IaWRlXCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwiZW5kVGFnQ29udGVudFwiOiBcIjwvY2Y+XCIsXHJcbiAgICAgICAgICAgIFwiZW5kVGFnRGlzcGxheVRleHRcIjogXCJjZlwiLFxyXG4gICAgICAgICAgICBcImZvcm1hdHRpbmdHcm91cElkXCI6IDUsXHJcbiAgICAgICAgICAgIFwiaWRcIjogNSxcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiBudWxsLFxyXG4gICAgICAgICAgICBcInN0YXJ0VGFnQ29udGVudFwiOiBcIjxjZiBjb2xvcj0wMDcwQzAgc2l6ZT0xMj5cIixcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0Rpc3BsYXlUZXh0XCI6IFwiY2ZcIixcclxuICAgICAgICAgICAgXCJzdWJDb250ZW50XCI6IFtdXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJlbmRUYWdDb250ZW50XCI6IFwiPC9jZj5cIixcclxuICAgICAgICAgICAgXCJlbmRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwiZm9ybWF0dGluZ0dyb3VwSWRcIjogNixcclxuICAgICAgICAgICAgXCJpZFwiOiA2LFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGwsXHJcbiAgICAgICAgICAgIFwic3RhcnRUYWdDb250ZW50XCI6IFwiPGNmIGJvbGQ9VHJ1ZSBzdHJpa2V0aHJvdWdoPXNpbmdsZT5cIixcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0Rpc3BsYXlUZXh0XCI6IFwiY2ZcIixcclxuICAgICAgICAgICAgXCJzdWJDb250ZW50XCI6IFtdXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJlbmRUYWdDb250ZW50XCI6IFwiPC9jZj5cIixcclxuICAgICAgICAgICAgXCJlbmRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwiZm9ybWF0dGluZ0dyb3VwSWRcIjogNyxcclxuICAgICAgICAgICAgXCJpZFwiOiA3LFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGwsXHJcbiAgICAgICAgICAgIFwic3RhcnRUYWdDb250ZW50XCI6IFwiPGNmIGNvbG9yPUZGRkZGRiBzaXplPTEyPlwiLFxyXG4gICAgICAgICAgICBcInN0YXJ0VGFnRGlzcGxheVRleHRcIjogXCJjZlwiLFxyXG4gICAgICAgICAgICBcInN1YkNvbnRlbnRcIjogW11cclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiY2FuSGlkZVwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImVuZFRhZ0NvbnRlbnRcIjogXCI8L2NmPlwiLFxyXG4gICAgICAgICAgICBcImVuZFRhZ0Rpc3BsYXlUZXh0XCI6IFwiY2ZcIixcclxuICAgICAgICAgICAgXCJmb3JtYXR0aW5nR3JvdXBJZFwiOiA4LFxyXG4gICAgICAgICAgICBcImlkXCI6IDgsXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjogbnVsbCxcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0NvbnRlbnRcIjogXCI8Y2YgaGlnaGxpZ2h0PXJlZD5cIixcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0Rpc3BsYXlUZXh0XCI6IFwiY2ZcIixcclxuICAgICAgICAgICAgXCJzdWJDb250ZW50XCI6IFtdXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJlbmRUYWdDb250ZW50XCI6IFwiPC9jZj5cIixcclxuICAgICAgICAgICAgXCJlbmRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwiZm9ybWF0dGluZ0dyb3VwSWRcIjogOSxcclxuICAgICAgICAgICAgXCJpZFwiOiA5LFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGwsXHJcbiAgICAgICAgICAgIFwic3RhcnRUYWdDb250ZW50XCI6IFwiPGNmIGhpZ2hsaWdodD1ncmVlbj5cIixcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0Rpc3BsYXlUZXh0XCI6IFwiY2ZcIixcclxuICAgICAgICAgICAgXCJzdWJDb250ZW50XCI6IFtdXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJlbmRUYWdDb250ZW50XCI6IFwiPC9jZj5cIixcclxuICAgICAgICAgICAgXCJlbmRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwiZm9ybWF0dGluZ0dyb3VwSWRcIjogMTAsXHJcbiAgICAgICAgICAgIFwiaWRcIjogMTAsXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjogbnVsbCxcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0NvbnRlbnRcIjogXCI8Y2YgaXRhbGljPVRydWUgdW5kZXJsaW5lPXNpbmdsZT5cIixcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0Rpc3BsYXlUZXh0XCI6IFwiY2ZcIixcclxuICAgICAgICAgICAgXCJzdWJDb250ZW50XCI6IFtdXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJlbmRUYWdDb250ZW50XCI6IFwiPC9jZj5cIixcclxuICAgICAgICAgICAgXCJlbmRUYWdEaXNwbGF5VGV4dFwiOiBcImNmXCIsXHJcbiAgICAgICAgICAgIFwiZm9ybWF0dGluZ0dyb3VwSWRcIjogMTEsXHJcbiAgICAgICAgICAgIFwiaWRcIjogMTEsXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjogbnVsbCxcclxuICAgICAgICAgICAgXCJzdGFydFRhZ0NvbnRlbnRcIjogXCI8Y2YgY29sb3I9RkZGRkZGIGhpZ2hsaWdodD1ibHVlPlwiLFxyXG4gICAgICAgICAgICBcInN0YXJ0VGFnRGlzcGxheVRleHRcIjogXCJjZlwiLFxyXG4gICAgICAgICAgICBcInN1YkNvbnRlbnRcIjogW11cclxuICAgICAgICAgIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9O1xyXG4gIHJldHVybiB1ZURvY3VtZW50O1xyXG59O1xyXG5cclxucHJvdG8uZGVmYXVsdFBhcmFncmFwaHNTYW1wbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHBhcmFncmFwaHM7XHJcblxyXG4gIHBhcmFncmFwaHMgPSBbXHJcbiAgICB7XHJcbiAgICAgIFwiY29udGV4dElkXCI6IDAsXHJcbiAgICAgIFwiaWRcIjogXCJmODVmNTUxOC1lNmRmLTRhNzYtOTY2NC1iZjk2YjlhZGVkMGZcIixcclxuICAgICAgXCJpbmRleFwiOiAxLFxyXG4gICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICBcImlzU3RydWN0dXJlXCI6IGZhbHNlLFxyXG4gICAgICBcInBhcmVudEZpbGVJZFwiOiBcIjY5YjA3YTM0NzViYTRkOTY4N2ZkNmJiODAzNjNjYWRiXCIsXHJcbiAgICAgIFwic291cmNlXCI6IHtcclxuICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlRoZSBFdXJvcGVhbiBsYW5ndWFnZXMgYXJlIG1lbWJlcnMgb2YgdGhlIHNhbWUgZmFtaWx5LlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMVwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlRoZWlyIHNlcGFyYXRlIGV4aXN0ZW5jZSBpcyBhIG15dGguXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMlwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkZvciBzY2llbmNlLCBtdXNpYywgc3BvcnQsIFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJldGNcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhcmVudFRhZ1wiOiBcInc6clwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlRleHRDb2xvclwiOiBcIkZGMDAwMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJmcmFtZXdvcmtPcmlnaW5hbFRhZ0lkXCI6IFwiNVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OmNvbG9yXCI6IFwiPHc6Y29sb3Igdzp2YWw9XFxcIkZGMDAwMFxcXCIvPlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6XCI6IFwiPHc6c3ogdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCJcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGFnUGFpckRlZmluaXRpb25JZFwiOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRhZ1BhaXJcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiLCBFdXJvcGUgdXNlcyB0aGUgc2FtZSB2b2NhYnVsYXJ5LlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiM1wiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlRoZSBsYW5ndWFnZXMgb25seSBkaWZmZXIgaW4gdGhlaXIgZ3JhbW1hciwgdGhlaXIgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2FuSGlkZVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwicHJvbnVuY2lhdGlvbiBhbmQgdGhlaXIgbW9zdCBjb21tb25cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN0YXJ0VGFnXCI6IFwidzpyUHJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlN0cmlrZXRocm91Z2hcIjogXCJzaW5nbGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlRleHRDb2xvclwiOiBcIkMwNTA0RFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiVW5kZXJsaW5lXCI6IFwic2luZ2xlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmcmFtZXdvcmtPcmlnaW5hbFRhZ0lkXCI6IFwiMTFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInc6Y29sb3JcIjogXCI8dzpjb2xvciB3OnZhbD1cXFwiQzA1MDREXFxcIiB3OnRoZW1lQ29sb3I9XFxcImFjY2VudDJcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInc6c3RyaWtlXCI6IFwiPHc6c3RyaWtlLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3OnVcIjogXCI8dzp1IHc6dmFsPVxcXCJzaW5nbGVcXFwiLz5cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGFnUGFpclwiXHJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjNcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCJDMDUwNERcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiZnJhbWV3b3JrT3JpZ2luYWxUYWdJZFwiOiBcIjE0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6Y29sb3JcIjogXCI8dzpjb2xvciB3OnZhbD1cXFwiQzA1MDREXFxcIiB3OnRoZW1lQ29sb3I9XFxcImFjY2VudDJcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpzelwiOiBcIjx3OnN6IHc6dmFsPVxcXCIyNFxcXCIvPlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6Q3NcIjogXCI8dzpzekNzIHc6dmFsPVxcXCIyNFxcXCIvPlwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogMyxcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0YWdQYWlyXCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIndvcmRzLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjRcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJFdmVyeW9uZSByZWFsaXplcyB3aHkgYSBuZXcgY29tbW9uIGxhbmd1YWdlIHdvdWxkIGJlIGRlc2lyYWJsZTogb25lIGNvdWxkIHJlZnVzZSB0byBwYXkgZXhwZW5zaXZlIHRyYW5zbGF0b3JzLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjVcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFwiaWRcIjogXCIxXCIsXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgIFwiUGFyZW50VGFnXCI6IFwidzpyXCIsXHJcbiAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgXCJmcmFtZXdvcmtPcmlnaW5hbFRhZ0lkXCI6IFwiMlwiLFxyXG4gICAgICAgICAgICAgIFwidzpzelwiOiBcIjx3OnN6IHc6dmFsPVxcXCIyNFxcXCIvPlwiLFxyXG4gICAgICAgICAgICAgIFwidzpzekNzXCI6IFwiPHc6c3pDcyB3OnZhbD1cXFwiMjRcXFwiLz5cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogMSxcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGFnUGFpclwiXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcInR5cGVcIjogXCJwYXJhZ3JhcGhcIlxyXG4gICAgICB9LFxyXG4gICAgICBcInRhcmdldFwiOiB7XHJcbiAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiY2FuSGlkZVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJMaW1iaWxlIGV1cm9wZW5lIHN1bnQgbWVtYnJlIGFsZSBhY2VsZWlhc2kgZmFtaWxpaSBsaW5ndmlzdGljZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJjb25maXJtYXRpb25MZXZlbFwiOiBcIkRyYWZ0XCIsXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIxXCIsXHJcbiAgICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uT3JpZ2luXCI6IHtcclxuICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgXCJtYXRjaFBlcmNlbnRcIjogMCxcclxuICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwiY09YV3UvM1M1c2d0SUdwU2M1Z2kzSllIL204PVwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luQmVmb3JlQWRhcHRhdGlvblwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwiY09YV3UvM1M1c2d0SUdwU2M1Z2kzSllIL204PVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbkJlZm9yZUFkYXB0YXRpb25cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBcIm9yaWdpblN5c3RlbVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwib3JpZ2luVHlwZVwiOiBcImludGVyYWN0aXZlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5TeXN0ZW1cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5UeXBlXCI6IFwiaW50ZXJhY3RpdmVcIixcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcInRleHRDb250ZXh0TWF0Y2hMZXZlbFwiOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkV4aXN0ZW5cXHUwMjFiYSBsb3Igc2VwYXJhdFxcdTAxMDMgZXN0ZSB1biBtaXQuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImNvbmZpcm1hdGlvbkxldmVsXCI6IFwiRHJhZnRcIixcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIyXCIsXHJcbiAgICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uT3JpZ2luXCI6IHtcclxuICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgXCJtYXRjaFBlcmNlbnRcIjogMCxcclxuICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwiZHBpS3BQSUREamZHNXJWVDY3bWJROEVaSWFBPVwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luQmVmb3JlQWRhcHRhdGlvblwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpblN5c3RlbVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpblR5cGVcIjogXCJpbnRlcmFjdGl2ZVwiLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsVHJhbnNsYXRpb25IYXNoXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiUGVudHJ1IFxcdTAyMTl0aWluXFx1MDIxYlxcdTAxMDMsIG11emljXFx1MDEwMywgc3BvcnQsIFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcImV0Y1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiNlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBhcmVudFRhZ1wiOiBcInc6clwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGV4dENvbG9yXCI6IFwiRkYwMDAwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmcmFtZXdvcmtPcmlnaW5hbFRhZ0lkXCI6IFwiNVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidzpjb2xvclwiOiBcIjx3OmNvbG9yIHc6dmFsPVxcXCJGRjAwMDBcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRhZ1BhaXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiLFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImxvY2tlZFwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJFdXJvcGEgZm9sb3NlXFx1MDIxOXRlIGFjZWxhXFx1MDIxOWkgdm9jYWJ1bGFyLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJjb25maXJtYXRpb25MZXZlbFwiOiBcIkRyYWZ0XCIsXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIzXCIsXHJcbiAgICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uT3JpZ2luXCI6IHtcclxuICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgXCJtYXRjaFBlcmNlbnRcIjogMCxcclxuICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwiTGdBbUpvRHBBN1htaDRFMWVyYVJVQ0VLSmdVPVwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luQmVmb3JlQWRhcHRhdGlvblwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwiTGdBbUpvRHBBN1htaDRFMWVyYVJVQ0VLSmdVPVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbkJlZm9yZUFkYXB0YXRpb25cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBcIm9yaWdpblN5c3RlbVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwib3JpZ2luVHlwZVwiOiBcImludGVyYWN0aXZlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5TeXN0ZW1cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5UeXBlXCI6IFwiaW50ZXJhY3RpdmVcIixcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcInRleHRDb250ZXh0TWF0Y2hMZXZlbFwiOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkxpbWJpbGUgZGlmZXJcXHUwMTAzIGRvYXIgXFx1MDBlZW4gZ3JhbWF0aWNhIGxvciwgcHJvbnVuXFx1MDIxYmllIFxcdTAyMTlpIGN1dmludGVsZSBsb3IsIGNlbGUgbWFpIGNvbXVuZS5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiY29uZmlybWF0aW9uTGV2ZWxcIjogXCJEcmFmdFwiLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjRcIixcclxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRpb25PcmlnaW5cIjoge1xyXG4gICAgICAgICAgICAgICAgICBcImlzU3RydWN0dXJlQ29udGV4dE1hdGNoXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIlNlZ21lbnRJZGVudGl0eUhhc2hcIjogXCJxMTU0VmJla2M3WjhxYlpncFRJUXF6dHJXeVU9XCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5CZWZvcmVBZGFwdGF0aW9uXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luU3lzdGVtXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luVHlwZVwiOiBcImludGVyYWN0aXZlXCIsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxUcmFuc2xhdGlvbkhhc2hcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJ0ZXh0Q29udGV4dE1hdGNoTGV2ZWxcIjogbnVsbFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJcXHRcXHRcXHRcXHRDdSB0b3RpaSByZWFsaXplYXphIC4uLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJjb25maXJtYXRpb25MZXZlbFwiOiBcIkRyYWZ0XCIsXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiNVwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0cmFuc2xhdGlvbk9yaWdpblwiOiB7XHJcbiAgICAgICAgICAgICAgICAgIFwiaXNTdHJ1Y3R1cmVDb250ZXh0TWF0Y2hcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgIFwibWF0Y2hQZXJjZW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiU2VnbWVudElkZW50aXR5SGFzaFwiOiBcIm0xeGR1Ni9VbFljVEtQS1lINHdZM21pYWZqaz1cIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbkJlZm9yZUFkYXB0YXRpb25cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5TeXN0ZW1cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5UeXBlXCI6IFwiaW50ZXJhY3RpdmVcIixcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcInRleHRDb250ZXh0TWF0Y2hMZXZlbFwiOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgXCJpZFwiOiBcIjVcIixcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICBcIlN0YXJ0VGFnXCI6IFwidzpyUHJcIixcclxuICAgICAgICAgICAgICBcImZyYW1ld29ya09yaWdpbmFsVGFnSWRcIjogXCIyXCIsXHJcbiAgICAgICAgICAgICAgXCJ3OnN6XCI6IFwiPHc6c3ogdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgXCJ3OnN6Q3NcIjogXCI8dzpzekNzIHc6dmFsPVxcXCIyNFxcXCIvPlwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwidGFnUGFpckRlZmluaXRpb25JZFwiOiAxLFxyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0YWdQYWlyXCJcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwidHlwZVwiOiBcInBhcmFncmFwaFwiXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIFwiY29udGV4dElkXCI6IDAsXHJcbiAgICAgIFwiaWRcIjogXCI1ZDVhYmJiZi02YWQxLTQyY2QtYTkxOS1iMzQzYzFiZmRlODZcIixcclxuICAgICAgXCJpbmRleFwiOiAyLFxyXG4gICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICBcImlzU3RydWN0dXJlXCI6IGZhbHNlLFxyXG4gICAgICBcInBhcmVudEZpbGVJZFwiOiBcIjY5YjA3YTM0NzViYTRkOTY4N2ZkNmJiODAzNjNjYWRiXCIsXHJcbiAgICAgIFwic291cmNlXCI6IHtcclxuICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlRvIGFjaGlldmUgdGhpcywgaXQgd291bGQgYmUgbmVjZXNzYXJ5IHRvIGhhdmUgdW5pZm9ybSBncmFtbWFyLCBwcm9udW5jaWF0aW9uIGFuZCBtb3JlIGNvbW1vbiB3b3Jkcy5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCI2XCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiSWYgc2V2ZXJhbCBsYW5ndWFnZXMgY29hbGVzY2UsIHRoZSBncmFtbWFyIG9mIHRoZSByZXN1bHRpbmcgbGFuZ3VhZ2UgaXMgbW9yZSBzaW1wbGUgYW5kIHJlZ3VsYXIgdGhhbiB0aGF0IG9mIHRoZSBpbmRpdmlkdWFsIGxhbmd1YWdlcy5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCI3XCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiVGhlIG5ldyBjb21tb24gbGFuZ3VhZ2Ugd2lsbCBiZSBtb3JlIHNpbXBsZSBhbmQgcmVndWxhciB0aGFuIHRoZSBleGlzdGluZyBFdXJvcGVhbiBsYW5ndWFnZXMuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiOFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkl0IHdpbGwgYmUgYXMgc2ltcGxlIGFzIE9jY2lkZW50YWw7IGluIGZhY3QsIGl0IHdpbGwgYmUgT2NjaWRlbnRhbC5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCI5XCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFwiaWRcIjogXCI3XCIsXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgIFwiUGFyZW50VGFnXCI6IFwidzpyXCIsXHJcbiAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCIwMDcwQzBcIixcclxuICAgICAgICAgICAgICBcImZyYW1ld29ya09yaWdpbmFsVGFnSWRcIjogXCIyMFwiLFxyXG4gICAgICAgICAgICAgIFwidzpjb2xvclwiOiBcIjx3OmNvbG9yIHc6dmFsPVxcXCIwMDcwQzBcXFwiLz5cIixcclxuICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDUsXHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRhZ1BhaXJcIlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJ0eXBlXCI6IFwicGFyYWdyYXBoXCJcclxuICAgICAgfSxcclxuICAgICAgXCJ0YXJnZXRcIjoge1xyXG4gICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiVG8gYWNoaWV2ZSB0aGlzLCBpdCB3b3VsZCBiZSBuZWNlc3NhcnkgdG8gaGF2ZSB1bmlmb3JtIGdyYW1tYXIsIHByb251bmNpYXRpb24gYW5kIG1vcmUgY29tbW9uIHdvcmRzLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjZcIixcclxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRpb25PcmlnaW5cIjoge1xyXG4gICAgICAgICAgICAgICAgICBcImlzU3RydWN0dXJlQ29udGV4dE1hdGNoXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIlNlZ21lbnRJZGVudGl0eUhhc2hcIjogXCJoN1JKOW54UUJwbDRFQnRCUGlHVkx1cllpRlk9XCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5CZWZvcmVBZGFwdGF0aW9uXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luU3lzdGVtXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luVHlwZVwiOiBcInNvdXJjZVwiLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsVHJhbnNsYXRpb25IYXNoXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiSWYgc2V2ZXJhbCBsYW5ndWFnZXMgY29hbGVzY2UsIHRoZSBncmFtbWFyIG9mIHRoZSByZXN1bHRpbmcgbGFuZ3VhZ2UgaXMgbW9yZSBzaW1wbGUgYW5kIHJlZ3VsYXIgdGhhbiB0aGF0IG9mIHRoZSBpbmRpdmlkdWFsIGxhbmd1YWdlcy5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCI3XCIsXHJcbiAgICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uT3JpZ2luXCI6IHtcclxuICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgXCJtYXRjaFBlcmNlbnRcIjogMCxcclxuICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwiak0vd1MzS3ZNdGdCTy91VWU1eDJJWkxUWFJnPVwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luQmVmb3JlQWRhcHRhdGlvblwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpblN5c3RlbVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpblR5cGVcIjogXCJzb3VyY2VcIixcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcInRleHRDb250ZXh0TWF0Y2hMZXZlbFwiOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlRoZSBuZXcgY29tbW9uIGxhbmd1YWdlIHdpbGwgYmUgbW9yZSBzaW1wbGUgYW5kIHJlZ3VsYXIgdGhhbiB0aGUgZXhpc3RpbmcgRXVyb3BlYW4gbGFuZ3VhZ2VzLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjhcIixcclxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRpb25PcmlnaW5cIjoge1xyXG4gICAgICAgICAgICAgICAgICBcImlzU3RydWN0dXJlQ29udGV4dE1hdGNoXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIlNlZ21lbnRJZGVudGl0eUhhc2hcIjogXCJycnNwRjRXem8wd2xqZjFVQXpUbllOdEJUV1E9XCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5CZWZvcmVBZGFwdGF0aW9uXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luU3lzdGVtXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luVHlwZVwiOiBcInNvdXJjZVwiLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsVHJhbnNsYXRpb25IYXNoXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiSXQgd2lsbCBiZSBhcyBzaW1wbGUgYXMgT2NjaWRlbnRhbDsgaW4gZmFjdCwgaXQgd2lsbCBiZSBPY2NpZGVudGFsLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjlcIixcclxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRpb25PcmlnaW5cIjoge1xyXG4gICAgICAgICAgICAgICAgICBcImlzU3RydWN0dXJlQ29udGV4dE1hdGNoXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIlNlZ21lbnRJZGVudGl0eUhhc2hcIjogXCJyY005UkNZRFZDYitTUmE5VFFUaEhSclg2ekE9XCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5CZWZvcmVBZGFwdGF0aW9uXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luU3lzdGVtXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luVHlwZVwiOiBcInNvdXJjZVwiLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsVHJhbnNsYXRpb25IYXNoXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFwiaWRcIjogXCI4XCIsXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgIFwiUGFyZW50VGFnXCI6IFwidzpyXCIsXHJcbiAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCIwMDcwQzBcIixcclxuICAgICAgICAgICAgICBcImZyYW1ld29ya09yaWdpbmFsVGFnSWRcIjogXCIyMFwiLFxyXG4gICAgICAgICAgICAgIFwidzpjb2xvclwiOiBcIjx3OmNvbG9yIHc6dmFsPVxcXCIwMDcwQzBcXFwiLz5cIixcclxuICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDUsXHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRhZ1BhaXJcIlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJ0eXBlXCI6IFwicGFyYWdyYXBoXCJcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgXCJjb250ZXh0SWRcIjogMCxcclxuICAgICAgXCJpZFwiOiBcImEyMGEyZWY0LWQ1N2MtNGE2MC05YzkzLTY5OGUxZjk1ZmJjOFwiLFxyXG4gICAgICBcImluZGV4XCI6IDMsXHJcbiAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgIFwiaXNTdHJ1Y3R1cmVcIjogZmFsc2UsXHJcbiAgICAgIFwicGFyZW50RmlsZUlkXCI6IFwiNjliMDdhMzQ3NWJhNGQ5Njg3ZmQ2YmI4MDM2M2NhZGJcIixcclxuICAgICAgXCJzb3VyY2VcIjoge1xyXG4gICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiVG8gYW4gRW5nbGlzaCBwZXJzb24sIGl0IHdpbGwgc2VlbSBsaWtlIHNpbXBsaWZpZWQgRW5nbGlzaCwgYXMgYSBza2VwdGljYWwgQ2FtYnJpZGdlIGZyaWVuZCBvZiBtaW5lIHRvbGQgbWUgd2hhdCBPY2NpZGVudGFsIGlzLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJUaGUgRXVyb3BlYW4gbGFuZ3VhZ2VzIGFyZSBtZW1iZXJzIG9mIHRoZSBzYW1lIGZhbWlseVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCJCb2xkXCI6IFwiVHJ1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhcmVudFRhZ1wiOiBcInc6clwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0cmlrZXRocm91Z2hcIjogXCJzaW5nbGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiZnJhbWV3b3JrT3JpZ2luYWxUYWdJZFwiOiBcIjMyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6YlwiOiBcIjx3OmIvPlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OnN0cmlrZVwiOiBcIjx3OnN0cmlrZS8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpzekNzXCI6IFwiPHc6c3pDcyB3OnZhbD1cXFwiMjRcXFwiLz5cIlxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDYsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGFnUGFpclwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMTBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJUaGVpciBzZXBhcmF0ZSBleGlzdGVuY2UgaXMgYSBteXRoLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjExXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiRm9yIHNjaWVuY2UsIG11c2ljLCBzcG9ydCwgZXRjLCBFdXJvcGUgdXNlcyB0aGUgc2FtZSB2b2NhYnVsYXJ5LlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiVGhlIGxhbmd1YWdlcyBvbmx5IGRpZmZlciBpbiB0aGVpciBncmFtbWFyLCB0aGVpciBwcm9udW5jaWF0aW9uIGFuZCB0aGVpciBtb3N0IGNvbW1vbiB3b3Jkcy5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIxM1wiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkV2ZXJ5b25lIHJlYWxpemVzIHdoeSBhIG5ldyBjb21tb24gbGFuZ3VhZ2Ugd291bGQgYmUgZGVzaXJhYmxlOiBvbmUgY291bGQgcmVmdXNlIHRvIHBheSBleHBlbnNpdmUgdHJhbnNsYXRvcnMuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMTRcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFwiaWRcIjogXCI5XCIsXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgIFwiUGFyZW50VGFnXCI6IFwidzpyXCIsXHJcbiAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgXCJmcmFtZXdvcmtPcmlnaW5hbFRhZ0lkXCI6IFwiMjZcIixcclxuICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDEsXHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRhZ1BhaXJcIlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJ0eXBlXCI6IFwicGFyYWdyYXBoXCJcclxuICAgICAgfSxcclxuICAgICAgXCJ0YXJnZXRcIjoge1xyXG4gICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiVG8gYW4gRW5nbGlzaCBwZXJzb24sIGl0IHdpbGwgc2VlbSBsaWtlIHNpbXBsaWZpZWQgRW5nbGlzaCwgYXMgYSBza2VwdGljYWwgQ2FtYnJpZGdlIGZyaWVuZCBvZiBtaW5lIHRvbGQgbWUgd2hhdCBPY2NpZGVudGFsIGlzLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJUaGUgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiRXVyb3BlYW5cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwibG9ja2VkXCJcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBsYW5ndWFnZXMgYXJlIG1lbWJlcnMgb2YgdGhlIHNhbWUgZmFtaWx5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkJvbGRcIjogXCJUcnVlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiUGFyZW50VGFnXCI6IFwidzpyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlN0YXJ0VGFnXCI6IFwidzpyUHJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiU3RyaWtldGhyb3VnaFwiOiBcInNpbmdsZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJmcmFtZXdvcmtPcmlnaW5hbFRhZ0lkXCI6IFwiMzJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpiXCI6IFwiPHc6Yi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6c3RyaWtlXCI6IFwiPHc6c3RyaWtlLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpzelwiOiBcIjx3OnN6IHc6dmFsPVxcXCIyNFxcXCIvPlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6Q3NcIjogXCI8dzpzekNzIHc6dmFsPVxcXCIyNFxcXCIvPlwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogNixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0YWdQYWlyXCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIi5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiY29uZmlybWF0aW9uTGV2ZWxcIjogXCJEcmFmdFwiLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjEwXCIsXHJcbiAgICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uT3JpZ2luXCI6IHtcclxuICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgXCJtYXRjaFBlcmNlbnRcIjogMCxcclxuICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwia0JndUc0Qnl0OEtEekxrYm50dkdJSG9KSEZRPVwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luQmVmb3JlQWRhcHRhdGlvblwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwia0JndUc0Qnl0OEtEekxrYm50dkdJSG9KSEZRPVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbkJlZm9yZUFkYXB0YXRpb25cIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgIFwibWF0Y2hQZXJjZW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbkJlZm9yZUFkYXB0YXRpb25cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luU3lzdGVtXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpblR5cGVcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxUcmFuc2xhdGlvbkhhc2hcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwib3JpZ2luU3lzdGVtXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5UeXBlXCI6IFwic291cmNlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5TeXN0ZW1cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5UeXBlXCI6IFwiaW50ZXJhY3RpdmVcIixcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcInRleHRDb250ZXh0TWF0Y2hMZXZlbFwiOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjExXCIsXHJcbiAgICAgICAgICAgICAgICBcInRyYW5zbGF0aW9uT3JpZ2luXCI6IHtcclxuICAgICAgICAgICAgICAgICAgXCJpc1N0cnVjdHVyZUNvbnRleHRNYXRjaFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgXCJtYXRjaFBlcmNlbnRcIjogMCxcclxuICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJTZWdtZW50SWRlbnRpdHlIYXNoXCI6IFwiZHBpS3BQSUREamZHNXJWVDY3bWJROEVaSWFBPVwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luQmVmb3JlQWRhcHRhdGlvblwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpblN5c3RlbVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpblR5cGVcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcInRleHRDb250ZXh0TWF0Y2hMZXZlbFwiOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW10sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMTNcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIxNFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0cmFuc2xhdGlvbk9yaWdpblwiOiB7XHJcbiAgICAgICAgICAgICAgICAgIFwiaXNTdHJ1Y3R1cmVDb250ZXh0TWF0Y2hcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgIFwibWF0Y2hQZXJjZW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiU2VnbWVudElkZW50aXR5SGFzaFwiOiBcIm0xeGR1Ni9VbFljVEtQS1lINHdZM21pYWZqaz1cIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbkJlZm9yZUFkYXB0YXRpb25cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5TeXN0ZW1cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5UeXBlXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxUcmFuc2xhdGlvbkhhc2hcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgXCJ0ZXh0Q29udGV4dE1hdGNoTGV2ZWxcIjogbnVsbFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIFwiaWRcIjogXCIxMVwiLFxyXG4gICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICBcIlBhcmVudFRhZ1wiOiBcInc6clwiLFxyXG4gICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgIFwiZnJhbWV3b3JrT3JpZ2luYWxUYWdJZFwiOiBcIjI2XCIsXHJcbiAgICAgICAgICAgICAgXCJ3OnN6XCI6IFwiPHc6c3ogdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgXCJ3OnN6Q3NcIjogXCI8dzpzekNzIHc6dmFsPVxcXCIyNFxcXCIvPlwiXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwidGFnUGFpckRlZmluaXRpb25JZFwiOiAxLFxyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJ0YWdQYWlyXCJcclxuICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwidHlwZVwiOiBcInBhcmFncmFwaFwiXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIFwiY29udGV4dElkXCI6IDAsXHJcbiAgICAgIFwiaWRcIjogXCJjNDM0NTg2Zi1hNGZlLTRmMmMtOGY4YS0zOTgwNDIzNmUyOTFcIixcclxuICAgICAgXCJpbmRleFwiOiA0LFxyXG4gICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICBcImlzU3RydWN0dXJlXCI6IGZhbHNlLFxyXG4gICAgICBcInBhcmVudEZpbGVJZFwiOiBcIjY5YjA3YTM0NzViYTRkOTY4N2ZkNmJiODAzNjNjYWRiXCIsXHJcbiAgICAgIFwic291cmNlXCI6IHtcclxuICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIk9uZSBtb3JuaW5nLCB3aGVuIFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkdyZWdvciBTYW1zYVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJCYWNrZ3JvdW5kQ29sb3JcIjogXCJyZWRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBhcmVudFRhZ1wiOiBcInc6clwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGV4dENvbG9yXCI6IFwiRkZGRkZGXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmcmFtZXdvcmtPcmlnaW5hbFRhZ0lkXCI6IFwiNTBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInc6Y29sb3JcIjogXCI8dzpjb2xvciB3OnZhbD1cXFwiRkZGRkZGXFxcIiB3OnRoZW1lQ29sb3I9XFxcImJhY2tncm91bmQxXFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3OmhpZ2hsaWdodFwiOiBcIjx3OmhpZ2hsaWdodCB3OnZhbD1cXFwicmVkXFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6XCI6IFwiPHc6c3ogdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6Q3NcIjogXCI8dzpzekNzIHc6dmFsPVxcXCIyNFxcXCIvPlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGFnUGFpckRlZmluaXRpb25JZFwiOiA4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0YWdQYWlyXCJcclxuICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICBcImlkXCI6IFwiMTRcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCJGRkZGRkZcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiZnJhbWV3b3JrT3JpZ2luYWxUYWdJZFwiOiBcIjU5XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6Y29sb3JcIjogXCI8dzpjb2xvciB3OnZhbD1cXFwiRkZGRkZGXFxcIiB3OnRoZW1lQ29sb3I9XFxcImJhY2tncm91bmQxXFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpzekNzXCI6IFwiPHc6c3pDcyB3OnZhbD1cXFwiMjRcXFwiLz5cIlxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDcsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGFnUGFpclwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJ3b2tlIGZyb20gdHJvdWJsZWQgZHJlYW1zLCBoZSBmb3VuZCBoaW1zZWxmIHRyYW5zZm9ybWVkIGluIGhpcyBiZWQgaW50byBhIGhvcnJpYmxlIHZlcm1pbi5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIxNVwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkhlIGxheSBvbiBoaXMgYXJtb3VyLWxpa2UgYmFjaywgYW5kIGlmIGhlIGxpZnRlZCBoaXMgaGVhZCBhIGxpdHRsZSBoZSBjb3VsZCBzZWUgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcImhpcyBicm93biBiZWxseVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCIxNlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCJCYWNrZ3JvdW5kQ29sb3JcIjogXCJncmVlblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhcmVudFRhZ1wiOiBcInc6clwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcImZyYW1ld29ya09yaWdpbmFsVGFnSWRcIjogXCI3MVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OmhpZ2hsaWdodFwiOiBcIjx3OmhpZ2hsaWdodCB3OnZhbD1cXFwiZ3JlZW5cXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpzelwiOiBcIjx3OnN6IHc6dmFsPVxcXCIyNFxcXCIvPlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6Q3NcIjogXCI8dzpzekNzIHc6dmFsPVxcXCIyNFxcXCIvPlwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogOSxcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0YWdQYWlyXCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiwgc2xpZ2h0bHkgZG9tZWQgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcImFuZCBkaXZpZGVkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE3XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiSXRhbGljXCI6IFwiVHJ1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJVbmRlcmxpbmVcIjogXCJzaW5nbGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiZnJhbWV3b3JrT3JpZ2luYWxUYWdJZFwiOiBcIjc3XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6aVwiOiBcIjx3OmkvPlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6XCI6IFwiPHc6c3ogdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6dVwiOiBcIjx3OnUgdzp2YWw9XFxcInNpbmdsZVxcXCIvPlwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGFnUGFpclwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgYnkgYXJjaGVzIGludG8gc3RpZmYgc2VjdGlvbnMuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMTZcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJUaGUgYmVkZGluZyB3YXMgaGFyZGx5IGFibGUgdG8gY292ZXIgaXQgYW5kIHNlZW1lZCByZWFkeSB0byBzbGlkZSBvZmYgYW55IG1vbWVudC5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIxN1wiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkhpcyBtYW55IGxlZ3MsIHBpdGlmdWxseSB0aGluIGNvbXBhcmVkIHdpdGggdGhlIHNpemUgb2YgdGhlIHJlc3Qgb2YgaGltLCB3YXZlZCBhYm91dCBoZWxwbGVzc2x5IGFzIGhlIGxvb2tlZC5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIxOFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIlxcXCJXaGF0J3MgaGFwcGVuZWQgdG8gbWU/XFxcIlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjE5XCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJoZSB0aG91Z2h0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjE4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkJhY2tncm91bmRDb2xvclwiOiBcImJsdWVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCJGRkZGRkZcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiZnJhbWV3b3JrT3JpZ2luYWxUYWdJZFwiOiBcIjgzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6Y29sb3JcIjogXCI8dzpjb2xvciB3OnZhbD1cXFwiRkZGRkZGXFxcIiB3OnRoZW1lQ29sb3I9XFxcImJhY2tncm91bmQxXFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6aGlnaGxpZ2h0XCI6IFwiPHc6aGlnaGxpZ2h0IHc6dmFsPVxcXCJibHVlXFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpzekNzXCI6IFwiPHc6c3pDcyB3OnZhbD1cXFwiMjRcXFwiLz5cIlxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDExLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRhZ1BhaXJcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjIwXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiSXQgd2Fzbid0IGEgZHJlYW0uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMjFcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJIaXMgcm9vbSwgYSBwcm9wZXIgaHVtYW4gcm9vbSBhbHRob3VnaCBhIGxpdHRsZSB0b28gc21hbGwsIGxheSBwZWFjZWZ1bGx5IGJldHdlZW4gaXRzIGZvdXIgZmFtaWxpYXIgd2FsbHMuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMjJcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJBIGNvbGxlY3Rpb24gb2YgdGV4dGlsZSBzYW1wbGVzIGxheSBzcHJlYWQgb3V0IG9uIHRoZSB0YWJsZSAtIFNhbXNhIHdhcyBhIHRyYXZlbGxpbmcgc2FsZXNtYW4gLSBhbmQgYWJvdmUgaXQgdGhlcmUgaHVuZyBhIHBpY3R1cmUgdGhhdCBoZSBoYWQgcmVjZW50bHkgY3V0IG91dCBvZiBhbiBpbGx1c3RyYXRlZCBtYWdhemluZSBhbmQgaG91c2VkIGluIGEgbmljZSwgZ2lsZGVkIGZyYW1lLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjIzXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiSXQgc2hvd2VkIGEgbGFkeSBmaXR0ZWQgb3V0IHdpdGggYSBmdXIgaGF0IGFuZCBmdXIgYm9hIHdobyBzYXQgdXByaWdodCwgcmFpc2luZyBhIGhlYXZ5IGZ1ciBtdWZmIHRoYXQgY292ZXJlZCB0aGUgd2hvbGUgb2YgaGVyIGxvd2VyIGFybSB0b3dhcmRzIHRoZSB2aWV3ZXIuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMjRcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJHcmVnb3IgdGhlbiB0dXJuZWQgdG8gbG9vayBvdXQgdGhlIHdpbmRvdyBhdCB0aGUgZHVsbCB3ZWF0aGVyLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjI1XCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBcImlkXCI6IFwiMTNcIixcclxuICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICBcIlN0YXJ0VGFnXCI6IFwidzpyUHJcIixcclxuICAgICAgICAgICAgICBcImZyYW1ld29ya09yaWdpbmFsVGFnSWRcIjogXCI0N1wiLFxyXG4gICAgICAgICAgICAgIFwidzpzelwiOiBcIjx3OnN6IHc6dmFsPVxcXCIyNFxcXCIvPlwiLFxyXG4gICAgICAgICAgICAgIFwidzpzekNzXCI6IFwiPHc6c3pDcyB3OnZhbD1cXFwiMjRcXFwiLz5cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogMSxcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGFnUGFpclwiXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcInR5cGVcIjogXCJwYXJhZ3JhcGhcIlxyXG4gICAgICB9LFxyXG4gICAgICBcInRhcmdldFwiOiB7XHJcbiAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiY2FuSGlkZVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIxNVwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIkhlIGxheSBvbiBoaXMgYXJtb3VyLWxpa2UgYmFjaywgYW5kIGlmIGhlIGxpZnRlZCBoaXMgaGVhZCBhIGxpdHRsZSBoZSBjb3VsZCBzZWUgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcImhpcyBicm93biBiZWxseVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogXCIyMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgXCJCYWNrZ3JvdW5kQ29sb3JcIjogXCJncmVlblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlBhcmVudFRhZ1wiOiBcInc6clwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcImZyYW1ld29ya09yaWdpbmFsVGFnSWRcIjogXCI3MVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OmhpZ2hsaWdodFwiOiBcIjx3OmhpZ2hsaWdodCB3OnZhbD1cXFwiZ3JlZW5cXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpzelwiOiBcIjx3OnN6IHc6dmFsPVxcXCIyNFxcXCIvPlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6Q3NcIjogXCI8dzpzekNzIHc6dmFsPVxcXCIyNFxcXCIvPlwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogOSxcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0YWdQYWlyXCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiwgc2xpZ2h0bHkgZG9tZWQgXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcImNhbkhpZGVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcImFuZCBkaXZpZGVkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjIxXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkZvbnRTaXplXCI6IFwiMTJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiSXRhbGljXCI6IFwiVHJ1ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJVbmRlcmxpbmVcIjogXCJzaW5nbGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiZnJhbWV3b3JrT3JpZ2luYWxUYWdJZFwiOiBcIjc3XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6aVwiOiBcIjx3OmkvPlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ3OnN6XCI6IFwiPHc6c3ogdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6dVwiOiBcIjx3OnUgdzp2YWw9XFxcInNpbmdsZVxcXCIvPlwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBcInRhZ1BhaXJEZWZpbml0aW9uSWRcIjogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGFnUGFpclwiXHJcbiAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgYnkgYXJjaGVzIGludG8gc3RpZmYgc2VjdGlvbnMuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMTZcIixcclxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRpb25PcmlnaW5cIjoge1xyXG4gICAgICAgICAgICAgICAgICBcImlzU3RydWN0dXJlQ29udGV4dE1hdGNoXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIlNlZ21lbnRJZGVudGl0eUhhc2hcIjogXCJDRmJLeFQrMHhQR3g3em55VFRUcHFpS05SVkU9XCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5CZWZvcmVBZGFwdGF0aW9uXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luU3lzdGVtXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwib3JpZ2luVHlwZVwiOiBcInNvdXJjZVwiLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsVHJhbnNsYXRpb25IYXNoXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW10sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMTdcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIxOFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjE5XCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW1xyXG4gICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHRcIjogXCJzLWEgZ2FuZGl0IGVsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpZFwiOiBcIjIyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBcIkJhY2tncm91bmRDb2xvclwiOiBcImJsdWVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJQYXJlbnRUYWdcIjogXCJ3OnJcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJUZXh0Q29sb3JcIjogXCJGRkZGRkZcIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwiZnJhbWV3b3JrT3JpZ2luYWxUYWdJZFwiOiBcIjgzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6Y29sb3JcIjogXCI8dzpjb2xvciB3OnZhbD1cXFwiRkZGRkZGXFxcIiB3OnRoZW1lQ29sb3I9XFxcImJhY2tncm91bmQxXFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6aGlnaGxpZ2h0XCI6IFwiPHc6aGlnaGxpZ2h0IHc6dmFsPVxcXCJibHVlXFxcIi8+XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICAgICAgICAgIFwidzpzekNzXCI6IFwiPHc6c3pDcyB3OnZhbD1cXFwiMjRcXFwiLz5cIlxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDExLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRhZ1BhaXJcIlxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiLlwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgXCJjb25maXJtYXRpb25MZXZlbFwiOiBcIkRyYWZ0XCIsXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMjBcIixcclxuICAgICAgICAgICAgICAgIFwidHJhbnNsYXRpb25PcmlnaW5cIjoge1xyXG4gICAgICAgICAgICAgICAgICBcImlzU3RydWN0dXJlQ29udGV4dE1hdGNoXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICBcIm1hdGNoUGVyY2VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIlNlZ21lbnRJZGVudGl0eUhhc2hcIjogXCI1M215L1lic0ZlT083b005WWpQVmIwN3JoNlk9XCJcclxuICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgXCJvcmlnaW5CZWZvcmVBZGFwdGF0aW9uXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICBcImlzU3RydWN0dXJlQ29udGV4dE1hdGNoXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWF0Y2hQZXJjZW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtZXRhZGF0YVwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBcIlNlZ21lbnRJZGVudGl0eUhhc2hcIjogXCI1M215L1lic0ZlT083b005WWpQVmIwN3JoNlk9XCJcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwib3JpZ2luQmVmb3JlQWRhcHRhdGlvblwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBcImlzU3RydWN0dXJlQ29udGV4dE1hdGNoXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJtYXRjaFBlcmNlbnRcIjogMCxcclxuICAgICAgICAgICAgICAgICAgICAgIFwibWV0YWRhdGFcIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luQmVmb3JlQWRhcHRhdGlvblwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5TeXN0ZW1cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luVHlwZVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbFRyYW5zbGF0aW9uSGFzaFwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0Q29udGV4dE1hdGNoTGV2ZWxcIjogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5TeXN0ZW1cIjogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBcIm9yaWdpblR5cGVcIjogXCJzb3VyY2VcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsVHJhbnNsYXRpb25IYXNoXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0Q29udGV4dE1hdGNoTGV2ZWxcIjogbnVsbFxyXG4gICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpblN5c3RlbVwiOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpblR5cGVcIjogXCJpbnRlcmFjdGl2ZVwiLFxyXG4gICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsVHJhbnNsYXRpb25IYXNoXCI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgIFwidGV4dENvbnRleHRNYXRjaExldmVsXCI6IG51bGxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW10sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMjFcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIyMlwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcImNoYXJhY3RlckNvdW50XCI6IDAsXHJcbiAgICAgICAgICAgICAgICBcImNoaWxkcmVuXCI6IFtdLFxyXG4gICAgICAgICAgICAgICAgXCJpc0xvY2tlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIFwic2VnbWVudE51bWJlclwiOiBcIjIzXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJzZWdtZW50XCIsXHJcbiAgICAgICAgICAgICAgICBcIndvcmRDb3VudFwiOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBcInRleHRcIjogXCIgXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiY2hhcmFjdGVyQ291bnRcIjogMCxcclxuICAgICAgICAgICAgICAgIFwiY2hpbGRyZW5cIjogW10sXHJcbiAgICAgICAgICAgICAgICBcImlzTG9ja2VkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgXCJzZWdtZW50TnVtYmVyXCI6IFwiMjRcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInNlZ21lbnRcIixcclxuICAgICAgICAgICAgICAgIFwid29yZENvdW50XCI6IDBcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwidGV4dFwiOiBcIiBcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInRleHRcIlxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJjaGFyYWN0ZXJDb3VudFwiOiAwLFxyXG4gICAgICAgICAgICAgICAgXCJjaGlsZHJlblwiOiBbXSxcclxuICAgICAgICAgICAgICAgIFwiaXNMb2NrZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBcInNlZ21lbnROdW1iZXJcIjogXCIyNVwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic2VnbWVudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ3b3JkQ291bnRcIjogMFxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgXCJpZFwiOiBcIjE5XCIsXHJcbiAgICAgICAgICAgIFwibWV0YWRhdGFcIjoge1xyXG4gICAgICAgICAgICAgIFwiRm9udFNpemVcIjogXCIxMlwiLFxyXG4gICAgICAgICAgICAgIFwiUGFyZW50VGFnXCI6IFwidzpyXCIsXHJcbiAgICAgICAgICAgICAgXCJTdGFydFRhZ1wiOiBcInc6clByXCIsXHJcbiAgICAgICAgICAgICAgXCJmcmFtZXdvcmtPcmlnaW5hbFRhZ0lkXCI6IFwiNDdcIixcclxuICAgICAgICAgICAgICBcInc6c3pcIjogXCI8dzpzeiB3OnZhbD1cXFwiMjRcXFwiLz5cIixcclxuICAgICAgICAgICAgICBcInc6c3pDc1wiOiBcIjx3OnN6Q3Mgdzp2YWw9XFxcIjI0XFxcIi8+XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXCJ0YWdQYWlyRGVmaW5pdGlvbklkXCI6IDEsXHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInRhZ1BhaXJcIlxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJ0eXBlXCI6IFwicGFyYWdyYXBoXCJcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIF07XHJcblxyXG4gIHJldHVybiBwYXJhZ3JhcGhzO1xyXG59O1xyXG5cclxucHJvdG8uc2ltcGxlVGFnUGFpciA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgXCJjYW5IaWRlXCI6IGZhbHNlLFxyXG4gICAgXCJjaGlsZHJlblwiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcInRleHRcIjogXCJldGNcIixcclxuICAgICAgICBcInR5cGVcIjogXCJ0ZXh0XCJcclxuICAgICAgfVxyXG4gICAgXSxcclxuICAgIFwiaWRcIjogXCIyXCIsXHJcbiAgICBcIm1ldGFkYXRhXCI6IHtcclxuICAgICAgXCJGb250U2l6ZVwiOiBcIjEyXCIsXHJcbiAgICAgIFwiUGFyZW50VGFnXCI6IFwidzpyXCIsXHJcbiAgICAgIFwiU3RhcnRUYWdcIjogXCJ3OnJQclwiLFxyXG4gICAgICBcIlRleHRDb2xvclwiOiBcIkZGMDAwMFwiLFxyXG4gICAgICBcImZyYW1ld29ya09yaWdpbmFsVGFnSWRcIjogXCI1XCIsXHJcbiAgICAgIFwidzpjb2xvclwiOiBcIjx3OmNvbG9yIHc6dmFsPVxcXCJGRjAwMDBcXFwiLz5cIixcclxuICAgICAgXCJ3OnN6XCI6IFwiPHc6c3ogdzp2YWw9XFxcIjI0XFxcIi8+XCIsXHJcbiAgICAgIFwidzpzekNzXCI6IFwiPHc6c3pDcyB3OnZhbD1cXFwiMjRcXFwiLz5cIlxyXG4gICAgfSxcclxuICAgIFwidGFnUGFpckRlZmluaXRpb25JZFwiOiAyLFxyXG4gICAgXCJ0eXBlXCI6IFwidGFnUGFpclwiXHJcbiAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2lkZUJ5U2lkZVBhcmFncmFwaFVuaXRzUmVuZGVyZXJGaXh0dXJlOyIsIi8qIEZpbGU6IENvbW1hbmRNYW5hZ2VyX3Rlc3QuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyByZXF1aXJlLCBkZXNjcmliZSwgaXQgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBDb21tYW5kTWFuYWdlciA9IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy9qcy91ZS9Db21tYW5kTWFuYWdlcicpO1xyXG5cclxudmFyIHNpbm9uID0gcmVxdWlyZSgnc2lub24nKTtcclxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XHJcblxyXG5kZXNjcmliZSgnQ29tbWFuZE1hbmFnZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGNvbW1hbmRlcjtcclxuXHJcbiAgdmFyIGNvbW1hbmRzID0ge1xyXG4gICAgc2luZ2xlOiB7XHJcbiAgICAgICd0ZXN0X2NvbW1hbmQnOiB7XHJcbiAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgbXVsdGlwbGU6IHtcclxuICAgICAgJ2ZpcnN0X3Rlc3RfY29tbWFuZCc6IHtcclxuICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgJ3NlY29uZF90ZXN0X2NvbW1hbmQnOiB7XHJcbiAgICAgICAgaGFuZGxlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbW1hbmRlciA9IG5ldyBDb21tYW5kTWFuYWdlcigpO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnY29uc3RydWN0b3InLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgnc2hvdWxkIGluc3RhbnRpYXRlIHRoZSBuZXcgY2xhc3MnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFzc2VydC5pbnN0YW5jZU9mKGNvbW1hbmRlciwgQ29tbWFuZE1hbmFnZXIsICdhbmQgY29tbWFuZGVyIHdpbGwgYmUgQ29tbWFuZE1hbmFnZXIgaW5zdGFuY2UnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgaGF2ZSBhIGRlZmF1bHQgXCJvcHRpb25zXCIgcHJvcGVydHknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFzc2VydC5wcm9wZXJ0eShjb21tYW5kZXIsICdvcHRpb25zJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGhhdmUgYSBkZWZhdWx0IFwiY29tbWFuZHNcIiBwcm9wZXJ0eScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYXNzZXJ0LnByb3BlcnR5KGNvbW1hbmRlciwgJ2NvbW1hbmRzJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQ29tbWFuZE1hbmFnZXIjbWV0aG9kcycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaXQoJ3Nob3VsZCBoYXZlIGEgXCJleGVjdXRlXCIgbWV0aG9kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFzc2VydC5pc0Z1bmN0aW9uKGNvbW1hbmRlci5leGVjdXRlLCAnQ29tbWFuZE1hbmFnZXIjZXhlY3V0ZSBleGlzdCcpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdzaG91bGQgaGF2ZSBhbiBcImFkZENvbW1hbmRzXCIgbWV0aG9kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFzc2VydC5pc0Z1bmN0aW9uKGNvbW1hbmRlci5hZGRDb21tYW5kcywgJycpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnQ29tbWFuZE1hbmFnZXIjYWRkQ29tbWFuZHMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgnc2hvdWxkIGR5bmFtaWNhbGx5IGFkZCBvbmUgc2luZ2xlIGNvbW1hbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNvbW1hbmRlci5hZGRDb21tYW5kcyhjb21tYW5kcy5zaW5nbGUpO1xyXG4gICAgICBhc3NlcnQuaXNGdW5jdGlvbihjb21tYW5kZXIuY29tbWFuZHNbJ3Rlc3RfY29tbWFuZCddLmhhbmRsZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIGR5bmFtaWNhbGx5IGFkZCBtdWx0aXBsZSBjb21tYW5kcycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgY29tbWFuZGVyLmFkZENvbW1hbmRzKGNvbW1hbmRzLm11bHRpcGxlKTtcclxuICAgICAgYXNzZXJ0LmlzRnVuY3Rpb24oY29tbWFuZGVyLmNvbW1hbmRzWydmaXJzdF90ZXN0X2NvbW1hbmQnXS5oYW5kbGUpO1xyXG4gICAgICBhc3NlcnQuaXNGdW5jdGlvbihjb21tYW5kZXIuY29tbWFuZHNbJ3NlY29uZF90ZXN0X2NvbW1hbmQnXS5oYW5kbGUpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdDb21tYW5kTWFuYWdlciNkZWxldGVDb21tYW5kcycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGl0KCdzaG91bGQgYmUgYWJsZSB0byBkZWxldGUgY29tbWFuZHMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNvbW1hbmRlci5hZGRDb21tYW5kcyhjb21tYW5kcy5tdWx0aXBsZSk7XHJcbiAgICAgIGNvbW1hbmRlci5kZWxldGVDb21tYW5kcygnZmlyc3RfdGVzdF9jb21tYW5kJywgJ3NlY29uZF90ZXN0X2NvbW1hbmQnKTtcclxuXHJcbiAgICAgIGFzc2VydC5pc1VuZGVmaW5lZChjb21tYW5kZXIuZXhlY3V0ZSgnZmlyc3RfdGVzdF9jb21tYW5kJyksICdmaXJzdF90ZXN0X2NvbW1hbmQgd2FzIG5vdCBleGVjdXRlZCcpO1xyXG4gICAgICBhc3NlcnQuaXNVbmRlZmluZWQoY29tbWFuZGVyLmV4ZWN1dGUoJ3NlY29uZF90ZXN0X2NvbW1hbmQnKSwgJ3NlY29uZF90ZXN0X2NvbW1hbmQgd2FzIG5vdCBleGVjdXRlZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBleGl0IHRoZSBleGVjdXRpb24gaWYgY29tbWFuZCBpcyBub3QgYXZhaWxhYmxlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBhc3NlcnQuaXNVbmRlZmluZWQoY29tbWFuZGVyLmV4ZWN1dGUoJ3Vua25vd25fdGVzdF9jb21tYW5kJyksICd1bmtub3duX3Rlc3RfY29tbWFuZCB3YXMgbm90IGV4ZWN1dGVkJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ0NvbW1hbmRNYW5hZ2VyI2V4ZWN1dGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgnc2hvdWxkIGJlIGFibGUgdG8gZXhlY3V0ZSBhdmFpbGFibGUgY29tbWFuZHMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNvbW1hbmRlci5hZGRDb21tYW5kcyhjb21tYW5kcy5tdWx0aXBsZSk7XHJcbiAgICAgIGFzc2VydC5pc1RydWUoY29tbWFuZGVyLmV4ZWN1dGUoJ2ZpcnN0X3Rlc3RfY29tbWFuZCcpLCAnZmlyc3RfdGVzdF9jb21tYW5kIHdhcyBleGVjdXRlZCcpO1xyXG4gICAgICBhc3NlcnQuaXNUcnVlKGNvbW1hbmRlci5leGVjdXRlKCdzZWNvbmRfdGVzdF9jb21tYW5kJyksICdzZWNvbmRfdGVzdF9jb21tYW5kIHdhcyBleGVjdXRlZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBleGl0IHRoZSBleGVjdXRpb24gaWYgY29tbWFuZCBpcyBub3QgYXZhaWxhYmxlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBhc3NlcnQuaXNVbmRlZmluZWQoY29tbWFuZGVyLmV4ZWN1dGUoJ3Vua25vd25fdGVzdF9jb21tYW5kJyksICd1bmtub3duX3Rlc3RfY29tbWFuZCB3YXMgbm90IGV4ZWN1dGVkJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7IiwiLyogRmlsZTogRGF0YVByb3ZpZGVyX3Rlc3QuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyByZXF1aXJlLCBkZXNjcmliZSwgaXQsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBEYXRhUHJvdmlkZXIgPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvRGF0YVByb3ZpZGVyJyk7XHJcbnZhciBNZWRpYXRvciA9IHJlcXVpcmUoJy4uLy4uL2Fzc2V0cy9qcy91ZS9NZWRpYXRvcicpO1xyXG52YXIgRGF0YVByb3ZpZGVyT2JqZWN0TW90aGVyID0gcmVxdWlyZSgnLi4vc3VwcG9ydC9EYXRhUHJvdmlkZXJPYmplY3RNb3RoZXInKTtcclxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvSGVscGVycycpLnN0cmluZ1RvSFRNTEVsZW1lbnQ7XHJcblxyXG52YXIgc2lub24gPSByZXF1aXJlKCdzaW5vbicpO1xyXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcclxuXHJcbmRlc2NyaWJlKCdEYXRhUHJvdmlkZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGRhdGFQcm92aWRlck9iamVjdE1vdGhlcjtcclxuICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgIGRhdGFQcm92aWRlck9iamVjdE1vdGhlciA9IG5ldyBEYXRhUHJvdmlkZXJPYmplY3RNb3RoZXIoKTtcclxuICAgIERhdGFQcm92aWRlci5pbml0KCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCd3aGVuIHJlY2VpdmVzIHRoZSBzZWdtZW50OmVuZC1lZGl0IG1lc3NhZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICBzaW5vbi5zdHViKERhdGFQcm92aWRlciwgJ3NhdmVTZWdtZW50Q2hhbmdlJyk7XHJcbiAgICAgIE1lZGlhdG9yLnB1Ymxpc2goJ3NlZ21lbnQ6c3RhcnQtZWRpdCcsIHtcclxuICAgICAgICBlbDogaCgnPGRpdiBjbGFzcz1cInNlZ21lbnRcIi8+JyksXHJcbiAgICAgICAgc2VnbWVudE51bWJlcjogJzEnLFxyXG4gICAgICAgIG90aGVyU2VnbWVudERhdGE6IHtcclxuICAgICAgICAgICdjb25maXJtYXRpb25sZXZlbCc6ICdkcmFmdCdcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgRGF0YVByb3ZpZGVyLnNhdmVTZWdtZW50Q2hhbmdlLnJlc3RvcmUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCd3aGVuIHRoZSBjb250ZW50IGhhcyBjaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpdCgnY2FsbHMgRGF0YVByb3ZpZGVyI3NhdmVTZWdtZW50Q2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIE1lZGlhdG9yLnB1Ymxpc2goJ3NlZ21lbnQ6ZW5kLWVkaXQnLCB7XHJcbiAgICAgICAgICBlbDogaCgnPGRpdiBjbGFzcz1cInNlZ21lbnRcIj5jb250ZW50IGhhcyBjaGFuZ2VkPC9kaXY+JyksXHJcbiAgICAgICAgICBzZWdtZW50TnVtYmVyOiAnMScsXHJcbiAgICAgICAgICBvdGhlclNlZ21lbnREYXRhOiB7XHJcbiAgICAgICAgICAgICdjb25maXJtYXRpb25sZXZlbCc6ICdkcmFmdCdcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYXNzZXJ0KERhdGFQcm92aWRlci5zYXZlU2VnbWVudENoYW5nZS5jYWxsZWQsICdEYXRhUHJvdmlkZXIjc2F2ZVNlZ21lbnRDaGFuZ2UgaGFzIGJlZW4gY2FsbGVkJyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ3doZW4gdGhlIHN0YXR1cyBoYXMgY2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaXQoJ2NhbGxzIERhdGFQcm92aWRlciNzYXZlU2VnbWVudENoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBNZWRpYXRvci5wdWJsaXNoKCdzZWdtZW50OmVuZC1lZGl0Jywge1xyXG4gICAgICAgICAgZWw6IGgoJzxkaXYgY2xhc3M9XCJzZWdtZW50XCIvPicpLFxyXG4gICAgICAgICAgc2VnbWVudE51bWJlcjogJzEnLFxyXG4gICAgICAgICAgb3RoZXJTZWdtZW50RGF0YToge1xyXG4gICAgICAgICAgICAnY29uZmlybWF0aW9ubGV2ZWwnOiAnbm8tbG9uZ2VyLWRyYWZ0J1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBhc3NlcnQoRGF0YVByb3ZpZGVyLnNhdmVTZWdtZW50Q2hhbmdlLmNhbGxlZCwgJ0RhdGFQcm92aWRlciNzYXZlU2VnbWVudENoYW5nZSBoYXMgYmVlbiBjYWxsZWQnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnd2hlbiB0aGUgY29udGVudCBhbmQgc3RhdHVzIGlzIHVuY2hhbmdlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaXQoJ2RvZXMgbm90IGNhbGwgRGF0YVByb3ZpZGVyI3NhdmVTZWdtZW50Q2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIE1lZGlhdG9yLnB1Ymxpc2goJ3NlZ21lbnQ6ZW5kLWVkaXQnLCB7XHJcbiAgICAgICAgICBlbDogaCgnPGRpdiBjbGFzcz1cInNlZ21lbnRcIi8+JyksXHJcbiAgICAgICAgICBzZWdtZW50TnVtYmVyOiAnMScsXHJcbiAgICAgICAgICBvdGhlclNlZ21lbnREYXRhOiB7XHJcbiAgICAgICAgICAgICdjb25maXJtYXRpb25sZXZlbCc6ICdkcmFmdCdcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgYXNzZXJ0LmlzRmFsc2UoRGF0YVByb3ZpZGVyLnNhdmVTZWdtZW50Q2hhbmdlLmNhbGxlZCwgJ0RhdGFQcm92aWRlciNzYXZlU2VnbWVudENoYW5nZSBoYXMgYmVlbiBjYWxsZWQnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiIsIi8qIEZpbGU6IFNlZ21lbnRDbGVhbnVwX3Rlc3QuanMgKi9cclxuLyogZ2xvYmFscyBkZXNjcmliZSwgYmVmb3JlRWFjaCwgaXQgKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgU2VnbWVudHNXYXRjaGVyID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2pzL3VlL1NlZ21lbnRzV2F0Y2hlcicpO1xyXG52YXIgU2VnbWVudENsZWFudXAgPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvU2VnbWVudENsZWFudXAnKTtcclxudmFyIE5vZGVXYWxrZXIgPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvc2VsZWN0aW9uL05vZGVXYWxrZXInKTtcclxuXHJcbnZhciBTZWdtZW50Q2xlYW51cEZpeHR1cmUgPSByZXF1aXJlKCcuLi9zdXBwb3J0L1NlZ21lbnRDbGVhbnVwRml4dHVyZScpO1xyXG5cclxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XHJcblxyXG5kZXNjcmliZSgnU2VnbWVudENsZWFudXAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNlZ21lbnRGaXh0dXJlID0gbmV3IFNlZ21lbnRDbGVhbnVwRml4dHVyZSgpLFxyXG4gICAgICBzZWdtZW50TnVtYmVyID0gJzEnLFxyXG4gICAgICBzZWdtZW50Q2xlYW51cCxcclxuICAgICAgdGFyZ2V0Q29udGVudCxcclxuICAgICAgd2Fsa2VyO1xyXG5cclxuICBmdW5jdGlvbiBjbGVhbnVwU2VnbWVudCgpIHtcclxuICAgIHNlZ21lbnRDbGVhbnVwID0gbmV3IFNlZ21lbnRDbGVhbnVwKHNlZ21lbnROdW1iZXIpO1xyXG4gICAgc2VnbWVudENsZWFudXAuY2xlYW5TdHJ1Y3R1cmUoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldHVwVGFyZ2V0Q29udGVudCh0YXJnZXRDb250ZW50KSB7XHJcbiAgICBTZWdtZW50c1dhdGNoZXIud2F0Y2hTZWdtZW50KHNlZ21lbnROdW1iZXIpXHJcbiAgICAgIC5zZXRUYXJnZXQodGFyZ2V0Q29udGVudCk7XHJcbiAgfVxyXG5cclxuICBkZXNjcmliZSgnI2NsZWFuU3RydWN0dXJlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgZGVzY3JpYmUoJ3doZW4gY29udGVudCBpcyBiZWZvcmUgZGl2LmlubGluZS1jb250ZW50JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0YXJnZXRDb250ZW50ID0gc2VnbWVudEZpeHR1cmUuY29udGVudEJlZm9yZUlubGluZUNvbnRlbnQoKTtcclxuICAgICAgICBzZXR1cFRhcmdldENvbnRlbnQodGFyZ2V0Q29udGVudCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ21vdmVzIGNvbnRlbnQgaW5zaWRlIGRpdi5pbmxpbmUtY29udGVudCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjbGVhbnVwU2VnbWVudCgpO1xyXG5cclxuICAgICAgICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcih0YXJnZXRDb250ZW50LmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIGFzc2VydC5pc0ZhbHNlKHdhbGtlci5pc1RleHROb2RlKCksICd0ZXh0IG5vZGUgaGFzIGJlZW4gbW92ZWQnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnd2hlbiBjb250ZW50IGlzIGFmdGVyIGRpdi5pbmxpbmUtY29udGVudCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGFyZ2V0Q29udGVudCA9IHNlZ21lbnRGaXh0dXJlLmNvbnRlbnRBZnRlcklubGluZUNvbnRlbnQoKTtcclxuICAgICAgICBzZXR1cFRhcmdldENvbnRlbnQodGFyZ2V0Q29udGVudCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ21vdmVzIGNvbnRlbnQgaW5zaWRlIGRpdi5pbmxpbmUtY29udGVudCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjbGVhbnVwU2VnbWVudCgpO1xyXG5cclxuICAgICAgICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcih0YXJnZXRDb250ZW50Lmxhc3RDaGlsZCk7XHJcbiAgICAgICAgYXNzZXJ0LmlzRmFsc2Uod2Fsa2VyLmlzVGV4dE5vZGUoKSwgJ3RleHQgbm9kZSBoYXMgYmVlbiBtb3ZlZCcpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCd3aGVuIGRpdi5pbmxpbmUtY29udGVudCBpcyBtaXNzaW5nIGZyb20gc2VnbWVudCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGFyZ2V0Q29udGVudCA9IHNlZ21lbnRGaXh0dXJlLnNlZ21lbnRXaXRoTm9JbmxpbmVDb250ZW50KCk7XHJcbiAgICAgICAgc2V0dXBUYXJnZXRDb250ZW50KHRhcmdldENvbnRlbnQpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdjcmVhdGVzIHRoZSBpbmxpbmUgY29udGVudCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjbGVhbnVwU2VnbWVudCgpO1xyXG5cclxuICAgICAgICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcih0YXJnZXRDb250ZW50LmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgIGFzc2VydC5pc1RydWUod2Fsa2VyLmlzSW5saW5lQ29udGVudCgpLCAnaW5saW5lIGNvbnRlbnQgaGFzIGJlZW4gY3JlYXRlZCcpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCd3aGVuIHRleHQgY29udGFpbnMgcGxhY2Vob2xkZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRhcmdldENvbnRlbnQgPSBzZWdtZW50Rml4dHVyZS5wbGFjZWhvbGRlckluc2lkZVRleHQoKTtcclxuICAgICAgICBzZXR1cFRhcmdldENvbnRlbnQodGFyZ2V0Q29udGVudCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ3NwbGl0cyB0aGUgdGV4dCBub2RlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwbGFjZWhvbGRlcixcclxuICAgICAgICAgICAgd2Fsa2VyLFxyXG4gICAgICAgICAgICB0ZXh0QmVmb3JlLFxyXG4gICAgICAgICAgICB0ZXh0QWZ0ZXI7XHJcblxyXG4gICAgICAgIGNsZWFudXBTZWdtZW50KCk7XHJcblxyXG4gICAgICAgIHBsYWNlaG9sZGVyID0gdGFyZ2V0Q29udGVudC5xdWVyeVNlbGVjdG9yKCcudWUtdGFnLXdyYXBwZXInKTtcclxuICAgICAgICB3YWxrZXIgPSBuZXcgTm9kZVdhbGtlcihwbGFjZWhvbGRlcik7XHJcbiAgICAgICAgdGV4dEJlZm9yZSA9IHdhbGtlci5wcmV2KCk7XHJcbiAgICAgICAgdGV4dEFmdGVyID0gd2Fsa2VyLm5leHQoKTtcclxuXHJcbiAgICAgICAgYXNzZXJ0KHRleHRCZWZvcmUuaXNUZXh0KCksICd0ZXh0IHdhcyBzcGxpdCBiZWZvcmUnKTtcclxuICAgICAgICBhc3NlcnQodGV4dEFmdGVyLmlzVGV4dCgpLCAndGV4dCB3YXMgc3BsaXQgYWZ0ZXInKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbn0pO1xyXG4iLCIvKiBGaWxlOiBTZWdtZW50V2F0Y2hlcl90ZXN0LmpzICovXHJcbi8qIGdsb2JhbHMgZGVzY3JpYmUsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCwgaXQgKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIGggPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvSGVscGVycycpLnN0cmluZ1RvSFRNTEVsZW1lbnQ7XHJcbnZhciBTZWdtZW50c1dhdGNoZXIgPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvU2VnbWVudHNXYXRjaGVyJyk7XHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xyXG5cclxuZGVzY3JpYmUoJ1NlZ21lbnRXYXRjaGVyJywgZnVuY3Rpb24gKCkge1xyXG4gIHZhciB1bmRlZmluZWRUYXJnZXRTZWdtZW50TnVtYmVyID0gJzEwJyxcclxuICAgICAgc291cmNlRWwgPSBoKCc8ZGl2IGNsYXNzPVwidWUtc2VnbWVudFwiLz4nKSxcclxuICAgICAgc3RhdHVzRWwgPSBoKCc8ZGl2IGNsYXNzPVwidWUtc3RhdHVzXCIvPicpLFxyXG4gICAgICB0YXJnZXRFbCA9IGgoJzxkaXYgY2xhc3M9XCJ1ZS1zZWdtZW50XCIvPicpO1xyXG5cclxuICBkZXNjcmliZSgnZ2V0VGFyZ2V0RWwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcmV0dXJuZWRUYXJnZXRFbCxcclxuICAgICAgICBzZWdtZW50TnVtYmVyID0gJzEnO1xyXG5cclxuICAgIGl0KCdyZXR1cm5zIG51bGwgd2hlbiB0aGUgc2VnbWVudCBudW1iZXIgaXMgbm90IHdhdGNoZWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICByZXR1cm5lZFRhcmdldEVsID0gU2VnbWVudHNXYXRjaGVyLmdldFRhcmdldEVsKHVuZGVmaW5lZFRhcmdldFNlZ21lbnROdW1iZXIpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzTnVsbChyZXR1cm5lZFRhcmdldEVsLCAndGFyZ2V0IHNlZ21lbnQgaGFzIG5vdCBiZWVuIGZvdW5kJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnd2hlbiB0aGUgc2VnbWVudCBpcyB3YXRjaGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBTZWdtZW50c1dhdGNoZXIud2F0Y2hTZWdtZW50KHNlZ21lbnROdW1iZXIpXHJcbiAgICAgICAgICAuc2V0U291cmNlKHNvdXJjZUVsKVxyXG4gICAgICAgICAgLnNldFN0YXR1cyhzdGF0dXNFbClcclxuICAgICAgICAgIC5zZXRUYXJnZXQodGFyZ2V0RWwpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdyZXR1cm5zIHRoZSB0YXJnZXRFbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm5lZFRhcmdldEVsID0gU2VnbWVudHNXYXRjaGVyLmdldFRhcmdldEVsKHNlZ21lbnROdW1iZXIpO1xyXG5cclxuICAgICAgICBhc3NlcnQuZXF1YWwodGFyZ2V0RWwsIHJldHVybmVkVGFyZ2V0RWwsICd0YXJnZXQgc2VnbWVudCBoYXMgYmVlbiByZXR1cm5lZCcpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTsiLCIvKiBGaWxlOiBTaWRlQnlTaWRlUGFyYWdyYXBoVW5pdHNSZW5kZXJlcl90ZXN0LmpzICovXHJcbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcbi8qIGdsb2JhbHMgcmVxdWlyZSwgZGVzY3JpYmUsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCwgaXQgKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcclxuXHJcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvY29uZmlnJyk7XHJcblxyXG52YXIgRGF0YVByb3ZpZGVyT2JqZWN0TW90aGVyID0gcmVxdWlyZSgnLi4vc3VwcG9ydC9EYXRhUHJvdmlkZXJPYmplY3RNb3RoZXInKTtcclxudmFyIFNpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2pzL3VlL1NpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyJyk7XHJcbnZhciBTaWRlQnlTaWRlUGFyYWdyYXBoVW5pdHNSZW5kZXJlckZpeHR1cmUgPSByZXF1aXJlKCcuLi9zdXBwb3J0L1NpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyRml4dHVyZScpO1xyXG5cclxuZGVzY3JpYmUoJ1NpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyICcsIGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcmVuZGVyZXIsXHJcbiAgICAgIGZpeHR1cmUsXHJcbiAgICAgIGRhdGFQcm92aWRlck9iamVjdE1vdGhlcixcclxuICAgICAgdWVEb2N1bWVudCxcclxuICAgICAgcGFyYWdyYXBocztcclxuXHJcbiAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICBmaXh0dXJlID0gbmV3IFNpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyRml4dHVyZSgpO1xyXG4gICAgZGF0YVByb3ZpZGVyT2JqZWN0TW90aGVyID0gbmV3IERhdGFQcm92aWRlck9iamVjdE1vdGhlcigpO1xyXG5cclxuICAgIHVlRG9jdW1lbnQgPSBmaXh0dXJlLmRlZmF1bHREb2N1bWVudFNhbXBsZSgpO1xyXG4gICAgcGFyYWdyYXBocyA9IGZpeHR1cmUuZGVmYXVsdFBhcmFncmFwaHNTYW1wbGUoKTtcclxuXHJcbiAgICBkYXRhUHJvdmlkZXJPYmplY3RNb3RoZXIuaGFja0luaXRpYWxpemF0aW9uKFxyXG4gICAgICBwYXJhZ3JhcGhzLCB1ZURvY3VtZW50KTtcclxuXHJcbiAgICBmaXh0dXJlID0gbmV3IFNpZGVCeVNpZGVQYXJhZ3JhcGhVbml0c1JlbmRlcmVyRml4dHVyZSgpO1xyXG4gICAgcmVuZGVyZXIgPSBuZXcgU2lkZUJ5U2lkZVBhcmFncmFwaFVuaXRzUmVuZGVyZXIoXHJcbiAgICAgIHBhcmFncmFwaHMsXHJcbiAgICAgIHVlRG9jdW1lbnQpO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgncmVuZGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaXQoJ2dlbmVyYXRlcyB0aGUgZWRpdG9yIGNvbnRlbnQgaW4gc291cmNlIGFuZCB0YXJnZXQgY29sdW1ucycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHNvdXJjZUVkaXRhYmxlQ29sdW1uLFxyXG4gICAgICAgICAgdGFyZ2V0RWRpdGFibGVDb2x1bW47XHJcblxyXG4gICAgICByZW5kZXJlci5yZW5kZXIoKTtcclxuXHJcbiAgICAgIHNvdXJjZUVkaXRhYmxlQ29sdW1uID0gcmVuZGVyZXIuc291cmNlRWRpdGFibGVDb2x1bW47XHJcbiAgICAgIHRhcmdldEVkaXRhYmxlQ29sdW1uID0gcmVuZGVyZXIudGFyZ2V0RWRpdGFibGVDb2x1bW47XHJcblxyXG4gICAgICBhc3NlcnQuaXNOb3ROdWxsKHNvdXJjZUVkaXRhYmxlQ29sdW1uLCAnc291cmNlRWRpdGFibGVDb2x1bW4gaXMgYXNzaWduZWQgdG8nKTtcclxuICAgICAgYXNzZXJ0LmlzTm90TnVsbCh0YXJnZXRFZGl0YWJsZUNvbHVtbiwgJ3RhcmdldEVkaXRhYmxlQ29sdW1uIGlzIGFzc2lnbmVkIHRvJyk7XHJcblxyXG4gICAgICBhc3NlcnQuaW5zdGFuY2VPZihzb3VyY2VFZGl0YWJsZUNvbHVtbiwgalF1ZXJ5LCAnc291cmNlRWRpdGFibGVDb2x1bW4gaXMganF1ZXJ5IG9iamVjdCcpO1xyXG4gICAgICBhc3NlcnQuaW5zdGFuY2VPZih0YXJnZXRFZGl0YWJsZUNvbHVtbiwgalF1ZXJ5LCAndGFyZ2V0RWRpdGFibGVDb2x1bW4gaXMganF1ZXJ5IG9iamVjdCcpO1xyXG4gICAgfSk7XHJcblxyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnI19yZW5kZXJUYWdQYWlyJywgZnVuY3Rpb24gKCl7XHJcbiAgICBpdCgncmVuZGVycyB0aGUgZWxlbWVudHMgdGhhdCBmb3JtIGEgdGFnJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdGFnUGFpciA9IGZpeHR1cmUuc2ltcGxlVGFnUGFpcigpLFxyXG4gICAgICAgICAgdGFnUGFpclJlbmRlcjtcclxuXHJcbiAgICAgIHRhZ1BhaXJSZW5kZXIgPSByZW5kZXJlci5fcmVuZGVyVGFnUGFpcih0YWdQYWlyKTtcclxuXHJcbiAgICAgIGFzc2VydC5pc05vdE51bGwodGFnUGFpclJlbmRlcik7XHJcbiAgICAgIGFzc2VydC5sZW5ndGhPZih0YWdQYWlyUmVuZGVyLCAzLCAnc3RhcnQtdGFnLCBjb250ZW50LCBlbmQtdGFnIGFyZSByZW5kZXJlZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3JlbmRlcnMgdGhlIGVsZW1lbnRzIGFzIGpRdWVyeSBvYmplY3RzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdGFnUGFpciA9IGZpeHR1cmUuc2ltcGxlVGFnUGFpcigpLFxyXG4gICAgICAgICAgdGFnUGFpclJlbmRlcjtcclxuXHJcbiAgICAgIHRhZ1BhaXJSZW5kZXIgPSByZW5kZXJlci5fcmVuZGVyVGFnUGFpcih0YWdQYWlyKTtcclxuXHJcbiAgICAgIGFzc2VydC5pbnN0YW5jZU9mKHRhZ1BhaXJSZW5kZXJbMF0sIGpRdWVyeSwgJ3N0YXJ0LXRhZyBpcyByZW5kZXJlZCBhcyBhIGpRdWVyeSBvYmplY3QnKTtcclxuICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YodGFnUGFpclJlbmRlclsxXSwgalF1ZXJ5LCAnc3RhcnQtdGFnIGlzIHJlbmRlcmVkIGFzIGEgalF1ZXJ5IG9iamVjdCcpO1xyXG4gICAgICBhc3NlcnQuaW5zdGFuY2VPZih0YWdQYWlyUmVuZGVyWzJdLCBqUXVlcnksICdzdGFydC10YWcgaXMgcmVuZGVyZWQgYXMgYSBqUXVlcnkgb2JqZWN0Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnYWRkcyB0aGUgY2FuSGlkZSBhcyBhIGRhdGEgYXR0cmlidXRlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdGFnUGFpciA9IGZpeHR1cmUuc2ltcGxlVGFnUGFpcigpLFxyXG4gICAgICAgICAgdGFnUGFpclJlbmRlcixcclxuICAgICAgICAgIHN0YXJ0VGFnLCBzdGFydFRhZ0VsLFxyXG4gICAgICAgICAgZW5kVGFnLCBlbmRUYWdFbDtcclxuXHJcbiAgICAgIHRhZ1BhaXJSZW5kZXIgPSByZW5kZXJlci5fcmVuZGVyVGFnUGFpcih0YWdQYWlyKTtcclxuXHJcbiAgICAgIHN0YXJ0VGFnID0gdGFnUGFpclJlbmRlclswXTtcclxuICAgICAgc3RhcnRUYWdFbCA9IHN0YXJ0VGFnWzBdO1xyXG4gICAgICBlbmRUYWcgPSB0YWdQYWlyUmVuZGVyWzJdO1xyXG4gICAgICBlbmRUYWdFbCA9IGVuZFRhZ1swXTtcclxuXHJcbiAgICAgIGFzc2VydC5lcXVhbChzdGFydFRhZ0VsLmRhdGFzZXQuY2FuSGlkZSwgJ2ZhbHNlJywgJ3N0YXJ0VGFnIGhhcyBjYW5IaWRlJyk7XHJcbiAgICAgIGFzc2VydC5lcXVhbChlbmRUYWdFbC5kYXRhc2V0LmNhbkhpZGUsICdmYWxzZScsICdlbmRUYWcgaGFzIGNhbkhpZGUnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCd3aGVuIGNhbkhpZGVJc1RydWUgYW5kIHRhZyBmb3JtYXR0aW5nIGlzIGhpZGRlbiBieSBkZWZhdWx0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdGFnUGFpcixcclxuICAgICAgICAgIHRhZ1BhaXJSZW5kZXIsXHJcbiAgICAgICAgICBzdGFydFRhZywgc3RhcnRUYWdFbCxcclxuICAgICAgICAgIGVuZFRhZywgZW5kVGFnRWw7XHJcblxyXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25maWcudGFnRGlzcGxheUNvbnRleHQuc2hvd0Zvcm1hdHRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0YWdQYWlyID0gZml4dHVyZS5zaW1wbGVUYWdQYWlyKCk7XHJcbiAgICAgICAgdGFnUGFpci5jYW5IaWRlID0gdHJ1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRhZ1BhaXIuY2FuSGlkZSA9IGZhbHNlO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdhZGRzIC5oaWRlIGFzIGEgQ1NTIGNsYXNzJywgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0YWdQYWlyUmVuZGVyID0gcmVuZGVyZXIuX3JlbmRlclRhZ1BhaXIodGFnUGFpcik7XHJcblxyXG4gICAgICAgIHN0YXJ0VGFnID0gdGFnUGFpclJlbmRlclswXTtcclxuICAgICAgICBzdGFydFRhZ0VsID0gc3RhcnRUYWdbMF07XHJcbiAgICAgICAgZW5kVGFnID0gdGFnUGFpclJlbmRlclsyXTtcclxuICAgICAgICBlbmRUYWdFbCA9IGVuZFRhZ1swXTtcclxuXHJcbiAgICAgICAgYXNzZXJ0LmlzVHJ1ZShzdGFydFRhZ0VsLmNsYXNzTGlzdC5jb250YWlucygnaGlkZScpLCAnc3RhcnRUYWcgaGFzIENTUyBjbGFzcyBoaWRlJyk7XHJcbiAgICAgICAgYXNzZXJ0LmlzVHJ1ZShlbmRUYWdFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2hpZGUnKSwgJ2VuZFRhZyBoYXMgQ1NTIGNsYXNzIGhpZGUnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnd2hlbiBjYW5IaWRlSXNUcnVlIGFuZCB0YWcgZm9ybWF0dGluZyBpcyBub3QgaGlkZGVuIGJ5IGRlZmF1bHQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB0YWdQYWlyLFxyXG4gICAgICAgICAgdGFnUGFpclJlbmRlcixcclxuICAgICAgICAgIHN0YXJ0VGFnLCBzdGFydFRhZ0VsLFxyXG4gICAgICAgICAgZW5kVGFnLCBlbmRUYWdFbDtcclxuXHJcbiAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbmZpZy50YWdEaXNwbGF5Q29udGV4dC5zaG93Rm9ybWF0dGluZyA9IHRydWU7XHJcbiAgICAgICAgdGFnUGFpciA9IGZpeHR1cmUuc2ltcGxlVGFnUGFpcigpO1xyXG4gICAgICAgIHRhZ1BhaXIuY2FuSGlkZSA9IHRydWU7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0YWdQYWlyLmNhbkhpZGUgPSBmYWxzZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnZG9lcyBub3QgYWRkIC5oaWRlIGFzIGEgQ1NTIGNsYXNzJywgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgICB0YWdQYWlyUmVuZGVyID0gcmVuZGVyZXIuX3JlbmRlclRhZ1BhaXIodGFnUGFpcik7XHJcblxyXG4gICAgICAgIHN0YXJ0VGFnID0gdGFnUGFpclJlbmRlclswXTtcclxuICAgICAgICBzdGFydFRhZ0VsID0gc3RhcnRUYWdbMF07XHJcbiAgICAgICAgZW5kVGFnID0gdGFnUGFpclJlbmRlclsyXTtcclxuICAgICAgICBlbmRUYWdFbCA9IGVuZFRhZ1swXTtcclxuXHJcbiAgICAgICAgYXNzZXJ0LmlzRmFsc2Uoc3RhcnRUYWdFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2hpZGUnKSwgJ3N0YXJ0VGFnIGhhcyBubyBDU1MgY2xhc3MgaGlkZScpO1xyXG4gICAgICAgIGFzc2VydC5pc0ZhbHNlKGVuZFRhZ0VsLmNsYXNzTGlzdC5jb250YWlucygnaGlkZScpLCAnZW5kVGFnIGhhcyBubyBDU1MgY2xhc3MgaGlkZScpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTsiLCIvKiBGaWxlOiBUbXBsX3Rlc3QuanMgKi9cclxuLyogZ2xvYmFscyBkZXNjcmliZSwgYmVmb3JlRWFjaCwgaXQqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBUbXBsID0gcmVxdWlyZSgnLi4vLi4vYXNzZXRzL2pzL3VlL1RtcGwnKTtcclxudmFyIE5vZGVXYWxrZXIgPSByZXF1aXJlKCcuLi8uLi9hc3NldHMvanMvdWUvc2VsZWN0aW9uL05vZGVXYWxrZXInKTtcclxuXHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xyXG5cclxuZGVzY3JpYmUoJ1RtcGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgZGVzY3JpYmUoJyNidWxkU2VnbWVudElubGluZUNvbnRlbnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaW5saW5lQ29udGVudCxcclxuICAgICAgICBub2RlV2Fsa2VyO1xyXG5cclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBpbmxpbmVDb250ZW50ID0gVG1wbC5idWlsZFNlZ21lbnRJbmxpbmVDb250ZW50KCk7XHJcbiAgICAgIG5vZGVXYWxrZXIgPSBuZXcgTm9kZVdhbGtlcihpbmxpbmVDb250ZW50KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdidWlsZHMgdGhlIGlubGluZSBjb250ZW50IGZvciBhIHNlZ21lbnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFzc2VydC5pc1RydWUobm9kZVdhbGtlci5pc0lubGluZUNvbnRlbnQoKSwgJ2lubGluZSBjb250ZW50IGhhcyBiZWVuIGJ1aWx0Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnYWRkcyBhIHp3bmogY2hhcmFjdGVyIGFzIHRoZSBmaXJzdCBjaGlsZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgbm9kZVdhbGtlciA9IG5vZGVXYWxrZXIuZmlyc3RDaGlsZCgpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzVHJ1ZShub2RlV2Fsa2VyLmlzSW52aXNpYmxlQ2hhcigpLCAnaW52aXNpYmxlIGNoYXJhY3RlciB3YXMgYWRkZWQgdG8gdGhlIHN0cnVjdHVyZScpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pOyIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xyXG52YXIgc2lub24gPSByZXF1aXJlKCdzaW5vbicpO1xyXG5cclxudmFyIEtleWJvYXJkQmluZGluZ3MgPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUvS2V5Ym9hcmRCaW5kaW5ncycpO1xyXG52YXIgU2VnbWVudHNXYXRjaGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vYXNzZXRzL2pzL3VlL1NlZ21lbnRzV2F0Y2hlcicpO1xyXG52YXIgU2hpZnRFbnRlckhhbmRsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUva2V5Ym9hcmQvU2hpZnRFbnRlckhhbmRsZXInKTtcclxuXHJcbnZhciBGYWtlRXZlbnQgPSByZXF1aXJlKCcuLi8uLi9zdXBwb3J0L0Zha2VFdmVudCcpO1xyXG52YXIgU2hpZnRFbnRlckhhbmRsZXJGaXh0dXJlID0gcmVxdWlyZSgnLi4vLi4vc3VwcG9ydC9TaGlmdEVudGVySGFuZGxlckZpeHR1cmUnKTtcclxudmFyIFNlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXIgPSByZXF1aXJlKCcuLi8uLi9zdXBwb3J0L1NlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXInKTtcclxudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9zZWxlY3Rpb24nKTtcclxuXHJcbmRlc2NyaWJlKCdLZXlib2FyZDogU2hpZnRFbnRlckhhbmRsZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgdmFyIGZha2VFdmVudCxcclxuICAgICAgaGFuZGxlLFxyXG4gICAgICBrZXlzID0gS2V5Ym9hcmRCaW5kaW5ncy5wcm90b3R5cGUsXHJcbiAgICAgIHNlbGVjdGlvbk9iamVjdE1vdGhlcixcclxuICAgICAgc2VsZWN0aW9uQ29udGV4dCxcclxuICAgICAgZml4dHVyZSA9IG5ldyBTaGlmdEVudGVySGFuZGxlckZpeHR1cmUoKSxcclxuICAgICAgc2FtcGxlO1xyXG5cclxuICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgIGhhbmRsZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICBuZXcgU2hpZnRFbnRlckhhbmRsZXIoZXYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBzZWxlY3Rpb25PYmplY3RNb3RoZXIgPSBuZXcgU2VsZWN0aW9uQ29udGV4dE9iamVjdE1vdGhlcigpO1xyXG4gICAgc2VsZWN0aW9uQ29udGV4dCA9IHNlbGVjdGlvbk9iamVjdE1vdGhlci5zdHViU2VsZWN0aW9uQ29udGV4dCgpO1xyXG5cclxuICAgIHNpbm9uLnN0dWIoU2VnbWVudHNXYXRjaGVyLCAncmVzaXplJyk7XHJcbiAgfSk7XHJcblxyXG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICBzZWxlY3Rpb25PYmplY3RNb3RoZXIucmVzdG9yZVNlbGVjdGlvbkNvbnRleHQoKTtcclxuICAgIFNlZ21lbnRzV2F0Y2hlci5yZXNpemUucmVzdG9yZSgpO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnd2hlbiB0aGUgZXhwZWN0ZWQgc2hpZnQrZW50ZXIgY29tYmluYXRpb24gd2FzIHByZXNzZWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gYnJlYWtJc01vdmVkV2l0aGluSW5saW5lQ29udGVudEJlZm9yZVRleHQgKCkge1xyXG4gICAgICB2YXIgYnJJc0luc2lkZUlubGluZUNvbnRlbnQsXHJcbiAgICAgICAgICBpbmxpbmVDb250ZW50ID0gc2FtcGxlLmNoaWxkTm9kZXNbMV0sXHJcbiAgICAgICAgICBub2RlV2Fsa2VyID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKGlubGluZUNvbnRlbnQuZmlyc3RDaGlsZCk7XHJcblxyXG4gICAgICBicklzSW5zaWRlSW5saW5lQ29udGVudCA9IG5vZGVXYWxrZXIuaXNFbGVtZW50KCdicicpO1xyXG5cclxuICAgICAgcmV0dXJuIGJySXNJbnNpZGVJbmxpbmVDb250ZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBmYWtlRXZlbnQgPSBuZXcgRmFrZUV2ZW50KCk7XHJcbiAgICAgIGZha2VFdmVudC5zZXRTaGlmdEtleSh0cnVlKTtcclxuICAgICAgZmFrZUV2ZW50LnNldEtleUNvZGUoa2V5cy5rZXlFbnRlcik7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdDaHJvbWUgZ2VuZXJhdGVzIGEgPGJyPiBhdCB0aGUgaW52aXNpYmxlIGNoYXJhY3RlciBwb3NpdGlvbiBpbnNpZGUgdGhlIHVlLXNlZ21lbnQgY29udGFpbmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzYW1wbGUgPSBmaXh0dXJlLmJyZWFrQXRTZWdtZW50U3RhcnRTYW1wbGUoKTtcclxuICAgICAgICBzZWxlY3Rpb25Db250ZXh0LmZvY3VzTm9kZSA9IHNhbXBsZS5maXJzdENoaWxkO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ21vdmVzIHRoZSBzZWdtZW50IHN0YXJ0IDxicj4gaW5zaWRlIGlubGluZSBjb250ZW50IGNvbnRhaW5lciB0byBhbGxvdyBpdCB0byBiZSBwcm9jZXNzZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaGFuZGxlKGZha2VFdmVudCk7XHJcblxyXG4gICAgICAgIGFzc2VydC5pc1RydWUoYnJlYWtJc01vdmVkV2l0aGluSW5saW5lQ29udGVudEJlZm9yZVRleHQoKSwgJzxicj4gaXMgbW92ZWQgdG8gdGhlIHByb3BlciBjb250YWluZXInKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ3doZW4gQ2hyb21lIGluc2VydHMgY2FycmlhZ2UgcmV0dXJuIGluc2lkZSBzcGFuIHVlLXRhZycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaXQoJ2NvbnZlcnRzIHRoZSBcXG4gaW5zaWRlIHN0YXJ0IHRhZyB0byA8YnI+IGFuZCBtb3ZlcyBpdCBhZnRlciB0aGUgdGFnLXdyYXBwZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gQXJyYW5nZVxyXG4gICAgICAgIHNhbXBsZSA9IGZpeHR1cmUubmV3TGluZUluc2lkZVN0YXJ0VGFnV3JhcHBlclNhbXBsZSgpO1xyXG4gICAgICAgIHNlbGVjdGlvbkNvbnRleHQuZm9jdXNOb2RlID0gc2FtcGxlLmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgICAgIC8vIEFjdFxyXG4gICAgICAgIGhhbmRsZShmYWtlRXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBBc3NlcnRcclxuICAgICAgICBhc3NlcnQuaXNUcnVlKGJyZWFrSXNBZGRlZFRvSW5saW5lQ29udGVudCgpLCAnPGJyPiBpcyBtb3ZlZCB0byB0aGUgcHJvcGVyIGNvbnRhaW5lcicpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdjb252ZXJ0cyB0aGUgXFxuIGluc2lkZSBlbmQgdGFnIHRvIDxicj4gYW5kIG1vdmVzIGl0IGFmdGVyIHRoZSB0YWctd3JhcHBlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBBcnJhbmdlXHJcbiAgICAgICAgc2FtcGxlID0gZml4dHVyZS5uZXdMaW5lSW5zaWRlRW5kVGFnV3JhcHBlclNhbXBsZSgpO1xyXG4gICAgICAgIHNlbGVjdGlvbkNvbnRleHQuZm9jdXNOb2RlID0gc2FtcGxlLmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgICAgIC8vIEFjdFxyXG4gICAgICAgIGhhbmRsZShmYWtlRXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBBc3NlcnRcclxuICAgICAgICBhc3NlcnQuaXNUcnVlKGJyZWFrSXNBZGRlZFRvSW5saW5lQ29udGVudCgpLCAnPGJyPiBpcyBtb3ZlZCB0byB0aGUgcHJvcGVyIGNvbnRhaW5lcicpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGJyZWFrSXNBZGRlZFRvSW5saW5lQ29udGVudCgpe1xyXG4gICAgICAgIHZhciBub2RlV2Fsa2VyPSAgbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKHNhbXBsZSk7XHJcbiAgICAgICAgdmFyIHByb2Nlc3NpbmdRdWV1ZSA9IFtub2RlV2Fsa2VyXTtcclxuICAgICAgICB2YXIgYnJlYWtGb3VuZEluc2lkZUlubGluZUNvbnRlbnQ7XHJcblxyXG4gICAgICAgIHdoaWxlKHByb2Nlc3NpbmdRdWV1ZS5sZW5ndGggPiAwKXtcclxuICAgICAgICAgIG5vZGVXYWxrZXIgPSBwcm9jZXNzaW5nUXVldWUucG9wKCk7XHJcblxyXG4gICAgICAgICAgaWYoIW5vZGVXYWxrZXIubmV4dCgpLmlzTnVsbCgpKXtcclxuICAgICAgICAgICAgcHJvY2Vzc2luZ1F1ZXVlLnB1c2gobm9kZVdhbGtlci5uZXh0KCkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmKCFub2RlV2Fsa2VyLmZpcnN0Q2hpbGQoKS5pc051bGwoKSl7XHJcbiAgICAgICAgICAgIHByb2Nlc3NpbmdRdWV1ZS5wdXNoKG5vZGVXYWxrZXIuZmlyc3RDaGlsZCgpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZihub2RlV2Fsa2VyLmlzRWxlbWVudChcImJyXCIpICYmIG5vZGVXYWxrZXIucGFyZW50KCkuaXNJbmxpbmVDb250ZW50KCkpe1xyXG4gICAgICAgICAgICBicmVha0ZvdW5kSW5zaWRlSW5saW5lQ29udGVudCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBicmVha0ZvdW5kSW5zaWRlSW5saW5lQ29udGVudDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ3doZW4gQ2hyb21lIGluc2VydHMgY2FycmlhZ2UgcmV0dXJuIGluc2lkZSBhIHRleHQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICBpdCgnY29udmVydHMgdGhvc2UgY2FycmlhZ2UgcmV0dXJucyB0byA8YnI+IGVsZW1lbnRzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzYW1wbGUgPSBmaXh0dXJlLm5ld0xpbmVzSW5zaWRlVGV4dENvbnRhaW5lcigpO1xyXG4gICAgICAgIHZhciBicmVha0VsZW1lbnRzSW5zZXJ0ZWQ7XHJcbiAgICAgICAgc2VsZWN0aW9uQ29udGV4dC5mb2N1c05vZGUgPSBzYW1wbGUuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgICAgaGFuZGxlKGZha2VFdmVudCk7XHJcblxyXG4gICAgICAgIGJyZWFrRWxlbWVudHNJbnNlcnRlZCA9IHNhbXBsZS5xdWVyeVNlbGVjdG9yQWxsKCdicicpO1xyXG4gICAgICAgIGFzc2VydC5sZW5ndGhPZihicmVha0VsZW1lbnRzSW5zZXJ0ZWQsIDEsICduZXcgbGluZSBjb252ZXJ0ZWQgdG8gYnJlYWsnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ3doZW4gRmlyZWZveCBpbnNlcnRzIDxicj4gaW5zaWRlIHVlLXRhZy13cmFwcGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpdCgnbW92ZXMgPGJyPiBhZnRlciB0aGUgc3RhcnQgdGFnLXdyYXBwZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNhbXBsZSA9IGZpeHR1cmUuc3RhcnRUYWdXaXRoQnJlYWsoKTtcclxuICAgICAgICB2YXIgYnJlYWtFbGVtZW50O1xyXG4gICAgICAgIHZhciBub2RlV2Fsa2VyO1xyXG4gICAgICAgIHNlbGVjdGlvbkNvbnRleHQuZm9jdXNOb2RlID0gc2FtcGxlO1xyXG5cclxuICAgICAgICBoYW5kbGUoZmFrZUV2ZW50KTtcclxuXHJcbiAgICAgICAgYnJlYWtFbGVtZW50ID0gc2FtcGxlLnF1ZXJ5U2VsZWN0b3IoJ2JyJyk7XHJcbiAgICAgICAgbm9kZVdhbGtlciA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihicmVha0VsZW1lbnQpO1xyXG4gICAgICAgIG5vZGVXYWxrZXIgPSBub2RlV2Fsa2VyLnByZXYoKTtcclxuXHJcbiAgICAgICAgYXNzZXJ0LmlzVHJ1ZShub2RlV2Fsa2VyLmlzU3RhcnRUYWcoKSwgJzxicj4gd2FzIG1vdmVkIGFmdGVyIGVuZCB0YWcnKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnbW92ZXMgPGJyPiBhZnRlciB0aGUgZW5kIHRhZy13cmFwcGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzYW1wbGUgPSBmaXh0dXJlLmVuZFRhZ1dpdGhCcmVhaygpO1xyXG4gICAgICAgIHZhciBicmVha0VsZW1lbnQ7XHJcbiAgICAgICAgdmFyIG5vZGVXYWxrZXI7XHJcbiAgICAgICAgc2VsZWN0aW9uQ29udGV4dC5mb2N1c05vZGUgPSBzYW1wbGU7XHJcblxyXG4gICAgICAgIGhhbmRsZShmYWtlRXZlbnQpO1xyXG5cclxuICAgICAgICBicmVha0VsZW1lbnQgPSBzYW1wbGUucXVlcnlTZWxlY3RvcignYnInKTtcclxuICAgICAgICBub2RlV2Fsa2VyID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKGJyZWFrRWxlbWVudCk7XHJcbiAgICAgICAgbm9kZVdhbGtlciA9IG5vZGVXYWxrZXIucHJldigpO1xyXG5cclxuICAgICAgICBhc3NlcnQuaXNUcnVlKG5vZGVXYWxrZXIuaXNFbmRUYWcoKSwgJzxicj4gd2FzIG1vdmVkIGFmdGVyIGVuZCB0YWcnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnd2hlbiBzZWdtZW50IGlzIGVtcHR5JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpdCgnbW92ZXMgdGhlIGJyIGluc2lkZSB0aGUgaW5saW5lIGNvbnRlbnQnLCBmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBzYW1wbGUgPSBmaXh0dXJlLmVtcHR5U2VnbWVudCgpO1xyXG4gICAgICAgIHZhciBicmVha0VsZW1lbnQsXHJcbiAgICAgICAgICAgIG5vZGVXYWxrZXI7XHJcbiAgICAgICAgc2VsZWN0aW9uQ29udGV4dC5mb2N1c05vZGUgPSBzYW1wbGU7XHJcblxyXG4gICAgICAgIGhhbmRsZShmYWtlRXZlbnQpO1xyXG5cclxuICAgICAgICBicmVha0VsZW1lbnQgPSBzYW1wbGUucXVlcnlTZWxlY3RvcignYnInKTtcclxuICAgICAgICBub2RlV2Fsa2VyID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKGJyZWFrRWxlbWVudCk7XHJcbiAgICAgICAgYXNzZXJ0LmlzVHJ1ZShub2RlV2Fsa2VyLnBhcmVudCgpLmlzSW5saW5lQ29udGVudCgpLCAnYnIgd2FzIG1vdmVkIHRvIHRoZSBlbXB0eSBpbmxpbmUgY29udGVudCcpXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCd3aGVuIHNoaWZ0K2VudGVyIGlzIG5vdCBwcmVzc2VkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGZha2VFdmVudCA9IG5ldyBGYWtlRXZlbnQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkb2VzIG5vdGhpbmcgd2hlbiBlbnRlciBpcyBwcmVzc2VkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBmYWtlRXZlbnQuc2V0S2V5Q29kZShrZXlzLmtleUVudGVyKTtcclxuXHJcbiAgICAgIGhhbmRsZShmYWtlRXZlbnQpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzRmFsc2UoZmFrZUV2ZW50Lmhhc1ByZXZlbnRlZERlZmF1bHQsICdFdmVudCNwcmV2ZW50RGVmYXVsdCBoYXMgbm90IGJlZW4gY2FsbGVkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnZG9lcyBub3RoaW5nIHdoZW4gc2hpZnQgaXMgcHJlc3NlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgZmFrZUV2ZW50LnNldFNoaWZ0S2V5KHRydWUpO1xyXG5cclxuICAgICAgaGFuZGxlKGZha2VFdmVudCk7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShmYWtlRXZlbnQuaGFzUHJldmVudGVkRGVmYXVsdCwgJ0V2ZW50I3ByZXZlbnREZWZhdWx0IGhhcyBub3QgYmVlbiBjYWxsZWQnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuXHJcbn0pOyIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xyXG5cclxudmFyIFNlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXIgPSByZXF1aXJlKCcuLi8uLi9zdXBwb3J0L1NlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXInKTtcclxudmFyIEZha2VFdmVudCA9IHJlcXVpcmUoJy4uLy4uL3N1cHBvcnQvRmFrZUV2ZW50Jyk7XHJcblxyXG5kZXNjcmliZSgnS2V5Ym9hcmRCaW5kaW5ncyNoYW5kbGVDbGVhclRhZ3NTaG9ydGN1dFByZXZlbnRzRGVmYXVsdCcsIGZ1bmN0aW9uICgpIHtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgdmFyXHJcbiAgICBoYW5kbGVDbGVhclRhZ3NTaG9ydGN1dFByZXZlbnRzRGVmYXVsdCxcclxuXHJcbiAgICBvYmplY3RNb3RoZXIsXHJcbiAgICBmYWtlRXZlbnQ7XHJcblxyXG4gIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgb2JqZWN0TW90aGVyID0gbmV3IFNlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXIoKTtcclxuXHJcbiAgICBmYWtlRXZlbnQgPSBuZXcgRmFrZUV2ZW50KCk7XHJcblxyXG4gICAgZmFrZUV2ZW50LnNldEN0cmxLZXkodHJ1ZSk7XHJcbiAgICBmYWtlRXZlbnQuc2V0S2V5Q29kZShvYmplY3RNb3RoZXIua2V5Ym9hcmRCaW5kaW5ncy5rZXlTcGFjZSk7XHJcblxyXG4gICAgb2JqZWN0TW90aGVyLnNldHVwRW1wdHlDbG9uZUNvbnRlbnRzKCk7XHJcbiAgICBoYW5kbGVDbGVhclRhZ3NTaG9ydGN1dFByZXZlbnRzRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2JqZWN0TW90aGVyLmtleWJvYXJkQmluZGluZ3MuaGFuZGxlQ2xlYXJUYWdzU2hvcnRjdXRQcmV2ZW50c0RlZmF1bHQoZmFrZUV2ZW50KTtcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgfSk7XHJcblxyXG5cclxuICBkZXNjcmliZShcIndoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGNyb3NzIHNlZ21lbnQgc2VsZWN0aW9uXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYmplY3RNb3RoZXIuc2V0Q3Jvc3NTZWdtZW50U2VsZWN0aW9uVG8odHJ1ZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYmplY3RNb3RoZXIucmVzZXRDcm9zc1NlZ21lbnRTZWxlY3Rpb24oKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkb2VzIG5vdGhpbmcnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGhhbmRsZUNsZWFyVGFnc1Nob3J0Y3V0UHJldmVudHNEZWZhdWx0KCk7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShmYWtlRXZlbnQuaGFzUHJldmVudGVkRGVmYXVsdCwgJ0tleWJvYXJkRXZlbnQjUHJldmVudERlZmF1bHQgaGFzIGJlZW4gY2FsbGVkJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3doZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZCcsIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2JqZWN0TW90aGVyLnNldENvbGxhcHNlZFNlbGVjdGlvbigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2JqZWN0TW90aGVyLnJlc3RvcmVTZWxlY3Rpb25Db250ZXh0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnZG9lcyBub3RoaW5nJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBoYW5kbGVDbGVhclRhZ3NTaG9ydGN1dFByZXZlbnRzRGVmYXVsdCgpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzRmFsc2UoZmFrZUV2ZW50Lmhhc1ByZXZlbnRlZERlZmF1bHQsICdLZXlib2FyZEV2ZW50I1ByZXZlbnREZWZhdWx0IGhhcyBiZWVuIGNhbGxlZCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCd3aGVuIHRoZSBDVFJMICsgU3BhY2UgY29tYmluYXRpb24gaXMgbm90IHByZXNzZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2JqZWN0TW90aGVyLnN0dWJTZWxlY3Rpb25Db250ZXh0KCk7XHJcbiAgICAgIGZha2VFdmVudC5jdHJsS2V5ID0gZmFsc2U7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChmdW5jdGlvbigpe1xyXG4gICAgICBvYmplY3RNb3RoZXIucmVzdG9yZVNlbGVjdGlvbkNvbnRleHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkb2VzIG5vdGhpbmcnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGhhbmRsZUNsZWFyVGFnc1Nob3J0Y3V0UHJldmVudHNEZWZhdWx0KCk7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShmYWtlRXZlbnQuaGFzUHJldmVudGVkRGVmYXVsdCwgJ0tleWJvYXJkRXZlbnQjUHJldmVudERlZmF1bHQgaGFzIGJlZW4gY2FsbGVkJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3doZW4gdGhlIGNvbW1vbkFuY2VzdG9yIGlzIHNhbWUgYXMgZW5kQ29udGFpbmVyIGFuZCBzdGFydENvbnRhaW5lciAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2JqZWN0TW90aGVyLnNldHVwU2FtZUNvbnRhaW5lckZvclNlbGVjdGlvbigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2JqZWN0TW90aGVyLnJlc3RvcmVTZWxlY3Rpb25Db250ZXh0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncHJldmVudHMgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb24nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGhhbmRsZUNsZWFyVGFnc1Nob3J0Y3V0UHJldmVudHNEZWZhdWx0KCk7XHJcbiAgICAgIGFzc2VydC5pc1RydWUoZmFrZUV2ZW50Lmhhc1ByZXZlbnRlZERlZmF1bHQsICdLZXlib2FyZEV2ZW50I1ByZXZlbnREZWZhdWx0IGhhcyBiZWVuIGNhbGxlZCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcclxuXHJcbnZhciBIZWxwZXJzID0gcmVxdWlyZSgnLi4vLi4vLi4vYXNzZXRzL2pzL3VlL0hlbHBlcnMnKTtcclxudmFyIEZha2VFdmVudCA9IHJlcXVpcmUoJy4uLy4uL3N1cHBvcnQvRmFrZUV2ZW50Jyk7XHJcbnZhciBIYW5kbGVDbGVhclRhZ3NGaXh0dXJlcyA9IHJlcXVpcmUoJy4uLy4uL3N1cHBvcnQvSGFuZGxlQ2xlYXJUYWdzRml4dHVyZXMnKVxyXG52YXIgS2V5Ym9hcmRCaW5kaW5ncyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9LZXlib2FyZEJpbmRpbmdzJyk7XHJcbnZhciBTZWxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUvc2VsZWN0aW9uJyk7XHJcbnZhciBTZWdtZW50c1dhdGNoZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUvU2VnbWVudHNXYXRjaGVyJyk7XHJcblxyXG5kZXNjcmliZSgnS2V5Ym9hcmRCaW5kaW5ncyNoYW5kbGVDbGVhclRhZ3MgYWNjZXB0YW5jZScsIGZ1bmN0aW9uKCl7XHJcbiAgdmFyIGJvZHksXHJcbiAgICBmaXh0dXJlSG9zdCxcclxuICAgIGZpeHR1cmVzLFxyXG4gICAgdGFnUGFpclNhbXBsZSxcclxuICAgIHNlbGVjdGlvbixcclxuICAgIHJhbmdlO1xyXG5cclxuICB2YXIga2IsIGZha2VFdmVudDtcclxuXHJcbiAgYmVmb3JlRWFjaChmdW5jdGlvbigpe1xyXG4gICAgYm9keSA9IGRvY3VtZW50LmJvZHk7XHJcbiAgICBmaXh0dXJlSG9zdCA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRpdiBjbGFzcz1cImZpeHR1cmUtaG9zdCBoaWRkZW4gdWUtZWRpdGFibGVcIiBjb250ZW50ZWRpdGFibGU9XCJvblwiPjwvZGl2PicpO1xyXG4gICAgZml4dHVyZXMgPSBuZXcgSGFuZGxlQ2xlYXJUYWdzRml4dHVyZXMoKTtcclxuICAgIHRhZ1BhaXJTYW1wbGUgPSBmaXh0dXJlcy50YWdQYWlyU2FtcGxlKCk7XHJcblxyXG4gICAgYm9keS5hcHBlbmRDaGlsZChmaXh0dXJlSG9zdCk7XHJcblxyXG4gICAga2IgPSBuZXcgS2V5Ym9hcmRCaW5kaW5ncygpO1xyXG5cclxuICAgIGZha2VFdmVudCA9IG5ldyBGYWtlRXZlbnQoKTtcclxuICAgIGZha2VFdmVudC5zZXRDdHJsS2V5KHRydWUpO1xyXG4gICAgZmFrZUV2ZW50LnNldEtleUNvZGUoa2Iua2V5U3BhY2UpO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnd2hlbiBzZWxlY3Rpb24gc3RhcnRzIGJlZm9yZSBhIHRhZyBwYWlyLCBhbmQgZW5kcyBpbnNpZGUgdGFnIHBhaXInLCBmdW5jdGlvbigpe1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgdWVUZXh0U3RhcnQsXHJcbiAgICAgICAgICB1ZVRhZ1BhaXJDb250ZW50LFxyXG4gICAgICAgICAgdWVUYWdQYWlyVGV4dCxcclxuICAgICAgICAgIHN0YXJ0VGV4dE5vZGUsXHJcbiAgICAgICAgICBlbmRUZXh0Tm9kZTtcclxuXHJcbiAgICAgIGZpeHR1cmVIb3N0LmFwcGVuZENoaWxkKHRhZ1BhaXJTYW1wbGUpO1xyXG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgcmFuZ2UgPSBuZXdSYW5nZSgpO1xyXG4gICAgICB1ZVRleHRTdGFydCA9IHRhZ1BhaXJTYW1wbGUuZmlyc3RDaGlsZDtcclxuICAgICAgdWVUYWdQYWlyQ29udGVudCA9IHRhZ1BhaXJTYW1wbGUuY2hpbGROb2Rlc1syXTtcclxuICAgICAgdWVUYWdQYWlyVGV4dCA9IHVlVGFnUGFpckNvbnRlbnQuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgIHN0YXJ0VGV4dE5vZGUgPSB1ZVRleHRTdGFydC5maXJzdENoaWxkO1xyXG4gICAgICBlbmRUZXh0Tm9kZSA9IHVlVGFnUGFpclRleHQuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgIGFzc2lnblJhbmdlKHN0YXJ0VGV4dE5vZGUsIGVuZFRleHROb2RlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgZml4dHVyZUhvc3QuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCd3aWxsIGJyZWFrIHRoZSB0ZXh0IGF0IHRoZSBzdGFydCBvZiB0aGUgc2VsZWN0aW9uIGluIHR3byBwYXJ0cycsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIGtiLmhhbmRsZUNsZWFyVGFncyhmYWtlRXZlbnQpO1xyXG5cclxuICAgICAgdmFyIHVlVGV4dCA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcih0YWdQYWlyU2FtcGxlLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcpO1xyXG4gICAgICBhc3NlcnQuZXF1YWwodWVUZXh0LmVsLnRleHRDb250ZW50LCBcInh0XCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3dpbGwgbW92ZSB0aGUgdGV4dCBzZWxlY3RlZCBpbiB0aGUgdGFnIHBhaXIsIG91dHNpZGUnLCBmdW5jdGlvbigpe1xyXG4gICAgICBrYi5oYW5kbGVDbGVhclRhZ3MoZmFrZUV2ZW50KTtcclxuXHJcbiAgICAgIHZhciBub2RlV2Fsa2VyID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKHRhZ1BhaXJTYW1wbGUuZmlyc3RDaGlsZC5uZXh0U2libGluZyk7XHJcbiAgICAgIHZhciB1ZVRleHQgPSBub2RlV2Fsa2VyLm5leHQoKTtcclxuICAgICAgYXNzZXJ0KHVlVGV4dC5pc1RleHQoKSwgJ1RoZSBzYW1wbGUgaGFzIHVlLXRleHQgYXMgdGhlIHRoaXJkIGNoaWxkJyk7XHJcbiAgICAgIGFzc2VydC5lcXVhbCh1ZVRleHQuZWwudGV4dENvbnRlbnQsIFwiaW5uZXIgXCIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3dpbGwgbW92ZSB0aGUgdGFnIHBhaXIgc3RhcnQgd3JhcHBlciBhZnRlciB0aGUgc2VsZWN0ZWQgdGV4dCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIGtiLmhhbmRsZUNsZWFyVGFncyhmYWtlRXZlbnQpO1xyXG5cclxuICAgICAgdmFyIG5vZGVXYWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIodGFnUGFpclNhbXBsZS5maXJzdENoaWxkLm5leHRTaWJsaW5nLm5leHRTaWJsaW5nKTtcclxuICAgICAgdmFyIHN0YXJ0VGFnV3JhcHBlciA9IG5vZGVXYWxrZXIubmV4dCgpO1xyXG4gICAgICBhc3NlcnQoc3RhcnRUYWdXcmFwcGVyLmlzU3RhcnRUYWcoKSwgJ1RoZSBzYW1wbGUgaGFzIHN0YXJ0VGFnIGFzIHRoZSBmb3VydGggY2hpbGRcIicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCd3aGVuIHNlbGVjdGlvbiBzdGFydHMgaW5zaWRlIGEgdGFnIHBhaXIgYW5kIGNvbnRpbnVlcyBvdXRzaWRlIG9mIGl0JywgZnVuY3Rpb24oKXtcclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgdGFnUGFpckNvbnRlbnQsXHJcbiAgICAgICAgdWVUZXh0RW5kLFxyXG4gICAgICAgIHVlVGV4dFN0YXJ0LFxyXG4gICAgICAgIHN0YXJ0VGV4dE5vZGUsXHJcbiAgICAgICAgZW5kVGV4dE5vZGU7XHJcblxyXG4gICAgICBmaXh0dXJlSG9zdC5hcHBlbmRDaGlsZCh0YWdQYWlyU2FtcGxlKTtcclxuXHJcbiAgICAgIHRhZ1BhaXJDb250ZW50ID0gdGFnUGFpclNhbXBsZS5jaGlsZE5vZGVzWzJdO1xyXG4gICAgICB1ZVRleHRFbmQgPSB0YWdQYWlyU2FtcGxlLmxhc3RDaGlsZDtcclxuXHJcbiAgICAgIHVlVGV4dFN0YXJ0ID0gdGFnUGFpckNvbnRlbnQuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgIHN0YXJ0VGV4dE5vZGUgPSB1ZVRleHRTdGFydC5maXJzdENoaWxkO1xyXG4gICAgICBlbmRUZXh0Tm9kZSA9IHVlVGV4dEVuZC5maXJzdENoaWxkO1xyXG5cclxuICAgICAgYXNzaWduUmFuZ2Uoc3RhcnRUZXh0Tm9kZSwgZW5kVGV4dE5vZGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgICAgZml4dHVyZUhvc3QuaW5uZXJIVE1MID0gXCJcIjtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdtb3ZlcyB0aGUgZW5kIHRhZyBhdCB0aGUgZnJvbnQgb2YgdGhlIHNlbGVjdGlvbicsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIGtiLmhhbmRsZUNsZWFyVGFncyhmYWtlRXZlbnQpO1xyXG4gICAgICB2YXIgbm9kZVdhbGtlciA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcih0YWdQYWlyU2FtcGxlLmNoaWxkTm9kZXNbM10pO1xyXG4gICAgICBhc3NlcnQobm9kZVdhbGtlci5pc0VuZFRhZygpLCAnZW5kIHRhZyBwcmVzZXJ2ZWQgYmVmb3JlIHRoZSBzdGFydCBvZiB0aGUgc2VsZWN0aW9uJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnbW92ZXMgY29udGVudCBvdXQgb2YgdGhlIHRhZyBwYWlyIGNvbnRhaW5lcicsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIGtiLmhhbmRsZUNsZWFyVGFncyhmYWtlRXZlbnQpO1xyXG4gICAgICB2YXIgdWVUZXh0ID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKHRhZ1BhaXJTYW1wbGUuY2hpbGROb2Rlc1s0XSk7XHJcbiAgICAgIGFzc2VydCh1ZVRleHQuaXNUZXh0KCksICd0ZXh0IHdhcyBtb3ZlZCBvdXRzaWRlIG9mIHRoZSB0YWcgcGFpciBjb250YWluZXInKTtcclxuICAgICAgYXNzZXJ0LmVxdWFsKHVlVGV4dC5lbC50ZXh0Q29udGVudCwgJ2NvbnRlbnQnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnd2hlbiB0YWcgcGFpciBpcyBpbnNpZGUgc2VsZWN0aW9uJywgZnVuY3Rpb24oKXtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciB1ZVRleHRTdGFydCxcclxuICAgICAgICB1ZVRleHRFbmQsIHN0YXJ0VGV4dE5vZGUsIGVuZFRleHROb2RlLFxyXG4gICAgICAgIHRhZ1BhaXJTdGFydCwgdGFnUGFpckVuZCxcclxuICAgICAgICBzZWdtZW50V2F0Y2hlcjtcclxuICAgICAgc2VnbWVudFdhdGNoZXIgPSBTZWdtZW50c1dhdGNoZXI7XHJcbiAgICAgIHRhZ1BhaXJTdGFydCA9IHRhZ1BhaXJTYW1wbGUuY2hpbGROb2Rlc1sxXTtcclxuICAgICAgdGFnUGFpckVuZCA9IHRhZ1BhaXJTYW1wbGUuY2hpbGROb2Rlc1szXTtcclxuICAgICAgc2VnbWVudFdhdGNoZXIuYWRkVGFnUGFpcih0YWdQYWlyU3RhcnQuZGF0YXNldC5pZCwgW3RhZ1BhaXJTdGFydCwgdGFnUGFpckVuZF0pO1xyXG5cclxuICAgICAgZml4dHVyZUhvc3QuYXBwZW5kQ2hpbGQodGFnUGFpclNhbXBsZSk7XHJcblxyXG4gICAgICB1ZVRleHRTdGFydCA9IHRhZ1BhaXJTYW1wbGUuZmlyc3RDaGlsZDtcclxuICAgICAgdWVUZXh0RW5kID0gdGFnUGFpclNhbXBsZS5sYXN0Q2hpbGQ7XHJcblxyXG4gICAgICBzdGFydFRleHROb2RlID0gdWVUZXh0U3RhcnQuZmlyc3RDaGlsZDtcclxuICAgICAgZW5kVGV4dE5vZGUgPSB1ZVRleHRFbmQuZmlyc3RDaGlsZDtcclxuXHJcbiAgICAgIGFzc2lnblJhbmdlKHN0YXJ0VGV4dE5vZGUsIGVuZFRleHROb2RlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaChmdW5jdGlvbigpe1xyXG4gICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcbiAgICAgIGZpeHR1cmVIb3N0LmlubmVySFRNTCA9IFwiXCI7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgaXQoJ3JlbW92ZSB0aGUgdGFnIHBhaXInLCBmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgbncgPSBTZWxlY3Rpb24uTm9kZVdhbGtlcixcclxuICAgICAgICAgIGhhc1RhZ1BhaXI7XHJcblxyXG4gICAgICBrYi5oYW5kbGVDbGVhclRhZ3MoZmFrZUV2ZW50KTtcclxuXHJcbiAgICAgIGhhc1RhZ1BhaXIgPSBfKHRhZ1BhaXJTYW1wbGUuY2hpbGROb2RlcykuYW55KGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgIHZhciBub2RlV2Fsa2VyID0gbmV3IG53KG5vZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gbm9kZVdhbGtlci5pc1RhZ1BhaXJDb250YWluZXIoKSB8fCBub2RlV2Fsa2VyLmlzVGFnKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzRmFsc2UoaGFzVGFnUGFpciwgJ25vIHRhZyBwYWlyIGZvdW5kIGluIHRyYW5zZm9ybWVkIHNhbXBsZScpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGFzc2lnblJhbmdlKHN0YXJ0VGV4dE5vZGUsIGVuZFRleHROb2RlKXtcclxuICAgIHJhbmdlID0gbmV3UmFuZ2UoKTtcclxuXHJcbiAgICByYW5nZS5zZXRTdGFydChzdGFydFRleHROb2RlLCBzdGFydFRleHROb2RlLmxlbmd0aCAvMik7XHJcbiAgICByYW5nZS5zZXRFbmQoZW5kVGV4dE5vZGUsIGVuZFRleHROb2RlLmxlbmd0aCAvIDIpO1xyXG5cclxuICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBuZXdSYW5nZSgpe1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgfVxyXG59KTsiLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcclxudmFyIFNlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXIgPSByZXF1aXJlKCcuLi8uLi9zdXBwb3J0L1NlbGVjdGlvbkNvbnRleHRPYmplY3RNb3RoZXInKTtcclxudmFyIEZha2VFdmVudCA9IHJlcXVpcmUoJy4uLy4uL3N1cHBvcnQvRmFrZUV2ZW50Jyk7XHJcblxyXG5kZXNjcmliZSgnS2V5Ym9hcmRCaW5kaW5ncyNoYW5kbGVDbGVhclRhZ3MnLCBmdW5jdGlvbiAoKSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIHZhclxyXG4gICAgICBoYW5kbGVDbGVhclRhZ3MsXHJcblxyXG4gICAgICBvYmplY3RNb3RoZXIsXHJcbiAgICAgIGZha2VFdmVudDtcclxuXHJcbiAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICBvYmplY3RNb3RoZXIgPSBuZXcgU2VsZWN0aW9uQ29udGV4dE9iamVjdE1vdGhlcigpO1xyXG4gICAgb2JqZWN0TW90aGVyLnN0dWJTZWxlY3Rpb24oKTtcclxuXHJcbiAgICBmYWtlRXZlbnQgPSBuZXcgRmFrZUV2ZW50KCk7XHJcblxyXG4gICAgZmFrZUV2ZW50LnNldEN0cmxLZXkodHJ1ZSk7XHJcbiAgICBmYWtlRXZlbnQuc2V0S2V5Q29kZShvYmplY3RNb3RoZXIua2V5Ym9hcmRCaW5kaW5ncy5rZXlTcGFjZSk7XHJcblxyXG4gICAgb2JqZWN0TW90aGVyLnNldHVwRW1wdHlDbG9uZUNvbnRlbnRzKCk7XHJcbiAgICBoYW5kbGVDbGVhclRhZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG9iamVjdE1vdGhlci5rZXlib2FyZEJpbmRpbmdzLmhhbmRsZUNsZWFyVGFncyhmYWtlRXZlbnQpO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgIG9iamVjdE1vdGhlci5yZXN0b3JlU2VsZWN0aW9uKCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKFwid2hlbiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgY3Jvc3Mgc2VnbWVudCBzZWxlY3Rpb25cIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG9iamVjdE1vdGhlci5zZXRDcm9zc1NlZ21lbnRTZWxlY3Rpb25Ubyh0cnVlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG9iamVjdE1vdGhlci5yZXNldENyb3NzU2VnbWVudFNlbGVjdGlvbigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RvZXMgbm90aGluZycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaGFuZGxlQ2xlYXJUYWdzKCk7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShvYmplY3RNb3RoZXIuc3R1YlNlbGVjdGlvbkNvbnRleHQuZGVsZXRlQ29udGVudHMuY2FsbGVkLCAnU2VsZWN0aW9uQ29udGV4dCNkZWxldGVDb250ZW50cyB3YXMgY2FsbGVkJylcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnd2hlbiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgY29sbGFwc2VkJywgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYmplY3RNb3RoZXIuc2V0Q29sbGFwc2VkU2VsZWN0aW9uKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYmplY3RNb3RoZXIucmVzdG9yZVNlbGVjdGlvbkNvbnRleHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkb2VzIG5vdGhpbmcnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGhhbmRsZUNsZWFyVGFncygpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzRmFsc2Uob2JqZWN0TW90aGVyLnN0dWJTZWxlY3Rpb25Db250ZXh0LmRlbGV0ZUNvbnRlbnRzLmNhbGxlZCwgJ1NlbGVjdGlvbkNvbnRleHQjZGVsZXRlQ29udGVudHMgd2FzIGNhbGxlZCcpXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3doZW4gdGhlIENUUkwgKyBTcGFjZSBjb21iaW5hdGlvbiBpcyBub3QgcHJlc3NlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYmplY3RNb3RoZXIuc3R1YlNlbGVjdGlvbkNvbnRleHQoKTtcclxuICAgICAgZmFrZUV2ZW50LmN0cmxLZXkgPSBmYWxzZTtcclxuICAgIH0pO1xyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIG9iamVjdE1vdGhlci5yZXN0b3JlU2VsZWN0aW9uQ29udGV4dCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RvZXMgbm90aGluZycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaGFuZGxlQ2xlYXJUYWdzKCk7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShvYmplY3RNb3RoZXIuc3R1YlNlbGVjdGlvbkNvbnRleHQuZGVsZXRlQ29udGVudHMuY2FsbGVkLCAnU2VsZWN0aW9uQ29udGV4dCNkZWxldGVDb250ZW50cyB3YXMgY2FsbGVkJylcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnd2hlbiB0aGUgY29tbW9uQW5jZXN0b3IgaXMgc2FtZSBhcyBlbmRDb250YWluZXIgYW5kIHN0YXJ0Q29udGFpbmVyICcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYmplY3RNb3RoZXIuc2V0dXBTYW1lQ29udGFpbmVyRm9yU2VsZWN0aW9uKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBvYmplY3RNb3RoZXIucmVzdG9yZVNlbGVjdGlvbkNvbnRleHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkb2VzIG5vdGhpbmcnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGhhbmRsZUNsZWFyVGFncygpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzRmFsc2Uob2JqZWN0TW90aGVyLnN0dWJTZWxlY3Rpb25Db250ZXh0LmRlbGV0ZUNvbnRlbnRzLmNhbGxlZCwgJ1NlbGVjdGlvbkNvbnRleHQjZGVsZXRlQ29udGVudHMgd2FzIGNhbGxlZCcpXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3doZW4gdGhlIHN0YXJ0Q29udGFpbmVyIGlzIGRpZmZlcmVudCBmcm9tIGNvbW1vbkFuY2VzdG9yJywgZnVuY3Rpb24gKCkge1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG9iamVjdE1vdGhlci5zZXR1cFNpbXBsZUFuY2VzdG9yU3RhcnRDb250YWluZXIoKTtcclxuICAgICAgb2JqZWN0TW90aGVyLnNweUtleWJvYXJkQmluZGluZ3NNZXRob2QoJ2lkZW50aWZ5VGFnc0luQ29udGFpbmVyJyk7XHJcbiAgICAgIG9iamVjdE1vdGhlci5zcHlLZXlib2FyZEJpbmRpbmdzTWV0aG9kKCd0cmFuc2Zvcm1UYWdzJyk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG9iamVjdE1vdGhlci5yZXN0b3JlU2VsZWN0aW9uQ29udGV4dCgpO1xyXG4gICAgICBvYmplY3RNb3RoZXIucmVzdG9yZUtleWJvYXJkQmluZGluZ3NNZXRob2QoJ2lkZW50aWZ5VGFnc0luQ29udGFpbmVyJyk7XHJcbiAgICAgIG9iamVjdE1vdGhlci5yZXN0b3JlS2V5Ym9hcmRCaW5kaW5nc01ldGhvZCgndHJhbnNmb3JtVGFncycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2NhbGxzIGlkZW50aWZ5VGFnc0luQ29udGFpbmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBoYW5kbGVDbGVhclRhZ3MoKTtcclxuICAgICAgYXNzZXJ0KG9iamVjdE1vdGhlci5rZXlib2FyZEJpbmRpbmdzU3B5KCdpZGVudGlmeVRhZ3NJbkNvbnRhaW5lcicpLmNhbGxlZCxcclxuICAgICAgICAgICdleHBlY3RlZCBpZGVudGlmeVRhZ3NJbkNvbnRhaW5lciB0byBoYXZlIGJlZW4gY2FsbGVkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnY2FsbHMgdHJhbnNmb3JtVGFncycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaGFuZGxlQ2xlYXJUYWdzKCk7XHJcbiAgICAgIGFzc2VydChvYmplY3RNb3RoZXIua2V5Ym9hcmRCaW5kaW5nc1NweSgndHJhbnNmb3JtVGFncycpLmNhbGxlZCxcclxuICAgICAgICAgICdleHBlY3RlZCBpZGVudGlmeVRhZ3NJbkNvbnRhaW5lciB0byBoYXZlIGJlZW4gY2FsbGVkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnd2hlbiB0cmFuc2Zvcm1UYWdzIGhhcyB0YWdzIHRoYXQgbmVlZCB0byBiZSBtb3ZlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpdCgnY2FsbHMgTm9kZVdhbGtlciNyZW1vdmUgZm9yIHRhZ3MgaW4gbW92ZVRhZ3NUb0VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvYmplY3RNb3RoZXIuYXR0YWNoTW92ZVRhZ3NUb0VuZFN0dWIoKTtcclxuXHJcbiAgICAgICAgaGFuZGxlQ2xlYXJUYWdzKCk7XHJcblxyXG4gICAgICAgIGFzc2VydChvYmplY3RNb3RoZXIubm9kZVdhbGtlclN0dWIucmVtb3ZlLmNhbGxlZCwgJ05vZGVXYWxrZXIjcmVtb3ZlIGlzIGNhbGxlZCcpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdjYWxscyBOb2RlV2Fsa2VyI3JlbW92ZSBmb3IgdGFncyBpbiBtb3ZlVGFnc1RvU3RhcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2JqZWN0TW90aGVyLmF0dGFjaE1vdmVUYWdzVG9Gcm9udFN0dWIoKTtcclxuXHJcbiAgICAgICAgaGFuZGxlQ2xlYXJUYWdzKCk7XHJcblxyXG4gICAgICAgIGFzc2VydChvYmplY3RNb3RoZXIubm9kZVdhbGtlclN0dWIucmVtb3ZlLmNhbGxlZCwgJ05vZGVXYWxrZXIjcmVtb3ZlIGlzIGNhbGxlZCcpO1xyXG5cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgnY2FsbHMgU2VsZWN0aW9uQ29udGV4dCNkZWxldGVDb250ZW50cyB3aGVuIHRoZXJlIGFyZSB0YWdzIHRvIG1vdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2JqZWN0TW90aGVyLmF0dGFjaE1vdmVUYWdzVG9Gcm9udFN0dWIoKTtcclxuXHJcbiAgICAgICAgaGFuZGxlQ2xlYXJUYWdzKCk7XHJcblxyXG4gICAgICAgIGFzc2VydChvYmplY3RNb3RoZXIuc3R1YlNlbGVjdGlvbkNvbnRleHQuZGVsZXRlQ29udGVudHMuY2FsbGVkLCAnU2VsZWN0aW9uQ29udGV4dCNkZWxldGVDb250ZW50cyB3YXMgY2FsbGVkJylcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcblxyXG59KTsiLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcclxudmFyIEtleWJvYXJkQmluZGluZ3NPYmplY3RNb3RoZXIgPSByZXF1aXJlKCcuLi8uLi9zdXBwb3J0L0tleWJvYXJkQmluZGluZ3NPYmplY3RNb3RoZXInKTtcclxudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9zZWxlY3Rpb24nKTtcclxuXHJcbmRlc2NyaWJlKCdLZXlib2FyZEJpbmRpbmdzI2lkZW50aWZ5VGFnc0luQ29udGFpbmVyJywgZnVuY3Rpb24gKCkge1xyXG4gIFwidXNlIHN0cmljdFwiO1xyXG4gIHZhciBvYmplY3RNb3RoZXIsXHJcbiAgICAgIGlkZW50aWZ5VGFnc0luQ29udGFpbmVyLFxyXG4gICAgICBub2RlV2Fsa2VyLFxyXG4gICAgICBlbmQsXHJcbiAgICAgIGZha2VDb250YWluZXJFbCxcclxuICAgICAgc3RhcnRDb250YWluZXIsXHJcbiAgICAgIGVuZENvbnRhaW5lcjtcclxuXHJcbiAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICBvYmplY3RNb3RoZXIgPSBuZXcgS2V5Ym9hcmRCaW5kaW5nc09iamVjdE1vdGhlcigpO1xyXG5cclxuICAgIG9iamVjdE1vdGhlci5hc3NpZ25UYWdzQ29udGFpbmVyKCk7XHJcblxyXG4gICAgaWRlbnRpZnlUYWdzSW5Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG9iamVjdE1vdGhlci5rYi5pZGVudGlmeVRhZ3NJbkNvbnRhaW5lcihub2RlV2Fsa2VyLCBlbmQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgb2JqZWN0TW90aGVyLmRlbGV0ZVRhZ3NDb250YWluZXIoKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ3dpbGwgd2FsayB0aHJvdWdoIGFsbCBub2RlcycsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB0ZXh0Q29udGFpbmVyLFxyXG4gICAgICAgIGtiID0gb2JqZWN0TW90aGVyLmtiO1xyXG5cclxuICAgIC8vIGFycmFuZ2VcclxuICAgIGZha2VDb250YWluZXJFbCA9IG9iamVjdE1vdGhlci5zZXR1cFNpbXBsZUNvbnRhaW5lcigpO1xyXG4gICAgdGV4dENvbnRhaW5lciA9IGZha2VDb250YWluZXJFbC5maXJzdENoaWxkO1xyXG4gICAgZW5kID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKGZha2VDb250YWluZXJFbC5sYXN0Q2hpbGQpO1xyXG5cclxuICAgIG5vZGVXYWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIodGV4dENvbnRhaW5lcik7XHJcbiAgICAvLyBhY3RcclxuICAgIGlkZW50aWZ5VGFnc0luQ29udGFpbmVyKCk7XHJcblxyXG4gICAgLy9hc3NlcnRcclxuICAgIGFzc2VydC5pc1RydWUoa2IuZW5kQ29udGFpbmVyUmVhY2hlZCwgJ2V4cGVjdGVkIHRvIHJlYWNoIGVuZCBjb250YWluZXInKTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3doZW4gY29sbGVjdGluZyBzdGFydCB0YWdzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGNvbGxlY3RlZFRhZztcclxuXHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZha2VDb250YWluZXJFbCA9IG9iamVjdE1vdGhlci5zaW5nbGVTdGFydFRhZ1NhbXBsZSgpO1xyXG4gICAgICBzdGFydENvbnRhaW5lciA9IGZha2VDb250YWluZXJFbC5maXJzdENoaWxkO1xyXG4gICAgICBlbmRDb250YWluZXIgPSBmYWtlQ29udGFpbmVyRWwubGFzdENoaWxkO1xyXG5cclxuICAgICAgbm9kZVdhbGtlciA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihzdGFydENvbnRhaW5lcik7XHJcbiAgICAgIGVuZCA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihlbmRDb250YWluZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3dpbGwgY29sbGVjdCBzdGFydCB0YWdzIGlmIHRoZXkgY2FuIGhpZGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIC8vIGFycmFuZ2VcclxuICAgICAgLy8gYWN0XHJcbiAgICAgIGlkZW50aWZ5VGFnc0luQ29udGFpbmVyKCk7XHJcbiAgICAgIC8vIGFzc2VydFxyXG4gICAgICBhc3NlcnQuaXNUcnVlKG9iamVjdE1vdGhlci5oYXNDb2xsZWN0ZWRUYWcoXCIxXCIpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkb2VzIG5vdCByZWdpc3RlciBlbmQgdGFnJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAvLyBhcnJhbmdlXHJcbiAgICAgIC8vIGFjdFxyXG4gICAgICBpZGVudGlmeVRhZ3NJbkNvbnRhaW5lcigpO1xyXG4gICAgICAvLyBhc3NlcnRcclxuICAgICAgY29sbGVjdGVkVGFnID0gb2JqZWN0TW90aGVyLmdldFRhZyhcIjFcIik7XHJcbiAgICAgIGFzc2VydC5pc051bGwoY29sbGVjdGVkVGFnLmVuZFRhZyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc3RvcmVzIHRoZSBzdGFydFRhZyBhcyBhIE5vZGVXYWxrZXInLCBmdW5jdGlvbigpe1xyXG4gICAgICAvLyBhcnJhbmdlXHJcbiAgICAgIC8vIGFjdFxyXG4gICAgICBpZGVudGlmeVRhZ3NJbkNvbnRhaW5lcigpO1xyXG4gICAgICAvLyBhc3NlcnRcclxuICAgICAgY29sbGVjdGVkVGFnID0gb2JqZWN0TW90aGVyLmdldFRhZyhcIjFcIik7XHJcbiAgICAgIGFzc2VydC5pbnN0YW5jZU9mKGNvbGxlY3RlZFRhZy5zdGFydFRhZywgU2VsZWN0aW9uLk5vZGVXYWxrZXIsICdzdGFydCB0YWcgaXMgaW5zdGFuY2Ugb2YgTm9kZVdhbGtlcicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCd3aGVuIGNvbGxlY3RpbmcgZW5kVGFncycsIGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgY29sbGVjdGVkVGFnO1xyXG5cclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKXtcclxuICAgICAgZmFrZUNvbnRhaW5lckVsID0gb2JqZWN0TW90aGVyLnNpbmdsZUVuZFRhZ1NhbXBsZSgpO1xyXG4gICAgICBzdGFydENvbnRhaW5lciA9IGZha2VDb250YWluZXJFbC5maXJzdENoaWxkLm5leHRTaWJsaW5nOy8vIHNlbGVjdGlvbiBzdGFydHMgaW4gdGFnLXBhaXItY29udGFpbmVyXHJcbiAgICAgIGVuZENvbnRhaW5lciA9IGZha2VDb250YWluZXJFbC5sYXN0Q2hpbGQ7Ly8gZW5kcyBpbiB0ZXh0IG5vZGVcclxuXHJcbiAgICAgIG5vZGVXYWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoc3RhcnRDb250YWluZXIpO1xyXG4gICAgICBlbmQgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoZW5kQ29udGFpbmVyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCd3aWxsIGNvbGxlY3QgZW5kIHRhZ3MgaWYgdGhleSBjYW4gaGlkZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gYXJyYW5nZVxyXG4gICAgICAvLyBhY3RcclxuICAgICAgaWRlbnRpZnlUYWdzSW5Db250YWluZXIoKTtcclxuICAgICAgLy8gYXNzZXJ0XHJcbiAgICAgIGFzc2VydC5pc1RydWUob2JqZWN0TW90aGVyLmhhc0NvbGxlY3RlZFRhZyhcIjFcIikpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2RvZXMgbm90IHJlZ2lzdGVyIHN0YXJ0IHRhZycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gYXJyYW5nZVxyXG4gICAgICAvLyBhY3RcclxuICAgICAgaWRlbnRpZnlUYWdzSW5Db250YWluZXIoKTtcclxuICAgICAgLy8gYXNzZXJ0XHJcbiAgICAgIGNvbGxlY3RlZFRhZyA9IG9iamVjdE1vdGhlci5nZXRUYWcoXCIxXCIpO1xyXG4gICAgICBhc3NlcnQuaXNOdWxsKGNvbGxlY3RlZFRhZy5zdGFydFRhZyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc3RvcmVzIHRoZSBlbmRUYWcgYXMgYSBOb2RlV2Fsa2VyJywgZnVuY3Rpb24oKXtcclxuICAgICAgLy8gYXJyYW5nZVxyXG4gICAgICAvLyBhY3RcclxuICAgICAgaWRlbnRpZnlUYWdzSW5Db250YWluZXIoKTtcclxuICAgICAgLy8gYXNzZXJ0XHJcbiAgICAgIGNvbGxlY3RlZFRhZyA9IG9iamVjdE1vdGhlci5nZXRUYWcoXCIxXCIpO1xyXG4gICAgICBhc3NlcnQuaW5zdGFuY2VPZihjb2xsZWN0ZWRUYWcuZW5kVGFnLCBTZWxlY3Rpb24uTm9kZVdhbGtlciwgJ2VuZCB0YWcgaXMgaW5zdGFuY2Ugb2YgTm9kZVdhbGtlcicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCd3aGVuIHN0YXJ0IHRhZyBhbmQgZW5kIHRhZyBhcmUgaW5zaWRlIHRoZSBzYW1lIGNvbnRhaW5lcicsIGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIga2I7XHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIGZha2VDb250YWluZXJFbCA9IG9iamVjdE1vdGhlci5zaW5nbGVFbmRUYWdTYW1wbGUoKTtcclxuICAgICAgc3RhcnRDb250YWluZXIgPSBmYWtlQ29udGFpbmVyRWwuZmlyc3RDaGlsZDtcclxuICAgICAgZW5kQ29udGFpbmVyID0gZmFrZUNvbnRhaW5lckVsLmxhc3RDaGlsZDtcclxuXHJcbiAgICAgIG5vZGVXYWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoc3RhcnRDb250YWluZXIpO1xyXG4gICAgICBlbmQgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoZW5kQ29udGFpbmVyKTtcclxuXHJcbiAgICAgIG9iamVjdE1vdGhlci5zdHViUmVtb3ZlSW5saW5lKCk7XHJcbiAgICAgIGtiID0gb2JqZWN0TW90aGVyLmtiO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIG9iamVjdE1vdGhlci5yZXNldFJlbW92ZUlubGluZVN0dWIoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdjYWxscyBLZXlib2FyZEJpbmRpbmdzI19yZW1vdmVJbmxpbmUgd2l0aCBlbmQgdGFnIGVsZW1lbnQnLCBmdW5jdGlvbigpe1xyXG4gICAgICAvLyBhcnJhbmdlXHJcbiAgICAgIC8vIGFjdFxyXG4gICAgICBpZGVudGlmeVRhZ3NJbkNvbnRhaW5lcigpO1xyXG4gICAgICAvLyBhc3NlcnRcclxuICAgICAgdmFyIGVsZW1lbnQgPSBrYi5fcmVtb3ZlSW5saW5lLmdldENhbGwoMCkuYXJnc1swXTtcclxuICAgICAgYXNzZXJ0KGtiLl9yZW1vdmVJbmxpbmUuY2FsbGVkLCAnX3JlbW92ZSBpbmxpbmUgbWV0aG9kIHdhcyBjYWxsZWQnKTtcclxuICAgICAgYXNzZXJ0LmVxdWFsKGVsZW1lbnQuZGF0YXNldC50eXBlLCAnZW5kLXRhZycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3JlbW92ZXMgdGhlIHRhZ0lkIGZyb20gdGFncycsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIC8vIGFycmFuZ2VcclxuICAgICAgLy8gYWN0XHJcbiAgICAgIGlkZW50aWZ5VGFnc0luQ29udGFpbmVyKCk7XHJcbiAgICAgIC8vIGFzc2VydFxyXG4gICAgICBhc3NlcnQuaXNVbmRlZmluZWQob2JqZWN0TW90aGVyLmdldFRhZygnMScpKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTsiLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcclxudmFyIENyb3NzU2VnbWVudFNlbGVjdGlvbk9iamVjdE1vdGhlciA9IHJlcXVpcmUoJy4uLy4uL3N1cHBvcnQvQ3Jvc3NTZWdtZW50U2VsZWN0aW9uT2JqZWN0TW90aGVyJyk7XHJcblxyXG5kZXNjcmliZSgnS2V5Ym9hcmRCaW5kaW5ncyNpc0Nyb3NzU2VnbWVudFNlbGVjdGlvbicsIGZ1bmN0aW9uKCl7XHJcbiAgdmFyIGlzQ3Jvc3NTZWdtZW50U2VsZWN0aW9uLFxyXG4gICAgICBvYmplY3RNb3RoZXIsXHJcbiAgICAgIHJlc3VsdDtcclxuXHJcbiAgaXNDcm9zc1NlZ21lbnRTZWxlY3Rpb24gPSBmdW5jdGlvbigpe1xyXG4gICAgcmV0dXJuIG9iamVjdE1vdGhlci5rZXlib2FyZEJpbmRpbmdzLmlzQ3Jvc3NTZWdtZW50U2VsZWN0aW9uKCk7XHJcbiAgfTtcclxuXHJcbiAgYmVmb3JlRWFjaChmdW5jdGlvbigpe1xyXG4gICAgb2JqZWN0TW90aGVyID0gbmV3IENyb3NzU2VnbWVudFNlbGVjdGlvbk9iamVjdE1vdGhlcigpO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnIHdoZW4gY29tbW9uQW5jZXN0b3IgaXMgdWUtZWRpdGFibGUnLCBmdW5jdGlvbigpe1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpe1xyXG4gICAgICBvYmplY3RNb3RoZXIuc2V0dXBTZWxlY3Rpb25Db250ZXh0VG9IYXZlQ29tbW9uQW5jZXN0b3IoJ3VlLWVkaXRhYmxlJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goZnVuY3Rpb24oKXtcclxuICAgICAgb2JqZWN0TW90aGVyLnJlc2V0U2VsZWN0aW9uQ29udGV4dCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3JldHVybnMgdHJ1ZScsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJlc3VsdCA9IGlzQ3Jvc3NTZWdtZW50U2VsZWN0aW9uKCk7XHJcblxyXG4gICAgICBhc3NlcnQuaXNUcnVlKHJlc3VsdCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJyB3aGVuIGNvbW1vbkFuY2VzdG9yIGlzIG5vdCB1ZS1lZGl0YWJsZScsIGZ1bmN0aW9uKCl7XHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIG9iamVjdE1vdGhlci5zZXR1cFNlbGVjdGlvbkNvbnRleHRUb0hhdmVDb21tb25BbmNlc3RvcigndWUtaW5saW5lLWNvbnRlbnQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaChmdW5jdGlvbigpe1xyXG4gICAgICBvYmplY3RNb3RoZXIucmVzZXRTZWxlY3Rpb25Db250ZXh0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncmV0dXJucyBmYWxzZScsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJlc3VsdCA9IGlzQ3Jvc3NTZWdtZW50U2VsZWN0aW9uKCk7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShyZXN1bHQpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcclxudmFyIEtleWJvYXJkQmluZGluZ3NPYmplY3RNb3RoZXIgPSByZXF1aXJlKCcuLi8uLi9zdXBwb3J0L0tleWJvYXJkQmluZGluZ3NPYmplY3RNb3RoZXInKTtcclxudmFyIFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9zZWxlY3Rpb24nKTtcclxudmFyIEhlbHBlcnMgPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUvSGVscGVycycpO1xyXG5cclxuZGVzY3JpYmUoJ0tleWJvYXJkQmluZGluZ3MjdHJhbnNmb3JtVGFncycsZnVuY3Rpb24oKXtcclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgdmFyIG9iamVjdE1vdGhlcixcclxuICAgICAgdHJhbnNmb3JtVGFncyxcclxuICAgICAgZG9jdW1lbnRGcmFnbWVudFdhbGtlcixcclxuICAgICAgZG9jdW1lbnRGcmFnbWVudDtcclxuXHJcbiAgYmVmb3JlRWFjaChmdW5jdGlvbigpe1xyXG4gICAgb2JqZWN0TW90aGVyID0gbmV3IEtleWJvYXJkQmluZGluZ3NPYmplY3RNb3RoZXIoKTtcclxuXHJcbiAgICB0cmFuc2Zvcm1UYWdzID0gZnVuY3Rpb24oKXtcclxuICAgICAgZG9jdW1lbnRGcmFnbWVudFdhbGtlciA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihkb2N1bWVudEZyYWdtZW50KTtcclxuICAgICAgb2JqZWN0TW90aGVyLmtiLnRyYW5zZm9ybVRhZ3MoZG9jdW1lbnRGcmFnbWVudFdhbGtlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIG9iamVjdE1vdGhlci5hc3NpZ25UYWdzQ29udGFpbmVyKCk7XHJcblxyXG4gICAgc2V0dXBDb2RlU2FtcGxlKCk7XHJcbiAgfSk7XHJcblxyXG4gIGFmdGVyRWFjaChmdW5jdGlvbigpe1xyXG4gICAgb2JqZWN0TW90aGVyLmRlbGV0ZVRhZ3NDb250YWluZXIoKTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3doZW4gdGFncyBjb250YWluIHRoZSB0YWcgaWQnLCBmdW5jdGlvbigpe1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpe1xyXG4gICAgICBvYmplY3RNb3RoZXIua2IudGFnc1tcIjFcIl0gPSB7fTtcclxuICAgIH0pO1xyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIGRlbGV0ZSBvYmplY3RNb3RoZXIua2IudGFnc1tcIjFcIl07XHJcbiAgICB9KTtcclxuICAgIGl0KCdyZXBsYWNlcyB0YWcgcGFpciBjb250ZW50IHdpdGggaW5uZXIgY29udGVudCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIC8vIGFycmFuZ2VcclxuICAgICAgLy8gYWN0XHJcbiAgICAgIHRyYW5zZm9ybVRhZ3MoKTtcclxuICAgICAgLy8gYXNzZXJ0XHJcbiAgICAgIGFzc2VydCghdGFnUGFpckZvdW5kSW5Eb2N1bWVudEZyYWdtZW50KCksICd0aGVyZSBhcmUgbm8gdGFnIGNvbnRhaW5lcnMgaW4gZG9jdW1lbnQgZnJhZ21lbnQnKTtcclxuICAgIH0pO1xyXG4gICAgaXQoJ21vdmVzIHN0YXJ0IHRhZ3MgdG8gdGhlIGVuZCB0YWdzIGNvbGxlY3Rpb24nLCBmdW5jdGlvbigpe1xyXG4gICAgICAvLyBhcnJhbmdlXHJcbiAgICAgIC8vIGFjdFxyXG4gICAgICB0cmFuc2Zvcm1UYWdzKCk7XHJcbiAgICAgIC8vIGFzc2VydFxyXG4gICAgICBhc3NlcnQubGVuZ3RoT2Yob2JqZWN0TW90aGVyLmtiLm1vdmVUYWdzVG9FbmQsIDEpO1xyXG5cclxuICAgIH0pO1xyXG4gICAgaXQoJ21vdmVzIGVuZCB0YWdzIHRvIHRoZSBzdGFydCB0YWdzIGNvbGxlY3Rpb24nLCBmdW5jdGlvbigpe1xyXG4gICAgICAvLyBhcnJhbmdlXHJcbiAgICAgIC8vIGFjdFxyXG4gICAgICB0cmFuc2Zvcm1UYWdzKCk7XHJcbiAgICAgIC8vIGFzc2VydFxyXG4gICAgICBhc3NlcnQubGVuZ3RoT2Yob2JqZWN0TW90aGVyLmtiLm1vdmVUYWdzVG9Gcm9udCwgMSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gdGFnUGFpckZvdW5kSW5Eb2N1bWVudEZyYWdtZW50KCl7XHJcbiAgICB2YXIgd2Fsa2VyLFxyXG4gICAgICAgIGZvdW5kVGFnQ29udGFpbmVyID0gZmFsc2U7XHJcbiAgICB3YWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoZG9jdW1lbnRGcmFnbWVudCkuZmlyc3RDaGlsZCgpO1xyXG5cclxuICAgIGRve1xyXG4gICAgICBpZih3YWxrZXIuaXNUYWdQYWlyQ29udGFpbmVyKCkpe1xyXG4gICAgICAgIGZvdW5kVGFnQ29udGFpbmVyID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICB3YWxrZXIgPSB3YWxrZXIubmV4dCgpO1xyXG4gICAgfXdoaWxlKCF3YWxrZXIuaXNOdWxsKCkpO1xyXG4gICAgcmV0dXJuIGZvdW5kVGFnQ29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0dXBDb2RlU2FtcGxlKCl7XHJcbiAgICB2YXIgc2FtcGxlLFxyXG4gICAgICAgIGNoaWxkO1xyXG5cclxuICAgIGRvY3VtZW50RnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICBzYW1wbGUgPSBIZWxwZXJzLnN0cmluZ1RvSFRNTEVsZW1lbnQoJzxkaXY+PHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCI+dGV4dDwvc3Bhbj4nK1xyXG4gICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIiBkYXRhLWlkPVwiMVwiIGRhdGEtdHlwZT1cInN0YXJ0LXRhZ1wiPicrXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZyB1ZS10YWctc3RhcnRcIj5jZjwvc3Bhbj4nICtcclxuICAgICAgJyZ6d25qOycrXHJcbiAgICAnPC9zcGFuPicgK1xyXG4gICAgJzxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudCB1ZS10YWdwYWlyLWNvbnRlbnRcIiBkYXRhLXR5cGU9XCJ0YWdwYWlyXCIgZGF0YS1pZD1cIjFcIj4nK1xyXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIj5zYW1wbGU8L3NwYW4+JyArXHJcbiAgICAnPC9kaXY+JyArXHJcbiAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWctd3JhcHBlclwiIGRhdGEtaWQ9XCIxXCIgZGF0YS10eXBlPVwiZW5kLXRhZ1wiPicrXHJcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnIHVlLXRhZy1zdGFydFwiPmNmPC9zcGFuPicgK1xyXG4gICAgICAgICcmenduajsnK1xyXG4gICAgJzwvc3Bhbj48L2Rpdj4nXHJcbiAgICApO1xyXG5cclxuICAgIHdoaWxlKHNhbXBsZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApe1xyXG4gICAgICBjaGlsZCA9IHNhbXBsZS5jaGlsZE5vZGVzWzBdO1xyXG4gICAgICBkb2N1bWVudEZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgIH1cclxuICB9XHJcbn0pOyIsIi8qIEZpbGU6IE1vdXNlQ3RybENsaWNrSGFuZGxlcl9hY2NlcHRhbmNlX3Rlc3QuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyBkZXNjcmliZSwgaXQsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcclxudmFyIGggPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUvSGVscGVycycpLnN0cmluZ1RvSFRNTEVsZW1lbnQ7XHJcbnZhciBNb3VzZUhhbmRsZXJGaXh0dXJlID0gcmVxdWlyZSgnLi9Nb3VzZUhhbmRsZXJzRml4dHVyZScpO1xyXG52YXIgTW91c2VDdHJsQ2xpY2tIYW5kbGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vYXNzZXRzL2pzL3VlL21vdXNlL0N0cmxDbGlja0hhbmRsZXInKTtcclxudmFyIEZha2VFdmVudCA9IHJlcXVpcmUoJy4uLy4uL3N1cHBvcnQvRmFrZUV2ZW50Jyk7XHJcbnZhciBOb2RlV2Fsa2VyID0gcmVxdWlyZSgnLi4vLi4vLi4vYXNzZXRzL2pzL3VlL3NlbGVjdGlvbicpLk5vZGVXYWxrZXI7XHJcblxyXG5kZXNjcmliZSgnTW91c2VDdHJsQ2xpY2tIYW5kbGVyOmFjY2VwdGFuY2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNvdXJjZSA9IGgoJzxkaXYgY2xhc3M9XCJ1ZS1zb3VyY2VcIi8+JyksXHJcbiAgICB0YXJnZXQgPSBoKCc8ZGl2IGNsYXNzPVwidWUtdGFyZ2V0XCIvPicpLFxyXG4gICAgZml4dHVyZSxcclxuICAgIGZpeHR1cmVFbCxcclxuICAgIGNsaWNrZWRUYWcsXHJcbiAgICB0YXJnZXROb2RlLFxyXG4gICAgdGFyZ2V0T2Zmc2V0UmFuZ2VTdGFydCA9IDIsXHJcbiAgICB0YXJnZXRPZmZzZXRSYW5nZUVuZCA9IDUsXHJcbiAgICBzZWxlY3Rpb24sXHJcbiAgICByYW5nZSxcclxuICAgIGN0cmxDbGlja0hhbmRsZXIsXHJcbiAgICBldiA9IG5ldyBGYWtlRXZlbnQoKSxcclxuICAgIGV4cGVjdGVkVGFnSW5UYXJnZXQ7XHJcblxyXG4gIGZ1bmN0aW9uIHRhZ1BhaXJGaXh0dXJlU2V0dXAoKSB7XHJcbiAgICBzb3VyY2UuYXBwZW5kQ2hpbGQoZml4dHVyZS5zb3VyY2VXaXRoVGFnUGFpcigpKTtcclxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChmaXh0dXJlLnRhcmdldFdpdGhUZXh0KCkpO1xyXG5cclxuICAgIGNsaWNrZWRUYWcgPSBzb3VyY2UucXVlcnlTZWxlY3RvcignLnVlLXRhZy13cmFwcGVyJyk7XHJcbiAgICB0YXJnZXROb2RlID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJy51ZS10ZXh0JykuY2hpbGROb2Rlc1swXTtcclxuXHJcbiAgICBmaXh0dXJlRWwuYXBwZW5kQ2hpbGQoc291cmNlKTtcclxuICAgIGZpeHR1cmVFbC5hcHBlbmRDaGlsZCh0YXJnZXQpO1xyXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmaXh0dXJlRWwpO1xyXG5cclxuICAgIGN0cmxDbGlja0hhbmRsZXIgPSBuZXcgTW91c2VDdHJsQ2xpY2tIYW5kbGVyKCk7XHJcblxyXG4gICAgZXYuc2V0Q3VycmVudFRhcmdldChjbGlja2VkVGFnKTtcclxuICAgIGV2LnNldEN0cmxLZXkodHJ1ZSk7XHJcbiAgICBldi5zZXRMZWZ0QnV0dG9uUHJlc3NlZCgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcGxhY2Vob2xkZXJGaXh0dXJlU2V0dXAoKSB7XHJcbiAgICBzb3VyY2UuYXBwZW5kQ2hpbGQoZml4dHVyZS5zb3VyY2VXaXRoUGxhY2Vob2xkZXIoKSk7XHJcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZml4dHVyZS50YXJnZXRXaXRoVGV4dCgpKTtcclxuXHJcblxyXG4gICAgY2xpY2tlZFRhZyA9IHNvdXJjZS5xdWVyeVNlbGVjdG9yKCcudWUtdGFnLXdyYXBwZXInKTtcclxuICAgIHRhcmdldE5vZGUgPSB0YXJnZXQucXVlcnlTZWxlY3RvcignLnVlLXRleHQnKS5jaGlsZE5vZGVzWzBdO1xyXG5cclxuICAgIGZpeHR1cmVFbC5hcHBlbmRDaGlsZChzb3VyY2UpO1xyXG4gICAgZml4dHVyZUVsLmFwcGVuZENoaWxkKHRhcmdldCk7XHJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZpeHR1cmVFbCk7XHJcblxyXG4gICAgY3RybENsaWNrSGFuZGxlciA9IG5ldyBNb3VzZUN0cmxDbGlja0hhbmRsZXIoKTtcclxuXHJcbiAgICBldi5zZXRDdXJyZW50VGFyZ2V0KGNsaWNrZWRUYWcpO1xyXG4gICAgZXYuc2V0Q3RybEtleSh0cnVlKTtcclxuICAgIGV2LnNldExlZnRCdXR0b25QcmVzc2VkKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByYW5nZVNlbGVjdGlvbigpIHtcclxuICAgIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xyXG4gICAgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xyXG4gICAgLy8gY2FyZXQgc2VsZWN0aW9uXHJcbiAgICByYW5nZS5zZXRTdGFydCh0YXJnZXROb2RlLCB0YXJnZXRPZmZzZXRSYW5nZVN0YXJ0KTtcclxuICAgIHJhbmdlLnNldEVuZCh0YXJnZXROb2RlLCB0YXJnZXRPZmZzZXRSYW5nZUVuZCk7XHJcblxyXG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xyXG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhcmV0U2VsZWN0aW9uKCkge1xyXG4gICAgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XHJcbiAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAvLyBjYXJldCBzZWxlY3Rpb25cclxuICAgIHJhbmdlLnNldFN0YXJ0KHRhcmdldE5vZGUsIHRhcmdldE9mZnNldFJhbmdlU3RhcnQpO1xyXG4gICAgcmFuZ2Uuc2V0RW5kKHRhcmdldE5vZGUsIHRhcmdldE9mZnNldFJhbmdlU3RhcnQpO1xyXG5cclxuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcclxuICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBkb2N1bWVudENsZWFudXAoKSB7XHJcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGZpeHR1cmVFbCk7XHJcbiAgICBzb3VyY2UuaW5uZXJIVE1MID0gJyc7XHJcbiAgICB0YXJnZXQuaW5uZXJIVE1MID0gJyc7XHJcbiAgICBmaXh0dXJlLmlubmVySFRNTCA9ICcnO1xyXG4gIH1cclxuXHJcbiAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICBmaXh0dXJlID0gbmV3IE1vdXNlSGFuZGxlckZpeHR1cmUoKTtcclxuICAgIGZpeHR1cmVFbCA9IGgoJzxkaXYgaWQ9XCJmaXh0dXJlXCIvPicpO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgndGFnIHBhaXIgY29weSBiZWhhdmlvcicsIGZ1bmN0aW9uICgpIHtcclxuICAgIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGRvY3VtZW50Q2xlYW51cCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRhZ1BhaXJGaXh0dXJlU2V0dXAoKTtcclxuICAgICAgcmFuZ2VTZWxlY3Rpb24oKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdjb3BpZXMgc2VsZWN0ZWQgc3RhcnQgdGFnIHBhaXIgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0JywgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgY3RybENsaWNrSGFuZGxlci5oYW5kbGUoZXYpO1xyXG5cclxuICAgICAgZXhwZWN0ZWRUYWdJblRhcmdldCA9IHRhcmdldC5xdWVyeVNlbGVjdG9yKCcudWUtdGFnLXdyYXBwZXInKTtcclxuXHJcbiAgICAgIGFzc2VydC5lcXVhbChleHBlY3RlZFRhZ0luVGFyZ2V0LmRhdGFzZXQudHlwZSwgJ3N0YXJ0LXRhZycsICdzdGFydCB0YWcgaXMgbW92ZWQgaW4gdGFyZ2V0IHNlZ21lbnQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdyZW1vdmVzIC5hY3RpdmUgY3NzIGNsYXNzIGZyb20gc3RhcnQgdGFnJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBjbGlja2VkVGFnLmZpcnN0Q2hpbGQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcblxyXG4gICAgICBjdHJsQ2xpY2tIYW5kbGVyLmhhbmRsZShldik7XHJcblxyXG4gICAgICBleHBlY3RlZFRhZ0luVGFyZ2V0ID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJy51ZS10YWctd3JhcHBlcicpLmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShleHBlY3RlZFRhZ0luVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyksICcuYWN0aXZlIGNzcyBjbGFzcyB3YXMgcmVtb3ZlZCBmcm9tIHN0YXJ0IHRhZycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2NoYW5nZXMgdGhlIGNhbkNvcHkgYXR0cmlidXRlIHRvIGZhbHNlIG9uIHRhZyBzdGFydCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHN0YXJ0VGFnO1xyXG5cclxuICAgICAgY3RybENsaWNrSGFuZGxlci5oYW5kbGUoZXYpO1xyXG5cclxuICAgICAgc3RhcnRUYWcgPSB0YXJnZXQucXVlcnlTZWxlY3RvcignLnVlLXRhZy1zdGFydCcpLnBhcmVudE5vZGU7XHJcbiAgICAgIGFzc2VydC5lcXVhbChzdGFydFRhZy5kYXRhc2V0LnRhZ0NvcHksICdmYWxzZScsICd0YWcgY29weSBpcyBzZXQgdG8gZmFsc2UnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdjaGFuZ2VzIHRoZSBjYW5Db3B5IGF0dHJpYnV0ZSB0byBmYWxzZSBvbiB0YWcgZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZW5kVGFnO1xyXG5cclxuICAgICAgY3RybENsaWNrSGFuZGxlci5oYW5kbGUoZXYpO1xyXG5cclxuICAgICAgZW5kVGFnID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJy51ZS10YWctZW5kJykucGFyZW50Tm9kZTtcclxuICAgICAgYXNzZXJ0LmVxdWFsKGVuZFRhZy5kYXRhc2V0LnRhZ0NvcHksICdmYWxzZScsICd0YWcgY29weSBpcyBzZXQgdG8gZmFsc2UnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdjb3BpZXMgc2VsZWN0ZWQgZW5kIHRhZyBwYWlyIGZyb20gc291cmNlIHRvIHRhcmdldCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgY2xpY2tlZFRhZyA9IHNvdXJjZS5xdWVyeVNlbGVjdG9yQWxsKCcudWUtdGFnLXdyYXBwZXInKS5pdGVtKDEpO1xyXG4gICAgICBldi5zZXRDdXJyZW50VGFyZ2V0KGNsaWNrZWRUYWcpO1xyXG5cclxuICAgICAgY3RybENsaWNrSGFuZGxlci5oYW5kbGUoZXYpO1xyXG5cclxuICAgICAgZXhwZWN0ZWRUYWdJblRhcmdldCA9IHRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKCcudWUtdGFnLXdyYXBwZXInKS5pdGVtKDEpO1xyXG5cclxuICAgICAgYXNzZXJ0LmVxdWFsKGV4cGVjdGVkVGFnSW5UYXJnZXQuZGF0YXNldC50eXBlLCAnZW5kLXRhZycsICdzdGFydCB0YWcgaXMgbW92ZWQgaW4gdGFyZ2V0IHNlZ21lbnQnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdyZW1vdmVzIHRoZSAuYWN0aXZlIGNzcyBjbGFzcyBmcm9tIGVuZC10YWcnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGNsaWNrZWRUYWcgPSBzb3VyY2UucXVlcnlTZWxlY3RvckFsbCgnLnVlLXRhZy13cmFwcGVyJykuaXRlbSgxKTtcclxuICAgICAgY2xpY2tlZFRhZy5maXJzdENoaWxkLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xyXG4gICAgICBldi5zZXRDdXJyZW50VGFyZ2V0KGNsaWNrZWRUYWcpO1xyXG5cclxuICAgICAgY3RybENsaWNrSGFuZGxlci5oYW5kbGUoZXYpO1xyXG5cclxuICAgICAgZXhwZWN0ZWRUYWdJblRhcmdldCA9IHRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKCcudWUtdGFnLXdyYXBwZXInKS5pdGVtKDEpLmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShleHBlY3RlZFRhZ0luVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyksICcuYWN0aXZlIGNzcyBjbGFzcyB3YXMgcmVtb3ZlZCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG5cclxuICBkZXNjcmliZSgncGxhY2Vob2xkZXIgY29weSBiZWhhdmlvcicsIGZ1bmN0aW9uICgpIHtcclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgcGxhY2Vob2xkZXJGaXh0dXJlU2V0dXAoKTtcclxuXHJcbiAgICAgIHJhbmdlU2VsZWN0aW9uKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBkb2N1bWVudENsZWFudXAoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdjb3BpZXMgdGhlIHBsYWNlaG9sZGVyIGZyb20gc291cmNlIHRvIHRhcmdldCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgY3RybENsaWNrSGFuZGxlci5oYW5kbGUoZXYpO1xyXG5cclxuICAgICAgZXhwZWN0ZWRUYWdJblRhcmdldCA9IHRhcmdldC5xdWVyeVNlbGVjdG9yKCcudWUtdGFnLXdyYXBwZXInKTtcclxuXHJcbiAgICAgIGFzc2VydC5lcXVhbChleHBlY3RlZFRhZ0luVGFyZ2V0LmRhdGFzZXQudHlwZSwgJ3BsYWNlaG9sZGVyJywgJ3N0YXJ0IHRhZyBpcyBtb3ZlZCBpbiB0YXJnZXQgc2VnbWVudCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3JlbW92ZXMgdGhlIC5hY3RpdmUgY3NzIGNsYXNzIGZyb20gdGhlIHBsYWNlaG9sZGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBjbGlja2VkVGFnLmZpcnN0Q2hpbGQuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XHJcblxyXG4gICAgICBjdHJsQ2xpY2tIYW5kbGVyLmhhbmRsZShldik7XHJcblxyXG4gICAgICBleHBlY3RlZFRhZ0luVGFyZ2V0ID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJy51ZS10YWctd3JhcHBlcicpLmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgICBhc3NlcnQuaXNGYWxzZShleHBlY3RlZFRhZ0luVGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyksICcuYWN0aXZlIGNzcyBjbGFzcyB3YXMgcmVtb3ZlZCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2NoYW5nZXMgdGhlIHRhZ0NvcHkgdG8gZmFsc2Ugb24gcGxhY2Vob2xkZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGN0cmxDbGlja0hhbmRsZXIuaGFuZGxlKGV2KTtcclxuXHJcbiAgICAgIGV4cGVjdGVkVGFnSW5UYXJnZXQgPSB0YXJnZXQucXVlcnlTZWxlY3RvcignLnVlLXRhZy13cmFwcGVyJyk7XHJcblxyXG4gICAgICBhc3NlcnQuZXF1YWwoZXhwZWN0ZWRUYWdJblRhcmdldC5kYXRhc2V0LnRhZ0NvcHksICdmYWxzZScsICd0YWdDb3B5IGhhcyBiZWVuIGNoYW5nZWQgdG8gZmFsc2UnKTtcclxuICAgIH0pO1xyXG5cclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3BsYWNlaG9sZGVyIGNhcmV0IHBvc2l0aW9uIGFmdGVyIGNvcHknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZm9jdXNOb2RlO1xyXG5cclxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICBwbGFjZWhvbGRlckZpeHR1cmVTZXR1cCgpO1xyXG4gICAgICBjYXJldFNlbGVjdGlvbigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgZG9jdW1lbnRDbGVhbnVwKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncGxhY2VzIHRoZSBjdXJzb3IgYWZ0ZXIgdGhlIHBsYWNlaG9sZGVyIG9uIHRoZSBpbnZpc2libGUgY2hhcmFjdGVyJywgZnVuY3Rpb24gKGRvbmVBc3luYykge1xyXG4gICAgICBjdHJsQ2xpY2tIYW5kbGVyLmhhbmRsZShldik7XHJcblxyXG4gICAgICBfLmRlbGF5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICBmb2N1c05vZGUgPSBuZXcgTm9kZVdhbGtlcihzZWxlY3Rpb24uZm9jdXNOb2RlKTtcclxuICAgICAgICBhc3NlcnQuaXNUcnVlKGZvY3VzTm9kZS5pc0ludmlzaWJsZUNoYXIoKSwgJ2ZvY3VzIGlzIHNldCBvbiBpbnZpc2libGUgY2hhcicpO1xyXG4gICAgICAgIGRvbmVBc3luYygpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdwbGFjZXMgdGhlIGN1cnNvciBpbnNpZGUgdGhlIHBsYWNlaG9sZGVyIHRhZycsIGZ1bmN0aW9uIChkb25lQXN5bmMpIHtcclxuICAgICAgdmFyIHBhcmVudE5vZGU7XHJcbiAgICAgIGN0cmxDbGlja0hhbmRsZXIuaGFuZGxlKGV2KTtcclxuXHJcbiAgICAgIF8uZGVsYXkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgIGZvY3VzTm9kZSA9IG5ldyBOb2RlV2Fsa2VyKHNlbGVjdGlvbi5mb2N1c05vZGUpO1xyXG4gICAgICAgIHBhcmVudE5vZGUgPSBmb2N1c05vZGUucGFyZW50KCk7XHJcbiAgICAgICAgYXNzZXJ0LmlzVHJ1ZShwYXJlbnROb2RlLmlzUGxhY2Vob2xkZXIoKSwgJ2ZvY3VzIGlzIGluc2lkZSBwbGFjZWhvbGRlcicpO1xyXG4gICAgICAgIGRvbmVBc3luYygpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgndGFnIHBhaXIgY2FyZXQgcG9zaXRpb24gYWZ0ZXIgY29weScsIGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBmb2N1c05vZGUsXHJcbiAgICAgICAgcGFyZW50Tm9kZTtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGFnUGFpckZpeHR1cmVTZXR1cCgpO1xyXG4gICAgICBjYXJldFNlbGVjdGlvbigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgZG9jdW1lbnRDbGVhbnVwKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncGxhY2VzIHRoZSBjdXJzb3Igb24gdGhlIGludmlzaWJsZSBjaGFyYWN0ZXInLCBmdW5jdGlvbiAoZG9uZUFzeW5jKSB7XHJcblxyXG4gICAgICBjdHJsQ2xpY2tIYW5kbGVyLmhhbmRsZShldik7XHJcblxyXG4gICAgICBfLmRlbGF5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgICBmb2N1c05vZGUgPSBuZXcgTm9kZVdhbGtlcihzZWxlY3Rpb24uZm9jdXNOb2RlKTtcclxuICAgICAgICBhc3NlcnQuaXNUcnVlKGZvY3VzTm9kZS5pc0ludmlzaWJsZUNoYXIoKSwgJ2ZvY3VzIGlzIHNldCBvbiBpbnZpc2libGUgY2hhcicpO1xyXG4gICAgICAgIGRvbmVBc3luYygpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdwbGFjZXMgdGhlIGN1cnNvciBpbnNpZGUgdGhlIHN0YXJ0IHRhZycsIGZ1bmN0aW9uIChkb25lQXN5bmMpIHtcclxuXHJcbiAgICAgIGN0cmxDbGlja0hhbmRsZXIuaGFuZGxlKGV2KTtcclxuXHJcbiAgICAgIF8uZGVsYXkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgIGZvY3VzTm9kZSA9IG5ldyBOb2RlV2Fsa2VyKHNlbGVjdGlvbi5mb2N1c05vZGUpO1xyXG4gICAgICAgIHBhcmVudE5vZGUgPSBmb2N1c05vZGUucGFyZW50KCk7XHJcbiAgICAgICAgYXNzZXJ0LmlzVHJ1ZShwYXJlbnROb2RlLmlzU3RhcnRUYWcoKSwgJ2ludmlzaWJsZSB0ZXh0IG5vZGUgcGFyZW50IGlzIHN0YXJ0IHRhZycpO1xyXG4gICAgICAgIGRvbmVBc3luYygpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgndGFnIHBhaXIgY29udGVudCBzZWxlY3Rpb24nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZm9jdXNOb2RlLFxyXG4gICAgICAgIHBhcmVudE5vZGU7XHJcblxyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRhZ1BhaXJGaXh0dXJlU2V0dXAoKTtcclxuICAgICAgcmFuZ2VTZWxlY3Rpb24oKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGRvY3VtZW50Q2xlYW51cCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3NlbGVjdHMgdGhlIGlubmVyIGNvbnRlbnQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICBjdHJsQ2xpY2tIYW5kbGVyLmhhbmRsZShldik7XHJcblxyXG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcclxuICAgICAgZm9jdXNOb2RlID0gbmV3IE5vZGVXYWxrZXIoc2VsZWN0aW9uLmZvY3VzTm9kZSk7XHJcbiAgICAgIHBhcmVudE5vZGUgPSBmb2N1c05vZGUucGFyZW50KCk7XHJcbiAgICAgIGFzc2VydC5pc1RydWUoZm9jdXNOb2RlLmlzVGV4dE5vZGUoKSwgJ2ZvY3VzIGlzIHNldCBvbiB0ZXh0IG5vZGUnKTtcclxuICAgICAgYXNzZXJ0LmlzVHJ1ZShwYXJlbnROb2RlLmlzSW5saW5lQ29udGVudCgpLCAnZm9jdXMgaXMgaW5zaWRlIGlubGluZSBjb250ZW50Jyk7XHJcbiAgICB9KTtcclxuXHJcbiAgfSk7XHJcbn0pO1xyXG4iLCIvKiBGaWxlOiBNb3VzZUN0cmxDbGlja0hhbmRsZXJfdGVzdC5qcyAqL1xyXG4vKiBqc2hpbnQgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xyXG4vKiBnbG9iYWxzIGRlc2NyaWJlLCBiZWZvcmVFYWNoLCBpdCAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBNb3VzZUN0cmxDbGlja0hhbmRsZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUvTW91c2UnKS5DdHJsQ2xpY2tIYW5kbGVyO1xyXG52YXIgTW91c2VIYW5kbGVyc0ZpeHR1cmUgPSByZXF1aXJlKCcuL01vdXNlSGFuZGxlcnNGaXh0dXJlJyk7XHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xyXG5cclxuZGVzY3JpYmUoJ01vdXNlQ3RybENsaWNrSGFuZGxlcicsIGZ1bmN0aW9uICgpIHtcclxuICB2YXIgY3RybENsaWNrSGFuZGxlcixcclxuICAgICAgZml4dHVyZSxcclxuICAgICAgaHRtbCxcclxuICAgICAgc2libGluZ1RhZyxcclxuICAgICAgc3RhcnRUYWdQYWlyLFxyXG4gICAgICBlbmRUYWdQYWlyLFxyXG4gICAgICBwbGFjZWhvbGRlcixcclxuICAgICAgaW5saW5lQ29udGVudCxcclxuICAgICAgaW5saW5lQ29udGVudENsb25lLFxyXG4gICAgICB0YWdFbGVtZW50cztcclxuXHJcbiAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICBjdHJsQ2xpY2tIYW5kbGVyID0gbmV3IE1vdXNlQ3RybENsaWNrSGFuZGxlcigpO1xyXG4gICAgZml4dHVyZSA9IG5ldyBNb3VzZUhhbmRsZXJzRml4dHVyZSgpO1xyXG4gIH0pO1xyXG5cclxufSk7XHJcbiIsIi8qIEZpbGU6IEN0cmxIb3ZlckhhbmRsZXIuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyBkZXNjcmliZSwgYmVmb3JlRWFjaCwgaXQqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBNb3VzZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9Nb3VzZScpO1xyXG52YXIgRmFrZUV2ZW50ID0gcmVxdWlyZSgnLi4vLi4vc3VwcG9ydC9GYWtlRXZlbnQnKTtcclxuXHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xyXG52YXIgaCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9IZWxwZXJzJykuc3RyaW5nVG9IVE1MRWxlbWVudDtcclxuXHJcbmRlc2NyaWJlKCdNb3VzZUN0cmxIb3ZlckhhbmRsZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG1vdXNlRXZlbnQsXHJcbiAgICAgIGN1cnJlbnRUYXJnZXQsXHJcbiAgICAgIGNoaWxkLFxyXG4gICAgICBtb3VzZUN0cmxIb3ZlckhhbmRsZXI7XHJcblxyXG4gIGRlc2NyaWJlKCcjbW91c2VPdmVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGN1cnJlbnRUYXJnZXQgPSBoKCc8ZGl2IGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIj48c3BhbiBjbGFzcz1cInVlLXRhZ1wiLz48L2Rpdj4nKTtcclxuICAgICAgY2hpbGQgPSBjdXJyZW50VGFyZ2V0LmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgICBtb3VzZUV2ZW50ID0gbmV3IEZha2VFdmVudCgpO1xyXG4gICAgICBtb3VzZUV2ZW50LnNldEN0cmxLZXkodHJ1ZSk7XHJcbiAgICAgIG1vdXNlRXZlbnQuc2V0VHlwZSgnbW91c2VvdmVyJyk7XHJcblxyXG4gICAgICBtb3VzZUV2ZW50LnNldEN1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCk7XHJcblxyXG4gICAgICBtb3VzZUN0cmxIb3ZlckhhbmRsZXIgPSBuZXcgTW91c2UuQ3RybEhvdmVySGFuZGxlcigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2FkZHMgdGhlIC5hY3RpdmUgY3NzIGNsYXNzIHRvIGN1cnJlbnRUYXJnZXQgY2hpbGRyZW4nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG1vdXNlQ3RybEhvdmVySGFuZGxlci5tb3VzZU92ZXIobW91c2VFdmVudCk7XHJcblxyXG4gICAgICBhc3NlcnQoY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSwgJy5hY3RpdmUgY2xhc3MgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGN1cnJlbnQgdGFyZ2V0IGNoaWxkIG5vZGUnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCd3aGVuIGN0cmwgaXMgbm90IHByZXNzZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG1vdXNlRXZlbnQuc2V0Q3RybEtleShmYWxzZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaXQoJ2RvZXMgbm90IGFkZCB0aGUgLmFjdGl2ZSBjc3MgY2xhc3MgdG8gY3VycmVudFRhcmdldCBjaGlsZHJlbicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBtb3VzZUN0cmxIb3ZlckhhbmRsZXIubW91c2VPdmVyKG1vdXNlRXZlbnQpO1xyXG5cclxuICAgICAgICBhc3NlcnQuaXNGYWxzZShjaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpLCAnLmFjdGl2ZSBjbGFzcyBoYXMgYmVlbiBhZGRlZCB0byB0aGUgY3VycmVudCB0YXJnZXQgY2hpbGQgbm9kZScpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCd3aGVuIGV2ZW50LnR5cGUgaXMgbm90IG1vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbW91c2VFdmVudC5zZXRUeXBlKCdzb21ldGhpbmctZWxzZScpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGl0KCdkb2VzIG5vdCBhZGQgdGhlIC5hY3RpdmUgY3NzIGNsYXNzIHRvIGN1cnJlbnRUYXJnZXQgY2hpbGRyZW4nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbW91c2VDdHJsSG92ZXJIYW5kbGVyLm1vdXNlT3Zlcihtb3VzZUV2ZW50KTtcclxuXHJcbiAgICAgICAgYXNzZXJ0LmlzRmFsc2UoY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSwgJy5hY3RpdmUgY2xhc3MgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGN1cnJlbnQgdGFyZ2V0IGNoaWxkIG5vZGUnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJyNtb3VzZUxlYXZlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGN1cnJlbnRUYXJnZXQgPSBoKCc8ZGl2IGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIj48c3BhbiBjbGFzcz1cInVlLXRhZyBhY3RpdmVcIi8+PC9kaXY+Jyk7XHJcbiAgICAgIGNoaWxkID0gY3VycmVudFRhcmdldC5maXJzdENoaWxkO1xyXG5cclxuICAgICAgbW91c2VFdmVudCA9IG5ldyBGYWtlRXZlbnQoKTtcclxuICAgICAgbW91c2VFdmVudC5zZXRDdHJsS2V5KHRydWUpO1xyXG4gICAgICBtb3VzZUV2ZW50LnNldFR5cGUoJ21vdXNlbGVhdmUnKTtcclxuXHJcbiAgICAgIG1vdXNlRXZlbnQuc2V0Q3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KTtcclxuXHJcbiAgICAgIG1vdXNlQ3RybEhvdmVySGFuZGxlciA9IG5ldyBNb3VzZS5DdHJsSG92ZXJIYW5kbGVyKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncmVtb3ZlcyB0aGUgLmFjdGl2ZSBjc3MgY2xhc3MgZnJvbSB0aGUgY3VycmVudCB0YXJnZXQgY2hpbGQgbm9kZXMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG1vdXNlQ3RybEhvdmVySGFuZGxlci5tb3VzZUxlYXZlKG1vdXNlRXZlbnQpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzRmFsc2UoY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSwgJ3RoZSAuYWN0aXZlIGNsYXNzIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgY3VycmVudCB0YXJnZXQgY2hpbGQgbm9kZScpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ3doZW4gdGhlIGV2ZW50LnR5cGUgaXMgbm90IG1vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG1vdXNlRXZlbnQuc2V0VHlwZSgnc29tZXRoaW5nLWVsc2UnKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGl0KCdkb2VzIG5vdCByZW1vdmUgdGhlIC5hY3RpdmUgY2xhc3MnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbW91c2VDdHJsSG92ZXJIYW5kbGVyLm1vdXNlTGVhdmUobW91c2VFdmVudCk7XHJcblxyXG4gICAgICAgIGFzc2VydChjaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpLCAndGhlIC5hY3RpdmUgY2xhc3MgaGFzIGJlZW4gcHJlc2VydmVkIGZyb20gdGhlIGN1cnJlbnQgdGFyZ2V0IGNoaWxkIG5vZGUnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcblxyXG5cclxuIiwiLyogRmlsZTogTW91c2VIYW5kbGVyc0ZpeHR1cmUuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG52YXIgcHJvdG87XHJcbnZhciBoO1xyXG5cclxuaCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9IZWxwZXJzJykuc3RyaW5nVG9IVE1MRWxlbWVudDtcclxuXHJcbmZ1bmN0aW9uIE1vdXNlSGFuZGxlcnNGaXh0dXJlKCkge1xyXG59XHJcblxyXG5wcm90byA9IE1vdXNlSGFuZGxlcnNGaXh0dXJlLnByb3RvdHlwZTtcclxuXHJcbnByb3RvLnNvdXJjZVdpdGhUYWdQYWlyID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciByZXN1bHQ7XHJcblxyXG4gIHJlc3VsdCA9IGgoXHJcbiAgICAnPGRpdiBjbGFzcz1cInVlLXNlZ21lbnRcIiBkYXRhLXNvdXJjZS1zZWdtZW50LW51bWJlcj1cIjNcIiBkYXRhLXNvdXJjZS1wdWlkPVwiZDU4MjdmZDktZGI4Yi00ZDA1LTljNTMtOGUwMjQ0YzhiM2JiXCIgc3R5bGU9XCJoZWlnaHQ6IDI3cHg7XCI+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwidWUtaW5saW5lLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWctd3JhcHBlclwiIGRhdGEtdHlwZT1cInN0YXJ0LXRhZ1wiIGRhdGEtdGFnLWNvcHk9XCJ0cnVlXCIgZGF0YS1pZD1cIjE5XCIgZGF0YS1tZXRhZGF0YT1cInVuZGVmaW5lZFwiIGRhdGEtY2FuLWhpZGU9XCJmYWxzZVwiPicgK1xyXG4gICAgICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnIHVlLXRhZy1zdGFydFwiIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCI+W3N0YXJ0LXRhZ108L3NwYW4+4oCMJyArXHJcbiAgICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgJzxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudCB1ZS10YWdwYWlyLWNvbnRlbnRcIiBkYXRhLXR5cGU9XCJ0YWdwYWlyXCIgZGF0YS1pZD1cIjE5XCIgZGF0YS1kZWZpbml0aW9uaWQ9XCI1XCIgZGF0YS1tZXRhZGF0YT1cInVuZGVmaW5lZFwiPicgK1xyXG4gICAgICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGV4dFwiIGRhdGEtdHlwZT1cInRleHRcIj4gaXMgYW4gb3JnYW5pemVkIGNvbGxlY3Rpb24gb2YgPC9zcGFuPicgK1xyXG4gICAgICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGV4dFwiIGRhdGEtdHlwZT1cInRleHRcIj4uPC9zcGFuPicgK1xyXG4gICAgICAnPC9kaXY+JyArXHJcbiAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZy13cmFwcGVyXCIgZGF0YS10eXBlPVwiZW5kLXRhZ1wiIGRhdGEtdGFnLWNvcHk9XCJ0cnVlXCIgZGF0YS1pZD1cIjE5XCIgZGF0YS1tZXRhZGF0YT1cInVuZGVmaW5lZFwiIGRhdGEtY2FuLWhpZGU9XCJmYWxzZVwiPicgK1xyXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZyB1ZS10YWctZW5kXCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIj5bZW5kLXRhZ108L3NwYW4+4oCMJyArXHJcbiAgICAgICc8L3NwYW4+JyArXHJcbiAgICAgICc8L2Rpdj4nICtcclxuICAgICc8L2Rpdj4nXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuXHJcbnByb3RvLnNvdXJjZVdpdGhQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcmVzdWx0O1xyXG5cclxuICByZXN1bHQgPSBoKFxyXG4gICAgICAnPGRpdiBjbGFzcz1cInVlLXNlZ21lbnRcIiBkYXRhLXNvdXJjZS1zZWdtZW50LW51bWJlcj1cIjNcIiBkYXRhLXNvdXJjZS1wdWlkPVwiZDU4MjdmZDktZGI4Yi00ZDA1LTljNTMtOGUwMjQ0YzhiM2JiXCIgc3R5bGU9XCJoZWlnaHQ6IDI3cHg7XCI+JyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudFwiPicgK1xyXG4gICAgICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnLXdyYXBwZXJcIiBkYXRhLXR5cGU9XCJwbGFjZWhvbGRlclwiIGRhdGEtaWQ9XCI0MlwiIGRhdGEtZGVmaW5pdGlvbmlkPVwiOVwiIGRhdGEtbWV0YWRhdGE9XCI4NTAwMDIyLTE0MDMyOTU5LTI1MDkxMzFcIiBkYXRhLXRhZy1jb3B5PVwidHJ1ZVwiPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWdcIiBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiPng8L3NwYW4+JyArXHJcbiAgICAgICAgICAn4oCMPC9zcGFuPicgK1xyXG4gICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgJzwvZGl2PidcclxuICApO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG5cclxufTtcclxuXHJcbnByb3RvLnRhcmdldFdpdGhUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzYW1wbGU7XHJcblxyXG4gIHNhbXBsZSA9IGgoXHJcbiAgICAnPGRpdiBjbGFzcz1cInVlLXNlZ21lbnQgdWUtcm93LWFjdGl2ZVwiIGRhdGEtc2VnbWVudC1udW1iZXI9XCIyXCIgZGF0YS1wdWlkPVwiYjUyNjc0ZDMtOWRjNC00MjUyLWE4MjEtMzg2Njc2MTNjMDQyXCIgc3R5bGU9XCJoZWlnaHQ6IDI3cHg7XCI+JyArXHJcbiAgICAgICfigIw8ZGl2IGNsYXNzPVwidWUtaW5saW5lLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10ZXh0XCIgZGF0YS10eXBlPVwidGV4dFwiPkJhbmNvIGZvcm5lY2FlZG9yZXM8L3NwYW4+JyArXHJcbiAgICAgICc8L2Rpdj4nICtcclxuICAgICc8L2Rpdj4nXHJcbiAgKTtcclxuXHJcbiAgcmV0dXJuIHNhbXBsZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTW91c2VIYW5kbGVyc0ZpeHR1cmU7XHJcbiIsIi8qIEZpbGU6IFRhZ0NvbnRlbnRCdWlsZGVyX3Rlc3QuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyByZXF1aXJlLCBkZXNjcmliZSwgaXQgKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBUYWdDb250ZW50QnVpbGRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9yZW5kZXJlci9UYWdDb250ZW50QnVpbGRlcicpO1xyXG5cclxudmFyIHNpbm9uID0gcmVxdWlyZSgnc2lub24nKTtcclxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XHJcblxyXG5kZXNjcmliZSgnVGFnQ29udGVudEJ1aWxkZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgVGFnQ29udGVudEJ1aWxkZXIoKTtcclxuICB2YXIgc3RyYXRlZ2llcyA9IHtcclxuICAgIHRlc3Rfc3RyYXRlZ3k6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cclxuICB9O1xyXG5cclxuICBkZXNjcmliZSgnY29uc3RydWN0b3InLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgnc2hvdWxkIGluc3RhbnRpYXRlIHRoZSBuZXcgY2xhc3MnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFzc2VydC5pbnN0YW5jZU9mKGJ1aWxkZXIsIFRhZ0NvbnRlbnRCdWlsZGVyLCAnYW5kIGJ1aWxkZXIgd2lsbCBiZSBhIFRhZ0NvbnRlbnRCdWlsZGVyIGluc3RhbmNlJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7IiwiLyogRmlsZTogTm9kZVdhbGtlcl90ZXN0LmpzICovXHJcbi8qIGdsb2JhbHMgZGVzY3JpYmUsIGl0ICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xyXG52YXIgSGVscGVycyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9IZWxwZXJzJyk7XHJcbnZhciBoID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50O1xyXG52YXIgVG1wbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9UbXBsJyk7XHJcbnZhciBTZWxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUvU2VsZWN0aW9uJyk7XHJcblxyXG5kZXNjcmliZSgnU2VsZWN0aW9uLk5vZGVXYWxrZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgZGVzY3JpYmUoJyNhcHBlbmQoIG5vZGUgKScsIGZ1bmN0aW9uICgpIHtcclxuICAgIGl0KCdhZGRzIHRoZSBnaXZlbiBub2RlIGFzIGEgY2hpbGQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBub2RlRWwsXHJcbiAgICAgICAgICBjYXJyaWFnZVJldHVybk5vZGUsXHJcbiAgICAgICAgICBub2RlO1xyXG5cclxuICAgICAgbm9kZUVsID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KCc8ZGl2Lz4nKTtcclxuICAgICAgY2FycmlhZ2VSZXR1cm5Ob2RlID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KCdcXG4nKTtcclxuICAgICAgbm9kZSA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihub2RlRWwpO1xyXG5cclxuICAgICAgbm9kZS5hcHBlbmQoY2FycmlhZ2VSZXR1cm5Ob2RlKTtcclxuXHJcbiAgICAgIGFzc2VydChjYXJyaWFnZVJldHVybk5vZGUucGFyZW50Tm9kZSA9PT0gbm9kZUVsLCAnY2FycmlhZ2VSZXR1cm4gbm9kZSBpcyBhIGNoaWxkIG9mIG5vZGUnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnI3ByZXBlbmQoIG5vZGUgKScsIGZ1bmN0aW9uICgpIHtcclxuICAgIGl0KCdhZGRzIHRoZSBnaXZlbiBub2RlIGFzIHRoZSBmaXJzdCBjaGlsZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG5vZGVFbCA9IGgoJzxkaXYvPicpLFxyXG4gICAgICAgICAgbm9kZSA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihub2RlRWwpLFxyXG4gICAgICAgICAgcHJlcGVuZGVkTm9kZTEgPSBoKCc8c3BhbiBjbGFzcz1cImZpcnN0XCIvPicpLFxyXG4gICAgICAgICAgcHJlcGVuZGVkTm9kZTIgPSBoKCc8c3BhbiBjbGFzcz1cInNlY29uZFwiLz4nKTtcclxuXHJcbiAgICAgIG5vZGUucHJlcGVuZChwcmVwZW5kZWROb2RlMSk7XHJcbiAgICAgIG5vZGUucHJlcGVuZChwcmVwZW5kZWROb2RlMik7XHJcblxyXG4gICAgICBhc3NlcnQuZXF1YWwobm9kZS5maXJzdENoaWxkKCkuZWwsIHByZXBlbmRlZE5vZGUyLCAnc2Vjb25kIGVsZW1lbnQgaGFzIGJlZW4gaW5zZXJ0ZWQgYmVmb3JlIHRoZSBmaXJzdCcpO1xyXG4gICAgICBhc3NlcnQuZXF1YWwobm9kZS5sYXN0Q2hpbGQoKS5lbCwgcHJlcGVuZGVkTm9kZTEsICdmaXJzdCBlbGVtZW50IGlzIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnRhaW5lcicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCcjaXNJbnZpc2libGVDaGFyICgpJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaXQoJ3JldHVybnMgdHJ1ZSB3aGVuIHRoZSB0aGUgbm9kZSBpcyBjb21wb3NlZCBvZiB0aGUgemVybyB3aWR0aCBub24tam9pbmVyIGNoYXJhY3RlcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGVsLFxyXG4gICAgICAgICAgbm9kZSxcclxuICAgICAgICAgIGlzSW52aXNpYmxlQ2hhcjtcclxuXHJcbiAgICAgIGVsID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KFRtcGwuenduaik7XHJcbiAgICAgIG5vZGUgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoZWwpO1xyXG4gICAgICBpc0ludmlzaWJsZUNoYXIgPSBub2RlLmlzSW52aXNpYmxlQ2hhcigpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzVHJ1ZShpc0ludmlzaWJsZUNoYXIsICdub2RlIGlzIGFuIGludmlzaWJsZSBjaGFyYWN0ZXInKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnI2lzSW5saW5lQ29udGVudCAoKScsIGZ1bmN0aW9uICgpIHtcclxuICAgIGl0KCdyZXR1cm4gdHJ1ZSB3aGVuIHRoZSBub2RlIGhhcyB1ZS1pbmxpbmUtY29udGVudCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGVsLFxyXG4gICAgICAgICAgbm9kZTtcclxuXHJcbiAgICAgIGVsID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KCc8ZGl2IGNsYXNzPVwidWUtaW5saW5lLWNvbnRlbnRcIi8+Jyk7XHJcbiAgICAgIG5vZGUgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoZWwpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzVHJ1ZShub2RlLmlzSW5saW5lQ29udGVudCgpLCAnbm9kZSBpcyBpbmxpbmUgY29udGVudCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCcjaXNFbGVtZW50IChuYW1lKScsIGZ1bmN0aW9uICgpIHtcclxuICAgIGRlc2NyaWJlKCd3aGVuIG5hbWUgaXMgbm90IHByb3ZpZGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpdCgnb25seSBjaGVja3MgaWYgdGhlIG5vZGVUeXBlIGlzIEVsZW1lbnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBIZWxwZXJzLnN0cmluZ1RvSFRNTEVsZW1lbnQoJzxici8+Jyk7XHJcbiAgICAgICAgdmFyIG5vZGVXYWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIobm9kZSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgICAgcmVzdWx0ID0gbm9kZVdhbGtlci5pc0VsZW1lbnQoKTtcclxuXHJcbiAgICAgICAgYXNzZXJ0LmlzVHJ1ZShyZXN1bHQsICdub2RlIGlzIHJlcG9ydGVkIGFzIGVsZW1lbnQnKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnd2hlbiBuYW1lIGlzIHByb3ZpZGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpdCgnYWxzbyBjaGVja3MgdGhlIG5vZGVOYW1lIGZvciBhIG1hdGNoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KCc8YnIvPicpO1xyXG4gICAgICAgIHZhciBub2RlV2Fsa2VyID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKG5vZGUpO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICAgIHJlc3VsdCA9IG5vZGVXYWxrZXIuaXNFbGVtZW50KFwiYnJcIik7XHJcblxyXG4gICAgICAgIGFzc2VydC5pc1RydWUocmVzdWx0LCAnbm9kZSBpcyByZXBvcnRlZCBhcyBlbGVtZW50Jyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnI2luc2VydEFmdGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaXQoJ2luc2VydHMgdGhlIHNwZWNpZmllZCBIVE1MIG5vZGUgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbm9kZSA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPHRlc3QvPicpO1xyXG4gICAgICB2YXIgaW5zZXJ0ZWRBZnRlciA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRlbW8vPicpO1xyXG4gICAgICB2YXIgbm9kZVdhbGtlciA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihub2RlKTtcclxuXHJcbiAgICAgIG5vZGVXYWxrZXIuaW5zZXJ0QWZ0ZXIoaW5zZXJ0ZWRBZnRlcik7XHJcblxyXG4gICAgICBhc3NlcnQuZXF1YWwobm9kZVdhbGtlci5uZXh0KCkuZWwsIGluc2VydGVkQWZ0ZXIsICd0aGUgbm9kZSBoYXMgYmVlbiBpbnNlcnRlZCBhZnRlcicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2luc2VydHMgdGhlIHNwZWNpZmllZCBOb2RlV2Fsa2VyIG5vZGUgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbm9kZSA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPHRlc3QvPicpO1xyXG4gICAgICB2YXIgaW5zZXJ0ZWRBZnRlciA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRlbW8vPicpO1xyXG4gICAgICB2YXIgbm9kZVdhbGtlciA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihub2RlKTtcclxuICAgICAgdmFyIGluc2VydGVkQWZ0ZXJOb2RlV2Fsa2VyID0gbmV3IFNlbGVjdGlvbi5Ob2RlV2Fsa2VyKGluc2VydGVkQWZ0ZXIpO1xyXG5cclxuICAgICAgbm9kZVdhbGtlci5pbnNlcnRBZnRlcihpbnNlcnRlZEFmdGVyTm9kZVdhbGtlcik7XHJcblxyXG4gICAgICBhc3NlcnQobm9kZVdhbGtlci5uZXh0KCkuZXF1YWxzKGluc2VydGVkQWZ0ZXJOb2RlV2Fsa2VyKSwgJ3RoZSBub2RlIGhhcyBiZWVuIGluc2VydGVkIGFmdGVyJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJyNhcHBlbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgnYXBwZW5kcyBhIEhUTUwgbm9kZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG5vZGUgPSBIZWxwZXJzLnN0cmluZ1RvSFRNTEVsZW1lbnQoJzx0ZXN0Lz4nKTtcclxuICAgICAgdmFyIGFwcGVuZGVkTm9kZSA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPGRlbW8vPicpO1xyXG4gICAgICB2YXIgbm9kZVdhbGtlciA9IG5ldyBTZWxlY3Rpb24uTm9kZVdhbGtlcihub2RlKTtcclxuXHJcbiAgICAgIG5vZGVXYWxrZXIuYXBwZW5kKGFwcGVuZGVkTm9kZSk7XHJcblxyXG4gICAgICBhc3NlcnQuZXF1YWwobm9kZVdhbGtlci5maXJzdENoaWxkKCkuZWwsIGFwcGVuZGVkTm9kZSwgJ3RoZSBub2RlIGhhcyBiZWVuIGFwcGVuZGVkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnYXBwZW5kcyBhIE5vZGVXYWxrZXIgbm9kZScsIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIHZhciBub2RlID0gSGVscGVycy5zdHJpbmdUb0hUTUxFbGVtZW50KCc8dGVzdC8+Jyk7XHJcbiAgICAgIHZhciBhcHBlbmRlZE5vZGUgPSBIZWxwZXJzLnN0cmluZ1RvSFRNTEVsZW1lbnQoJzxkZW1vLz4nKTtcclxuICAgICAgdmFyIG5vZGVXYWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIobm9kZSk7XHJcbiAgICAgIHZhciBhcHBlbmRlZE5vZGVXYWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoYXBwZW5kZWROb2RlKTtcclxuXHJcbiAgICAgIG5vZGVXYWxrZXIuYXBwZW5kKGFwcGVuZGVkTm9kZVdhbGtlcik7XHJcblxyXG4gICAgICBhc3NlcnQobm9kZVdhbGtlci5maXJzdENoaWxkKCkuZXF1YWxzKGFwcGVuZGVkTm9kZVdhbGtlciksICd0aGUgbm9kZSBoYXMgYmVlbiBhcHBlbmRlZCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCcjdGV4dENvbnRlbnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgncmV0dXJucyB0aGUgdGV4dENvbnRlbnQgb2YgdGhlIG5vZGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBleGFtcGxlTm9kZSA9IEhlbHBlcnMuc3RyaW5nVG9IVE1MRWxlbWVudCgnPHRlc3Q+dGV4dDwvdGVzdD4nKTtcclxuICAgICAgdmFyIG5vZGVXYWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoZXhhbXBsZU5vZGUpO1xyXG5cclxuICAgICAgYXNzZXJ0LmVxdWFsKCd0ZXh0Jywgbm9kZVdhbGtlci50ZXh0Q29udGVudCgpKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnI2ZvckVhY2hDaGlsZCggY2FsbGJhY2soTm9kZVdhbGtlcikgKScsIGZ1bmN0aW9uICgpIHtcclxuICAgIGl0KCdpdGVyYXRlcyB0aHJvdWdoIGFsbCBjaGlsZE5vZGVzIGFuZCBwYXNzZXMgdGhlIGNoaWxkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsYmFjaycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGNvbnRhaW5lciA9IGgoJzxjb250YWluZXI+PG5vZGUxPjwvbm9kZTE+JyArXHJcbiAgICAgICAgJzxub2RlMj48L25vZGUyPicgK1xyXG4gICAgICAgICc8bm9kZTM+PG5vZGU0Lz48L25vZGUzPicgK1xyXG4gICAgICAgICc8L2NvbnRhaW5lcj4nKSxcclxuICAgICAgICB3YWxrZXIgPSBuZXcgU2VsZWN0aW9uLk5vZGVXYWxrZXIoY29udGFpbmVyKSxcclxuICAgICAgICBjb2xsZWN0ZWRDaGlsZHJlbiA9IFtdO1xyXG5cclxuICAgICAgd2Fsa2VyLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGRXYWxrZXIpIHtcclxuICAgICAgICBjb2xsZWN0ZWRDaGlsZHJlbi5wdXNoKGNoaWxkV2Fsa2VyKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBhc3NlcnQuZXF1YWwoMywgY29sbGVjdGVkQ2hpbGRyZW4ubGVuZ3RoLCAnYWxsIGNoaWxkcmVuIGhhdmUgYmVlbiBnaXZlbicpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG59KTsiLCIvKiBGaWxlOiBTZWxlY3Rpb25Db250ZXh0X3Rlc3QuanMgKi9cclxuLyoganNoaW50IHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cclxuLyogZ2xvYmFscyBkZXNjcmliZSwgaXQsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xyXG52YXIgU2VsZWN0aW9uQ29udGV4dE9iamVjdE1vdGhlciA9IHJlcXVpcmUoJy4uLy4uL3N1cHBvcnQvU2VsZWN0aW9uQ29udGV4dE9iamVjdE1vdGhlcicpO1xyXG52YXIgU2VsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vLi4vYXNzZXRzL2pzL3VlL3NlbGVjdGlvbicpO1xyXG52YXIgRmFrZU5vZGUgPSByZXF1aXJlKCcuLi8uLi9zdXBwb3J0L0Zha2VOb2RlJyk7XHJcblxyXG5kZXNjcmliZSgnU2VsZWN0aW9uQ29udGV4dCcsIGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2VsZWN0aW9uQ29udGV4dCxcclxuICAgICAgc2VsZWN0aW9uLFxyXG4gICAgICBvYmplY3RNb3RoZXIsXHJcbiAgICAgIGh0bWxGcmFnbWVudDtcclxuICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgIG9iamVjdE1vdGhlciA9IG5ldyBTZWxlY3Rpb25Db250ZXh0T2JqZWN0TW90aGVyKCk7XHJcblxyXG4gICAgb2JqZWN0TW90aGVyLnN0dWJTZWxlY3Rpb24oKTtcclxuXHJcbiAgICBzZWxlY3Rpb25Db250ZXh0ID0gbmV3IFNlbGVjdGlvbi5TZWxlY3Rpb25Db250ZXh0KCk7XHJcbiAgICBodG1sRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgfSk7XHJcblxyXG4gIGFmdGVyRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICBvYmplY3RNb3RoZXIucmVzdG9yZVNlbGVjdGlvbigpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnY2FsbHMgZG9jdW1lbnQjZ2V0U2VsZWN0aW9uJywgZnVuY3Rpb24gKCkge1xyXG4gICAgYXNzZXJ0KGRvY3VtZW50LmdldFNlbGVjdGlvbi5jYWxsZWQsICdkb2N1bWVudCNnZXRTZWxlY3Rpb24gd2FzIGV4cGVjdGVkIHRvIGJlIGNhbGxlZCcpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnYXNzaWducyBzZWxlY3Rpb24gaW5zdGFuY2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBhc3NlcnQuaXNOb3ROdWxsKHNlbGVjdGlvbkNvbnRleHQuc2VsZWN0aW9uLCAnc2VsZWN0aW9uIGluc3RhbmNlIHNob3VsZCBoYXZlIGJlZW4gYXNzaWduZWQnKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ2Fzc2lnbnMgcmFuZ2UgaW5zdGFuY2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBhc3NlcnQuaXNOb3ROdWxsKHNlbGVjdGlvbkNvbnRleHQucmFuZ2UsICdyYW5nZSBpbnN0YW5jZSBzaG91bGQgaGF2ZSBiZWVuIGFzc2lnbmVkJyk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdhc3NpZ25zIGZvY3VzTm9kZSBhbmQgZm9jdXNPZmZzZXQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBhc3NlcnQuaXNOb3ROdWxsKHNlbGVjdGlvbkNvbnRleHQuZm9jdXNOb2RlLCAnZm9jdXNOb2RlIHNob3VsZCBoYXZlIGJlZW4gYXNzaWduZWQnKTtcclxuICAgIGFzc2VydC5lcXVhbChzZWxlY3Rpb25Db250ZXh0LmZvY3VzT2Zmc2V0LCAwKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ2Fzc2lnbnMgcmFuZ2UgcHJvcGVydGllcycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGFzc2VydC5pc05vdE51bGwoc2VsZWN0aW9uQ29udGV4dC5jb21tb25BbmNlc3RvckNvbnRhaW5lcik7XHJcbiAgICBhc3NlcnQuaXNOb3ROdWxsKHNlbGVjdGlvbkNvbnRleHQuc3RhcnRDb250YWluZXIpO1xyXG4gICAgYXNzZXJ0LmlzTm90TnVsbChzZWxlY3Rpb25Db250ZXh0LmVuZENvbnRhaW5lcik7XHJcbiAgICBhc3NlcnQuZXF1YWwoc2VsZWN0aW9uQ29udGV4dC5zdGFydE9mZnNldCwgb2JqZWN0TW90aGVyLmZha2VSYW5nZS5zdGFydE9mZnNldCk7XHJcbiAgICBhc3NlcnQuZXF1YWwoc2VsZWN0aW9uQ29udGV4dC5lbmRPZmZzZXQsIG9iamVjdE1vdGhlci5mYWtlUmFuZ2UuZW5kT2Zmc2V0KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ3doZW4gZm9jdXNOb2RlI3BhcmVudE5vZGUgaXMgbnVsbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGl0KCdhc3NpZ25zIGZhbHNlIHRvIGhhc0ZvY3VzTm9kZVBhcmVudCAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFzc2VydC5pc0ZhbHNlKHNlbGVjdGlvbkNvbnRleHQuaGFzRm9jdXNOb2RlUGFyZW50KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkb2VzIG5vdCBhc3NpZ24gdG8gZm9jdXNOb2RlUGFyZW50JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBhc3NlcnQuaXNVbmRlZmluZWQoc2VsZWN0aW9uQ29udGV4dC5mb2N1c05vZGVQYXJlbnQpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCd3aGVuIGZvY3VzTm9kZSNwYXJlbnROb2RlIGlzIG5vdCBudWxsJywgZnVuY3Rpb24gKCkge1xyXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIG9iamVjdE1vdGhlci5kZWZpbmVGb2N1c05vZGVQYXJlbnQoKTtcclxuICAgICAgc2VsZWN0aW9uQ29udGV4dCA9IG5ldyBTZWxlY3Rpb24uU2VsZWN0aW9uQ29udGV4dCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2Fzc2lnbnMgdHJ1ZSB0byBoYXNGb2N1c05vZGVQYXJlbnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFzc2VydC5pc1RydWUoc2VsZWN0aW9uQ29udGV4dC5oYXNGb2N1c05vZGVQYXJlbnQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2Fzc2lnbnMgZm9jdXNOb2RlUGFyZW50JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBhc3NlcnQuaXNOb3ROdWxsKHNlbGVjdGlvbkNvbnRleHQuZm9jdXNOb2RlUGFyZW50KTtcclxuICAgIH0pO1xyXG5cclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2ZvY3VzTm9kZSwgc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lciBoYXZlIG5vZGVUeXBlIGRpZmZlcmVudCBmcm9tIFRleHROb2RlVHlwZSh2YWx1ZTogMyknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgnc2V0cyBpc0ZvY3VzVGV4dE5vZGUgdG8gZmFsc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFzc2VydC5pc0ZhbHNlKHNlbGVjdGlvbkNvbnRleHQuaXNGb2N1c1RleHROb2RlKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzZXRzIGlzU3RhcnRDb250YWluZXJUZXh0Tm9kZSB0byBmYWxzZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYXNzZXJ0LmlzRmFsc2Uoc2VsZWN0aW9uQ29udGV4dC5pc1N0YXJ0Q29udGFpbmVyVGV4dE5vZGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3NldHMgaXNFbmRDb250YWluZXJUZXh0Tm9kZSB0byBmYWxzZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYXNzZXJ0LmlzRmFsc2Uoc2VsZWN0aW9uQ29udGV4dC5pc0VuZENvbnRhaW5lclRleHROb2RlKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnZm9jdXNOb2RlLCBzdGFydENvbnRhaW5lciwgZW5kQ29udGFpbmVyIGhhdmUgbm9kZVR5cGUgVGV4dE5vZGUodmFsdWU6MyknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgb2JqZWN0TW90aGVyLmFzc2lnblRleHROb2RlcygpO1xyXG4gICAgICBzZWxlY3Rpb25Db250ZXh0ID0gbmV3IFNlbGVjdGlvbi5TZWxlY3Rpb25Db250ZXh0KCk7XHJcbiAgICB9KTtcclxuICAgIGl0KCdzZXRzIGlzRm9jdXNUZXh0Tm9kZSB0byBmYWxzZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYXNzZXJ0LmlzVHJ1ZShzZWxlY3Rpb25Db250ZXh0LmlzRm9jdXNUZXh0Tm9kZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2V0cyBpc1N0YXJ0Q29udGFpbmVyVGV4dE5vZGUgdG8gZmFsc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGFzc2VydC5pc1RydWUoc2VsZWN0aW9uQ29udGV4dC5pc1N0YXJ0Q29udGFpbmVyVGV4dE5vZGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3NldHMgaXNFbmRDb250YWluZXJUZXh0Tm9kZSB0byBmYWxzZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYXNzZXJ0LmlzVHJ1ZShzZWxlY3Rpb25Db250ZXh0LmlzRW5kQ29udGFpbmVyVGV4dE5vZGUpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCcjaXNDb2xsYXBzZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBkZXNjcmliZSgnd2hlbiByYW5nZSBpcyBub3QgY29sbGFwc2VkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBvYmplY3RNb3RoZXIuc2V0UmFuZ2VDb2xsYXBzZWQoZmFsc2UpO1xyXG4gICAgICAgIHNlbGVjdGlvbkNvbnRleHQgPSBuZXcgU2VsZWN0aW9uLlNlbGVjdGlvbkNvbnRleHQoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgncmV0dXJucyBmYWxzZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhc3NlcnQuaXNGYWxzZShzZWxlY3Rpb25Db250ZXh0LmlzQ29sbGFwc2VkKCkpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCd3aGVuIHJhbmdlIGlzIGNvbGxhcHNlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgb2JqZWN0TW90aGVyLnNldFJhbmdlQ29sbGFwc2VkKHRydWUpO1xyXG4gICAgICAgIHNlbGVjdGlvbkNvbnRleHQgPSBuZXcgU2VsZWN0aW9uLlNlbGVjdGlvbkNvbnRleHQoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpdCgncmV0dXJucyB0cnVlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGFzc2VydC5pc1RydWUoc2VsZWN0aW9uQ29udGV4dC5pc0NvbGxhcHNlZCgpKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJyNjbG9uZUNvbnRlbnRzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaXQoJ2NhbGxzIHJhbmdlI2Nsb25lQ29udGVudHMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHNlbGVjdGlvbkNvbnRleHQuY2xvbmVDb250ZW50cygpO1xyXG5cclxuICAgICAgYXNzZXJ0KHNlbGVjdGlvbkNvbnRleHQucmFuZ2UuY2xvbmVDb250ZW50cy5jYWxsZWQsICdyYW5nZSNjbG9uZUNvbnRlbnRzIHdhcyBub3QgY2FsbGVkJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJyNkZWxldGVDb250ZW50cycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGl0KCdjYWxscyByYW5nZSNkZWxldGVDb250ZW50cycsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2VsZWN0aW9uQ29udGV4dC5kZWxldGVDb250ZW50cygpO1xyXG5cclxuICAgICAgYXNzZXJ0KHNlbGVjdGlvbkNvbnRleHQucmFuZ2UuZGVsZXRlQ29udGVudHMuY2FsbGVkLCAncmFuZ2UjZGVsZXRlQ29udGVudHMgd2FzIG5vdCBjYWxsZWQnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnI2luc2VydE5vZGUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgnY2FsbHMgcmFuZ2UjaW5zZXJ0Tm9kZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2VsZWN0aW9uQ29udGV4dC5pbnNlcnROb2RlKGh0bWxGcmFnbWVudCk7XHJcblxyXG4gICAgICBhc3NlcnQoc2VsZWN0aW9uQ29udGV4dC5yYW5nZS5pbnNlcnROb2RlLmNhbGxlZCwgJ3JhbmdlI2luc2VydE5vZGUgd2FzIGNhbGxlZCcpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCcjaGFzQ29tbW9uQW5jZXN0b3JDbGFzcycsIGZ1bmN0aW9uICgpIHtcclxuICAgIGl0KCdjaGVja3MgdGhlIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHRvIHNlZSBpZiBpdCBoYXMgdGhlIGdpdmVuIGNsYXNzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBzZWxlY3Rpb25Db250ZXh0LmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gbmV3IEZha2VOb2RlKCkud2l0aENsYXNzKCd1ZS1lZGl0YWJsZScpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzVHJ1ZShzZWxlY3Rpb25Db250ZXh0Lmhhc0NvbW1vbkFuY2VzdG9yQ2xhc3MoJ3VlLWVkaXRhYmxlJykpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoXCJyZXR1cm5zIGZhbHNlIHdoZW4gY29tbW9uQW5jZXN0b3JDb250YWluZXIgZG9lc24ndCBoYXZlIHRoZSBwcm92aWRlZCBjbGFzc05hbWVcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBzZWxlY3Rpb25Db250ZXh0LmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gbmV3IEZha2VOb2RlKCkud2l0aENsYXNzKCd1ZS1pbmxpbmUtY29udGVudCcpO1xyXG5cclxuICAgICAgYXNzZXJ0LmlzRmFsc2Uoc2VsZWN0aW9uQ29udGV4dC5oYXNDb21tb25BbmNlc3RvckNsYXNzKCd1ZS1lZGl0YWJsZScpKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxufSk7XHJcbiIsIi8qIEZpbGU6IE1vdXNlQ3RybENsaWNrSGFuZGxlcl90ZXN0LmpzICovXHJcbi8qIGpzaGludCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXHJcbi8qIGdsb2JhbHMgZGVzY3JpYmUsIGJlZm9yZUVhY2gsIGl0ICovXHJcbid1c2Ugc3RyaWN0JztcclxudmFyIGggPSByZXF1aXJlKCcuLi8uLi8uLi9hc3NldHMvanMvdWUvSGVscGVycycpLnN0cmluZ1RvSFRNTEVsZW1lbnQsXHJcbiAgICBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0LFxyXG4gICAgTm9kZVdhbGtlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9zZWxlY3Rpb24nKS5Ob2RlV2Fsa2VyLFxyXG4gICAgVGFnUGFpciA9IHJlcXVpcmUoJy4uLy4uLy4uL2Fzc2V0cy9qcy91ZS9zZWxlY3Rpb24nKS5UYWdQYWlyO1xyXG5cclxuXHJcbmRlc2NyaWJlKCdUYWdQYWlyJywgZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzdGFydFRhZyxcclxuICAgICAgaW5saW5lQ29udGVudCxcclxuICAgICAgZW5kVGFnLFxyXG4gICAgICBzZWdtZW50Q29udGVudCxcclxuICAgICAgc2VnbWVudCxcclxuICAgICAgdGFnUGFpcixcclxuICAgICAgdGFnRWxlbWVudHMsXHJcbiAgICAgIHBsYWNlaG9sZGVyLFxyXG4gICAgICB0YWdTdHJ1Y3R1cmU7XHJcblxyXG4gIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgc2VnbWVudCA9IGgoXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJ1ZS1zZWdtZW50XCIgZGF0YS1zb3VyY2Utc2VnbWVudC1udW1iZXI9XCIzXCIgZGF0YS1zb3VyY2UtcHVpZD1cImQ1ODI3ZmQ5LWRiOGItNGQwNS05YzUzLThlMDI0NGM4YjNiYlwiIHN0eWxlPVwiaGVpZ2h0OiAyN3B4O1wiPicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJ1ZS1pbmxpbmUtY29udGVudFwiPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWctd3JhcHBlclwiIGRhdGEtdHlwZT1cInN0YXJ0LXRhZ1wiIGRhdGEtdGFnLWNvcHk9XCJ0cnVlXCIgZGF0YS1pZD1cIjE5XCIgZGF0YS1tZXRhZGF0YT1cInVuZGVmaW5lZFwiIGRhdGEtY2FuLWhpZGU9XCJmYWxzZVwiPicgK1xyXG4gICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRhZyB1ZS10YWctc3RhcnRcIiBjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiPltzdGFydC10YWddPC9zcGFuPuKAjCcgK1xyXG4gICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cInVlLWlubGluZS1jb250ZW50IHVlLXRhZ3BhaXItY29udGVudFwiIGRhdGEtdHlwZT1cInRhZ3BhaXJcIiBkYXRhLWlkPVwiMTlcIiBkYXRhLWRlZmluaXRpb25pZD1cIjVcIiBkYXRhLW1ldGFkYXRhPVwidW5kZWZpbmVkXCI+JyArXHJcbiAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGV4dFwiIGRhdGEtdHlwZT1cInRleHRcIj4gaXMgYW4gb3JnYW5pemVkIGNvbGxlY3Rpb24gb2YgPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cInVlLXRleHRcIiBkYXRhLXR5cGU9XCJ0ZXh0XCI+Ljwvc3Bhbj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWctd3JhcHBlclwiIGRhdGEtdHlwZT1cImVuZC10YWdcIiBkYXRhLXRhZy1jb3B5PVwidHJ1ZVwiIGRhdGEtaWQ9XCIxOVwiIGRhdGEtbWV0YWRhdGE9XCJ1bmRlZmluZWRcIiBkYXRhLWNhbi1oaWRlPVwiZmFsc2VcIj4nICtcclxuICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWcgdWUtdGFnLWVuZFwiIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCI+W2VuZC10YWddPC9zcGFuPuKAjCcgK1xyXG4gICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJ1ZS10YWctd3JhcHBlclwiIGRhdGEtdHlwZT1cInBsYWNlaG9sZGVyXCIgZGF0YS1pZD1cIjQyXCIgZGF0YS1kZWZpbml0aW9uaWQ9XCI5XCIgZGF0YS1tZXRhZGF0YT1cIjg1MDAwMjItMTQwMzI5NTktMjUwOTEzMVwiIGRhdGEtdGFnLWNvcHk9XCJ0cnVlXCI+JyArXHJcbiAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwidWUtdGFnXCIgY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIj54PC9zcGFuPicgK1xyXG4gICAgICAgICAgICAn4oCMPC9zcGFuPicgK1xyXG4gICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICc8L2Rpdj4nXHJcbiAgICApO1xyXG4gICAgc2VnbWVudENvbnRlbnQgPSBzZWdtZW50LmZpcnN0Q2hpbGQ7XHJcbiAgICBzdGFydFRhZyA9IHNlZ21lbnRDb250ZW50LmZpcnN0Q2hpbGQ7XHJcbiAgICBpbmxpbmVDb250ZW50ID0gc2VnbWVudENvbnRlbnQuY2hpbGROb2Rlc1sxXTtcclxuICAgIGVuZFRhZyA9IHNlZ21lbnRDb250ZW50LmNoaWxkTm9kZXNbMl07XHJcbiAgICBwbGFjZWhvbGRlciA9IHNlZ21lbnRDb250ZW50LmNoaWxkTm9kZXNbM107XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdjcmVhdGVzIGEgdmFsaWQgaW5zdGFuY2UsIGZyb20gc3RhcnQtdGFnJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdGFnUGFpciA9IG5ldyBUYWdQYWlyKHN0YXJ0VGFnKTtcclxuXHJcbiAgICBhc3NlcnQodGFnUGFpci5pc1ZhbGlkKCksICd2YWxpZCB0YWcgcGFpciBjcmVhdGVkJyk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdjcmVhdGVzIGEgdmFsaWQgaW5zdGFuY2UsIGZyb20gaW5saW5lQ29udGVudCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIHRhZ1BhaXIgPSBuZXcgVGFnUGFpcihpbmxpbmVDb250ZW50KTtcclxuXHJcbiAgICBhc3NlcnQodGFnUGFpci5pc1ZhbGlkKCksICd2YWxpZCB0YWcgcGFpciBjcmVhdGVkJyk7XHJcbiAgfSk7XHJcblxyXG4gIGl0KCdjcmVhdGVzIGEgdmFsaWQgaW5zdGFuY2UsIGZyb20gZW5kLXRhZycsIGZ1bmN0aW9uICgpIHtcclxuICAgIHRhZ1BhaXIgPSBuZXcgVGFnUGFpcihlbmRUYWcpO1xyXG5cclxuICAgIGFzc2VydCh0YWdQYWlyLmlzVmFsaWQoKSwgJ3ZhbGlkIHRhZyBwYWlyIGNyZWF0ZWQnKTtcclxuICB9KTtcclxuXHJcbiAgaXQoJ2NyZWF0ZXMgYSB2YWxpZCBpbnN0YW5jZSwgZnJvbSBhIG5vZGUgd2Fsa2VyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdGFnUGFpciA9IG5ldyBUYWdQYWlyKG5ldyBOb2RlV2Fsa2VyKHN0YXJ0VGFnKSk7XHJcblxyXG4gICAgYXNzZXJ0KHRhZ1BhaXIuaXNWYWxpZCgpLCAndmFsaWQgdGFnIHBhaXIgY3JlYXRlZCcpO1xyXG4gIH0pO1xyXG5cclxuICBpdCgnY2FuXFwndCBjcmVhdGUgYSB2YWxpZCBpbnN0YW5jZSBmcm9tIHBsYWNlaG9sZGVyJywgZnVuY3Rpb24gKCkge1xyXG4gICAgdGFnUGFpciA9IG5ldyBUYWdQYWlyKHBsYWNlaG9sZGVyKTtcclxuXHJcbiAgICBhc3NlcnQuaXNGYWxzZSh0YWdQYWlyLmlzVmFsaWQoKSwgJ3ZhbGlkIHRhZyBwYWlyIGNhblxcJ3QgYmUgY3JlYXRlZCBmcm9tIHBsYWNlaG9sZGVyJyk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCcjY2xvbmVTdHJ1Y3R1cmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpdCgnY2xvbmVzIGFsbCB0aGUgdGFncywgYW5kIHJldHVybnMgYSBkb2N1bWVudEZyYWdtZW50IHdpdGggdGhlIHRhZ3MnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRhZ1BhaXIgPSBuZXcgVGFnUGFpcihpbmxpbmVDb250ZW50KTtcclxuXHJcbiAgICAgIHRhZ1N0cnVjdHVyZSA9IHRhZ1BhaXIuY2xvbmVTdHJ1Y3R1cmUoKTtcclxuICAgICAgYXNzZXJ0LmlzTm90TnVsbCh0YWdTdHJ1Y3R1cmUuY2hpbGROb2Rlc1swXSwgJ3N0YXJ0VGFnRWwgaXMgYXNzaWduZWQgdG8nKTtcclxuICAgICAgYXNzZXJ0LmlzTm90TnVsbCh0YWdTdHJ1Y3R1cmUuY2hpbGROb2Rlc1sxXSwgJ2lubGluZUNvbnRlbnRFbCBpcyBhc3NpZ25lZCB0bycpO1xyXG4gICAgICBhc3NlcnQuaXNOb3ROdWxsKHRhZ1N0cnVjdHVyZS5jaGlsZE5vZGVzWzJdLCAnZW5kVGFnRWwgaXMgYXNzaWduZWQgdG8nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdkb2VzIG5vdCBrZWVwIHRoZSBpbmxpbmUgY29udGVudCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGFnUGFpciA9IG5ldyBUYWdQYWlyKGlubGluZUNvbnRlbnQpO1xyXG5cclxuICAgICAgdGFnU3RydWN0dXJlID0gdGFnUGFpci5jbG9uZVN0cnVjdHVyZSgpO1xyXG5cclxuICAgICAgYXNzZXJ0LmVxdWFsKDAsIHRhZ1N0cnVjdHVyZS5jaGlsZE5vZGVzWzFdLmNoaWxkTm9kZXMubGVuZ3RoLCAndmFsaWQgdGFnIHBhaXIgY2xvbmUgd2FzIGNyZWF0ZWQnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnI3RvQXJyYXknLCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0YWdQYWlyID0gbmV3IFRhZ1BhaXIoc3RhcnRUYWcpO1xyXG5cclxuICAgIHRhZ0VsZW1lbnRzID0gdGFnUGFpci50b0FycmF5KCk7XHJcblxyXG4gICAgYXNzZXJ0Lmxlbmd0aE9mKHRhZ0VsZW1lbnRzLCAzLCAndGhyZWUgZWxlbWVudHMgYXJlIHJldHVybmVkJyk7XHJcbiAgICBhc3NlcnQodGFnUGFpci5zdGFydFRhZ0VsID09PSB0YWdFbGVtZW50c1swXSwgJ2ZpcnN0IGVsZW1lbnQgaXMgc3RhcnQgdGFnJyk7XHJcbiAgICBhc3NlcnQodGFnUGFpci5pbmxpbmVDb250ZW50RWwgPT09IHRhZ0VsZW1lbnRzWzFdLCAnc2Vjb25kIGVsZW1lbnQgaXMgc3RhcnQgdGFnJyk7XHJcbiAgICBhc3NlcnQodGFnUGFpci5lbmRUYWdFbCA9PT0gdGFnRWxlbWVudHNbMl0sICd0aGlyZCBlbGVtZW50IGlzIHN0YXJ0IHRhZycpO1xyXG4gIH0pO1xyXG59KTtcclxuIl19
